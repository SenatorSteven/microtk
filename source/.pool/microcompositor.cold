
/*!
	has been observed to not update correctly on configure, which has something to do with drawing to buffer. redrawing the entire buffer always works.
*/

/*!
	shaped windows don't show properly always. notable examples: xterm and gnome-screenshot.
*/

/*!
	certain windows that are supposed to be transparent or have such corners do not show properly. chromium browsers and the gedit selection, which has an opacity atom after moving it around, are examples.
*/

/*!
	has been observed to not draw xterm borders correctly when moving fullscreen window under virtual root. similar issue on system tray window.
*/

/*!
	windows that unmap might have a final frame that is has a default background only.
*/



























/*!includes:{*/
	#include <errno.h>
	#include <grp.h>
	#include <limits.h>
	#include <locale.h>
	#include <poll.h>
	#include <pthread.h>
	#include <pwd.h>
	#include <signal.h>
	#include <stdarg.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <sys/shm.h>
	#include <sys/stat.h>
	#include <sys/wait.h>
	#include <xcb/composite.h>
	#include <xcb/damage.h>
	#include <xcb/randr.h>
	#include <xcb/render.h>
	#include <xcb/shape.h>
	#include <xcb/xfixes.h>
/*!}*/

/*!defines:{*/
	#define DEBUG /*-----------------------------------------*/ (false)

	#define PROGRAM_NAME /*----------------------------------*/ "microcompositor"

	#define WHICH_MONITOR_CONTENT(k, v, n, p) /*-------------*/ { \
		  v(none)           k(NONE##p) \
		, v(pointer)        k(POINTER##p) \
		, v(focused-window) k(FOCUSED_WINDOW##p) \
		, v(all)            k(ALL##p) \
		, n(NULL)           k(NULL##p) \
	}

	#define NUMBER_TYPE_CONTENT(k, v, n, p) /*---------------*/ { \
		  v(none)       k(NONE##p) \
		, v(integer)    k(INTEGER##p) \
		, v(percentage) k(PERCENTAGE##p) \
		, v(millimeter) k(MILLIMETER##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define POSITION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(bottom) k(BOTTOM##p) \
		, v(left)   k(LEFT##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define HORIZONTAL_ALIGNMENT_CONTENT(k, v, n, p) /*------*/ { \
		  v(none)   k(NONE##p) \
		, v(left)   k(LEFT##p) \
		, v(center) k(CENTER##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define VERTICAL_ALIGNMENT_CONTENT(k, v, n, p) /*--------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(center) k(CENTER##p) \
		, v(bottom) k(BOTTOM##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define CORNER_CONTENT(k, v, n, p) /*--------------------*/ { \
		  v(none)         k(NONE##p         = (b(0000))) \
		, v(top-left)     k(TOP_LEFT##p     = (b(0001))) \
		, v(top-right)    k(TOP_RIGHT##p    = (b(0010))) \
		, v(bottom-left)  k(BOTTOM_LEFT##p  = (b(0100))) \
		, v(bottom-right) k(BOTTOM_RIGHT##p = (b(1000))) \
		, n(NULL)         k(NULL##p) \
	}

	#define AXIS_CONTENT(k, v, n, p) /*----------------------*/ { \
		  v(none)       k(NONE##p) \
		, v(horizontal) k(HORIZONTAL##p) \
		, v(vertical)   k(VERTICAL##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define _STRING_TREE_NODE_CHILDREN_AMOUNT /*-------------*/ (14)
	#define STRING_TREE_NODE_CHILDREN_AMOUNT /*--------------*/ (_STRING_TREE_NODE_CHILDREN_AMOUNT > 28? 28 : _STRING_TREE_NODE_CHILDREN_AMOUNT)

	#define EMPTY_SHARED_STATUS /*---------------------------*/ (0)
	#define FULL_SHARED_STATUS /*----------------------------*/ (1)

	#define SHORTCUT_CODE_AMOUNT /*--------------------------*/ (256)

	#define SHORTCUT_STATE_CONTENT(k, v, n, p) /*------------*/ { \
		  v(none)    k(NONE##p    = (b(000))) \
		, v(press)   k(PRESS##p   = (b(001))) \
		, v(repeat)  k(REPEAT##p  = (b(010))) \
		, v(release) k(RELEASE##p = (b(100))) \
		, n(NULL)    k(NULL##p) \
	}

	#define NONE_INSTRUCTION_TYPE /*-------------------------*/ (b(000000))
	#define NAME_INSTRUCTION_TYPE /*-------------------------*/ (b(000001))
	#define NAME_LIST_INSTRUCTION_TYPE /*--------------------*/ (b(000010))
	#define NUMBER_INSTRUCTION_TYPE /*-----------------------*/ (b(000100))
	#define STRING_INSTRUCTION_TYPE /*-----------------------*/ (b(001000))
	#define IMAGE_INSTRUCTION_TYPE /*------------------------*/ (b(010000))
	#define END_INSTRUCTION_TYPE /*--------------------------*/ (b(100000))

	#define GLOBAL_SCOPES_INSTRUCTION_CONTENT(k, v, n, p) /*-*/ { \
		  v(scope1) k(SCOPE1##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define GLOBAL_INSTRUCTION_CONTENT(k, v, n, p) /*--------*/ { \
		  v(help)           k(HELP##p) \
		, v(expand)         k(EXPAND##p) \
		, v(contract)       k(CONTRACT##p) \
		, v(read-config)    k(READ_CONFIG##p) \
		, v(use-terminal)   k(USE_TERMINAL##p) \
		, v(use-messenger)  k(USE_MESSENGER##p) \
		, v(set)            k(SET##p) \
		, v(do)             k(DO##p) \
		, v(grab-keycode)   k(GRAB_KEYCODE##p) \
		, v(grab-button)    k(GRAB_BUTTON##p) \
		, v(ungrab-keycode) k(UNGRAB_KEYCODE##p) \
		, v(ungrab-button)  k(UNGRAB_BUTTON##p) \
		, v(stop)           k(STOP##p) \
		, n(NULL)           k(NULL##p) \
	}

	#define SCOPE1_SCOPE_INSTRUCTION_CONTENT(k, v, n, p) /*--*/ { \
		  v(help)     k(HELP##p) \
		, v(expand)   k(EXPAND##p) \
		, v(contract) k(CONTRACT##p) \
		, v(stop)     k(STOP##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define BOOLEAN_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)  k(NONE##p) \
		, v(true)  k(TRUE##p) \
		, v(false) k(FALSE##p) \
		, n(NULL)  k(NULL##p) \
	}

	#define VARIABLE_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none) k(NONE##p) \
		, n(NULL) k(NULL##p) \
	}

	#define COMMAND_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)    k(NONE##p) \
		, v(execute) k(EXECUTE##p) \
		, v(restart) k(RESTART##p) \
		, v(exit)    k(EXIT##p) \
		, n(NULL)    k(NULL##p) \
	}

	#define MODIFIER_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)     k(NONE##p) \
		, v(shift)    k(SHIFT##p) \
		, v(caps)     k(CAPS##p) \
		, v(control)  k(CONTROL##p) \
		, v(mod-1)    k(MOD_1##p) \
		, v(mod-2)    k(MOD_2##p) \
		, v(mod-3)    k(MOD_3##p) \
		, v(mod-4)    k(MOD_4##p) \
		, v(mod-5)    k(MOD_5##p) \
		, v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NAME_LIST /*--------------------------------*/ (0)
	#define SUCCESS_NAME_LIST /*-----------------------------*/ (1)
	#define INVALID_NAME_NAME_LIST /*------------------------*/ (2)
	#define PREMATURE_END_NAME_LIST /*-----------------------*/ (3)

	#define MACRO_CONTENT(k, v, n, p) /*---------------------*/ { \
		  v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NUMBER /*-----------------------------------*/ (0)
	#define VALID_NUMBER_NUMBER /*---------------------------*/ (1)
	#define NON_NUMBER_NUMBER /*-----------------------------*/ (2)
	#define OVERFLOWN_NUMBER_NUMBER /*-----------------------*/ (3)
	#define DIVIDED_BY_ZERO_NUMBER /*------------------------*/ (4)

	#define NONE_MATCH_IMAGE /*------------------------------*/ (0)
	#define CANNOT_OPEN_MATCH_IMAGE /*-----------------------*/ (1)
	#define CANNOT_READ_MATCH_IMAGE /*-----------------------*/ (2)
	#define UNSUPPORTED_FORMAT_MATCH_IMAGE /*----------------*/ (3)
	#define BAD_HEADER_MATCH_IMAGE /*------------------------*/ (4)
	#define BAD_DEPTH_MATCH_IMAGE /*-------------------------*/ (5)
	#define BAD_COMPRESSION_MATCH_IMAGE /*-------------------*/ (6)
	#define UNSUPPORTED_HEIGHT_MATCH_IMAGE /*----------------*/ (7)
	#define BAD_SIZE_MATCH_IMAGE /*--------------------------*/ (8)
	#define FAILED_MATCH_IMAGE /*----------------------------*/ (9)
	#define BAD_PIXELS_MATCH_IMAGE /*------------------------*/ (10)
	#define BAD_IMAGE_MATCH_IMAGE /*-------------------------*/ (11)
	#define SUCCESS_MATCH_IMAGE /*---------------------------*/ (12)

	#define NONE_MATCH_COMMAND_ORIGIN /*---------------------*/ (0)
	#define PRESS_MATCH_COMMAND_ORIGIN /*--------------------*/ (1)
	#define RELEASE_MATCH_COMMAND_ORIGIN /*------------------*/ (2)
	#define CONFIG_MATCH_COMMAND_ORIGIN /*-------------------*/ (3)
	#define STDIN_MATCH_COMMAND_ORIGIN /*--------------------*/ (4)
	#define TRANSMITTER_MATCH_COMMAND_ORIGIN /*--------------*/ (5)

	#define NONE_MATCH_COMMAND_TYPE /*-----------------------*/ (0)
	#define TYPICAL_MATCH_COMMAND_TYPE /*--------------------*/ (1)
	#define RESTART_MATCH_COMMAND_TYPE /*--------------------*/ (2)
	#define EXIT_MATCH_COMMAND_TYPE /*-----------------------*/ (3)

	#define ROTATION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)        k(NONE##p) \
		, v(degrees-90)  k(DEGREES_90##p)  \
		, v(degrees-180) k(DEGREES_180##p) \
		, v(degrees-270) k(DEGREES_270##p) \
		, n(NULL)        k(NULL##p) \
	}

	#define INITFORMATSYSTEM() /*----------------------------*/ local bool                     initFormatSystem(FormatSystem *const formatSystem)
	#define REQUESTFORMATS() /*------------------------------*/ local bool                     requestFormats(FormatSystem *const formatSystem)
	#define FINDFORMAT() /*----------------------------------*/ local xcb_render_pictformat_t  findFormat(FormatSystem *const formatSystem, const uint8 depth)
	#define FINIFORMATSYSTEM() /*----------------------------*/ local bool                     finiFormatSystem(FormatSystem *const formatSystem)

	#define INITWALLPAPERSYSTEM() /*-------------------------*/ local bool                     initWallpaperSystem(WallpaperSystem *const wallpaperSystem)
	#define SETWALLPAPERCOLOR() /*---------------------------*/ local bool                     setWallpaperColor(WallpaperSystem *const wallpaperSystem, FormatSystem *const formatSystem, MonitorSystem *const monitorSystem, const uint32 color)
	#define SETWALLPAPERPIXMAP() /*--------------------------*/ local bool                     setWallpaperPixmap(WallpaperSystem *const wallpaperSystem, FormatSystem *const formatSystem, MonitorSystem *const monitorSystem, const xcb_atom_t pixmapProperty)
	#define CREATEWALLPAPER() /*-----------------------------*/ local bool                     createWallpaper(WallpaperSystem *const wallpaperSystem, FormatSystem *const formatSystem, MonitorSystem *const monitorSystem, const uint width, const uint height)
	#define FINIWALLPAPERSYSTEM() /*-------------------------*/ local bool                     finiWallpaperSystem(WallpaperSystem *const wallpaperSystem)

	#define INITCLIENTSYSTEM() /*----------------------------*/ local bool                     initClientSystem(ClientSystem *const clientSystem)
	#define CREATEEXISTINGCLIENTS() /*-----------------------*/ local bool                     createExistingClients(ClientSystem *const clientSystem, FormatSystem *const formatSystem)
	#define CREATECLIENT() /*--------------------------------*/ local bool                     createClient(ClientSystem *const clientSystem, FormatSystem *const formatSystem, const xcb_window_t window, const xcb_window_t parent, uint8 class)
	#define MAPCLIENT() /*-----------------------------------*/ local bool                     mapClient(ClientSystem *const clientSystem, Client *const client)
	#define CONFIGURECLIENT() /*-----------------------------*/ local bool                     configureClient(ClientSystem *const clientSystem, Client *const client, const int x, const int y, const uint width, const uint height, const uint border, const uint8 stackMode, const xcb_window_t aboveSibling)
	#define RESTACKCLIENT() /*-------------------------------*/ local bool                     restackClient(ClientSystem *const clientSystem, Client *const client, const uint8 stackMode, xcb_window_t sibling)
	#define CALCULATECLIENTSRECTANGLES() /*------------------*/ local bool                     calculateClientsRectangles(ClientSystem *const clientSystem, uint *orderedClientOffset)
	#define UNMAPCLIENT() /*---------------------------------*/ local bool                     unmapClient(ClientSystem *const clientSystem, Client *const client)
	#define DESTROYCLIENT() /*-------------------------------*/ local bool                     destroyClient(ClientSystem *const clientSystem, Client *const client)
	#define DESTROYCLIENTS() /*------------------------------*/ local bool                     destroyClients(ClientSystem *const clientSystem)
	#define ISVALIDCLIENT() /*-------------------------------*/ local bool                     isValidClient(ClientSystem *const clientSystem, const Client *const client)
	#define FINDCLIENT() /*----------------------------------*/ local Client *                 findClient(ClientSystem *const clientSystem, const xcb_window_t window)
	#define FINDORDEREDCLIENTOFFSET() /*---------------------*/ local uint *                   findOrderedClientOffset(ClientSystem *const clientSystem, const Client *const client)
	#define FINDORDEREDCLIENTWINDOWOFFSET() /*---------------*/ local uint *                   findOrderedClientWindowOffset(ClientSystem *const clientSystem, const xcb_window_t window)
	#define FINICLIENTSYSTEM() /*----------------------------*/ local bool                     finiClientSystem(ClientSystem *const clientSystem)

	#define INITBUFFERSYSTEM() /*----------------------------*/ local bool                     initBufferSystem(BufferSystem *const bufferSystem)
	#define CREATEBUFFERSYSTEM() /*--------------------------*/ local bool                     createBufferSystem(BufferSystem *const bufferSystem, const xcb_window_t overlayWindow)
	#define REDRAWBUFFER() /*--------------------------------*/ local bool                     redrawBuffer(BufferSystem *const bufferSystem, WallpaperSystem *const wallpaperSystem, ClientSystem *const clientSystem)
	#define COMMITBUFFER() /*--------------------------------*/ local bool                     commitBuffer(BufferSystem *const bufferSystem, const int x, const int y, const uint width, const uint height)
	#define RENDERCOMPOSITECLIENT() /*-----------------------*/ local bool                     renderCompositeClient(BufferSystem *const bufferSystem, WallpaperSystem *const wallpaperSystem, ClientSystem *const clientSystem, uint *const orderedClientOffset, int x, int y, int width, int height, const bool commit)
	#define RENDERCOMPOSITEWITHOUTCLIENT() /*----------------*/ local bool                     renderCompositeWithoutClient(BufferSystem *const bufferSystem, WallpaperSystem *const wallpaperSystem, ClientSystem *const clientSystem, uint *const orderedClientOffset, const int x, const int y, const int width, const int height, const bool commit)
	#define FINIBUFFERSYSTEM() /*----------------------------*/ local bool                     finiBufferSystem(BufferSystem *const bufferSystem)

	#define INITCOMPOSITORSYSTEM() /*------------------------*/ local bool                     initCompositorSystem(void)
	#define STARTCOMPOSITOR() /*-----------------------------*/ local bool                     startCompositor(void)
	#define FINDOWNEDWINDOW() /*-----------------------------*/ local bool                     findOwnedWindow(const xcb_window_t window)
	#define FINICOMPOSITORSYSTEM() /*------------------------*/ local bool                     finiCompositorSystem(void)

	#define INITWINDOWSYSTEM() /*----------------------------*/ local bool                     initWindowSystem(WindowSystem *const windowSystem)
	#define CREATEWINDOWCIRCLEPIXMAP() /*--------------------*/ local bool                     createWindowCirclePixmap(WindowSystem *const windowSystem, const uint radius, const uint32 foreground, const uint32 background)
	#define CREATEWINDOWS() /*-------------------------------*/ local bool                     createWindows(WindowSystem *const windowSystem, const uint amount, const bool overrideRedirect, const uint32 eventMask)
	#define MAPWINDOWS() /*----------------------------------*/ local bool                     mapWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences, const uint8 whichMonitor)
	#define CONFIGUREWINDOWS() /*----------------------------*/ local bool                     configureWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences, const uint8 whichMonitor)
	#define DRAWWINDOWS() /*---------------------------------*/ local bool                     drawWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences)
	#define SETWINDOWPROPERTIES() /*-------------------------*/ local bool                     setWindowProperties(WindowInfo *const windowInfo, const ElementPreferences *const windowPreferences, const int x, const int y, const uint width, const uint height)
	#define DRAWWINDOW() /*----------------------------------*/ local bool                     drawWindow(WindowSystem *const windowSystem, const WindowInfo *const windowInfo, const ElementPreferences *const windowPreferences, Monitor *const monitor, ElementRectangle *windowRectangle)
	#define UNMAPWINDOWS() /*--------------------------------*/ local bool                     unmapWindows(WindowSystem *const windowSystem)
	#define DESTROYWINDOWS() /*------------------------------*/ local bool                     destroyWindows(WindowSystem *const windowSystem)
	#define GETRECTANGLE() /*--------------------------------*/ local bool                     getRectangle(Monitor *const _monitor, const ElementRectangle *const parentRectangle, const ElementPreferences *const preferences, ElementRectangle *const rectangle)
	#define GETTYPEDNUMBER() /*------------------------------*/ local int                      getTypedNumber(const int number, const uint8 type, const uint8 axis, const int size, Monitor *const monitor)
	#define FINDWINDOW() /*----------------------------------*/ local bool                     findWindow(WindowSystem *const windowSystem, const xcb_window_t window)
	#define FINIWINDOWSYSTEM() /*----------------------------*/ local bool                     finiWindowSystem(WindowSystem *const windowSystem)

	#define SETCONFIGVARIABLES() /*--------------------------*/ local void                     setConfigVariables(void)
	#define READCONFIG() /*----------------------------------*/ local void                     readConfig(const bool createConfigFile, const char *const configPath, int (*getNextConfigChar)(void *const arg), int (*getPreviousConfigChar)(void *const arg))
	#define IFGETC() /*--------------------------------------*/ local int                      ifgetc(void *const system)
	#define MATCHNAMELIST() /*-------------------------------*/ local uint8                    matchNameList(StringTreeSystem *const stringTreeSystem, const char *const statementWall, char **statementCurrentReturn, uint8 *const valueReturn)
	#define MATCHINTEGER() /*--------------------------------*/ local uint8                    matchInteger(char **statementCurrent, const char *const statementWall, int64 *const returnValue)
	#define MATCHSTRING() /*---------------------------------*/ local bool                     matchString(char **statementCurrent, char **stringReturn, uint32 *stringToken)
	#define MATCHIMAGE() /*----------------------------------*/ local uint8                    matchImage(const char *const path, const char **errorMessage, Image *const image)
	#define MATCHCOMMAND() /*--------------------------------*/ local uint8                    matchCommand(const Command command, const char *const execute, const uint8 origin, const int32 field0, const int32 field1, const int32 field2, const int32 field3, const int32 field4)
	#define FREECONFIGVARIABLES() /*-------------------------*/ local void                     freeConfigVariables(void)

	#define GETRECTANGLEUNION() /*---------------------------*/ local void                     getRectangleUnion(const int x0, const int y0, const int width0, const int height0, const int x1, const int y1, const int width1, const int height1, int *const xReturn, int *const yReturn, int *const widthReturn, int *const heightReturn)
	#define GETINTERSECTINGRECTANGLES() /*-------------------*/ local bool                     getIntersectingRectangles(const uint source0Size, const xcb_rectangle_t *const source0Start, const uint source1Size, const xcb_rectangle_t *source1Start, uint *destinationSize, xcb_rectangle_t **destinationStart, uint32 *destinationToken)
	#define SUBTRACTRECTANGLES() /*--------------------------*/ local bool                     subtractRectangles(const uint sourceSize, const xcb_rectangle_t *const sourceStart, const uint subtractRectangleSize, const xcb_rectangle_t *const subtractRectangleStart, uint *destinationSize, xcb_rectangle_t **destinationStart, uint32 *destinationToken)
	#define SORTRECTANGLES() /*------------------------------*/ local bool                     sortRectangles(xcb_rectangle_t *const start, const uint allocated)
	#define MERGERECTANGLES() /*-----------------------------*/ local bool                     mergeRectangles(xcb_rectangle_t *const start, uint *const allocated)

	#define CREATECIRCLE() /*--------------------------------*/ local bool                     createCircle(const int radius, const uint32 foreground, const uint32 background, Image *image)
	#define COMPOSITEIMAGES() /*-----------------------------*/ local void                     compositeImages(void (*operation)(const uint32 *const, uint32 *const), const int sourceX, const int sourceY, Image *const source, int destinationX, int destinationY, Image *const destination)
	#define COMPOSITEIMAGESOVER() /*-------------------------*/ local void                     compositeImagesOver(const uint32 *const source, uint32 *const destination)
	#define COMPOSITEIMAGESAND() /*--------------------------*/ local void                     compositeImagesAnd(const uint32 *const source, uint32 *const destination)
	#define TWOPASSBOXBLUR() /*------------------------------*/ local void                     twoPassBoxBlur(const int width, const int height, const int boxSize, uint32 *destinationData)
	#define ROTATEIMAGE() /*---------------------------------*/ local bool                     rotateImage(const uint8 rotation, Image *const image, const bool deletePreviousData)

	#define XCB_SYNC() /*------------------------------------*/ local bool                     xcb_sync(void)
	#define GETWINDOWCLASS() /*------------------------------*/ local uint8                    getWindowClass(xcb_window_t window)
	#define GETFOCUSEDWINDOW() /*----------------------------*/ local xcb_window_t             getFocusedWindow(void)

	#define RESTART() /*-------------------------------------*/ local void                     restart(const bool isInsideConfig)
	#define CLEANUP() /*-------------------------------------*/ local void                     cleanup(void)
	#define CANCELTHREADS() /*-------------------------------*/ local void                     cancelThreads(void)

	#define PRINTUNACCOUNTEDFORPOINTERS() /*-----------------*/ local void                     printUnaccountedForPointers(const Pointer *current, const Pointer *wall)
	#define PRINTERROR() /*----------------------------------*/ local void                     printError(const char *const message, ...)
	#define PRINTTITLEDERROR() /*----------------------------*/ local void                     printTitledError(const char *const title, const char *const message)
	#define PRINTTITLEDQUOTEDERROR() /*----------------------*/ local void                     printTitledQuotedError(const char *const title, const char *const argument, const char *const message)
	#define PRINTCONNECTIONERROR() /*------------------------*/ local void                     printConnectionError(void)
	#define PRINTTITLEDNAMEDERROR() /*-----------------------*/ local void                     printTitledNamedError(const char *const title, const char *const message, const char *const name)
	#define PRINTXERROR() /*---------------------------------*/ local void                     printXError(const char *const *const name)
	#define PRINTTITLEDVALUEDERROR() /*----------------------*/ local void                     printTitledValuedError(const char *const title, const char *const message, const uint value)
	#define PRINTCONFIGERROR() /*----------------------------*/ local void                     printConfigError(const char *const type, const char *const message, const char finalStatementCharacter, const bool printLine, const bool printConfig, const bool printPointer, const bool printPattern, const char *const configPath, const uint statementLine, const char *const statementStart, const char *const statementWall, const Instruction *instructionStart, const Instruction *instructionCurrent, StringTreeSystem *const *const instructionDataStart, const char *const *currentScopeInstructionList, const StringTreeSystem *const currentScopeInstructionStringTreeSystem)

	#if DEBUG
		#define printCommand(s, c) /*---*/ (fprintf(DEFAULT_OUTPUT_STREAM, "%s%s: %s" s " command:%s %s\n", colorStart, programName, colorEvent, colorEnd, *(commandList + (c >= countof(commandList)? countof(commandList) - 1 : c))))
	#else
		#define printCommand(s, c) /*---*/ EMPTY_MACRO
	#endif
/*!}*/

/*!defs:{*/
	def enum ENUM_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	def enum ENUM_CONTENT(GLOBAL_INSTRUCTION);
	def enum ENUM_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	def enum ENUM_CONTENT(BOOLEAN);
	def enum ENUM_CONTENT(VARIABLE);
	def enum ENUM_CONTENT(COMMAND);
	def enum ENUM_CONTENT(MODIFIER);
	def enum ENUM_CONTENT(SHORTCUT_STATE);
	def enum ENUM_CONTENT(NUMBER_TYPE);
	def enum ENUM_CONTENT(POSITION);
	def enum ENUM_CONTENT(HORIZONTAL_ALIGNMENT);
	def enum ENUM_CONTENT(VERTICAL_ALIGNMENT);
	def enum ENUM_CONTENT(CORNER);
	def enum ENUM_CONTENT(AXIS);
	def enum ENUM_CONTENT(WHICH_MONITOR);
	def enum ENUM_CONTENT(ROTATION);
	def enum ENUM_CONTENT(MACRO);

	def struct{
		xcb_render_pictformat_t /*-*/ opaqueFormat;
		xcb_render_pictformat_t /*-*/ transparentFormat;
	} FormatSystem;

	def struct{
		xcb_pixmap_t /*------------*/ pixmap;
		xcb_gcontext_t /*----------*/ gc;
		xcb_render_picture_t /*----*/ picture;
		uint32 /*------------------*/ width;
		uint32 /*------------------*/ height;
		uint32 /*------------------*/ color;
		xcb_pixmap_t /*------------*/ wallpaperPixmap;
		uint32 /*------------------*/ wallpaperWidth;
		uint32 /*------------------*/ wallpaperHeight;
	} WallpaperSystem;

	def struct{
		xcb_rectangle_t * /*-------*/ rectangleStart;
		xcb_rectangle_t * /*-------*/ availableRectangleStart;
		xcb_rectangle_t * /*-------*/ shapeRectangleStart;
		xcb_rectangle_t * /*-------*/ drawingRectangleStart;
		uint32 /*------------------*/ rectangleSize;
		uint32 /*------------------*/ rectangleAllocated;
		uint32 /*------------------*/ rectangleToken;
		uint32 /*------------------*/ availableRectangleSize;
		uint32 /*------------------*/ availableRectangleAllocated;
		uint32 /*------------------*/ availableRectangleToken;
		uint32 /*------------------*/ shapeRectangleSize;
		uint32 /*------------------*/ shapeRectangleToken;
		uint32 /*------------------*/ drawingRectangleSize;
		uint32 /*------------------*/ drawingRectangleToken;
		xcb_window_t /*------------*/ parent;
		xcb_window_t /*------------*/ window;
		xcb_pixmap_t /*------------*/ pixmap;
		xcb_render_pictformat_t /*-*/ format;
		xcb_render_picture_t /*----*/ picture;
		xcb_damage_damage_t /*-----*/ damage;
		int32 /*-------------------*/ x;
		int32 /*-------------------*/ y;
		uint32 /*------------------*/ width;
		uint32 /*------------------*/ height;
		uint32 /*------------------*/ border;
		uint32 /*------------------*/ opacity;
		bool /*--------------------*/ depth;
		bool /*--------------------*/ mapped;
		bool /*--------------------*/ inUse;
		uint8 /*-------------------*/ pad0[5];
	} Client;

	def struct{
		Client * /*----------------*/ clientStart;
		uint32 /*------------------*/ clientToken;
		uint32 /*------------------*/ clientSize;
		uint32 /*------------------*/ clientAllocated;
		uint32 /*------------------*/ clientNotInUseOffset;
		uint32 /*------------------*/ orderedClientOffsetSize;
		uint32 /*------------------*/ orderedClientOffsetAllocated;
		uint32 * /*----------------*/ orderedClientOffsetStart;
		uint32 /*------------------*/ orderedClientOffsetToken;
		bool /*--------------------*/ createExistingLock;
		uint8 /*-------------------*/ pad0[3];
	} ClientSystem;

	def struct{
		xcb_render_picture_t /*----*/ rootPicture;
		xcb_pixmap_t /*------------*/ bufferPixmap;
		xcb_render_picture_t /*----*/ bufferPicture;
	} BufferSystem;

	def struct{
		int32 /*-------------------*/ x;
		int32 /*-------------------*/ y;
		int32 /*-------------------*/ xOffset;
		int32 /*-------------------*/ yOffset;
		int32 /*-------------------*/ width;
		int32 /*-------------------*/ height;
		int32 /*-------------------*/ padding;
		int32 /*-------------------*/ margin;
		uint8 /*-------------------*/ xType;
		uint8 /*-------------------*/ yType;
		uint8 /*-------------------*/ xOffsetType;
		uint8 /*-------------------*/ yOffsetType;
		uint8 /*-------------------*/ widthType;
		uint8 /*-------------------*/ heightType;
		uint8 /*-------------------*/ paddingType;
		uint8 /*-------------------*/ marginType;
		uint8 /*-------------------*/ position;
		uint8 /*-------------------*/ horizontalAlignment;
		uint8 /*-------------------*/ verticalAlignment;
		uint8 /*-------------------*/ pad0[3];
		bool /*--------------------*/ clipChildren;
		uint8 /*-------------------*/ cornerUsed;
		uint32 /*------------------*/ cornerRadius;
		uint32 /*------------------*/ foreground;
		uint32 /*------------------*/ background;
		uint32 /*------------------*/ selectedForeground;
		uint32 /*------------------*/ selectedBackground;
	} ElementPreferences;

	def struct{
		xcb_window_t /*------------*/ window;
		xcb_pixmap_t /*------------*/ bufferPixmap;
		xcb_pixmap_t /*------------*/ pixmap;
		xcb_gcontext_t /*----------*/ gc;
		int32 /*-------------------*/ x;
		int32 /*-------------------*/ y;
		uint32 /*------------------*/ width;
		uint32 /*------------------*/ height;
		bool /*--------------------*/ mapped;
		uint8 /*-------------------*/ pad0[3];
	} WindowInfo;

	def struct{
		xcb_pixmap_t /*------------*/ circlePixmap;
		uint32 /*------------------*/ windowInfoSize;
		WindowInfo * /*------------*/ windowInfoStart;
		uint32 /*------------------*/ windowInfoToken;
		bool /*--------------------*/ mapped;
		uint8 /*-------------------*/ pad0[3];
	} WindowSystem;

	def struct{
		Monitor * /*---------------*/ monitor;
		int32 /*-------------------*/ x;
		int32 /*-------------------*/ y;
		uint32 /*------------------*/ width;
		uint32 /*------------------*/ height;
		uint32 /*------------------*/ horizontalPadding;
		uint32 /*------------------*/ verticalPadding;
		uint32 /*------------------*/ horizontalMargin;
		uint32 /*------------------*/ verticalMargin;
	} ElementRectangle;

	def struct{
		bool /*----------------*/ (*risingOperation)(void *const arg);
		void * /*--------------*/ risingOperationArgument;
		bool /*----------------*/ (*fallingOperation)(void *const arg);
		void * /*--------------*/ fallingOperationArgument;
		uint32 /*--------------*/ seconds;
		uint32 /*--------------*/ nanoseconds;
		bool /*----------------*/ loopOperation;
		bool /*----------------*/ restartTimer;
		uint8 /*---------------*/ pad0[1];
		bool /*----------------*/ running;
		bool /*----------------*/ quittingThread;
		bool /*----------------*/ mutexCreated;
		bool /*----------------*/ condCreated;
		bool /*----------------*/ threadCreated;
		pthread_mutex_t /*-----*/ mutex;
		pthread_cond_t /*------*/ cond;
		pthread_t /*-----------*/ thread;
	} SleepThreadSystem;

	def struct{
		uint8 /*-------------------*/ letter;
		uint8 /*-------------------*/ childrenAmount;
		uint16 /*------------------*/ offset[STRING_TREE_NODE_CHILDREN_AMOUNT];
	} StringTreeNode;

	def struct{
		const char *const * /*-----*/ stringArray;
		uint32 /*------------------*/ dataSize;
		uint32 /*------------------*/ dataAllocated;
		StringTreeNode * /*--------*/ dataStart;
		uint32 /*------------------*/ dataToken;
		uint8 /*-------------------*/ counter;
		uint8 /*-------------------*/ returnedCounter;
		uint8 /*-------------------*/ pad0[2];
	} StringTreeSystem;

	def struct{
		uint32 /*------------------*/ size;
		uint32 /*------------------*/ allocated;
		char * /*------------------*/ start;
		char * /*------------------*/ current;
		uint32 /*------------------*/ token;
		uint8 /*-------------------*/ pad0[1];
		bool /*--------------------*/ threadCreated;
		bool /*--------------------*/ operating;
		bool /*--------------------*/ quittingThread;
		pthread_t /*---------------*/ thread;
	} STDINSystem;

	def struct{
		int32 /*-------------------*/ shmID;
		uint32 /*------------------*/ shmToken;
		uint8 * /*-----------------*/ start;
		uint8 * /*-----------------*/ current;
		uint32 /*------------------*/ token;
		uint8 /*-------------------*/ pad0[6];
		bool /*--------------------*/ mutexCreated;
		bool /*--------------------*/ condCreated;
		bool /*--------------------*/ threadCreated;
		bool /*--------------------*/ operating;
		bool /*--------------------*/ quittingFromInside;
		bool /*--------------------*/ quittingThread;
		pthread_mutex_t * /*-------*/ mutex;
		pthread_cond_t * /*--------*/ cond;
		pthread_t /*---------------*/ thread;
	} SharedMemorySystem;
/*!}*/

/*!globals:{*/
	local const char * /*-------------------*/ programName;
	local const char * /*-------------------*/ errorPath;
	local const char * /*-------------------*/ colorStart;
	local const char * /*-------------------*/ colorFatal;
	local const char * /*-------------------*/ colorError;
	local const char * /*-------------------*/ colorEvent;
	local const char * /*-------------------*/ colorEnd;
	local const char * /*-------------------*/ labelExamined;
	local const char * /*-------------------*/ connectionName;
	local const char * /*-------------------*/ configPath;
	local const char * /*-------------------*/ localeName;
	local const ModifierNode * /*-----------*/ eventModifierNode;
	local bool /*---------------------------*/ mustOpenErrorStream;
	local FILE * /*-------------------------*/ errorStream;
	local uint32 /*-------------------------*/ errorStreamToken;
	local volatile bool /*------------------*/ processingSignal;
	local bool /*---------------------------*/ quitting;
	local MemoryManagementSystem /*------------*/ memoryManagementSystem;
	local PermissionSystem /*---------------*/ permissionSystem;
	local bool /*---------------------------*/ globalsLockCreated;
	local pthread_rwlock_t /*---------------*/ globalsLock;
	local int /*----------------------------*/ screenNumber;
	local xcb_connection_t * /*-------------*/ connection;
	local uint32 /*-------------------------*/ connectionToken;
	local xcb_screen_t * /*-----------------*/ screen;
	local uint /*---------------------------*/ screenWidthInPixels;
	local uint /*---------------------------*/ screenHeightInPixels;
	local uint /*---------------------------*/ screenWidthInMillimeters;
	local uint /*---------------------------*/ screenHeightInMillimeters;
	local uint8 /*--------------------------*/ compositeMajorOpcode;
	local uint8 /*--------------------------*/ compositeBaseEvent;
	local uint8 /*--------------------------*/ compositeBaseError;
	local uint8 /*--------------------------*/ damageMajorOpcode;
	local uint8 /*--------------------------*/ damageBaseEvent;
	local uint8 /*--------------------------*/ damageBaseError;
	local uint8 /*--------------------------*/ randrMajorOpcode;
	local uint8 /*--------------------------*/ randrBaseEvent;
	local uint8 /*--------------------------*/ randrBaseError;
	local uint8 /*--------------------------*/ renderMajorOpcode;
	local uint8 /*--------------------------*/ renderBaseEvent;
	local uint8 /*--------------------------*/ renderBaseError;
	local uint8 /*--------------------------*/ shapeMajorOpcode;
	local uint8 /*--------------------------*/ shapeBaseEvent;
	local uint8 /*--------------------------*/ shapeBaseError;
	local uint8 /*--------------------------*/ xfixesMajorOpcode;
	local uint8 /*--------------------------*/ xfixesBaseEvent;
	local uint8 /*--------------------------*/ xfixesBaseError;
	local CommonAtoms /*--------------------*/ atom;
	local xcb_visualid_t /*-----------------*/ visual;
	local uint8 /*--------------------------*/ depth;
	local xcb_colormap_t /*-----------------*/ colormap;
	local FormatSystem /*-------------------*/ formatSystem;
	local MonitorSystem /*------------------*/ monitorSystem;
	local WallpaperSystem /*----------------*/ wallpaperSystem;
	local ClientSystem /*-------------------*/ clientSystem;
	local BufferSystem /*-------------------*/ bufferSystem;
	local xcb_window_t /*-------------------*/ previousWMCMSelectionWindow;
	local xcb_window_t /*-------------------*/ wmCMSelectionWindow;
	local xcb_timestamp_t /*----------------*/ wmCMSelectionTimestamp;
	local xcb_window_t /*-------------------*/ overlayWindow;
	local ElementPreferences /*-------------*/ windowPreferences;
	local uint8 /*--------------------------*/ whichMonitor;
	local WindowSystem /*-------------------*/ windowSystem;
	local SleepThreadSystem /*--------------*/ sleepThreadSystem;
	local StringTreeSystem /*---------------*/ globalScopesInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ globalInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ scope1ScopeInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ booleanStringTreeSystem;
	local StringTreeSystem /*---------------*/ variableStringTreeSystem;
	local StringTreeSystem /*---------------*/ commandStringTreeSystem;
	local StringTreeSystem /*---------------*/ modifierStringTreeSystem;
	local StringTreeSystem /*---------------*/ shortcutStateStringTreeSystem;
	local StringTreeSystem /*---------------*/ numberTypeStringTreeSystem;
	local StringTreeSystem /*---------------*/ horizontalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ verticalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ cornerStringTreeSystem;
	local StringTreeSystem /*---------------*/ whichMonitorStringTreeSystem;
	local StringTreeSystem /*---------------*/ macroStringTreeSystem;
	local bool /*---------------------------*/ displaySimpleConfigErrors;
	local STDINSystem /*--------------------*/ stdinSystem;
	local SharedMemorySystem /*-------------*/ sharedMemorySystem;
	local ShortcutSystem /*-----------------*/ keycodeShortcutSystem;
	local ShortcutSystem /*-----------------*/ buttonShortcutSystem;
	local xcb_generic_event_t * /*----------*/ event;
	local uint32 /*-------------------------*/ eventToken;
	local int /*----------------------------*/ keyPressNextOffset;
	local int /*----------------------------*/ keyReleaseNextOffset;
	local int /*----------------------------*/ buttonPressNextOffset;
	local int /*----------------------------*/ buttonReleaseNextOffset;
	local uint8 /*--------------------------*/ shortcutCode;
	local uint16 /*-------------------------*/ shortcutModifier;
	local bool /*---------------------------*/ expectingSecondKeyRelease;
	local uint8 /*--------------------------*/ realKeyReleaseModifier;
	local const char *const /*--------------*/ globalScopesInstructionList[] = STRING_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	local const char *const /*--------------*/ globalInstructionList[] = STRING_CONTENT(GLOBAL_INSTRUCTION);
	local const char *const /*--------------*/ scope1ScopeInstructionList[] = STRING_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	local const char *const /*--------------*/ booleanList[] = STRING_CONTENT(BOOLEAN);
	local const char *const /*--------------*/ variableList[] = STRING_CONTENT(VARIABLE);
	local const char *const /*--------------*/ commandList[] = STRING_CONTENT(COMMAND);
	local const char *const /*--------------*/ modifierList[] = STRING_CONTENT(MODIFIER);
	local const char *const /*--------------*/ shortcutStateList[] = STRING_CONTENT(SHORTCUT_STATE);
	local const char *const /*--------------*/ numberTypeList[] = STRING_CONTENT(NUMBER_TYPE);
	local const char *const /*--------------*/ horizontalAlignmentList[] = STRING_CONTENT(HORIZONTAL_ALIGNMENT);
	local const char *const /*--------------*/ verticalAlignmentList[] = STRING_CONTENT(VERTICAL_ALIGNMENT);
	local const char *const /*--------------*/ cornerList[] = STRING_CONTENT(CORNER);
	local const char *const /*--------------*/ whichMonitorList[] = STRING_CONTENT(WHICH_MONITOR);
	local const char *const /*--------------*/ macroList[] = STRING_CONTENT(MACRO);

	local const Instruction /*--------------*/ helpInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ expandInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ contractInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ readConfigInstruction[] = {STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useTerminalInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useMessengerInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ setInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ doInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ stopInstruction[] = {END_INSTRUCTION_TYPE};

	local const Instruction /*--------------*/ executeDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};

	local StringTreeSystem *const *const /*-*/ helpInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ expandInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ contractInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ readConfigInstructionData = NULL;
	local StringTreeSystem *const /*--------*/ useTerminalInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ useMessengerInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ setInstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ doInstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabKeycodeInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabButtonInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabKeycodeInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabButtonInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const *const /*-*/ stopInstructionData = NULL;

	local StringTreeSystem *const /*--------*/ executeDoSubinstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};

	#define getInstruction(i) /*-----*/ (i##Instruction)
	#define getInstructionData(i) /*-*/ (i##InstructionData)
	#define getGlobalScope(i) /*-----*/ { \
		  get##i(help) \
		, get##i(expand) \
		, get##i(contract) \
		, get##i(readConfig) \
		, get##i(useTerminal) \
		, get##i(useMessenger) \
		, get##i(set) \
		, get##i(do) \
		, get##i(grabKeycode) \
		, get##i(grabButton) \
		, get##i(ungrabKeycode) \
		, get##i(ungrabButton) \
		, get##i(stop) \
	}
/*!}*/

int main(int argumentAmount, const char *const *argument){
	setGlobals:{
		programName /*---------------*/ = *argument;
		errorPath /*-----------------*/ = NULL;
		colorStart /*----------------*/ = MESSAGE_START;
		colorFatal /*----------------*/ = MESSAGE_FATAL;
		colorError /*----------------*/ = MESSAGE_ERROR;
		colorEvent /*----------------*/ = MESSAGE_EVENT;
		colorEnd /*------------------*/ = MESSAGE_END;
		connectionName /*------------*/ = NULL;
		configPath /*----------------*/ = NULL;
		localeName /*----------------*/ = setlocale(LC_ALL, "");
		mustOpenErrorStream /*-------*/ = false;
		errorStream /*---------------*/ = DEFAULT_ERROR_STREAM;
		errorStreamToken /*----------*/ = 0;
		quitting /*------------------*/ = false;
		connection /*----------------*/ = NULL;
		connectionToken /*-----------*/ = 0;
		event /*---------------------*/ = NULL;
		eventToken /*----------------*/ = 0;
		keyPressNextOffset /*--------*/ = 0;
		keyReleaseNextOffset /*------*/ = 0;
		buttonPressNextOffset /*-----*/ = 0;
		buttonReleaseNextOffset /*---*/ = 0;
		shortcutCode /*--------------*/ = 0;
		shortcutModifier /*----------*/ = XCB_NONE;
		expectingSecondKeyRelease /*-*/ = false;
		initMemorySystem();
		initPermissionSystem(&permissionSystem);
		initCompositorSystem();
		initFormatSystem(&formatSystem);
		initMonitorSystem(&monitorSystem);
		initWallpaperSystem(&wallpaperSystem);
		initClientSystem(&clientSystem);
		initBufferSystem(&bufferSystem);
		initWindowSystem(&windowSystem);
		initSleepThreadSystem(&sleepThreadSystem);
		initStringTreeSystem(&globalScopesInstructionStringTreeSystem);
		initStringTreeSystem(&globalInstructionStringTreeSystem);
		initStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
		initStringTreeSystem(&booleanStringTreeSystem);
		initStringTreeSystem(&variableStringTreeSystem);
		initStringTreeSystem(&commandStringTreeSystem);
		initStringTreeSystem(&modifierStringTreeSystem);
		initStringTreeSystem(&shortcutStateStringTreeSystem);
		initStringTreeSystem(&numberTypeStringTreeSystem);
		initStringTreeSystem(&horizontalAlignmentStringTreeSystem);
		initStringTreeSystem(&verticalAlignmentStringTreeSystem);
		initStringTreeSystem(&cornerStringTreeSystem);
		initStringTreeSystem(&whichMonitorStringTreeSystem);
		initStringTreeSystem(&macroStringTreeSystem);
		initSTDINSystem(&stdinSystem);
		initSharedMemorySystem(&sharedMemorySystem);
		initShortcutSystem(&keycodeShortcutSystem);
		initShortcutSystem(&buttonShortcutSystem);
		setConfigVariables();
		setPermissions(&permissionSystem);
		lowerPermissions(&permissionSystem);
		processingSignal = false;
		jmp getProgramArguments;
	}
	selectInput:{
		xcb_void_cookie_t cookie;
		xcb_generic_error_t *error;
		uint32 token;
		struct{
			uint32 /*-*/ eventMask;
		} valueList;
		valueList.eventMask = XCB_EVENT_MASK_NO_EVENT;
		cookie = xcb_change_window_attributes_checked(connection, (*screen).root, XCB_CW_EVENT_MASK, &valueList);
		error = xcb_request_check(connection, cookie);
		token = pushPointer(error, "select input event mask error", iFree);
		if(error){
			printTitledError("select input error", "could not apply to receive root window events");
			free(error);
			popPointer(token);
		}
		cookie = xcb_randr_select_input_checked(connection, (*screen).root, XCB_RANDR_NOTIFY_MASK_SCREEN_CHANGE);
		error = xcb_request_check(connection, cookie);
		token = pushPointer(error, "randr select input event mask error", iFree);
		if(error){
			printTitledError("randr select input error", "could not apply to receive monitor events");
			free(error);
			popPointer(token);
		}
		xcb_flush(connection);
		jmp setupScreenProfile;
	}
	initSystems:{
		xcb_get_selection_owner_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_selection_owner_unchecked(connection, atom._NET_WM_CM_Sn), NULL);
		uint32 token = pushPointer(reply, "initSystems: get selection owner reply", iFree);
		struct{
			uint32 /*-*/ eventMask;
		} valueList;
		previousWMCMSelectionWindow = XCB_NONE;
		if(reply){
			if((*reply).owner){
				xcb_generic_error_t *error;
				uint32 token;
				previousWMCMSelectionWindow = (*reply).owner;
				valueList.eventMask = XCB_EVENT_MASK_STRUCTURE_NOTIFY;
				error = xcb_request_check(connection, xcb_change_window_attributes_checked(connection, previousWMCMSelectionWindow, XCB_CW_EVENT_MASK, &valueList));
				token = pushPointer(error, "initSystems: change window attributes error", iFree);
				if(error){
					previousWMCMSelectionWindow = XCB_NONE;
					free(error);
					popPointer(token);
				}
			}
			free(reply);
			popPointer(token);
		}
		wmCMSelectionWindow = xcb_generate_id(connection);
		wmCMSelectionTimestamp = XCB_NONE;
		valueList.eventMask = XCB_EVENT_MASK_PROPERTY_CHANGE;
		xcb_create_window(connection, XCB_COPY_FROM_PARENT, wmCMSelectionWindow, (*screen).root, -1, -1, 1, 1, 0, XCB_WINDOW_CLASS_INPUT_ONLY, (*screen).root_visual, XCB_CW_EVENT_MASK, &valueList);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, wmCMSelectionWindow, atom.MICRO_INIT, XCB_ATOM_ATOM, bitsof(xcb_atom_t), 0, NULL);
		createMonitors(&monitorSystem);
		bulkInsertString(&globalScopesInstructionStringTreeSystem, globalScopesInstructionList);
		bulkInsertString(&globalInstructionStringTreeSystem, globalInstructionList);
		bulkInsertString(&scope1ScopeInstructionStringTreeSystem, scope1ScopeInstructionList);
		bulkInsertString(&booleanStringTreeSystem, booleanList);
		bulkInsertString(&variableStringTreeSystem, variableList);
		bulkInsertString(&commandStringTreeSystem, commandList);
		bulkInsertString(&modifierStringTreeSystem, modifierList);
		bulkInsertString(&shortcutStateStringTreeSystem, shortcutStateList);
		bulkInsertString(&numberTypeStringTreeSystem, numberTypeList);
		bulkInsertString(&horizontalAlignmentStringTreeSystem, horizontalAlignmentList);
		bulkInsertString(&verticalAlignmentStringTreeSystem, verticalAlignmentList);
		bulkInsertString(&cornerStringTreeSystem, cornerList);
		bulkInsertString(&whichMonitorStringTreeSystem, whichMonitorList);
		bulkInsertString(&macroStringTreeSystem, macroList);
		jmp readConfig;
	}
	switchEvent:{
		#define XCB_ONE /*-*/ (1)
		if(((*event).response_type & ~b(10000000)) > XCB_NONE and ((*event).response_type & ~b(10000000)) < XCB_GE_GENERIC){
			printXEvent(baseEventName);
		}
		switch (*event).response_type & ~b(10000000) over
			to XCB_NONE: /*--------------*/ jmp errorEvent;
			to XCB_ONE: /*---------------*/ jmp unrecognizedEvent;
			to XCB_KEY_PRESS: /*---------*/ jmp keyPressEvent;
			to XCB_KEY_RELEASE: /*-------*/ jmp keyReleaseEvent;
			to XCB_BUTTON_PRESS: /*------*/ jmp buttonPressEvent;
			to XCB_BUTTON_RELEASE: /*----*/ jmp buttonReleaseEvent;
			to XCB_MOTION_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_ENTER_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_LEAVE_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*----------*/ jmp focusInEvent;
			to XCB_FOCUS_OUT: /*---------*/ jmp eventLoop;
			to XCB_KEYMAP_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*-*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*-------*/ jmp unexpectedEvent;
			to XCB_VISIBILITY_NOTIFY: /*-*/ jmp unexpectedEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ jmp createNotifyEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ jmp destroyNotifyEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ jmp unmapNotifyEvent;
			to XCB_MAP_NOTIFY: /*--------*/ jmp mapNotifyEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ jmp reparentNotifyEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ jmp configureNotifyEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ jmp circulateNotifyEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ jmp propertyNotifyEvent;
			to XCB_SELECTION_CLEAR: /*---*/ jmp selectionClearEvent;
			to XCB_SELECTION_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_SELECTION_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_COLORMAP_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CLIENT_MESSAGE: /*----*/ jmp eventLoop;
			to XCB_MAPPING_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*--------*/ jmp genericEvent;
			off: /*----------------------*/ jmp extensionEvent;
		end
		#undef  XCB_ONE
	}
	keyReleaseEvent:{
		#define e /*-*/ ((xcb_key_release_event_t *)event)
		uint8 keycode = (*e).detail;
		uint16 modifier = (*e).state & b(11111111);
		if(getNextShortcut(&keycodeShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &keyReleaseNextOffset)){
			xcb_query_keymap_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_keymap_unchecked(connection), NULL);
			uint32 token = pushPointer(reply, "query keymap reply", iFree);
			if(reply){
				const bool keyIsPressed = !!(*((*reply).keys + (*e).detail / 8) & (1 << (*e).detail % 8));
				free(reply);
				popPointer(token);
				if(keyIsPressed){
					keyReleaseNextOffset = 0;
					jmp eventLoop;
				}
			}
			jmp matchCommandRelease;
		}
		if(keycode != shortcutCode and modifier == shortcutModifier){
			expectingSecondKeyRelease = true;
			realKeyReleaseModifier = shortcutModifier;
			jmp eventLoop;
		}
		if(keycode == shortcutCode and modifier != shortcutModifier){
			if(!expectingSecondKeyRelease){
				jmp eventLoop;
			}
			keycode = shortcutCode;
			modifier = realKeyReleaseModifier;
			expectingSecondKeyRelease = false;
			keyReleaseNextOffset = 0;
			if(getNextShortcut(&keycodeShortcutSystem, true, keycode, modifier, &keyReleaseNextOffset)){
				jmp matchCommandRelease;
			}
		}
		jmp eventLoop;
		#undef  e
	}
	buttonPressEvent:{
		#define e /*-*/ ((xcb_button_press_event_t *)event)
		if(getNextShortcut(&buttonShortcutSystem, false, (*e).detail, (*e).state & b(11111111), &buttonPressNextOffset)){
			jmp matchCommandPress;
		}
		jmp eventLoop;
		#undef  e
	}
	buttonReleaseEvent:{
		#define e /*-*/ ((xcb_button_release_event_t *)event)
		if(getNextShortcut(&buttonShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &buttonReleaseNextOffset)){
			jmp matchCommandRelease;
		}
		jmp eventLoop;
		#undef  e
	}
	{
		uint8 commandOrigin;
		matchCommandPress:{
			commandOrigin = PRESS_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommandRelease:{
			commandOrigin = RELEASE_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommand: switch matchCommand((*eventModifierNode).command, (*eventModifierNode).string, commandOrigin, (*eventModifierNode).field0, (*eventModifierNode).field1, (*eventModifierNode).field2, (*eventModifierNode).field3, (*eventModifierNode).field4) over
			to TYPICAL_MATCH_COMMAND_TYPE:{
				jmp eventLoopCheckShortcuts;
			}
			to RESTART_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp readConfig;
			}
			to EXIT_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp mainEmergencyExit;
			}
			off:{
				jmp eventLoopCheckShortcuts;
			}
		end
	}
	focusInEvent:{
		#define e /*-*/ ((xcb_focus_in_event_t *)event)
		jmp eventLoop;
		#undef  e
	}
	createNotifyEvent:{
		#define e /*-*/ ((xcb_create_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		Client *client;
		if(findOwnedWindow(eventWindow)){
			jmp eventLoop;
		}
		if((*e).parent == (*screen).root){
			if(!(client = findClient(&clientSystem, eventWindow))){
				if(createClient(&clientSystem, &formatSystem, eventWindow, (*e).parent, XCB_WINDOW_CLASS_COPY_FROM_PARENT)){
					if((client = findClient(&clientSystem, eventWindow))){
						if((*client).mapped){
							renderCompositeClient(&bufferSystem, &wallpaperSystem, &clientSystem, findOrderedClientOffset(&clientSystem, client), (*client).x, (*client).y, (*client).width + 2 * (*client).border, (*client).height + 2 * (*client).border, true);
						}
					}
				}
			}
			jmp eventLoop;
		}
		xcb_discard_reply(connection, xcb_kill_client_checked(connection, eventWindow));
		jmp eventLoop;
		#undef  e
	}
	destroyNotifyEvent:{
		#define e /*-*/ ((xcb_destroy_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		Client *client;
		if((client = findClient(&clientSystem, eventWindow))){
			renderCompositeWithoutClient(&bufferSystem, &wallpaperSystem, &clientSystem, findOrderedClientOffset(&clientSystem, client), (*client).x, (*client).y, (*client).width + 2 * (*client).border, (*client).height + 2 * (*client).border, true);
			destroyClient(&clientSystem, client);
			jmp eventLoop;
		}
		if(!wmCMSelectionTimestamp and eventWindow == previousWMCMSelectionWindow){
			if(!startCompositor()){
				jmp mainEmergencyExit;
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  e
	}
	unmapNotifyEvent:{
		#define e /*-*/ ((xcb_unmap_notify_event_t *)event)
		Client *client;
		if((client = findClient(&clientSystem, (*e).window))){
			if(unmapClient(&clientSystem, client)){
				renderCompositeWithoutClient(&bufferSystem, &wallpaperSystem, &clientSystem, findOrderedClientOffset(&clientSystem, client), (*client).x, (*client).y, (*client).width + 2 * (*client).border, (*client).height + 2 * (*client).border, true);
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  e
	}
	mapNotifyEvent:{
		#define e /*-*/ ((xcb_map_notify_event_t *)event)
		Client *client;
		if((client = findClient(&clientSystem, (*e).window))){
			if(mapClient(&clientSystem, client)){
				renderCompositeClient(&bufferSystem, &wallpaperSystem, &clientSystem, findOrderedClientOffset(&clientSystem, client), (*client).x, (*client).y, (*client).width + 2 * (*client).border, (*client).height + 2 * (*client).border, true);
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  e
	}
	reparentNotifyEvent:{
		#define e /*-*/ ((xcb_reparent_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		Client *client = findClient(&clientSystem, eventWindow);
		if((*e).parent == (*screen).root){
			if(!client){
				if(createClient(&clientSystem, &formatSystem, eventWindow, (*e).parent, XCB_WINDOW_CLASS_COPY_FROM_PARENT)){
					if((client = findClient(&clientSystem, eventWindow))){
						if((*client).mapped){
							renderCompositeClient(&bufferSystem, &wallpaperSystem, &clientSystem, findOrderedClientOffset(&clientSystem, client), (*client).x, (*client).y, (*client).width + 2 * (*client).border, (*client).height + 2 * (*client).border, true);
						}
					}
				}
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		if(client){
			renderCompositeWithoutClient(&bufferSystem, &wallpaperSystem, &clientSystem, findOrderedClientOffset(&clientSystem, client), (*client).x, (*client).y, (*client).width + 2 * (*client).border, (*client).height + 2 * (*client).border, true);
			destroyClient(&clientSystem, client);
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  e
	}
	configureNotifyEvent:{
		#define e /*-*/ ((xcb_configure_notify_event_t *)event)
		Client *client;
		if((client = findClient(&clientSystem, (*e).window))){
			const int x = (*client).x;
			const int y = (*client).y;
			const int width = (*client).width;
			const int height = (*client).height;
			const int border = (*client).border;
			if((*e).x != x or (*e).y != y or (*e).width != width or (*e).height != height or (*e).border_width != border){
				renderCompositeWithoutClient(&bufferSystem, &wallpaperSystem, &clientSystem, findOrderedClientOffset(&clientSystem, client), x, y, width + 2 * border, height + 2 * border, false);
			}
			configureClient(&clientSystem, client, (*e).x, (*e).y, (*e).width, (*e).height, (*e).border_width, (*e).above_sibling? XCB_STACK_MODE_ABOVE : XCB_STACK_MODE_BELOW, (*e).above_sibling);
			if((*client).mapped){
				int combinedX;
				int combinedY;
				int combinedWidth;
				int combinedHeight;
				renderCompositeClient(&bufferSystem, &wallpaperSystem, &clientSystem, findOrderedClientOffset(&clientSystem, client), (*client).x, (*client).y, (*client).width + 2 * (*client).border, (*client).height + 2 * (*client).border, false);
				getRectangleUnion(x, y, width + 2 * border, height + 2 * border, (*client).x, (*client).y, (*client).width + 2 * (*client).border, (*client).height + 2 * (*client).border, &combinedX, &combinedY, &combinedWidth, &combinedHeight);
				/*! commitBuffer(&bufferSystem, 0, 0, screenWidthInPixels, screenHeightInPixels); */
				redrawBuffer(&bufferSystem, &wallpaperSystem, &clientSystem);
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  e
	}
	circulateNotifyEvent:{
		#define e /*-*/ ((xcb_circulate_notify_event_t *)event)
		Client *client;
		if((client = findClient(&clientSystem, (*e).event))){
			uint8 stackMode = XCB_STACK_MODE_BELOW;
			if((*e).place == XCB_PLACE_ON_TOP){
				stackMode = XCB_STACK_MODE_ABOVE;
			}
			if(restackClient(&clientSystem, client, stackMode, XCB_NONE)){
				uint *const orderedClientOffset = clientSystem.orderedClientOffsetStart + clientSystem.orderedClientOffsetAllocated - 1;
				if(calculateClientsRectangles(&clientSystem, orderedClientOffset)){
					renderCompositeClient(&bufferSystem, &wallpaperSystem, &clientSystem, orderedClientOffset, (*client).x, (*client).y, (*client).width + 2 * (*client).border, (*client).height + 2 * (*client).border, true);
				}
			}
		}
		jmp eventLoop;
		#undef  e
	}
	propertyNotifyEvent:{
		#define e /*-*/ ((xcb_property_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		const xcb_atom_t property = (*e).atom;
		Client *client;
		if(eventWindow == (*screen).root){
			if(property == atom._NET_VIRTUAL_ROOTS){
				/*! remove and add virtual roots */
				jmp eventLoop;
			}
			if(property == atom._XROOTPMAP_ID){
				if((client = findClient(&clientSystem, (*screen).root))){
					setWallpaperPixmap(&wallpaperSystem, &formatSystem, &monitorSystem, atom._XROOTPMAP_ID);
					renderCompositeClient(&bufferSystem, &wallpaperSystem, &clientSystem, findOrderedClientOffset(&clientSystem, client), (*client).x, (*client).y, (*client).width + 2 * (*client).border, (*client).height + 2 * (*client).border, true);
				}
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		if((client = findClient(&clientSystem, eventWindow))){
			if(property == atom._NET_WM_WINDOW_OPACITY){
				xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property(connection, false, eventWindow, atom._NET_WM_WINDOW_OPACITY, XCB_ATOM_CARDINAL, 0, 0xFFFFFFFF), NULL);
				uint32 token = pushPointer(reply, "propertyNotifyEvent: get property reply", iFree);
				if(reply){
					if(xcb_get_property_value_length(reply) == sizeof(uint32)){
						(*client).opacity = *(uint32 *)xcb_get_property_value(reply);
					}
					free(reply);
					popPointer(token);
				}
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		if(eventWindow == wmCMSelectionWindow){
			if(property == atom.MICRO_INIT){
				if((*e).state == XCB_PROPERTY_NEW_VALUE and !wmCMSelectionTimestamp){
					xcb_get_selection_owner_reply_t *reply;
					uint32 token;
					xcb_window_t owner = XCB_NONE;
					xcb_set_selection_owner(connection, wmCMSelectionWindow, atom._NET_WM_CM_Sn, getTimestamp());
					xcb_delete_property(connection, eventWindow, atom.MICRO_INIT);
					xcb_sync();
					reply = xcb_wait_for_reply(connection, xcb_get_selection_owner_unchecked(connection, atom._NET_WM_CM_Sn), NULL);
					token = pushPointer(reply, "propertyNotifyEvent: get selection owner reply", iFree);
					if(reply){
						owner = (*reply).owner;
						free(reply);
						popPointer(token);
					}
					if(!previousWMCMSelectionWindow){
						if(owner != wmCMSelectionWindow){
							printTitledError("selection error", "could not get ownership of _NET_WM_CM_Sn selection");
							jmp mainEmergencyExit;
						}
						if(!startCompositor()){
							jmp mainEmergencyExit;
						}
					}
				}
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  e
	}
	selectionClearEvent:{
		#define e /*-*/ ((xcb_selection_clear_event_t *)event)
		if((*e).selection == atom._NET_WM_CM_Sn and (*e).owner == wmCMSelectionWindow){
			jmp mainEmergencyExit;
		}
		jmp eventLoop;
		#undef  e
	}
	genericEvent:{
		#define e /*-*/ ((xcb_ge_generic_event_t *)event)
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  e
	}
	extensionEvent:{
		#define isExtensionEvent(e) /*-*/ (eventType >= e##BaseEvent and eventType < e##BaseEvent + countof(e##EventName) - 1)
		const uint8 eventType = (*event).response_type & ~b(10000000);
		if(isExtensionEvent(composite)) /*-*/ jmp switchCompositeEvent;
		if(isExtensionEvent(damage)) /*----*/ jmp switchDamageEvent;
		if(isExtensionEvent(randr)) /*-----*/ jmp switchRandrEvent;
		if(isExtensionEvent(render)) /*----*/ jmp switchRenderEvent;
		if(isExtensionEvent(shape)) /*-----*/ jmp switchShapeEvent;
		if(isExtensionEvent(xfixes)) /*----*/ jmp switchXfixesEvent;
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  isExtensionEvent
	}
	switchCompositeEvent:{
		printXEvent(compositeEventName);
		switch ((*event).response_type & ~b(10000000)) - compositeBaseEvent over
			off: /*-*/ jmp unrecognizedEvent;
		end
	}
	switchDamageEvent:{
		printXEvent(damageEventName);
		switch ((*event).response_type & ~b(10000000)) - damageBaseEvent over
			to XCB_DAMAGE_NOTIFY:{
				#define e /*-*/ ((xcb_damage_notify_event_t *)event)
				Client *client;
				xcb_discard_reply(connection, xcb_damage_subtract_checked(connection, (*e).damage, XCB_NONE, XCB_NONE));
				if((client = findClient(&clientSystem, (*e).drawable))){
					if((*client).mapped and (*client).rectangleAllocated){
						const xcb_rectangle_t *const rectangle = &(*e).area;
						renderCompositeClient(&bufferSystem, &wallpaperSystem, &clientSystem, findOrderedClientOffset(&clientSystem, client), (*client).x + (*client).border + (*rectangle).x, (*client).y + (*client).border + (*rectangle).y, (*rectangle).width, (*rectangle).height, true);
					}
					jmp eventLoop;
				}
				jmp eventLoop;
				#undef  e
			}
			off:{
				jmp unrecognizedEvent;
			}
		end
	}
	switchRandrEvent:{
		printXEvent(randrEventName);
		switch ((*event).response_type & ~b(10000000)) - randrBaseEvent over
			to XCB_RANDR_SCREEN_CHANGE_NOTIFY:
			to XCB_RANDR_NOTIFY:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
					printTitledError("pthread error", "could not lock globals write lock");
				}
				{
					int screenNumber;
					xcb_connection_t *const connection = xcb_connect_to_display_with_auth_info(connectionName, NULL, &screenNumber);
					uint32 token = pushPointer(connection, "X connection", iXCBDisconnect);
					if(connection){
						xcb_screen_t *const screen = xcb_setup_roots_iterator(xcb_get_setup(connection)).data + screenNumber;
						if(screen){
							screenWidthInPixels = (*screen).width_in_pixels;
							screenHeightInPixels = (*screen).height_in_pixels;
							screenWidthInMillimeters = (*screen).width_in_millimeters;
							screenHeightInMillimeters = (*screen).height_in_millimeters;
						}else{
							screenWidthInPixels = 0;
							screenHeightInPixels = 0;
							screenWidthInMillimeters = 0;
							screenHeightInMillimeters = 0;
						}
						xcb_disconnect(connection);
						popPointer(token);
					}
				}
				createMonitors(&monitorSystem);
				createWallpaper(&wallpaperSystem, &formatSystem, &monitorSystem, screenWidthInPixels, screenHeightInPixels);
				configureClient(&clientSystem, findClient(&clientSystem, (*screen).root), 0, 0, screenWidthInPixels, screenHeightInPixels, 0, XCB_STACK_MODE_BELOW, XCB_NONE);
				calculateClientsRectangles(&clientSystem, clientSystem.orderedClientOffsetStart + clientSystem.orderedClientOffsetAllocated - 1);
				createBufferSystem(&bufferSystem, overlayWindow);
				redrawBuffer(&bufferSystem, &wallpaperSystem, &clientSystem);
				jmp eventLoop;
			}
			off:{
				jmp unrecognizedEvent;
			}
		end
	}
	switchRenderEvent:{
		printXEvent(renderEventName);
		switch ((*event).response_type & ~b(10000000)) - renderBaseEvent over
			off: /*-*/ jmp unrecognizedEvent;
		end
	}
	switchShapeEvent:{
		printXEvent(shapeEventName);
		switch ((*event).response_type & ~b(10000000)) - shapeBaseEvent over
			to XCB_SHAPE_NOTIFY:{
				#define e /*-*/ ((xcb_shape_notify_event_t *)event)
				Client *client;
				if((*e).shape_kind != XCB_SHAPE_SK_BOUNDING){
					jmp eventLoop;
				}
				if((client = findClient(&clientSystem, (*e).affected_window))){
					xcb_shape_get_rectangles_reply_t *const reply = xcb_wait_for_reply(connection, xcb_shape_get_rectangles(connection, (*client).window, XCB_SHAPE_SK_BOUNDING), NULL);
					uint32 token = pushPointer(reply, "get rectangles reply", iFree);
					if(reply){
						const uint size = xcb_shape_get_rectangles_rectangles_length(reply);
						const xcb_rectangle_t *const rectangleStart = xcb_shape_get_rectangles_rectangles(reply);
						free((*client).shapeRectangleStart);
						popPointer((*client).shapeRectangleToken);
						(*client).shapeRectangleSize = 0;
						(*client).shapeRectangleStart = NULL;
						(*client).shapeRectangleToken = 0;
						if(size > 0 and ((*rectangleStart).x or (*rectangleStart).y or (*rectangleStart).width != (*client).width + 2 * (*client).border or (*rectangleStart).height != (*client).height + 2 * (*client).border)){
							uint *orderedClientOffset = findOrderedClientOffset(&clientSystem, client);
							xcb_rectangle_t *current;
							xcb_rectangle_t *wall;
							(*client).shapeRectangleSize = size;
							(*client).shapeRectangleStart = malloc((*client).shapeRectangleSize * sizeof(xcb_rectangle_t));
							(*client).shapeRectangleToken = pushPointer((*client).shapeRectangleStart, "shape rectangles pointer", iFree);
							if(!(*client).shapeRectangleStart){
								(*client).shapeRectangleSize = 0;
							}
							current = (*client).shapeRectangleStart;
							wall = current + (*client).shapeRectangleSize;
							copyMemory(rectangleStart, (*client).shapeRectangleStart, (*client).shapeRectangleSize * sizeof(xcb_rectangle_t));
							renderCompositeWithoutClient(&bufferSystem, &wallpaperSystem, &clientSystem, orderedClientOffset, (*client).x, (*client).y, (*client).width + 2 * (*client).border, (*client).height + 2 * (*client).border, false);
							jmp makeShapeRectangleGlobalLoop;
							makeShapeRectangleGlobalLoop:{
								if(current < wall){
									(*current).x += (*client).x;
									(*current).y += (*client).y;
									inc current;
									jmp makeShapeRectangleGlobalLoop;
								}
								sortRectangles((*client).shapeRectangleStart, (*client).shapeRectangleSize);
								calculateClientsRectangles(&clientSystem, orderedClientOffset);
								renderCompositeClient(&bufferSystem, &wallpaperSystem, &clientSystem, orderedClientOffset, (*client).x, (*client).y, (*client).width + 2 * (*client).border, (*client).height + 2 * (*client).border, false);
								commitBuffer(&bufferSystem, (*client).x, (*client).y, (*client).width + 2 * (*client).border, (*client).height + 2 * (*client).border);
							}
						}
						free(reply);
						popPointer(token);
					}
				}
				jmp eventLoop;
				#undef  e
			}
			off:{
				jmp unrecognizedEvent;
			}
		end
	}
	switchXfixesEvent:{
		printXEvent(xfixesEventName);
		switch ((*event).response_type & ~b(10000000)) - xfixesBaseEvent over
			to XCB_XFIXES_SELECTION_NOTIFY: /*-*/ jmp eventLoop;
			to XCB_XFIXES_CURSOR_NOTIFY: /*----*/ jmp eventLoop;
			off: /*----------------------------*/ jmp unrecognizedEvent;
		end
	}
	unrecognizedEvent:{
		printTitledValuedError("X event error", "unrecognized event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unexpectedEvent:{
		printTitledValuedError("unexpected X event", "unexpected event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unhandledEvent:{
		printTitledValuedError("X event error", "unhandled event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	mainEmergencyExit:{
		cleanup();
		ret 0;
	}
}
INITFORMATSYSTEM(){
	if(!formatSystem){
		ret false;
	}
	(*formatSystem).opaqueFormat = XCB_NONE;
	(*formatSystem).transparentFormat = XCB_NONE;
	ret true;
}
REQUESTFORMATS(){
	const xcb_render_pictforminfo_t *current;
	const xcb_render_pictforminfo_t *wall;
	xcb_render_query_pict_formats_reply_t *reply;
	uint32 token;
	if(!formatSystem){
		ret false;
	}
	reply = xcb_wait_for_reply(connection, xcb_render_query_pict_formats_unchecked(connection), NULL);
	token = pushPointer(reply, "render query pict formats reply", iFree);
	if(!reply){
		ret false;
	}
	current = xcb_render_query_pict_formats_formats(reply);
	wall = current + xcb_render_query_pict_formats_formats_length(reply);
	(*formatSystem).opaqueFormat = XCB_NONE;
	(*formatSystem).transparentFormat = XCB_NONE;
	jmp formatLoop;
	formatLoop:{
		if(current < wall){
			if((*current).type == XCB_RENDER_PICT_TYPE_DIRECT){
				if((*current).depth == 24 and !(*formatSystem).opaqueFormat){
					(*formatSystem).opaqueFormat = (*current).id;
				}
				if((*current).depth == 32 and !(*formatSystem).transparentFormat){
					(*formatSystem).transparentFormat = (*current).id;
				}
				if((*formatSystem).opaqueFormat and (*formatSystem).transparentFormat){
					jmp returnFormats;
				}
			}
			inc current;
			jmp formatLoop;
		}
		jmp returnFormats;
	}
	returnFormats:{
		free(reply);
		popPointer(token);
		ret (*formatSystem).opaqueFormat or (*formatSystem).transparentFormat;
	}
}
FINDFORMAT(){
	if(!formatSystem or !depth){
		ret XCB_NONE;
	}
	if(depth == 32){
		ret (*formatSystem).transparentFormat;
	}
	ret (*formatSystem).opaqueFormat;
}
FINIFORMATSYSTEM(){
	if(!formatSystem){
		ret false;
	}
	(*formatSystem).opaqueFormat = XCB_NONE;
	(*formatSystem).transparentFormat = XCB_NONE;
	ret true;
}
INITWALLPAPERSYSTEM(){
	if(!wallpaperSystem){
		ret false;
	}
	(*wallpaperSystem).pixmap = XCB_NONE;
	(*wallpaperSystem).gc = XCB_NONE;
	(*wallpaperSystem).picture = XCB_NONE;
	(*wallpaperSystem).width = 0;
	(*wallpaperSystem).height = 0;
	(*wallpaperSystem).color = 0x00000000;
	(*wallpaperSystem).wallpaperPixmap = XCB_NONE;
	(*wallpaperSystem).wallpaperWidth = 0;
	(*wallpaperSystem).wallpaperHeight = 0;
	ret true;
}
SETWALLPAPERCOLOR(){
	if(!wallpaperSystem or !formatSystem or !monitorSystem or !(*monitorSystem).size){
		ret false;
	}
	(*wallpaperSystem).color = color;
	createWallpaper(wallpaperSystem, formatSystem, monitorSystem, (*wallpaperSystem).width, (*wallpaperSystem).height);
	ret true;
}
SETWALLPAPERPIXMAP(){
	xcb_pixmap_t pixmap;
	uint width;
	uint height;
	if(!wallpaperSystem or !formatSystem or !monitorSystem or !(*monitorSystem).size or !pixmapProperty){
		ret false;
	}
	jmp getWallpaper;
	getWallpaper:{
		xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property_unchecked(connection, false, (*screen).root, pixmapProperty, XCB_ATOM_PIXMAP, 0, 0xFFFFFFFF), NULL);
		uint32 token = pushPointer(reply, "setWallpaperPixmap() get property reply", iFree);
		if(!reply){
			ret false;
		}
		pixmap = XCB_NONE;
		if(xcb_get_property_value_length(reply) == sizeof(xcb_pixmap_t)){
			pixmap = *(xcb_pixmap_t *)xcb_get_property_value(reply);
		}
		free(reply);
		popPointer(token);
		if(!pixmap){
			ret false;
		}
		jmp getWallpaperSize;
	}
	getWallpaperSize:{
		xcb_get_geometry_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_geometry(connection, pixmap), NULL);
		uint32 token = pushPointer(reply, "setWallpaperPixmap() get geometry reply", iFree);
		width = 0;
		height = 0;
		if(reply){
			width = (*reply).width;
			height = (*reply).height;
			free(reply);
			popPointer(token);
		}
		if(!width or !height){
			ret false;
		}
		jmp setWallpaper;
	}
	setWallpaper:{
		const xcb_gcontext_t gc = xcb_generate_id(connection);
		struct{
			uint32 /*-*/ generateExpose;
		} valueList;
		valueList.generateExpose = false;
		if((*wallpaperSystem).wallpaperPixmap){
			xcb_free_pixmap(connection, (*wallpaperSystem).wallpaperPixmap);
		}
		(*wallpaperSystem).wallpaperPixmap = xcb_generate_id(connection);
		(*wallpaperSystem).wallpaperWidth = width;
		(*wallpaperSystem).wallpaperHeight = height;
		xcb_create_pixmap(connection, (*screen).root_depth, (*wallpaperSystem).wallpaperPixmap, (*screen).root, width, height);
		xcb_create_gc(connection, gc, (*wallpaperSystem).wallpaperPixmap, XCB_GC_GRAPHICS_EXPOSURES, &valueList);
		fillDrawable((*wallpaperSystem).wallpaperPixmap, gc, 0, 0, width, height, (*wallpaperSystem).color);
		xcb_discard_reply(connection, xcb_copy_area_checked(connection, pixmap, (*wallpaperSystem).wallpaperPixmap, gc, 0, 0, 0, 0, width, height));
		xcb_free_gc(connection, gc);
		jmp createWallpaper;
	}
	createWallpaper:{
		createWallpaper(wallpaperSystem, formatSystem, monitorSystem, (*wallpaperSystem).width, (*wallpaperSystem).height);
		ret true;
	}
}
CREATEWALLPAPER(){
	struct{
		uint32 /*-*/ generateExpose;
	} valueList;
	if(!wallpaperSystem or !formatSystem or !monitorSystem or !(*monitorSystem).size or !width or !height){
		ret false;
	}
	valueList.generateExpose = false;
	if((*wallpaperSystem).picture){
		xcb_render_free_picture(connection, (*wallpaperSystem).picture);
	}
	if((*wallpaperSystem).gc){
		xcb_free_gc(connection, (*wallpaperSystem).gc);
	}
	if((*wallpaperSystem).pixmap){
		xcb_free_pixmap(connection, (*wallpaperSystem).pixmap);
	}
	(*wallpaperSystem).pixmap = xcb_generate_id(connection);
	(*wallpaperSystem).gc = xcb_generate_id(connection);
	(*wallpaperSystem).picture = xcb_generate_id(connection);
	(*wallpaperSystem).width = width;
	(*wallpaperSystem).height = height;
	xcb_create_pixmap(connection, (*screen).root_depth, (*wallpaperSystem).pixmap, (*screen).root, (*wallpaperSystem).width, (*wallpaperSystem).height);
	xcb_create_gc(connection, (*wallpaperSystem).gc, (*wallpaperSystem).pixmap, XCB_GC_GRAPHICS_EXPOSURES, &valueList);
	xcb_render_create_picture(connection, (*wallpaperSystem).picture, (*wallpaperSystem).pixmap, findFormat(formatSystem, (*screen).root_depth), XCB_NONE, NULL);
	fillDrawable((*wallpaperSystem).pixmap, (*wallpaperSystem).gc, 0, 0, (*wallpaperSystem).width, (*wallpaperSystem).height, (*wallpaperSystem).color);
	if((*wallpaperSystem).wallpaperPixmap){
		xcb_copy_area(connection, (*wallpaperSystem).wallpaperPixmap, (*wallpaperSystem).pixmap, (*wallpaperSystem).gc, 0, 0, 0, 0, (*wallpaperSystem).wallpaperWidth, (*wallpaperSystem).wallpaperHeight);
	}
	ret true;
}
FINIWALLPAPERSYSTEM(){
	if(!wallpaperSystem){
		ret false;
	}
	(*wallpaperSystem).wallpaperWidth = 0;
	(*wallpaperSystem).wallpaperHeight = 0;
	if((*wallpaperSystem).wallpaperPixmap){
		xcb_free_pixmap(connection, (*wallpaperSystem).wallpaperPixmap);
		(*wallpaperSystem).wallpaperPixmap = XCB_NONE;
	}
	(*wallpaperSystem).width = 0;
	(*wallpaperSystem).height = 0;
	(*wallpaperSystem).color = 0x00000000;
	if((*wallpaperSystem).gc){
		xcb_free_gc(connection, (*wallpaperSystem).gc);
		(*wallpaperSystem).gc = XCB_NONE;
	}
	if((*wallpaperSystem).picture){
		xcb_render_free_picture(connection, (*wallpaperSystem).picture);
		(*wallpaperSystem).picture = XCB_NONE;
	}
	if((*wallpaperSystem).pixmap){
		xcb_free_pixmap(connection, (*wallpaperSystem).pixmap);
		(*wallpaperSystem).pixmap = XCB_NONE;
	}
	ret true;
}
INITCLIENTSYSTEM(){
	#define CLIENT_BLOCK_SIZE /*-*/ (64)
	if(!clientSystem){
		ret false;
	}
	(*clientSystem).clientSize = 0;
	(*clientSystem).clientAllocated = 0;
	(*clientSystem).clientNotInUseOffset = 0;
	(*clientSystem).clientStart = NULL;
	(*clientSystem).clientToken = 0;
	(*clientSystem).orderedClientOffsetSize = 0;
	(*clientSystem).orderedClientOffsetAllocated = 0;
	(*clientSystem).orderedClientOffsetStart = NULL;
	(*clientSystem).orderedClientOffsetToken = 0;
	(*clientSystem).createExistingLock = false;
	ret true;
}
CREATEEXISTINGCLIENTS(){
	const xcb_window_t *rootSubwindowCurrent;
	const xcb_window_t *rootSubwindowWall;
	xcb_window_t *virtualRootStart;
	xcb_window_t *virtualRootWall;
	xcb_query_tree_cookie_t treeCookie;
	xcb_query_tree_reply_t *treeReply;
	uint32 treeToken;
	xcb_get_property_cookie_t propertyCookie;
	xcb_get_property_reply_t *propertyReply;
	uint32 propertyToken;
	if(!clientSystem or !formatSystem){
		ret false;
	}
	treeCookie = xcb_query_tree_unchecked(connection, (*screen).root);
	propertyCookie = xcb_get_property(connection, false, (*screen).root, atom._NET_VIRTUAL_ROOTS, XCB_ATOM_WINDOW, 0, 0xFFFFFFFF);
	treeReply = xcb_wait_for_reply(connection, treeCookie, NULL);
	treeToken = pushPointer(treeReply, "query tree reply", iFree);
	propertyReply = xcb_get_property_reply(connection, propertyCookie, NULL);
	propertyToken = pushPointer(treeReply, "get property reply", iFree);
	if(!treeReply or !propertyReply){
		free(treeReply);
		popPointer(treeToken);
		free(propertyReply);
		popPointer(propertyToken);
		ret false;
	}
	rootSubwindowCurrent = xcb_query_tree_children(treeReply);
	rootSubwindowWall = rootSubwindowCurrent + xcb_query_tree_children_length(treeReply);
	virtualRootStart = xcb_get_property_value(propertyReply);
	virtualRootWall = virtualRootStart + xcb_get_property_value_length(propertyReply) / sizeof(xcb_window_t);
	destroyClients(clientSystem);
	(*clientSystem).createExistingLock = true;
	createClient(clientSystem, formatSystem, (*screen).root, XCB_NONE, XCB_WINDOW_CLASS_INPUT_OUTPUT);
	jmp createRootSubwindowLoop;
	createRootSubwindowLoop:{
		if(rootSubwindowCurrent < rootSubwindowWall){
			const xcb_window_t window = *rootSubwindowCurrent;
			createClient(clientSystem, formatSystem, window, (*screen).root, XCB_WINDOW_CLASS_COPY_FROM_PARENT);
			inc rootSubwindowCurrent;
			jmp createRootSubwindowLoop;
		}
		free(treeReply);
		popPointer(treeToken);
		free(propertyReply);
		popPointer(propertyToken);
		(*clientSystem).createExistingLock = false;
		calculateClientsRectangles(clientSystem, (*clientSystem).orderedClientOffsetStart + (*clientSystem).orderedClientOffsetAllocated - 1);
		ret true;
	}
}
CREATECLIENT(){
	Client *client;
	xcb_get_geometry_reply_t *geometryReply;
	uint32 geometryToken;
	xcb_get_window_attributes_reply_t *attributesReply;
	uint32 attributesToken;
	if(!clientSystem or !formatSystem or !window or window == overlayWindow){
		ret false;
	}
	if(!class or class == XCB_WINDOW_CLASS_COPY_FROM_PARENT){
		class = getWindowClass(window);
	}
	if(class != XCB_WINDOW_CLASS_INPUT_OUTPUT){
		ret false;
	}
	jmp addClient;
	addClient:{
		if((*clientSystem).clientAllocated == (*clientSystem).clientSize){
			void *temp;
			(*clientSystem).clientSize += CLIENT_BLOCK_SIZE;
			temp = realloc((*clientSystem).clientStart, (*clientSystem).clientSize * sizeof(Client));
			if(!(*clientSystem).clientToken){
				(*clientSystem).clientToken = pushPointer(temp, "client pointer", iFree);
			}else{
				updatePointer((*clientSystem).clientToken, temp);
			}
			if(!temp){
				printTitledError("memory allocation error", "could not allocate memory for clients");
				(*clientSystem).clientSize -= CLIENT_BLOCK_SIZE;
				ret false;
			}
			(*clientSystem).clientStart = temp;
		}
		if((*clientSystem).orderedClientOffsetAllocated == (*clientSystem).orderedClientOffsetSize){
			void *temp;
			(*clientSystem).orderedClientOffsetSize += CLIENT_BLOCK_SIZE;
			temp = realloc((*clientSystem).orderedClientOffsetStart, (*clientSystem).orderedClientOffsetSize * sizeof(uint));
			if(!(*clientSystem).orderedClientOffsetToken){
				(*clientSystem).orderedClientOffsetToken = pushPointer(temp, "ordered client offset pointer", iFree);
			}else{
				updatePointer((*clientSystem).orderedClientOffsetToken, temp);
			}
			if(!temp){
				printTitledError("memory allocation error", "could not allocate memory for ordered client offsets");
				(*clientSystem).orderedClientOffsetSize -= CLIENT_BLOCK_SIZE;
				ret false;
			}
			(*clientSystem).orderedClientOffsetStart = temp;
		}
		client = (*clientSystem).clientStart + (*clientSystem).clientNotInUseOffset;
		*((*clientSystem).orderedClientOffsetStart + (*clientSystem).orderedClientOffsetAllocated) = (*clientSystem).clientNotInUseOffset;
		inc (*clientSystem).orderedClientOffsetAllocated;
		if((*clientSystem).clientNotInUseOffset == (*clientSystem).clientAllocated){
			inc (*clientSystem).clientAllocated;
			inc (*clientSystem).clientNotInUseOffset;
			jmp setDefaultClient;
		}
		jmp findNextAvailableClientSlot;
	}
	findNextAvailableClientSlot:{
		const Client *current = client + 1;
		const Client *const wall = (*clientSystem).clientStart + (*clientSystem).clientAllocated;
		jmp findNextAvailableClientSlotLoop;
		findNextAvailableClientSlotLoop:{
			if(current < wall and (*current).inUse){
				inc current;
				jmp findNextAvailableClientSlotLoop;
			}
			(*clientSystem).clientNotInUseOffset = current - (*clientSystem).clientStart;
			jmp setDefaultClient;
		}
	}
	setDefaultClient:{
		(*client).rectangleSize = 0;
		(*client).rectangleAllocated = 0;
		(*client).rectangleStart = NULL;
		(*client).rectangleToken = 0;
		(*client).availableRectangleSize = 0;
		(*client).availableRectangleAllocated = 0;
		(*client).availableRectangleStart = NULL;
		(*client).availableRectangleToken = 0;
		(*client).shapeRectangleSize = 0;
		(*client).shapeRectangleStart = NULL;
		(*client).shapeRectangleToken = 0;
		(*client).drawingRectangleSize = 0;
		(*client).drawingRectangleStart = NULL;
		(*client).drawingRectangleToken = 0;
		(*client).parent = parent;
		(*client).window = window;
		(*client).pixmap = XCB_NONE;
		(*client).format = findFormat(formatSystem, 24);
		(*client).picture = XCB_NONE;
		(*client).damage = XCB_NONE;
		(*client).x = -1;
		(*client).y = -1;
		(*client).width = 1;
		(*client).height = 1;
		(*client).border = 0;
		(*client).opacity = 0x00000000;
		(*client).mapped = false;
		(*client).inUse = true;
		if(window == (*screen).root){
			(*client).x = 0;
			(*client).y = 0;
			(*client).width = screenWidthInPixels;
			(*client).height = screenHeightInPixels;
			ret true;
		}
		jmp setClient;
	}
	setClient:{
		xcb_get_geometry_cookie_t geometryCookie;
		xcb_get_window_attributes_cookie_t attributesCookie;
		uint8 depth;
		struct{
			uint32 /*-*/ eventMask;
		} valueList;
		geometryReply = NULL;
		geometryToken = 0;
		attributesReply = NULL;
		attributesToken = 0;
		geometryCookie = xcb_get_geometry(connection, window);
		attributesCookie = xcb_get_window_attributes(connection, window);
		geometryReply = xcb_wait_for_reply(connection, geometryCookie, NULL);
		geometryToken = pushPointer(geometryReply, "get geometry reply", iFree);
		attributesReply = xcb_wait_for_reply(connection, attributesCookie, NULL);
		attributesToken = pushPointer(geometryReply, "get window attributes reply", iFree);
		if(!geometryReply or !attributesReply){
			jmp emergencyExit;
		}
		depth = (*geometryReply).depth;
		if(depth != 24 and depth != 32){
			jmp emergencyExit;
		}
		(*client).format = findFormat(formatSystem, depth);
		(*client).x = (*geometryReply).x;
		(*client).y = (*geometryReply).y;
		(*client).width = (*geometryReply).width;
		(*client).height = (*geometryReply).height;
		(*client).border = (*geometryReply).border_width;
		(*client).depth = depth;
		(*client).mapped = (*attributesReply).map_state != XCB_MAP_STATE_UNMAPPED;
		valueList.eventMask = XCB_EVENT_MASK_PROPERTY_CHANGE;
		restackClient(clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE);
		xcb_discard_reply(connection, xcb_shape_select_input_checked(connection, (*client).window, true));
		xcb_discard_reply(connection, xcb_change_window_attributes_checked(connection, (*client).window, XCB_CW_EVENT_MASK, &valueList));
		if((*client).mapped){
			(*client).mapped = false;
			mapClient(clientSystem, client);
		}
		jmp emergencyExit;
	}
	emergencyExit:{
		free(geometryReply);
		popPointer(geometryToken);
		free(attributesReply);
		popPointer(attributesToken);
		ret true;
	}
}
MAPCLIENT(){
	xcb_get_property_cookie_t propertyCookie;
	xcb_get_property_reply_t *propertyReply;
	uint32 propertyToken;
	xcb_shape_get_rectangles_cookie_t rectanglesCookie;
	xcb_shape_get_rectangles_reply_t *rectanglesReply;
	uint32 rectanglesToken;
	if(!clientSystem or !isValidClient(clientSystem, client) or (*client).mapped){
		ret false;
	}
	(*client).pixmap = xcb_generate_id(connection);
	(*client).picture = xcb_generate_id(connection);
	(*client).damage = xcb_generate_id(connection);
	(*client).mapped = true;
	xcb_discard_reply(connection, xcb_composite_name_window_pixmap_checked(connection, (*client).window, (*client).pixmap));
	xcb_discard_reply(connection, xcb_render_create_picture_checked(connection, (*client).picture, (*client).pixmap, (*client).format, XCB_NONE, NULL));
	xcb_discard_reply(connection, xcb_damage_create_checked(connection, (*client).damage, (*client).window, XCB_DAMAGE_REPORT_LEVEL_RAW_RECTANGLES));
	propertyCookie = xcb_get_property(connection, false, (*client).window, atom._NET_WM_WINDOW_OPACITY, XCB_ATOM_CARDINAL, 0, 0xFFFFFFFF);
	rectanglesCookie = xcb_shape_get_rectangles(connection, (*client).window, XCB_SHAPE_SK_BOUNDING);
	propertyReply = xcb_wait_for_reply(connection, propertyCookie, NULL);
	propertyToken = pushPointer(propertyReply, "get property reply", iFree);
	rectanglesReply = xcb_wait_for_reply(connection, rectanglesCookie, NULL);
	rectanglesToken = pushPointer(rectanglesReply, "get rectangles reply", iFree);
	if(propertyReply){
		if(xcb_get_property_value_length(propertyReply) == sizeof(uint32)){
			(*client).opacity = *(uint32 *)xcb_get_property_value(propertyReply);
		}
		free(propertyReply);
		popPointer(propertyToken);
	}
	if(rectanglesReply){
		const uint size = xcb_shape_get_rectangles_rectangles_length(rectanglesReply);
		const xcb_rectangle_t *const rectangleStart = xcb_shape_get_rectangles_rectangles(rectanglesReply);
		free((*client).shapeRectangleStart);
		popPointer((*client).shapeRectangleToken);
		(*client).shapeRectangleSize = 0;
		(*client).shapeRectangleStart = NULL;
		(*client).shapeRectangleToken = 0;
		if(size > 0 and ((*rectangleStart).x or (*rectangleStart).y or (*rectangleStart).width != (*client).width + 2 * (*client).border or (*rectangleStart).height != (*client).height + 2 * (*client).border)){
			xcb_rectangle_t *current;
			xcb_rectangle_t *wall;
			(*client).shapeRectangleSize = size;
			(*client).shapeRectangleStart = malloc((*client).shapeRectangleSize * sizeof(xcb_rectangle_t));
			(*client).shapeRectangleToken = pushPointer((*client).shapeRectangleStart, "shape rectangles pointer", iFree);
			if(!(*client).shapeRectangleStart){
				(*client).shapeRectangleSize = 0;
			}
			current = (*client).shapeRectangleStart;
			wall = current + (*client).shapeRectangleSize;
			copyMemory(rectangleStart, (*client).shapeRectangleStart, (*client).shapeRectangleSize * sizeof(xcb_rectangle_t));
			jmp makeShapeRectangleGlobalLoop;
			makeShapeRectangleGlobalLoop:{
				if(current < wall){
					(*current).x += (*client).x;
					(*current).y += (*client).y;
					inc current;
					jmp makeShapeRectangleGlobalLoop;
				}
				sortRectangles((*client).shapeRectangleStart, (*client).shapeRectangleSize);
			}
		}
		free(rectanglesReply);
		popPointer(rectanglesToken);
	}
	calculateClientsRectangles(clientSystem, findOrderedClientOffset(clientSystem, client));
	ret true;
}
CONFIGURECLIENT(){
	uint oldWidth;
	uint oldHeight;
	uint oldBorder;
	uint *orderedClientOffset;
	if(!clientSystem or !isValidClient(clientSystem, client) or !width or !height){
		ret false;
	}
	oldWidth = (*client).width;
	oldHeight = (*client).height;
	oldBorder = (*client).border;
	orderedClientOffset = findOrderedClientOffset(clientSystem, client);
	if(restackClient(clientSystem, client, stackMode, aboveSibling)){
		uint *newOrderedClientOffset = findOrderedClientOffset(clientSystem, client);
		if(newOrderedClientOffset > orderedClientOffset){
			orderedClientOffset = newOrderedClientOffset;
		}
	}
	if((*client).shapeRectangleSize){
		xcb_rectangle_t *current = (*client).shapeRectangleStart;
		xcb_rectangle_t *const wall = current + (*client).shapeRectangleSize;
		jmp makeShapeRectangleGlobalLoop;
		makeShapeRectangleGlobalLoop:{
			if(current < wall){
				(*current).x += x - (*client).x;
				(*current).y += y - (*client).y;
				inc current;
				jmp makeShapeRectangleGlobalLoop;
			}
			sortRectangles((*client).shapeRectangleStart, (*client).shapeRectangleSize);
		}
	}
	(*client).x = x;
	(*client).y = y;
	(*client).width = width;
	(*client).height = height;
	(*client).border = border;
	if((*client).mapped){
		if(width != oldWidth or height != oldHeight or border != oldBorder){
			if((*client).picture){
				xcb_discard_reply(connection, xcb_render_free_picture_checked(connection, (*client).picture));
			}
			if((*client).pixmap){
				xcb_discard_reply(connection, xcb_free_pixmap_checked(connection, (*client).pixmap));
			}
			(*client).pixmap = xcb_generate_id(connection);
			(*client).picture = xcb_generate_id(connection);
			xcb_discard_reply(connection, xcb_composite_name_window_pixmap_checked(connection, (*client).window, (*client).pixmap));
			xcb_discard_reply(connection, xcb_render_create_picture_checked(connection, (*client).picture, (*client).pixmap, (*client).format, XCB_NONE, NULL));
		}



		/*! calculateClientsRectangles(clientSystem, orderedClientOffset); */



		calculateClientsRectangles(clientSystem, (*clientSystem).orderedClientOffsetStart + (*clientSystem).orderedClientOffsetAllocated - 1);
	}
	ret true;
}
RESTACKCLIENT(){
	uint *start;
	uint *current;
	uint *wall;
	uint copy;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	start = (*clientSystem).orderedClientOffsetStart;
	wall = start + (*clientSystem).orderedClientOffsetAllocated;
	switch stackMode over
		to XCB_STACK_MODE_ABOVE: /*-*/ jmp stackModeAbove;
		to XCB_STACK_MODE_BELOW: /*-*/ jmp stackModeBelow;
		off: /*---------------------*/ ret false;
	end
	stackModeAbove:{
		uint *siblingCurrent = wall - 1;
		if(!(current = findOrderedClientOffset(clientSystem, client))){
			ret false;
		}
		if(sibling and !(siblingCurrent = findOrderedClientWindowOffset(clientSystem, sibling))){
			ret false;
		}
		if(current == siblingCurrent or current == siblingCurrent + 1){
			ret false;
		}
		copy = *current;
		if(current < siblingCurrent){
			shiftMemory(current + 1, (siblingCurrent - current) * sizeof(uint), -(int)sizeof(uint));
			*siblingCurrent = copy;
			ret true;
		}
		shiftMemory(siblingCurrent + 1, (current - siblingCurrent - 1) * sizeof(uint), sizeof(uint));
		*(siblingCurrent + 1) = copy;
		ret true;
	}
	stackModeBelow:{
		uint *siblingCurrent = start;
		if(!(current = findOrderedClientOffset(clientSystem, client))){
			ret false;
		}
		if(sibling and !(siblingCurrent = findOrderedClientWindowOffset(clientSystem, sibling))){
			ret false;
		}
		if(current == siblingCurrent or current == siblingCurrent - 1){
			ret false;
		}
		copy = *current;
		if(current < siblingCurrent){
			shiftMemory(current + 1, (siblingCurrent - current - 1) * sizeof(uint), -(int)sizeof(uint));
			*(siblingCurrent - 1) = copy;
			ret true;
		}
		shiftMemory(siblingCurrent, (current - siblingCurrent) * sizeof(uint), sizeof(uint));
		*siblingCurrent = copy;
		ret true;
	}
}
CALCULATECLIENTSRECTANGLES(){
	const uint *start;
	const uint *current;
	Client *clientStart;
	xcb_rectangle_t rootRectangle;
	uint aboveRectangleSize;
	uint aboveRectangleAllocated;
	xcb_rectangle_t *aboveRectangleStart;
	uint32 aboveRectangleToken;
	if(!clientSystem or (*clientSystem).createExistingLock or orderedClientOffset < (*clientSystem).orderedClientOffsetStart or orderedClientOffset >= (*clientSystem).orderedClientOffsetStart + (*clientSystem).orderedClientOffsetAllocated){
		ret false;
	}
	start = (*clientSystem).orderedClientOffsetStart;
	current = orderedClientOffset;
	clientStart = (*clientSystem).clientStart;
	jmp findAvailableRectangles;
	findAvailableRectangles:{
		const uint *wall = (*clientSystem).orderedClientOffsetStart + (*clientSystem).orderedClientOffsetAllocated;
		inc orderedClientOffset;
		jmp findAvailableRectanglesLoop;
		findAvailableRectanglesLoop:{
			if(orderedClientOffset < wall){
				Client *const client = clientStart + *orderedClientOffset;
				if(!(*client).mapped or !(*client).availableRectangleAllocated){
					inc orderedClientOffset;
					jmp findAvailableRectanglesLoop;
				}
			}
			if(orderedClientOffset >= (*clientSystem).orderedClientOffsetStart + (*clientSystem).orderedClientOffsetAllocated - 1){
				rootRectangle.x = 0;
				rootRectangle.y = 0;
				rootRectangle.width = screenWidthInPixels;
				rootRectangle.height = screenHeightInPixels;
				aboveRectangleSize = 1;
				aboveRectangleAllocated = 1;
				aboveRectangleStart = &rootRectangle;
				aboveRectangleToken = 0;
			}else{
				Client *const client = clientStart + *orderedClientOffset;
				aboveRectangleSize = (*client).availableRectangleSize;
				aboveRectangleAllocated = (*client).availableRectangleAllocated;
				aboveRectangleStart = (*client).availableRectangleStart;
				aboveRectangleToken = (*client).availableRectangleToken;
			}
			jmp calculateClientRectanglesLoop;
		}
	}
	calculateClientRectanglesLoop:{
		if(current >= start){
			Client *const client = clientStart + *current;
			if((*client).mapped){
				free((*client).availableRectangleStart);
				popPointer((*client).availableRectangleToken);
				(*client).availableRectangleSize = 0;
				(*client).availableRectangleAllocated = 0;
				(*client).availableRectangleStart = NULL;
				(*client).availableRectangleToken = 0;
				free((*client).rectangleStart);
				popPointer((*client).rectangleToken);
				(*client).rectangleSize = 0;
				(*client).rectangleAllocated = 0;
				(*client).rectangleStart = NULL;
				(*client).rectangleToken = 0;
				if(aboveRectangleAllocated){
					uint availableRectangleSize = aboveRectangleSize;
					uint availableRectangleAllocated = aboveRectangleAllocated;
					xcb_rectangle_t *availableRectangleStart = malloc(availableRectangleSize * sizeof(xcb_rectangle_t));
					uint32 availableRectangleToken = pushPointer(availableRectangleStart, "rectangles pointer", iFree);
					uint destinationSize;
					xcb_rectangle_t *destinationStart;
					uint32 destinationToken;
					if(!availableRectangleStart){
						ret false;
					}
					copyMemory(aboveRectangleStart, availableRectangleStart, availableRectangleAllocated * sizeof(xcb_rectangle_t));
					if((*client).shapeRectangleSize){
						if(getIntersectingRectangles(availableRectangleSize, availableRectangleStart, (*client).shapeRectangleSize, (*client).shapeRectangleStart, &destinationSize, &destinationStart, &destinationToken)){
							sortRectangles(destinationStart, destinationSize);
						}
					}else{
						xcb_rectangle_t rectangle;
						rectangle.x = (*client).x;
						rectangle.y = (*client).y;
						rectangle.width = (*client).width + 2 * (*client).border;
						rectangle.height = (*client).height + 2 * (*client).border;
						if(getIntersectingRectangles(availableRectangleSize, availableRectangleStart, 1, &rectangle, &destinationSize, &destinationStart, &destinationToken)){
							sortRectangles(destinationStart, destinationSize);
						}
					}
					(*client).rectangleSize = destinationSize;
					(*client).rectangleAllocated = destinationSize;
					(*client).rectangleStart = destinationStart;
					(*client).rectangleToken = destinationToken;
					if((*client).depth == 24){
						if(subtractRectangles(availableRectangleSize, availableRectangleStart, (*client).rectangleSize, (*client).rectangleStart, &destinationSize, &destinationStart, &destinationToken)){
							sortRectangles(destinationStart, destinationSize);
							mergeRectangles(destinationStart, &destinationSize);
							free(availableRectangleStart);
							popPointer(availableRectangleToken);
							availableRectangleSize = destinationSize;
							availableRectangleAllocated = destinationSize;
							availableRectangleStart = destinationStart;
							availableRectangleToken = destinationToken;
						}
					}
					(*client).availableRectangleSize = availableRectangleSize;
					(*client).availableRectangleAllocated = availableRectangleAllocated;
					(*client).availableRectangleStart = availableRectangleStart;
					(*client).availableRectangleToken = availableRectangleToken;
					mergeRectangles((*client).rectangleStart, &(*client).rectangleAllocated);
					aboveRectangleSize = availableRectangleSize;
					aboveRectangleAllocated = availableRectangleAllocated;
					aboveRectangleStart = availableRectangleStart;
					aboveRectangleToken = availableRectangleToken;
				}
			}
			dec current;
			jmp calculateClientRectanglesLoop;
		}
		ret true;
	}
}
UNMAPCLIENT(){
	if(!clientSystem or !isValidClient(clientSystem, client) or !(*client).mapped){
		ret false;
	}
	if((*client).damage){
		xcb_discard_reply(connection, xcb_damage_destroy_checked(connection, (*client).damage));
		(*client).damage = XCB_NONE;
	}
	if((*client).picture){
		xcb_discard_reply(connection, xcb_render_free_picture_checked(connection, (*client).picture));
		(*client).picture = XCB_NONE;
	}
	if((*client).pixmap){
		xcb_discard_reply(connection, xcb_free_pixmap_checked(connection, (*client).pixmap));
		(*client).pixmap = XCB_NONE;
	}
	(*client).mapped = false;
	free((*client).drawingRectangleStart);
	popPointer((*client).drawingRectangleToken);
	(*client).drawingRectangleSize = 0;
	(*client).drawingRectangleStart = NULL;
	(*client).drawingRectangleToken = 0;
	free((*client).shapeRectangleStart);
	popPointer((*client).shapeRectangleToken);
	(*client).shapeRectangleSize = 0;
	(*client).shapeRectangleStart = NULL;
	(*client).shapeRectangleToken = 0;
	free((*client).availableRectangleStart);
	popPointer((*client).availableRectangleToken);
	(*client).availableRectangleSize = 0;
	(*client).availableRectangleAllocated = 0;
	(*client).availableRectangleStart = NULL;
	(*client).availableRectangleToken = 0;
	free((*client).rectangleStart);
	popPointer((*client).rectangleToken);
	(*client).rectangleSize = 0;
	(*client).rectangleAllocated = 0;
	(*client).rectangleStart = NULL;
	(*client).rectangleToken = 0;
	calculateClientsRectangles(clientSystem, findOrderedClientOffset(clientSystem, client));
	ret true;
}
DESTROYCLIENT(){
	uint *clientOffset;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	unmapClient(clientSystem, client);
	if((clientOffset = findOrderedClientOffset(clientSystem, client))){
		shiftMemory(clientOffset + 1, ((*clientSystem).orderedClientOffsetStart + (*clientSystem).orderedClientOffsetAllocated - clientOffset - 1) * sizeof(uint), -(int)sizeof(uint));
		dec (*clientSystem).orderedClientOffsetAllocated;
	}
	(*client).inUse = false;
	if(client == (*clientSystem).clientStart + (*clientSystem).clientAllocated - 1){
		if(dec (*clientSystem).clientAllocated < (*clientSystem).clientNotInUseOffset){
			dec (*clientSystem).clientNotInUseOffset;
		}
	}elif(client - (*clientSystem).clientStart < (*clientSystem).clientNotInUseOffset){
		(*clientSystem).clientNotInUseOffset = client - (*clientSystem).clientStart;
	}
	ret true;
}
DESTROYCLIENTS(){
	Client *current;
	Client *wall;
	if(!clientSystem or !(*clientSystem).clientAllocated){
		ret false;
	}
	current = (*clientSystem).clientStart;
	wall = current + (*clientSystem).clientAllocated;
	(*clientSystem).createExistingLock = true;
	jmp destroyClientLoop;
	destroyClientLoop:{
		if(current < wall){
			if((*current).inUse){
				destroyClient(clientSystem, current);
			}
			inc current;
			jmp destroyClientLoop;
		}
		(*clientSystem).createExistingLock = false;
		ret true;
	}
}
ISVALIDCLIENT(){
	ret clientSystem and (*clientSystem).clientAllocated and client and client >= (*clientSystem).clientStart and client < (*clientSystem).clientStart + (*clientSystem).clientAllocated and (*client).inUse;
}
FINDCLIENT(){
	Client *current;
	Client *wall;
	if(!clientSystem or !(*clientSystem).clientAllocated or !window){
		ret NULL;
	}
	current = (*clientSystem).clientStart;
	wall = current + (*clientSystem).clientAllocated;
	jmp findClientLoop;
	findClientLoop:{
		if(current < wall){
			if((*current).window == window){
				if(!(*current).inUse){
					ret NULL;
				}
				ret current;
			}
			inc current;
			jmp findClientLoop;
		}
		ret NULL;
	}
}
FINDORDEREDCLIENTOFFSET(){
	uint *current;
	uint *wall;
	Client *clientStart;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret NULL;
	}
	current = (*clientSystem).orderedClientOffsetStart;
	wall = current + (*clientSystem).orderedClientOffsetAllocated;
	clientStart = (*clientSystem).clientStart;
	jmp findOrderedClientOffsetLoop;
	findOrderedClientOffsetLoop:{
		if(current < wall){
			if(clientStart + *current == client){
				ret current;
			}
			inc current;
			jmp findOrderedClientOffsetLoop;
		}
		ret NULL;
	}
}
FINDORDEREDCLIENTWINDOWOFFSET(){
	uint *current;
	uint *wall;
	Client *clientStart;
	if(!clientSystem or !(*clientSystem).orderedClientOffsetAllocated or !window){
		ret NULL;
	}
	current = (*clientSystem).orderedClientOffsetStart;
	wall = current + (*clientSystem).orderedClientOffsetAllocated;
	clientStart = (*clientSystem).clientStart;
	jmp findOrderedClientWindowOffsetLoop;
	findOrderedClientWindowOffsetLoop:{
		if(current < wall){
			if((*(clientStart + *current)).window == window){
				ret current;
			}
			inc current;
			jmp findOrderedClientWindowOffsetLoop;
		}
		ret NULL;
	}
}
FINICLIENTSYSTEM(){
	if(!clientSystem){
		ret false;
	}
	destroyClients(clientSystem);
	(*clientSystem).createExistingLock = false;
	free((*clientSystem).orderedClientOffsetStart);
	popPointer((*clientSystem).orderedClientOffsetToken);
	(*clientSystem).orderedClientOffsetSize = 0;
	(*clientSystem).orderedClientOffsetAllocated = 0;
	(*clientSystem).orderedClientOffsetStart = NULL;
	(*clientSystem).orderedClientOffsetToken = 0;
	free((*clientSystem).clientStart);
	popPointer((*clientSystem).clientToken);
	(*clientSystem).clientSize = 0;
	(*clientSystem).clientAllocated = 0;
	(*clientSystem).clientNotInUseOffset = 0;
	(*clientSystem).clientStart = NULL;
	(*clientSystem).clientToken = 0;
	ret true;
	#undef  CLIENT_BLOCK_SIZE
}
INITBUFFERSYSTEM(){
	if(!bufferSystem){
		ret false;
	}
	(*bufferSystem).rootPicture = XCB_NONE;
	(*bufferSystem).bufferPixmap = XCB_NONE;
	(*bufferSystem).bufferPicture = XCB_NONE;
	ret true;
}
CREATEBUFFERSYSTEM(){
	if(!bufferSystem or !overlayWindow){
		ret false;
	}
	if((*bufferSystem).bufferPicture){
		xcb_render_free_picture(connection, (*bufferSystem).bufferPicture);
	}
	if((*bufferSystem).bufferPixmap){
		xcb_free_pixmap(connection, (*bufferSystem).bufferPixmap);
	}
	if((*bufferSystem).rootPicture){
		xcb_render_free_picture(connection, (*bufferSystem).rootPicture);
	}
	(*bufferSystem).rootPicture = xcb_generate_id(connection);
	(*bufferSystem).bufferPixmap = xcb_generate_id(connection);
	(*bufferSystem).bufferPicture = xcb_generate_id(connection);
	xcb_render_create_picture(connection, (*bufferSystem).rootPicture, overlayWindow, findFormat(&formatSystem, (*screen).root_depth), XCB_NONE, NULL);
	xcb_create_pixmap(connection, (*screen).root_depth, (*bufferSystem).bufferPixmap, (*screen).root, screenWidthInPixels, screenHeightInPixels);
	xcb_render_create_picture(connection, (*bufferSystem).bufferPicture, (*bufferSystem).bufferPixmap, findFormat(&formatSystem, (*screen).root_depth), XCB_NONE, NULL);
	ret true;
}
REDRAWBUFFER(){
	const uint *current;
	const uint *wall;
	const Client *clientStart;
	xcb_render_picture_t rootPicture;
	xcb_pixmap_t bufferPixmap;
	xcb_render_picture_t bufferPicture;
	if(!bufferSystem or !(*bufferSystem).rootPicture or !(*bufferSystem).bufferPixmap or !(*bufferSystem).bufferPicture or !wallpaperSystem or !(*wallpaperSystem).pixmap or !clientSystem){
		ret false;
	}
	current = (*clientSystem).orderedClientOffsetStart;
	wall = current + (*clientSystem).orderedClientOffsetAllocated;
	clientStart = (*clientSystem).clientStart;
	rootPicture = (*bufferSystem).rootPicture;
	bufferPixmap = (*bufferSystem).bufferPixmap;
	bufferPicture = (*bufferSystem).bufferPicture;
	jmp drawWallpaper;
	drawWallpaper:{
		xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, (*wallpaperSystem).picture, XCB_NONE, bufferPicture, 0, 0, 0, 0, 0, 0, (*wallpaperSystem).width, (*wallpaperSystem).height);
		jmp drawClientLoop;
	}
	drawClientLoop:{
		if(current < wall){
			const Client *const client = clientStart + *current;
			if((*client).mapped){
				uint rectangleAllocated = 0;
				xcb_rectangle_t *rectangleStart;
				if((*client).shapeRectangleSize){
					rectangleAllocated = (*client).shapeRectangleSize;
					rectangleStart = (*client).shapeRectangleStart;
				}elif((*client).rectangleAllocated){
					rectangleAllocated = (*client).rectangleAllocated;
					rectangleStart = (*client).rectangleStart;
				}
				if(rectangleAllocated){
					const xcb_xfixes_region_t region = xcb_generate_id(connection);
					xcb_xfixes_create_region(connection, region, rectangleAllocated, rectangleStart);
					xcb_xfixes_set_picture_clip_region(connection, bufferPicture, region, 0, 0);
					xcb_discard_reply(connection, xcb_render_composite_checked(connection, (*client).depth == 32? XCB_RENDER_PICT_OP_OVER : XCB_RENDER_PICT_OP_SRC, (*client).picture, XCB_NONE, bufferPicture, 0, 0, 0, 0, (*client).x, (*client).y, (*client).width + 2 * (*client).border, (*client).height + 2 * (*client).border));
					xcb_xfixes_destroy_region(connection, region);
				}
			}
			inc current;
			jmp drawClientLoop;
		}
		jmp commitBuffer;
	}
	commitBuffer:{
		xcb_xfixes_set_picture_clip_region(connection, bufferPicture, XCB_NONE, 0, 0);
		xcb_xfixes_set_picture_clip_region(connection, rootPicture, XCB_NONE, 0, 0);
		xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, bufferPicture, XCB_NONE, rootPicture, 0, 0, 0, 0, 0, 0, screenWidthInPixels, screenHeightInPixels);
		ret true;
	}
}
COMMITBUFFER(){
	if(!bufferSystem or !(*bufferSystem).rootPicture or !(*bufferSystem).bufferPixmap or !(*bufferSystem).bufferPicture or !width or !height){
		ret false;
	}
	xcb_xfixes_set_picture_clip_region(connection, (*bufferSystem).bufferPicture, XCB_NONE, 0, 0);
	xcb_xfixes_set_picture_clip_region(connection, (*bufferSystem).rootPicture, XCB_NONE, 0, 0);
	xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, (*bufferSystem).bufferPicture, XCB_NONE, (*bufferSystem).rootPicture, x, y, 0, 0, x, y, width, height);
	ret true;
}
RENDERCOMPOSITECLIENT(){
	xcb_render_picture_t rootPicture;
	xcb_pixmap_t bufferPixmap;
	xcb_render_picture_t bufferPicture;
	Client *client;
	uint rectangleSize;
	xcb_rectangle_t *rectangleStart;
	uint32 rectangleToken;
	if(!bufferSystem or !(*bufferSystem).rootPicture or !(*bufferSystem).bufferPixmap or !(*bufferSystem).bufferPicture or !wallpaperSystem or !(*wallpaperSystem).pixmap or !clientSystem or (*clientSystem).createExistingLock or orderedClientOffset < (*clientSystem).orderedClientOffsetStart or orderedClientOffset >= (*clientSystem).orderedClientOffsetStart + (*clientSystem).orderedClientOffsetAllocated or !width or !height){
		ret false;
	}
	rootPicture = (*bufferSystem).rootPicture;
	bufferPixmap = (*bufferSystem).bufferPixmap;
	bufferPicture = (*bufferSystem).bufferPicture;
	jmp getVisibleRectangles;
	getVisibleRectangles:{
		xcb_rectangle_t rectangle;
		rectangle.x = x;
		rectangle.y = y;
		rectangle.width = width;
		rectangle.height = height;
		client = (*clientSystem).clientStart + *orderedClientOffset;
		rectangleSize = 0;
		rectangleStart = NULL;
		rectangleToken = 0;
		if(!(*client).mapped){
			rectangleSize = 1;
			rectangleStart = malloc(rectangleSize * sizeof(xcb_rectangle_t));
			rectangleToken = pushPointer(rectangleStart, "rectangles pointer", iFree);
			if(!rectangleStart){
				ret false;
			}



			/*! is there an issue here? */

			*rectangleStart = rectangle;



		}else{
			uint size;
			xcb_rectangle_t *start;
			if((*client).shapeRectangleSize){
				size = (*client).shapeRectangleSize;
				start = (*client).shapeRectangleStart;
			}elif((*client).rectangleAllocated){
				size = (*client).rectangleAllocated;
				start = (*client).rectangleStart;
			}else{
				ret false;
			}
			if(!getIntersectingRectangles(size, start, 1, &rectangle, &rectangleSize, &rectangleStart, &rectangleToken)){
				ret false;
			}
			if(!rectangleSize){
				ret false;
			}
			sortRectangles(rectangleStart, rectangleSize);
		}
		if((*client).depth == 24 and (*client).mapped){
			jmp drawClient;
		}
		jmp drawBelowClients;
	}
	drawBelowClients:{
		const uint *const start = (*clientSystem).orderedClientOffsetStart;
		const uint *current = orderedClientOffset - 1;
		const uint *const wall = orderedClientOffset;
		Client *const clientStart = (*clientSystem).clientStart;
		uint availableRectangleSize = rectangleSize;
		xcb_rectangle_t *availableRectangleStart = malloc(availableRectangleSize * sizeof(xcb_rectangle_t));
		uint32 availableRectangleToken = pushPointer(availableRectangleStart, "rectangles pointer", iFree);
		if(!availableRectangleStart){
			jmp emergencyExit;
		}
		copyMemory(rectangleStart, availableRectangleStart, availableRectangleSize * sizeof(xcb_rectangle_t));
		jmp findLowestClientLoop;
		findLowestClientLoop:{
			if(current >= start){
				Client *const c = clientStart + *current;
				if((*c).mapped){
					uint size;
					xcb_rectangle_t *start;
					uint destinationRectangleSize;
					xcb_rectangle_t *destinationRectangleStart;
					uint32 destinationRectangleToken;
					if((*c).shapeRectangleSize){
						size = (*c).shapeRectangleSize;
						start = (*c).shapeRectangleStart;
					}elif((*c).rectangleAllocated){
						size = (*c).rectangleAllocated;
						start = (*c).rectangleStart;
					}else{
						size = 0;
						start = NULL;
					}
					if(getIntersectingRectangles(rectangleSize, rectangleStart, size, start, &destinationRectangleSize, &destinationRectangleStart, &destinationRectangleToken)){
						if(destinationRectangleSize){
							sortRectangles(destinationRectangleStart, destinationRectangleSize);
							(*c).drawingRectangleSize = destinationRectangleSize;
							(*c).drawingRectangleStart = destinationRectangleStart;
							(*c).drawingRectangleToken = destinationRectangleToken;
							if((*c).depth == 24){
								if(subtractRectangles(availableRectangleSize, availableRectangleStart, (*c).drawingRectangleSize, (*c).drawingRectangleStart, &destinationRectangleSize, &destinationRectangleStart, &destinationRectangleToken)){
									sortRectangles(destinationRectangleStart, destinationRectangleSize);
									mergeRectangles(destinationRectangleStart, &destinationRectangleSize);
									free(availableRectangleStart);
									popPointer(availableRectangleToken);
									availableRectangleSize = destinationRectangleSize;
									availableRectangleStart = destinationRectangleStart;
									availableRectangleToken = destinationRectangleToken;
									if(!availableRectangleSize){
										jmp drawBelowClientLoop;
									}
								}
							}
						}
					}
				}
				dec current;
				jmp findLowestClientLoop;
			}
			current = start;
			jmp drawBelowClientLoop;
		}
		drawBelowClientLoop:{
			if(current < wall){
				Client *const client = clientStart + *current;
				if((*client).mapped and (*client).drawingRectangleSize){
					const xcb_xfixes_region_t region = xcb_generate_id(connection);
					xcb_render_picture_t picture;
					xcb_xfixes_create_region(connection, region, (*client).drawingRectangleSize, (*client).drawingRectangleStart);
					xcb_xfixes_set_picture_clip_region(connection, bufferPicture, region, 0, 0);
					if((*client).window == (*screen).root){
						picture = (*wallpaperSystem).picture;
					}else{
						picture = (*client).picture;
					}
					xcb_discard_reply(connection, xcb_render_composite_checked(connection, (*client).depth == 32? XCB_RENDER_PICT_OP_OVER : XCB_RENDER_PICT_OP_SRC, picture, XCB_NONE, bufferPicture, 0, 0, 0, 0, (*client).x, (*client).y, (*client).width + 2 * (*client).border, (*client).height + 2 * (*client).border));
					xcb_xfixes_destroy_region(connection, region);
					free((*client).drawingRectangleStart);
					popPointer((*client).drawingRectangleToken);
					(*client).drawingRectangleSize = 0;
					(*client).drawingRectangleStart = NULL;
					(*client).drawingRectangleToken = 0;
				}
				inc current;
				jmp drawBelowClientLoop;
			}
			free(availableRectangleStart);
			popPointer(availableRectangleToken);
			jmp drawClient;
		}
	}
	drawClient:{
		if((*client).mapped){
			const xcb_xfixes_region_t region = xcb_generate_id(connection);
			xcb_render_picture_t picture = (*client).picture;
			xcb_xfixes_create_region(connection, region, rectangleSize, rectangleStart);
			xcb_xfixes_set_picture_clip_region(connection, bufferPicture, region, 0, 0);
			if((*client).window == (*screen).root){
				picture = (*wallpaperSystem).picture;
			}
			xcb_discard_reply(connection, xcb_render_composite_checked(connection, (*client).depth == 32? XCB_RENDER_PICT_OP_OVER : XCB_RENDER_PICT_OP_SRC, picture, XCB_NONE, bufferPicture, x - (*client).x, y - (*client).y, 0, 0, x, y, width, height));
			xcb_xfixes_destroy_region(connection, region);
		}
		jmp drawAboveClients;
	}
	drawAboveClients:{
		const uint *current = orderedClientOffset + 1;
		const uint *const wall = (*clientSystem).orderedClientOffsetStart + (*clientSystem).orderedClientOffsetAllocated;
		Client *const clientStart = (*clientSystem).clientStart;
		jmp drawAboveClientLoop;
		drawAboveClientLoop:{
			if(current < wall){
				Client *const client = clientStart + *current;
				if((*client).mapped and (*client).depth == 32){
					uint destinationRectangleSize;
					xcb_rectangle_t *destinationRectangleStart;
					uint32 destinationRectangleToken;
					uint size;
					xcb_rectangle_t *start;
					if((*client).shapeRectangleSize){
						size = (*client).shapeRectangleSize;
						start = (*client).shapeRectangleStart;
					}elif((*client).rectangleAllocated){
						size = (*client).rectangleAllocated;
						start = (*client).rectangleStart;
					}else{
						size = 0;
						start = NULL;
					}
					if(getIntersectingRectangles(rectangleSize, rectangleStart, size, start, &destinationRectangleSize, &destinationRectangleStart, &destinationRectangleToken)){
						if(destinationRectangleSize){
							const xcb_xfixes_region_t region = xcb_generate_id(connection);
							sortRectangles(destinationRectangleStart, destinationRectangleSize);
							xcb_xfixes_create_region(connection, region, destinationRectangleSize, destinationRectangleStart);
							xcb_xfixes_set_picture_clip_region(connection, bufferPicture, region, 0, 0);
							xcb_discard_reply(connection, xcb_render_composite_checked(connection, (*client).depth == 32? XCB_RENDER_PICT_OP_OVER : XCB_RENDER_PICT_OP_SRC, (*client).picture, XCB_NONE, bufferPicture, x - (*client).x, y - (*client).y, 0, 0, x, y, width, height));
							xcb_xfixes_destroy_region(connection, region);
							free(destinationRectangleStart);
							popPointer(destinationRectangleToken);
						}
					}
				}
				inc current;
				jmp drawAboveClientLoop;
			}
			jmp commitBuffer;
		}
	}
	commitBuffer:{
		if(commit){
			const xcb_xfixes_region_t region = xcb_generate_id(connection);
			xcb_xfixes_create_region(connection, region, rectangleSize, rectangleStart);
			xcb_xfixes_set_picture_clip_region(connection, bufferPicture, XCB_NONE, 0, 0);
			xcb_xfixes_set_picture_clip_region(connection, rootPicture, region, 0, 0);
			xcb_render_composite(connection, XCB_RENDER_PICT_OP_SRC, bufferPicture, XCB_NONE, rootPicture, x, y, 0, 0, x, y, width, height);
			xcb_xfixes_destroy_region(connection, region);
		}
		jmp emergencyExit;
	}
	emergencyExit:{
		free(rectangleStart);
		popPointer(rectangleToken);
		ret true;
	}
}
RENDERCOMPOSITEWITHOUTCLIENT(){
	Client *client;
	bool mapped;
	if(!bufferSystem or !(*bufferSystem).rootPicture or !(*bufferSystem).bufferPixmap or !(*bufferSystem).bufferPicture or !wallpaperSystem or !(*wallpaperSystem).pixmap or !clientSystem or (*clientSystem).createExistingLock or orderedClientOffset < (*clientSystem).orderedClientOffsetStart or orderedClientOffset >= (*clientSystem).orderedClientOffsetStart + (*clientSystem).orderedClientOffsetAllocated or !width or !height){
		ret false;
	}
	client = (*clientSystem).clientStart + *orderedClientOffset;
	mapped = (*client).mapped;
	if(mapped){
		(*client).mapped = false;
	}



	/*! should be the given sizes. */

	(void)x;
	(void)y;
	renderCompositeClient(bufferSystem, wallpaperSystem, clientSystem, orderedClientOffset, 0, 0, screenWidthInPixels, screenHeightInPixels, commit);
	/*! renderCompositeClient(bufferSystem, wallpaperSystem, clientSystem, orderedClientOffset, x, y, width, height, commit); */



	if(mapped){
		(*client).mapped = true;
	}
	ret true;
}
FINIBUFFERSYSTEM(){
	if(!bufferSystem){
		ret false;
	}
	if((*bufferSystem).bufferPicture){
		xcb_render_free_picture(connection, (*bufferSystem).bufferPicture);
		(*bufferSystem).bufferPicture = XCB_NONE;
	}
	if((*bufferSystem).bufferPixmap){
		xcb_free_pixmap(connection, (*bufferSystem).bufferPixmap);
		(*bufferSystem).bufferPixmap = XCB_NONE;
	}
	if((*bufferSystem).rootPicture){
		xcb_render_free_picture(connection, (*bufferSystem).rootPicture);
		(*bufferSystem).rootPicture = XCB_NONE;
	}
	ret true;
}
INITCOMPOSITORSYSTEM(){
	previousWMCMSelectionWindow = XCB_NONE;
	wmCMSelectionTimestamp = XCB_NONE;
	ret true;
}
STARTCOMPOSITOR(){
	jmp updateSelection;
	updateSelection:{
		previousWMCMSelectionWindow = XCB_NONE;
		wmCMSelectionTimestamp = getTimestamp();
		jmp selectInput;
	}
	selectInput:{
		xcb_void_cookie_t cookie;
		xcb_generic_error_t *error;
		uint32 token;
		cookie = xcb_composite_redirect_subwindows_checked(connection, (*screen).root, XCB_COMPOSITE_REDIRECT_MANUAL);
		error = xcb_request_check(connection, cookie);
		token = pushPointer(error, "composite redirect subwindows event mask error", iFree);
		if(error){
			printTitledError("composite redirect subwindows error", "could not apply to redirect subwindow pixel data");
			free(error);
			popPointer(token);
			ret false;
		}
		xcb_xfixes_select_selection_input(connection, (*screen).root, atom._NET_WM_CM_Sn, XCB_XFIXES_SELECTION_EVENT_MASK_SET_SELECTION_OWNER | XCB_XFIXES_SELECTION_EVENT_MASK_SELECTION_WINDOW_DESTROY | XCB_XFIXES_SELECTION_EVENT_MASK_SELECTION_CLIENT_CLOSE);
		xcb_flush(connection);
		jmp initSystems;
	}
	initSystems:{
		xcb_composite_get_overlay_window_reply_t *const reply = xcb_wait_for_reply(connection, xcb_composite_get_overlay_window_unchecked(connection, (*screen).root), NULL);
		uint32 token = pushPointer(reply, "get overlay window reply", iFree);
		overlayWindow = XCB_NONE;
		if(reply){
			overlayWindow = (*reply).overlay_win;
			free(reply);
			popPointer(token);
		}
		if(overlayWindow){
			xcb_xfixes_region_t region = xcb_generate_id(connection);
			xcb_xfixes_create_region(connection, region, 0, NULL);
			xcb_xfixes_set_window_shape_region(connection, overlayWindow, XCB_SHAPE_SK_INPUT, 0, 0, region);
			xcb_xfixes_destroy_region(connection, region);
		}
		requestFormats(&formatSystem);
		setWallpaperColor(&wallpaperSystem, &formatSystem, &monitorSystem, 0xFF171717);
		setWallpaperPixmap(&wallpaperSystem, &formatSystem, &monitorSystem, atom._XROOTPMAP_ID);
		createWallpaper(&wallpaperSystem, &formatSystem, &monitorSystem, screenWidthInPixels, screenHeightInPixels);
		createExistingClients(&clientSystem, &formatSystem);
		createBufferSystem(&bufferSystem, overlayWindow);
		redrawBuffer(&bufferSystem, &wallpaperSystem, &clientSystem);
		jmp announce;
	}
	announce:{
		xcb_client_message_event_t message;
		uint32 *const data = message.data.data32;
		message.response_type = XCB_CLIENT_MESSAGE;
		message.format = 32;
		message.window = (*screen).root;
		message.type = atom.MANAGER;
		*(data + 0) = getTimestamp();
		*(data + 1) = atom._NET_WM_CM_Sn;
		*(data + 2) = wmCMSelectionWindow;
		*(data + 3) = 0;
		*(data + 4) = 0;
		xcb_send_event(connection, false, message.window, XCB_EVENT_MASK_STRUCTURE_NOTIFY, &message);
		ret true;
	}
}
FINDOWNEDWINDOW(){
	ret window == wmCMSelectionWindow or window == overlayWindow;
}
FINICOMPOSITORSYSTEM(){
	if(connection and wmCMSelectionTimestamp){
		xcb_composite_unredirect_subwindows(connection, (*screen).root, XCB_COMPOSITE_REDIRECT_MANUAL);
	}
	ret true;
}
SETCONFIGVARIABLES(){
	ret;
}
READCONFIG(){
	#define STATEMENT_BLOCK_SIZE /*-*/ (256)
	#define DEFAULT_CONFIG_PATH /*--*/ ("/etc/" PROGRAM_NAME "/" PROGRAM_NAME ".conf")
	const Instruction *const *currentScopeInstruction = globalScopeInstruction;
	const char *const *currentScopeInstructionList = globalInstructionList;
	const Instruction *instructionStart;
	const Instruction *instructionStartCopy;
	const Instruction *instructionCurrent;
	const Instruction *name0Instruction;
	const Instruction *name1Instruction;
	const Instruction *name2Instruction;
	const Instruction *name3Instruction;
	const Instruction *name4Instruction;
	const Instruction *nameList0Instruction;
	const Instruction *nameList1Instruction;
	const Instruction *nameList2Instruction;
	const Instruction *nameList3Instruction;
	const Instruction *nameList4Instruction;
	const Instruction *integer0Instruction;
	const Instruction *integer1Instruction;
	const Instruction *integer2Instruction;
	const Instruction *integer3Instruction;
	const Instruction *integer4Instruction;
	const Instruction *string0Instruction;
	const Instruction *string1Instruction;
	const Instruction *string2Instruction;
	const Instruction *string3Instruction;
	const Instruction *string4Instruction;
	const Instruction *image0Instruction;
	const Instruction *image1Instruction;
	const Instruction *image2Instruction;
	const Instruction *image3Instruction;
	const Instruction *image4Instruction;
	const char *imageErrorMessage;
	FILE *configFile = NULL;
	uint32 configFileToken;
	void *system = NULL;
	uint statementSize = STATEMENT_BLOCK_SIZE;
	char *statementStart = NULL;
	uint32 statementToken = 0;
	char *statementCurrent;
	char *statementWall = NULL;
	char *statementConcreteWall;
	uint8 name0Return;
	uint8 name1Return;
	uint8 name2Return;
	uint8 name3Return;
	uint8 name4Return;
	uint8 nameList0Return;
	uint8 nameList1Return;
	uint8 nameList2Return;
	uint8 nameList3Return;
	uint8 nameList4Return;
	int64 integer0Return;
	int64 integer1Return;
	int64 integer2Return;
	int64 integer3Return;
	int64 integer4Return;
	char *string0Return = NULL;
	uint32 string0Token = 0;
	char *string1Return = NULL;
	uint32 string1Token = 0;
	char *string2Return = NULL;
	uint32 string2Token = 0;
	char *string3Return = NULL;
	uint32 string3Token = 0;
	char *string4Return = NULL;
	uint32 string4Token = 0;
	Image image0Return;
	Image image1Return;
	Image image2Return;
	Image image3Return;
	Image image4Return;
	JmpPoint jmpPoint;
	uint fileLine = 1;
	uint statementLine = 0;
	char fileChar;
	uint itemAmount;
	char quote = '\0';
	uint currentScopeInstructionListSize = countof(globalInstructionList) - 1;
	StringTreeSystem *const *const *currentScopeInstructionData = globalScopeInstructionData;
	StringTreeSystem *const *instructionDataStart;
	StringTreeSystem *const *instructionDataStartCopy;
	StringTreeSystem *const *instructionDataCurrent;
	StringTreeSystem *currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
	image0Return.dataStart = NULL;
	image0Return.dataToken = 0;
	image1Return.dataStart = NULL;
	image1Return.dataToken = 0;
	image2Return.dataStart = NULL;
	image2Return.dataToken = 0;
	image3Return.dataStart = NULL;
	image3Return.dataToken = 0;
	image4Return.dataStart = NULL;
	image4Return.dataToken = 0;
	jmp setupPointers;
	setupPointers:{
		if(getNextConfigChar == &ifgetc){
			if(!createConfigFile){
				DIR *const dir = opendir(configPath);
				uint32 token = pushPointer(dir, "config directory argument", closedir);
				if(dir){
					closedir(dir);
					popPointer(token);
					printConfigError("config error", "config file is directory", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
			}
			configFile = fopen(configPath, "r");
			configFileToken = pushPointer(configFile, "config file", fclose);
			if(!configFile){
				#define BUFFER_SIZE /*-*/ (4096)
				FILE *defaultConfigFile;
				uint32 defaultConfigFileToken;
				if(!createConfigFile){
					printConfigError("config error", "could not open config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				configFile = fopen(configPath, "w");
				configFileToken = pushPointer(configFile, "config file", fclose);
				if(!configFile){
					printConfigError("config error", "could not create config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				defaultConfigFile = fopen(DEFAULT_CONFIG_PATH, "r");
				defaultConfigFileToken = pushPointer(defaultConfigFile, "default config file", fclose);
				if(!defaultConfigFile){
					remove(configPath);
					printTitledNamedError("config file error", "could not copy default configuration file from", DEFAULT_CONFIG_PATH);
					jmp configEmergencyExit;
				}
				copyConfigFileLoop:{
					char buffer[BUFFER_SIZE];
					size_t bytesRead;
					if((bytesRead = fread(buffer, sizeof(*buffer), sizeof(buffer), defaultConfigFile))){
						if(fwrite(buffer, sizeof(*buffer), bytesRead, configFile) != bytesRead){
							fclose(defaultConfigFile);
							popPointer(defaultConfigFileToken);
							remove(configPath);
							printTitledError("config copying error", "could not copy default config file correctly");
							jmp configEmergencyExit;
						}
						jmp copyConfigFileLoop;
					}
				}
				fclose(defaultConfigFile);
				popPointer(defaultConfigFileToken);
				fclose(configFile);
				popPointer(configFileToken);
				if(!(configFile = fopen(configPath, "r"))){
					printTitledError("config error", "could not open newly written file");
					jmp configEmergencyExit;
				}
				#undef  BUFFER_SIZE
			}
		}
		statementStart = malloc(statementSize * sizeof(char));
		statementToken = pushPointer(statementStart, "statement pointer", iFree);
		if(!statementStart){
			printTitledError("config error", "could not store user data");
			jmp configEmergencyExit;
		}
		if(getNextConfigChar == &ifgetc){
			system = configFile;
		}elif(getNextConfigChar == &getNextSTDINCharacter){
			system = &stdinSystem;
		}elif(getNextConfigChar == &getNextSharedMemoryCharacter){
			system = &sharedMemorySystem;
		}
		jmp getStatementStart;
	}
	getStatementStart:{
		#define EOF_N1 /*----------------------------*/ (EOF)
		#define ZER_00 /*----------------------------*/ ('\0')
		#define EOT_04 /*----------------------------*/ (0x04)
		#define ALR_07 /*----------------------------*/ ('\a')
		#define BSP_08 /*----------------------------*/ ('\b')
		#define TAB_09 /*----------------------------*/ ('\t')
		#define NLN_10 /*----------------------------*/ ('\n')
		#define VTB_11 /*----------------------------*/ ('\v')
		#define FFD_12 /*----------------------------*/ ('\f')
		#define CRE_13 /*----------------------------*/ ('\r')
		#define ESC_27 /*----------------------------*/ ('\e')
		#define SPC_32 /*----------------------------*/ (' ')
		#define DQT_34 /*----------------------------*/ ('\"')
		#define SQT_39 /*----------------------------*/ ('\'')
		#define AST_42 /*----------------------------*/ ('*')
		#define FSL_47 /*----------------------------*/ ('/')
		#define ZER_48 /*----------------------------*/ ('0')
		#define SCL_59 /*----------------------------*/ (';')
		#define QMK_63 /*----------------------------*/ ('?')
		#define BSL_92 /*----------------------------*/ ('\\')
		#define LOA_97 /*----------------------------*/ ('a')
		#define LOB_98 /*----------------------------*/ ('b')
		#define LOF_102 /*---------------------------*/ ('f')
		#define LON_110 /*---------------------------*/ ('n')
		#define LOR_114 /*---------------------------*/ ('r')
		#define LOT_116 /*---------------------------*/ ('t')
		#define LOV_118 /*---------------------------*/ ('v')
		#define OCB_123 /*---------------------------*/ ('{')
		#define BAR_124 /*---------------------------*/ ('|')
		#define CCB_125 /*---------------------------*/ ('}')
		#define GET_STATEMENT_JMP_POINT /*-----------*/ (0)
		#define STORE_WHITESPACE_JMP_POINT /*--------*/ (1)
		#define CHECK_COMMENT_JMP_POINT /*-----------*/ (2)
		#define STORE_BAR_JMP_POINT /*---------------*/ (3)
		#define GET_DOUBLE_QUOTATION_JMP_POINT /*----*/ (4)
		#define GET_SINGLE_QUOTATION_JMP_POINT /*----*/ (5)
		#define HANDLE_ESCAPE_CHARACTER_JMP_POINT /*-*/ (6)
		#define ENTER_SCOPE_JMP_POINT /*-------------*/ (7)
		#define GET_STATEMENT_END_JMP_POINT /*-------*/ (8)
		statementCurrent = statementStart;
		statementConcreteWall = statementStart + statementSize * sizeof(char);
		statementLine = 0;
		itemAmount = 0;
		free(string0Return);
		popPointer(string0Token);
		free(string1Return);
		popPointer(string1Token);
		free(string2Return);
		popPointer(string2Token);
		free(string3Return);
		popPointer(string3Token);
		free(string4Return);
		popPointer(string4Token);
		free(image0Return.dataStart);
		popPointer(image0Return.dataToken);
		free(image1Return.dataStart);
		popPointer(image1Return.dataToken);
		free(image2Return.dataStart);
		popPointer(image2Return.dataToken);
		free(image3Return.dataStart);
		popPointer(image3Return.dataToken);
		free(image4Return.dataStart);
		popPointer(image4Return.dataToken);
		name0Instruction = NULL;
		name1Instruction = NULL;
		name2Instruction = NULL;
		name3Instruction = NULL;
		name4Instruction = NULL;
		nameList0Instruction = NULL;
		nameList1Instruction = NULL;
		nameList2Instruction = NULL;
		nameList3Instruction = NULL;
		nameList4Instruction = NULL;
		integer0Instruction = NULL;
		integer1Instruction = NULL;
		integer2Instruction = NULL;
		integer3Instruction = NULL;
		integer4Instruction = NULL;
		string0Instruction = NULL;
		string1Instruction = NULL;
		string2Instruction = NULL;
		string3Instruction = NULL;
		string4Instruction = NULL;
		image0Instruction = NULL;
		image1Instruction = NULL;
		image2Instruction = NULL;
		image3Instruction = NULL;
		image4Instruction = NULL;
		string0Return = NULL;
		string0Token = 0;
		string1Return = NULL;
		string1Token = 0;
		string2Return = NULL;
		string2Token = 0;
		string3Return = NULL;
		string3Token = 0;
		string4Return = NULL;
		string4Token = 0;
		image0Return.dataStart = NULL;
		image0Return.dataToken = 0;
		image1Return.dataStart = NULL;
		image1Return.dataToken = 0;
		image2Return.dataStart = NULL;
		image2Return.dataToken = 0;
		image3Return.dataStart = NULL;
		image3Return.dataToken = 0;
		image4Return.dataStart = NULL;
		image4Return.dataToken = 0;
		jmp getStatement;
	}
	getStatement: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp checkCommentStoreCharacter;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	getDoubleQuotation: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getDoubleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getDoubleQuotationStoreCharacter;
		to DQT_34: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getDoubleQuotationStoreCharacter;
	end
	getSingleQuotation: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getSingleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getSingleQuotationStoreCharacter;
		to SQT_39: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getSingleQuotationStoreCharacter;
	end
	handleEscapeCharacter: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to DQT_34: /*--*/ fileChar = '\"'; /*-----------------*/ jmp storeEscapedCharacter;
		to SQT_39: /*--*/ fileChar = '\''; /*-----------------*/ jmp storeEscapedCharacter;
		to ZER_48: /*--*/ fileChar = '\0'; /*-----------------*/ jmp storeEscapedCharacter;
		to QMK_63: /*--*/ fileChar = '\?'; /*-----------------*/ jmp storeEscapedCharacter;
		to BSL_92: /*--*/ fileChar = '\\'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOA_97: /*--*/ fileChar = '\a'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOB_98: /*--*/ fileChar = '\b'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOF_102: /*-*/ fileChar = '\f'; /*-----------------*/ jmp storeEscapedCharacter;
		to LON_110: /*-*/ fileChar = '\n'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOR_114: /*-*/ fileChar = '\r'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOT_116: /*-*/ fileChar = '\t'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOV_118: /*-*/ fileChar = '\v'; /*-----------------*/ jmp storeEscapedCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	checkComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to AST_42: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreSingleLineComment;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	ignoreMultipleLineComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to AST_42: /*--*/ /*----------------------------------*/ jmp checkMultipleLineCommentEnd;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	end
	checkMultipleLineCommentEnd: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	end
	ignoreSingleLineComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreSingleLineComment;
	end
	endOfFile:{
		if(statementCurrent == statementStart){
			jmp successfulConfig;
		}
		if(getPreviousConfigChar){
			getPreviousConfigChar(system);
		}
		jmp completeStatement;
	}
	storeWhitespace:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp getStatement;
		}
		inc itemAmount;
		fileChar = '\0';
		jmp getStatementStoreCharacter;
	}
	completeStatement:{
		if(statementCurrent <= statementStart){
			jmp getStatement;
		}
		if(!*(statementCurrent - 1)){
			jmp getStatementEnd;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = GET_STATEMENT_END_JMP_POINT;
		jmp storeCharacter;
	}
	handleOpeningBracket:{
		if(statementCurrent <= statementStart){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray opening bracket error", "could not enter nameless scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(*(statementCurrent - 1)){
			inc itemAmount;
			fileChar = '\0';
			jmpPoint = ENTER_SCOPE_JMP_POINT;
			jmp storeCharacter;
		}
		jmp enterScope;
	}
	enterScope:{
		StringTreeSystem *stringTreeSystem;
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(currentScopeInstruction == globalScopeInstruction){
			stringTreeSystem = &globalScopesInstructionStringTreeSystem;
		}else{
			printConfigError("invalid scope error", "no scopes inside current scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(!findStringTreeString(stringTreeSystem, &statementCurrent)){
			printConfigError("invalid scope error", "invalid scope name", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(itemAmount > 1){
			/*! missing space between final argument and scope imminent */
			printConfigError("scope argument error", "too many arguments", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, (void *)1, (void *)1, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		currentScopeInstruction = scope1ScopeInstruction;
		currentScopeInstructionData = scope1ScopeInstructionData;
		currentScopeInstructionList = scope1ScopeInstructionList;
		currentScopeInstructionStringTreeSystem = &scope1ScopeInstructionStringTreeSystem;
		currentScopeInstructionListSize = countof(scope1ScopeInstructionList) - 1;
		jmp getStatementStart;
	}
	attemptStoreBar:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp storeBar;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = STORE_BAR_JMP_POINT;
		jmp storeCharacter;
	}
	storeBar:{
		fileChar = '|';
		jmpPoint = STORE_WHITESPACE_JMP_POINT;
		jmp storeCharacter;
	}
	handleClosingBracket:{
		if(statementCurrent > statementStart){
			if(getNextConfigChar != &ifgetc){
				getPreviousConfigChar(system);
				jmp completeStatement;
			}
			fseek(configFile, -1, SEEK_CUR);
			jmp completeStatement;
		}
		if(currentScopeInstruction == globalScopeInstruction){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray closing bracket error", "could not drop to previous config scope", '}', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(currentScopeInstruction == scope1ScopeInstruction){
			currentScopeInstruction = globalScopeInstruction;
			currentScopeInstructionData = globalScopeInstructionData;
			currentScopeInstructionList = globalInstructionList;
			currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
			currentScopeInstructionListSize = countof(globalInstructionList) - 1;
		}
		jmp getStatementStart;
	}
	storeEscapedCharacter:{
		*(statementCurrent - 1) = fileChar;
		if(quote == '\"'){
			jmp getDoubleQuotation;
		}
		jmp getSingleQuotation;
	}
	getStatementStoreCharacter:{
		jmpPoint = GET_STATEMENT_JMP_POINT;
		jmp storeCharacter;
	}
	getDoubleQuotationStoreCharacter:{
		jmpPoint = GET_DOUBLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	getSingleQuotationStoreCharacter:{
		jmpPoint = GET_SINGLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	handleEscapeCharacterStoreCharacter:{
		jmpPoint = HANDLE_ESCAPE_CHARACTER_JMP_POINT;
		jmp storeCharacter;
	}
	checkCommentStoreCharacter:{
		jmpPoint = CHECK_COMMENT_JMP_POINT;
		jmp storeCharacter;
	}
	storeCharacter:{
		if(statementCurrent >= statementConcreteWall){
			const uint offset = statementCurrent - statementStart;
			void *temp;
			statementSize += STATEMENT_BLOCK_SIZE;
			temp = realloc(statementStart, statementSize * sizeof(char));
			updatePointer(statementToken, temp);
			if(!temp){
				printConfigError("memory allocation error", "could not allocate memory for config statement", ';', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				statementSize -= STATEMENT_BLOCK_SIZE;
				jmp getStatementStart;
			}
			statementStart = temp;
			statementCurrent = statementStart + offset;
			statementConcreteWall = statementStart + statementSize * sizeof(char);
		}
		if(jmpPoint != CHECK_COMMENT_JMP_POINT and !statementLine){
			statementLine = fileLine;
		}
		*statementCurrent = fileChar;
		inc statementCurrent;
		switch jmpPoint over
			to GET_STATEMENT_JMP_POINT: /*-----------*/ jmp getStatement;
			to STORE_WHITESPACE_JMP_POINT: /*--------*/ jmp storeWhitespace;
			to CHECK_COMMENT_JMP_POINT: /*-----------*/ jmp checkComment;
			to STORE_BAR_JMP_POINT: /*---------------*/ jmp storeBar;
			to GET_DOUBLE_QUOTATION_JMP_POINT: /*----*/ jmp getDoubleQuotation;
			to GET_SINGLE_QUOTATION_JMP_POINT: /*----*/ jmp getSingleQuotation;
			to HANDLE_ESCAPE_CHARACTER_JMP_POINT: /*-*/ jmp handleEscapeCharacter;
			to ENTER_SCOPE_JMP_POINT: /*-------------*/ jmp enterScope;
			off: /*----------------------------------*/ jmp getStatementEnd;
		end
	}
	getStatementEnd:{
		if(statementCurrent > statementStart) /*-*/ jmp findStatement;
		if(!feof(configFile)) /*-----------------*/ jmp getStatementStart;
		/*---------------------------------------*/ jmp successfulConfig;
		#undef  GET_STATEMENT_END_JMP_POINT
		#undef  ENTER_SCOPE_JMP_POINT
		#undef  HANDLE_ESCAPE_CHARACTER_JMP_POINT
		#undef  GET_SINGLE_QUOTATION_JMP_POINT
		#undef  GET_DOUBLE_QUOTATION_JMPPOINT
		#undef  STORE_BAR_JMP_POINT
		#undef  CHECK_COMMENT_JMP_POINT
		#undef  STORE_WHITESPACE_JMP_POINT
		#undef  GET_STATEMENT_JMP_POINT
		#undef  CCB_125
		#undef  BAR_124
		#undef  OCB_123
		#undef  LOV_118
		#undef  LOT_116
		#undef  LOR_114
		#undef  LON_110
		#undef  LOF_102
		#undef  LOB_98
		#undef  LOA_97
		#undef  BSL_92
		#undef  QMK_63
		#undef  SCL_59
		#undef  ZER_48
		#undef  FSL_47
		#undef  AST_42
		#undef  SQT_39
		#undef  DQT_34
		#undef  SPC_32
		#undef  ESC_27
		#undef  CRE_13
		#undef  FFD_12
		#undef  VTB_11
		#undef  NLN_10
		#undef  TAB_09
		#undef  BSP_08
		#undef  ALR_07
		#undef  EOT_04
		#undef  ZER_00
		#undef  EOF_N1
	}
	findStatement:{
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(!findStringTreeString(currentScopeInstructionStringTreeSystem, &statementCurrent)){
			printConfigError("config error", "unrecognized instruction", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp printAllInstructionPatterns;
		}
		instructionStart = *(currentScopeInstruction + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionStartCopy = instructionStart;
		instructionCurrent = instructionStart;
		instructionDataStart = *(currentScopeInstructionData + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionDataStartCopy = instructionDataStart;
		instructionDataCurrent = instructionDataStart;
		if(*instructionCurrent == NONE_INSTRUCTION_TYPE){
			jmp unimplementedInstruction;
		}
		if(statementCurrent >= statementWall and *instructionCurrent != END_INSTRUCTION_TYPE){
			printConfigError("config error", "missing instruction body", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		inc statementCurrent;
		jmp switchInstructionLoop;
	}
	switchInstructionLoop: switch *instructionCurrent over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp unimplementedInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp matchName;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp matchNameList;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp matchInteger;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp matchString;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp matchImageString;
		off: /*---------------------------*/ jmp endOfInstruction;
	end
	unimplementedInstruction:{
		printConfigError("implementation error", "using unimplemented instruction", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchName:{
		char *s;
		uint8 *namePointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!name0Instruction){
			namePointer = &name0Return;
			name0Instruction = instructionCurrent;
		}elif(!name1Instruction){
			namePointer = &name1Return;
			name1Instruction = instructionCurrent;
		}elif(!name2Instruction){
			namePointer = &name2Return;
			name2Instruction = instructionCurrent;
		}elif(!name3Instruction){
			namePointer = &name3Return;
			name3Instruction = instructionCurrent;
		}else{
			namePointer = &name4Return;
			name4Instruction = instructionCurrent;
		}
		s = statementCurrent;
		if(!findStringTreeString(*instructionDataCurrent, &s)){
			printConfigError("match string error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		statementCurrent = s;
		inc statementCurrent;
		*namePointer = (**instructionDataCurrent).returnedCounter;
		jmp advanceDataInstruction;
	}
	matchNameList:{
		uint8 *nameListPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!nameList0Instruction){
			nameListPointer = &nameList0Return;
			nameList0Instruction = instructionCurrent;
		}elif(!nameList1Instruction){
			nameListPointer = &nameList1Return;
			nameList1Instruction = instructionCurrent;
		}elif(!nameList2Instruction){
			nameListPointer = &nameList2Return;
			nameList2Instruction = instructionCurrent;
		}elif(!nameList3Instruction){
			nameListPointer = &nameList3Return;
			nameList3Instruction = instructionCurrent;
		}else{
			nameListPointer = &nameList4Return;
			nameList4Instruction = instructionCurrent;
		}
		switch matchNameList(*instructionDataCurrent, statementWall, &statementCurrent, nameListPointer) over
			to INVALID_NAME_NAME_LIST: /*--*/ jmp invalidNameNameList;
			to PREMATURE_END_NAME_LIST: /*-*/ jmp prematureEndNameList;
			off: /*------------------------*/ jmp advanceDataInstruction;
		end
	}
	invalidNameNameList:{
		printConfigError("bar list error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	prematureEndNameList:{
		printConfigError("bar list error", "missing final name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchInteger:{
		int64 *integerPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!integer0Instruction){
			integerPointer = &integer0Return;
			integer0Instruction = instructionCurrent;
		}elif(!integer1Instruction){
			integerPointer = &integer1Return;
			integer1Instruction = instructionCurrent;
		}elif(!integer2Instruction){
			integerPointer = &integer2Return;
			integer2Instruction = instructionCurrent;
		}elif(!integer3Instruction){
			integerPointer = &integer3Return;
			integer3Instruction = instructionCurrent;
		}else{
			integerPointer = &integer4Return;
			integer4Instruction = instructionCurrent;
		}
		switch matchInteger(&statementCurrent, statementWall, integerPointer) over
			to NON_NUMBER_NUMBER: /*-------*/ jmp printNonNumberError;
			to OVERFLOWN_NUMBER_NUMBER: /*-*/ jmp printOverflownNumberError;
			to DIVIDED_BY_ZERO_NUMBER: /*--*/ jmp printDividedByZeroNumberError;
			off: /*------------------------*/ jmp advanceInstruction;
		end
	}
	printNonNumberError:{
		printConfigError("match integer error", "not a number", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printOverflownNumberError:{
		printConfigError("match integer error", "integer overflow", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printDividedByZeroNumberError:{
		printConfigError("match integer error", "integer divided by zero", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchString:{
		char **stringPointer;
		uint32 *stringTokenPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!string0Instruction){
			stringPointer = &string0Return;
			stringTokenPointer = &string0Token;
			string0Instruction = instructionCurrent;
		}elif(!string1Instruction){
			stringPointer = &string1Return;
			stringTokenPointer = &string1Token;
			string1Instruction = instructionCurrent;
		}elif(!string2Instruction){
			stringPointer = &string2Return;
			stringTokenPointer = &string2Token;
			string2Instruction = instructionCurrent;
		}elif(!string3Instruction){
			stringPointer = &string3Return;
			stringTokenPointer = &string3Token;
			string3Instruction = instructionCurrent;
		}else{
			stringPointer = &string4Return;
			stringTokenPointer = &string4Token;
			string4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, stringPointer, stringTokenPointer)){
			printConfigError("match string error", "could not allocate string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		jmp advanceInstruction;
	}
	matchImageString:{
		char *string = NULL;
		uint32 token = 0;
		Image *imagePointer;
		uint8 matchImageReturn;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!image0Instruction){
			imagePointer = &image0Return;
			image0Instruction = instructionCurrent;
		}elif(!image1Instruction){
			imagePointer = &image1Return;
			image1Instruction = instructionCurrent;
		}elif(!image2Instruction){
			imagePointer = &image2Return;
			image2Instruction = instructionCurrent;
		}elif(!image3Instruction){
			imagePointer = &image3Return;
			image3Instruction = instructionCurrent;
		}else{
			imagePointer = &image4Return;
			image4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, &string, &token)){
			printConfigError("match image error", "could not allocate image string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		matchImageReturn = matchImage(string, &imageErrorMessage, &image0Return);
		free(string);
		popPointer(token);
		switch matchImageReturn over
			to CANNOT_OPEN_MATCH_IMAGE: /*--------*/ jmp printCannotOpenReadConfig;
			to CANNOT_READ_MATCH_IMAGE: /*--------*/ jmp printCannotReadReadConfig;
			to UNSUPPORTED_FORMAT_MATCH_IMAGE: /*-*/ jmp printUnsupportedFormatReadConfig;
			to BAD_HEADER_MATCH_IMAGE: /*---------*/ jmp printBadHeaderReadConfig;
			to BAD_DEPTH_MATCH_IMAGE: /*----------*/ jmp printBadDepthReadConfig;
			to BAD_COMPRESSION_MATCH_IMAGE: /*----*/ jmp printBadCompressionReadConfig;
			to UNSUPPORTED_HEIGHT_MATCH_IMAGE: /*-*/ jmp printUnsupportedHeightReadConfig;
			to BAD_SIZE_MATCH_IMAGE: /*-----------*/ jmp printBadSizeReadConfig;
			to FAILED_MATCH_IMAGE: /*-------------*/ jmp printFailedReadConfig;
			to BAD_PIXELS_MATCH_IMAGE: /*---------*/ jmp printBadPixelsReadConfig;
			to BAD_IMAGE_MATCH_IMAGE: /*----------*/ jmp printBadImageReadConfig;
			off: /*-------------------------------*/ jmp advanceInstruction;
		end
	}
	printCannotOpenReadConfig:{
		printConfigError("match image error", "could not open image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printCannotReadReadConfig:{
		printConfigError("match image error", "could not read image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedFormatReadConfig:{
		printConfigError("match image error", "image file not bmp", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadHeaderReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadDepthReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadCompressionReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedHeightReadConfig:{
		printConfigError("match image error", "negative height is not supported", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadSizeReadConfig:{
		printConfigError("match image error", "could not traverse image past the header", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printFailedReadConfig:{
		printConfigError("match image error", "could not allocate pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadPixelsReadConfig:{
		printConfigError("match image error", "could not read pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadImageReadConfig:{
		printConfigError("match image error", "image is broken", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	endOfInstruction:{
		if(instructionStart == setInstruction){
			#define applySubinstruction(s, i) /*-*/ instructionStart = s##i##Subinstruction; instructionDataStart = s##i##SubinstructionData
			switch name0Return over
				off: /*-*/ brk;
			end
		}
		if(instructionStart == doInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, Do); jmp assessSubinstruction;
				off: /*----------------*/ /*-----------------------------*/ brk;
			end
		}
		if(instructionStart == grabKeycodeInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabKeycode); jmp assessSubinstruction;
				off: /*----------------*/ /*--------------------------------------*/ brk;
			end
		}
		if(instructionStart == grabButtonInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabButton); jmp assessSubinstruction;
				off: /*----------------*/ /*-------------------------------------*/ brk;
			end
			#undef  applySubinstruction
		}
		if(statementCurrent < statementWall){
			printConfigError("config error", "extra parameters error", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(instructionStartCopy == helpInstruction){
			printError("%s%s: %s: line %u: %s%s:%s %s:\n", colorStart, programName, configPath, statementLine, colorError, "config help menu", colorEnd, displaySimpleConfigErrors? "contracted" : "expanded");
			jmp printAllInstructionPatterns;
		}
		if(instructionStartCopy == expandInstruction){
			displaySimpleConfigErrors = false;
			jmp getStatementStart;
		}
		if(instructionStartCopy == contractInstruction){
			displaySimpleConfigErrors = true;
			jmp getStatementStart;
		}
		if(instructionStartCopy == readConfigInstruction){
			readConfig(false, string0Return, &ifgetc, NULL);
			jmp getStatementStart;
		}
		if(instructionStartCopy == useTerminalInstruction){
			switch name0Return over
				to TRUE_BOOLEAN:{
					if(!connectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == useMessengerInstruction){
			switch name0Return over
				to TRUE_BOOLEAN:{
					if(!connectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == setInstruction){
			switch name0Return over
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == doInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			end
			switch matchCommand(name0Return, string0Return, getNextConfigChar == &ifgetc? CONFIG_MATCH_COMMAND_ORIGIN : getNextConfigChar == &getNextSTDINCharacter? STDIN_MATCH_COMMAND_ORIGIN : TRANSMITTER_MATCH_COMMAND_ORIGIN, field0, field1, field2, field3, field4) over
				to TYPICAL_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to RESTART_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to EXIT_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				off:{
					printConfigError("config error", "do subinstruction not implemented yet", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionStart, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == grabKeycodeInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			end
			if(!insertShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_key_checked(connection, true, (*screen).root, nameList0Return, integer0Return, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab key on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == grabButtonInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			end
			if(!insertShortcut(&buttonShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_button_checked(connection, true, (*screen).root, XCB_EVENT_MASK_NO_EVENT, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, integer0Return, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab button on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabKeycodeInstruction){
			if(!removeShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find key to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_key_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab key from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabButtonInstruction){
			if(!removeShortcut(&buttonShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find button to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_button_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab button from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == stopInstruction){
			jmp successfulConfig;
		}
		jmp getStatementStart;
	}
	advanceInstruction:{
		inc instructionCurrent;
		jmp switchInstructionLoop;
	}
	advanceDataInstruction:{
		inc instructionCurrent;
		inc instructionDataCurrent;
		jmp switchInstructionLoop;
	}
	assessSubinstruction:{
		instructionCurrent = instructionStart + (instructionCurrent - instructionStartCopy);
		instructionDataCurrent = instructionDataStart + (instructionDataCurrent - instructionDataStartCopy);
		if(statementCurrent < statementWall){
			jmp switchInstructionLoop;
		}
		jmp printMissingArgumentError;
	}
	printMissingArgumentError:{
		printConfigError("config error", "missing argument error", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printAllInstructionPatterns:{
		const char *const *const wall = currentScopeInstructionList + currentScopeInstructionListSize;
		const char *const *current = currentScopeInstructionList;
		const Instruction *const *in = currentScopeInstruction;
		StringTreeSystem *const *const *da = currentScopeInstructionData;
		jmp printExpandedHelpInstructions;
		printExpandedHelpInstructions:{
			const Instruction *n = *in - 1;
			StringTreeSystem *const *d = *da;
			printError("\tpattern | %s", *current);
			jmp printHelpInstructionParametersLoop;
			printHelpInstructionParametersLoop: switch *(inc n) over
				to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
				to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
				to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
				to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
				to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
				to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
				off: /*---------------------------*/ jmp printHelpInstructionParametersLoopExit;
			end
			noneInstruction:{
				printError(" <unimplemented>");
				jmp printHelpInstructionParametersLoopExit;
			}
			nameInstruction:{
				if(displaySimpleConfigErrors){
					printError(" name");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" (%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
					printNameLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameLoop;
						}
						printError(")");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			nameListInstruction:{
				if(displaySimpleConfigErrors){
					printError(" list");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" ((%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
					printNameListOnceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListOnceLoop;
						}
						stringArray = (**d).stringArray;
						printError(")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
						inc stringArray;
						jmp printNameListTwiceLoop;
					}
					printNameListTwiceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListTwiceLoop;
						}
						printError("))*(?![\\s]*[|]))");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			numberInstruction:{
				if(displaySimpleConfigErrors){
					printError(" number");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
				jmp printHelpInstructionParametersLoop;
			}
			stringInstruction:{
				if(displaySimpleConfigErrors){
					printError(" string");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
			imageInstruction:{
				if(displaySimpleConfigErrors){
					printError(" image");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
		}
		printHelpInstructionParametersLoopExit:{
			inc in;
			inc da;
			if(displaySimpleConfigErrors){
				printError("\n");
			}else{
				printError(" $\n");
			}
			if(inc current < wall){
				jmp printExpandedHelpInstructions;
			}
			printError("\n");
			jmp getStatementStart;
		}
	}
	successfulConfig:{
		if(currentScopeInstruction != globalScopeInstruction){
			*statementCurrent = '\0';
			statementWall = statementCurrent;
			statementLine = fileLine;
			if(fileLine != 1){
				dec statementLine;
			}
			printConfigError("config error", "missing closing scope bracket", '\0', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		jmp configEmergencyExit;
	}
	configEmergencyExit:{
		if(configFile and fileLine == 1 and !statementLine){
			printConfigError("config warning", "empty config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		free(statementStart);
		popPointer(statementToken);
		if(configFile){
			fclose(configFile);
			popPointer(configFileToken);
		}
		jmp postReadConfig;
	}
	postReadConfig:{
		if(!configureWindows(&windowSystem, &monitorSystem, &windowPreferences, whichMonitor)){
			if(windowSystem.mapped){
				drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
			}
		}
		xcb_flush(connection);
		ret;
	}
	#undef  DEFAULT_CONFIG_PATH
	#undef  STATEMENT_BLOCK_SIZE
}
MATCHCOMMAND(){
	uint8 commandReturned = TYPICAL_MATCH_COMMAND_TYPE;
	(void)field0;
	(void)field1;
	(void)field2;
	(void)field3;
	(void)field4;
	switch origin over
		to PRESS_MATCH_COMMAND_ORIGIN:{
			printCommand("press", command);
			if(!((*eventModifierNode).onState & PRESS_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to RELEASE_MATCH_COMMAND_ORIGIN:{
			printCommand("release", command);
			if(!((*eventModifierNode).onState & RELEASE_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to CONFIG_MATCH_COMMAND_ORIGIN:{
			printCommand("config", command);
			jmp matchCommand;
		}
		to STDIN_MATCH_COMMAND_ORIGIN:{
			printCommand("stdin", command);
			jmp matchCommand;
		}
		to TRANSMITTER_MATCH_COMMAND_ORIGIN:{
			printCommand("transmitter", command);
			jmp matchCommand;
		}
		off:{
			jmp emergencyExit;
		}
	end
	matchCommand: switch command over
		to NONE_COMMAND: /*----*/ jmp noneCommand;
		to EXECUTE_COMMAND: /*-*/ jmp executeCommand;
		to RESTART_COMMAND: /*-*/ jmp restartCommand;
		to EXIT_COMMAND: /*----*/ jmp exitCommand;
		off: /*----------------*/ jmp unrecognizedCommand;
	end
	noneCommand:{
		jmp emergencyExit;
	}
	executeCommand:{
		spawnProcess(execute);
		jmp emergencyExit;
	}
	restartCommand:{
		commandReturned = RESTART_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	exitCommand:{
		commandReturned = EXIT_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	unrecognizedCommand:{
		printTitledValuedError("command error", "executed unrecognized command with type", command);
		jmp emergencyExit;
	}
	emergencyExit:{
		ret commandReturned;
	}
}
GETRECTANGLEUNION(){
	const int leftX = x0 < x1? x0 : x1;
	const int topY = y0 < y1? y0 : y1;
	const int rightX = x0 + width0 > x1 + width1? x0 + width0 : x1 + width1;
	const int bottomY = y0 + height0 > y1 + height1? y0 + height0 : y1 + height1;
	if(xReturn) /*------*/ *xReturn = leftX;
	if(yReturn) /*------*/ *yReturn = topY;
	if(widthReturn) /*--*/ *widthReturn = rightX - leftX;
	if(heightReturn) /*-*/ *heightReturn = bottomY - topY;
	ret;
}
GETINTERSECTINGRECTANGLES(){
	#define RECTANGLE_BLOCK_SIZE /*-*/ (16)
	const xcb_rectangle_t *source0Current;
	const xcb_rectangle_t *source0Wall;
	const xcb_rectangle_t *source1Current;
	const xcb_rectangle_t *source1Wall;
	uint rectangleSize;
	uint rectangleAllocated;
	xcb_rectangle_t *rectangleStart;
	uint32 rectangleToken;
	if(!source0Size or !source0Start or !source1Size or !source1Start or !destinationSize or !destinationStart or !destinationToken){
		ret false;
	}
	source0Current = source0Start;
	source0Wall = source0Current + source0Size;
	source1Current = source1Start;
	source1Wall = source1Current + source1Size;
	rectangleSize = 0;
	rectangleAllocated = 0;
	rectangleStart = NULL;
	rectangleToken = 0;
	jmp getIntersectingRectangleLoop;
	getIntersectingRectangleLoop:{
		if(source0Current < source0Wall){
			const xcb_rectangle_t *source1Current = source1Start;
			const xcb_rectangle_t *const source1Wall = source1Current + source1Size;
			jmp getIntersectingRectangle1Loop;
			getIntersectingRectangle1Loop:{
				if(source1Current < source1Wall){
					if((*source1Current).x + (*source1Current).width <= (*source0Current).x){
						inc source1Start;
						inc source1Current;
						jmp getIntersectingRectangle1Loop;
					}
					if(intersects((*source0Current).x, (*source0Current).y, (*source0Current).width, (*source0Current).height, (*source1Current).x, (*source1Current).y, (*source1Current).width, (*source1Current).height)){
						int intersectionX;
						int intersectionY;
						int intersectionWidth;
						int intersectionHeight;
						xcb_rectangle_t *rectangleCurrent;
						getIntersection((*source0Current).x, (*source0Current).y, (*source0Current).width, (*source0Current).height, (*source1Current).x, (*source1Current).y, (*source1Current).width, (*source1Current).height, &intersectionX, &intersectionY, &intersectionWidth, &intersectionHeight);
						if(rectangleAllocated == rectangleSize){
							void *temp;
							rectangleSize += RECTANGLE_BLOCK_SIZE;
							temp = realloc(rectangleStart, rectangleSize * sizeof(xcb_rectangle_t));
							if(!rectangleToken){
								rectangleToken = pushPointer(temp, "rectangles pointer", iFree);
							}else{
								updatePointer(rectangleToken, temp);
							}
							if(!temp){
								jmp trimMemory;
							}
							rectangleStart = temp;
						}
						rectangleCurrent = rectangleStart + rectangleAllocated;
						(*rectangleCurrent).x = intersectionX;
						(*rectangleCurrent).y = intersectionY;
						(*rectangleCurrent).width = intersectionWidth;
						(*rectangleCurrent).height = intersectionHeight;
						inc rectangleAllocated;
					}
					inc source1Current;
					jmp getIntersectingRectangle1Loop;
				}
				inc source0Current;
				jmp getIntersectingRectangleLoop;
			}
		}
		jmp trimMemory;
	}
	trimMemory:{
		rectangleSize = rectangleAllocated;
		if(rectangleSize){
			void *const temp = realloc(rectangleStart, rectangleSize * sizeof(xcb_rectangle_t));
			updatePointer(rectangleToken, temp);
			if(temp){
				rectangleStart = temp;
			}
		}
		jmp emergencyExit;
	}
	emergencyExit:{
		*destinationSize = rectangleSize;
		*destinationStart = rectangleStart;
		*destinationToken = rectangleToken;
		ret true;
	}
	#undef  RECTANGLE_BLOCK_SIZE
}
SUBTRACTRECTANGLES(){
	#define RECTANGLE_BLOCK_SIZE /*-*/ (16)
	const xcb_rectangle_t *sourceCurrent;
	const xcb_rectangle_t *sourceWall;
	const xcb_rectangle_t *subtractRectangleCurrent;
	const xcb_rectangle_t *subtractRectangleWall;
	uint rectangleSize;
	uint rectangleAllocated;
	xcb_rectangle_t *rectangleStart;
	uint32 rectangleToken;
	if(!sourceSize or !sourceStart or !destinationSize or !destinationStart or !destinationToken){
		ret false;
	}
	if(!subtractRectangleSize or !subtractRectangleStart){
		rectangleSize = sourceSize;
		rectangleStart = malloc(rectangleSize * sizeof(xcb_rectangle_t));
		rectangleToken = pushPointer(rectangleStart, "rectangles pointer", iFree);
		if(!rectangleStart){
			ret false;
		}
		copyMemory(sourceStart, rectangleStart, rectangleSize * sizeof(xcb_rectangle_t));
		jmp emergencyExit;
	}
	sourceCurrent = sourceStart;
	sourceWall = sourceCurrent + sourceSize;
	subtractRectangleCurrent = subtractRectangleStart;
	subtractRectangleWall = subtractRectangleCurrent + subtractRectangleSize;
	rectangleSize = 0;
	rectangleAllocated = 0;
	rectangleStart = NULL;
	rectangleToken = 0;
	jmp subtractRectangleLoop;
	subtractRectangleLoop:{
		if(sourceCurrent < sourceWall){
			uint amount = 0;
			xcb_rectangle_t start[4];
			xcb_rectangle_t *current;
			xcb_rectangle_t *rectangleCurrent;
			if(intersects((*subtractRectangleCurrent).x, (*subtractRectangleCurrent).y, (*subtractRectangleCurrent).width, (*subtractRectangleCurrent).height, (*sourceCurrent).x, (*sourceCurrent).y, (*sourceCurrent).width, (*sourceCurrent).height)){
				int intersectionX;
				int intersectionY;
				int intersectionWidth;
				int intersectionHeight;
				int sourceRightX;
				int sourceBottomY;
				int subtractRightX;
				int subtractBottomY;
				getIntersection((*subtractRectangleCurrent).x, (*subtractRectangleCurrent).y, (*subtractRectangleCurrent).width, (*subtractRectangleCurrent).height, (*sourceCurrent).x, (*sourceCurrent).y, (*sourceCurrent).width, (*sourceCurrent).height, &intersectionX, &intersectionY, &intersectionWidth, &intersectionHeight);
				current = start;
				sourceRightX = (*sourceCurrent).x + (*sourceCurrent).width;
				sourceBottomY = (*sourceCurrent).y + (*sourceCurrent).height;
				subtractRightX = (*subtractRectangleCurrent).x + (*subtractRectangleCurrent).width;
				subtractBottomY = (*subtractRectangleCurrent).y + (*subtractRectangleCurrent).height;
				if((*sourceCurrent).y < (*subtractRectangleCurrent).y){
					(*current).x = (*sourceCurrent).x;
					(*current).y = (*sourceCurrent).y;
					(*current).width = (*sourceCurrent).width;
					(*current).height = (*subtractRectangleCurrent).y - (*sourceCurrent).y;
					inc current;
				}
				if(sourceBottomY > subtractBottomY){
					(*current).x = (*sourceCurrent).x;
					(*current).y = subtractBottomY;
					(*current).width = (*sourceCurrent).width;
					(*current).height = sourceBottomY - subtractBottomY;
					inc current;
				}
				if((*sourceCurrent).x < (*subtractRectangleCurrent).x){
					(*current).x = (*sourceCurrent).x;
					(*current).y = (*subtractRectangleCurrent).y;
					(*current).width = (*subtractRectangleCurrent).x - (*sourceCurrent).x;
					(*current).height = (*subtractRectangleCurrent).height;
					inc current;
				}
				if(sourceRightX > subtractRightX){
					(*current).x = subtractRightX;
					(*current).y = (*subtractRectangleCurrent).y;
					(*current).width = sourceRightX - subtractRightX;
					(*current).height = (*subtractRectangleCurrent).height;
					inc current;
				}
				amount = current - start;
				inc subtractRectangleCurrent;
			}else{
				*(start + 0) = *sourceCurrent;
				inc amount;
			}
			if(rectangleAllocated + amount >= rectangleSize){
				void *temp;
				rectangleSize += RECTANGLE_BLOCK_SIZE;
				temp = realloc(rectangleStart, rectangleSize * sizeof(xcb_rectangle_t));
				if(!rectangleToken){
					rectangleToken = pushPointer(temp, "split rectangles pointer", iFree);
				}else{
					updatePointer(rectangleToken, temp);
				}
				if(!temp){
					jmp trimMemory;
				}
				rectangleStart = temp;
			}
			rectangleCurrent = rectangleStart + rectangleAllocated;
			switch amount over
				fallthrough4: to 4: *(rectangleCurrent + 3) = *(start + 3); /*------*/ jmp fallthrough3;
				fallthrough3: to 3: *(rectangleCurrent + 2) = *(start + 2); /*------*/ jmp fallthrough2;
				fallthrough2: to 2: *(rectangleCurrent + 1) = *(start + 1); /*------*/ jmp fallthrough1;
				fallthrough1: to 1: *(rectangleCurrent + 0) = *(start + 0); brk; /*-*/ jmp fallthrough4;
			end
			rectangleAllocated += amount;
			inc sourceCurrent;
			jmp subtractRectangleLoop;
		}
		jmp trimMemory;
	}
	trimMemory:{
		rectangleSize = rectangleAllocated;
		if(rectangleSize){
			void *const temp = realloc(rectangleStart, rectangleSize * sizeof(xcb_rectangle_t));
			updatePointer(rectangleToken, temp);
			if(temp){
				rectangleStart = temp;
			}
		}
		jmp emergencyExit;
	}
	emergencyExit:{
		*destinationSize = rectangleSize;
		*destinationStart = rectangleStart;
		*destinationToken = rectangleToken;
		ret true;
	}
	#undef  RECTANGLE_BLOCK_SIZE
}
SORTRECTANGLES(){
	xcb_rectangle_t *current;
	xcb_rectangle_t *wall;
	if(!start or !allocated){
		ret false;
	}
	current = start + 1;
	wall = start + allocated;
	jmp sortRectangleLoop;
	sortRectangleLoop:{
		if(current < wall){
			const xcb_rectangle_t rectangle = *current;
			xcb_rectangle_t *c = current - 1;
			jmp swapLoop;
			swapLoop:{
				if(c >= start and ((*c).x > rectangle.x or ((*c).x == rectangle.x and (*c).y > rectangle.y))){
					*(c + 1) = *c;
					dec c;
					jmp swapLoop;
				}
				*(c + 1) = rectangle;
				inc current;
				jmp sortRectangleLoop;
			}
		}
		ret true;
	}
}
MERGERECTANGLES(){
	xcb_rectangle_t *current;
	xcb_rectangle_t *wall;
	xcb_rectangle_t *newCurrent;
	if(!start or !allocated or !*allocated){
		ret false;
	}
	current = start + 1;
	wall = start + *allocated;
	newCurrent = start;
	jmp mergeRectangleLoop;
	mergeRectangleLoop:{
		if(current < wall){
			if((*newCurrent).y == (*current).y and (*newCurrent).height == (*current).height and (*newCurrent).x + (*newCurrent).width == (*current).x){
				(*newCurrent).width += (*current).width;
				inc current;
				jmp mergeRectangleLoop;
			}
			if((*newCurrent).x == (*current).x and (*newCurrent).width == (*current).width and (*newCurrent).y + (*newCurrent).height == (*current).y){
				(*newCurrent).height += (*current).height;
				inc current;
				jmp mergeRectangleLoop;
			}
			inc newCurrent;
			*newCurrent = *current;
			inc current;
			jmp mergeRectangleLoop;
		}
		*allocated = newCurrent + 1 - start;
		ret true;
	}
}
CLEANUP(){
	free(event);
	popPointer(eventToken);
	event = NULL;
	eventToken = 0;
	finiSharedMemorySystem(&sharedMemorySystem);
	finiSTDINSystem(&stdinSystem);
	finiSleepThreadSystem(&sleepThreadSystem);
	cancelThreads();
	ungrabShortcuts();
	freeConfigVariables();
	finiWindowSystem(&windowSystem);
	finiCompositorSystem();
	finiBufferSystem(&bufferSystem);
	finiClientSystem(&clientSystem);
	finiWallpaperSystem(&wallpaperSystem);
	finiMonitorSystem(&monitorSystem);
	finiFormatSystem(&formatSystem);
	if(connection){
		xcb_flush(connection);
		xcb_disconnect(connection);
		popPointer(connectionToken);
		connection = NULL;
		connectionToken = 0;
	}
	finiShortcutSystem(&buttonShortcutSystem);
	finiShortcutSystem(&keycodeShortcutSystem);
	finiStringTreeSystem(&macroStringTreeSystem);
	finiStringTreeSystem(&whichMonitorStringTreeSystem);
	finiStringTreeSystem(&cornerStringTreeSystem);
	finiStringTreeSystem(&verticalAlignmentStringTreeSystem);
	finiStringTreeSystem(&horizontalAlignmentStringTreeSystem);
	finiStringTreeSystem(&numberTypeStringTreeSystem);
	finiStringTreeSystem(&shortcutStateStringTreeSystem);
	finiStringTreeSystem(&modifierStringTreeSystem);
	finiStringTreeSystem(&commandStringTreeSystem);
	finiStringTreeSystem(&variableStringTreeSystem);
	finiStringTreeSystem(&booleanStringTreeSystem);
	finiStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
	finiStringTreeSystem(&globalInstructionStringTreeSystem);
	finiStringTreeSystem(&globalScopesInstructionStringTreeSystem);
	finiPermissionSystem(&permissionSystem);
	if(memoryManagementSystem.allocated > 1){
		printError("%s%s: %s%s:%s %s", colorStart, programName, colorError, "warning", colorEnd, "program exited with unaccounted for data pointers, namely:\n");
		printUnaccountedForPointers(memoryManagementSystem.data + 1, memoryManagementSystem.data + memoryManagementSystem.allocated);
	}
	finiMemorySystem();
	closeErrorStream();
	exit(EXIT_SUCCESS);
}
PRINTCONFIGERROR(){
	const char *statementCurrent = statementStart;
	const uint itemAmountWall = instructionCurrent - instructionStart;
	uint itemAmount = 0;
	uint spaceAmount = 0;
	StringTreeSystem *const *data;
	if(!openErrorStream()){
		ret;
	}
	flockfile(errorStream);
	fprintf(errorStream, "%s%s: %s: ", colorStart, programName, configPath);
	if(printLine){
		fprintf(errorStream, "line %u: ", statementLine);
	}
	fprintf(errorStream, "%s%s:%s %s", colorError, type, colorEnd, message);
	if(printConfig){
		fprintf(errorStream, ":\n\t config |");
	}else{
		fprintf(errorStream, "\n");
		jmp emergencyExit;
	}
	jmp printStatementItemLoop;
	printStatementItemLoop:{
		if(statementCurrent < statementWall){
			fprintf(errorStream, " %s", statementCurrent);
			jmp pushOutTermLoop;
			pushOutTermLoop:{
				if(*(inc statementCurrent)){
					jmp pushOutTermLoop;
				}
				inc statementCurrent;
			}
			if(itemAmount == itemAmountWall and instructionStart){
				spaceAmount = statementCurrent - statementStart;
			}
			inc itemAmount;
			jmp printStatementItemLoop;
		}
		if(spaceAmount == 0 and finalStatementCharacter != ';'){
			fprintf(errorStream, " ");
		}
		fprintf(errorStream, "%c\n", finalStatementCharacter);
		jmp printPattern;
	}
	printPattern:{
		if(printPointer){
			if(spaceAmount == statementCurrent - statementStart){
				dec spaceAmount;
			}
			fprintf(errorStream, "\t        |%*c^\n", inc spaceAmount, ' ');
		}
		if(!printPattern or !instructionStart){
			fprintf(errorStream, "\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, "\n\tpattern | %s", *(currentScopeInstructionList + (*currentScopeInstructionStringTreeSystem).returnedCounter));
		dec instructionStart;
		data = instructionDataStart;
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoop: switch *(inc instructionStart) over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
		off: /*---------------------------*/ jmp printInstructionParameterLoopExit;
	end
	noneInstruction:{
		fprintf(errorStream, " <unimplemented>");
		jmp printInstructionParameterLoopExit;
	}
	nameInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " name");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " (%s", *stringArray);
			inc stringArray;
			jmp printNameLoop;
			printNameLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
				}
				fprintf(errorStream, ")");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	nameListInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " list");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " ((%s", *stringArray);
			inc stringArray;
			jmp printNameListOnceLoop;
			printNameListOnceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
				}
				stringArray = (**data).stringArray;
				fprintf(errorStream, ")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
				inc stringArray;
				jmp printNameListTwiceLoop;
			}
			printNameListTwiceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListTwiceLoop;
				}
				fprintf(errorStream, "))*(?![\\s]*[|]))");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	numberInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " number");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
		jmp printInstructionParameterLoop;
	}
	stringInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " string");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	imageInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " image");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	printTilde:{
		fprintf(errorStream, " ~");
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoopExit:{
		if(displaySimpleConfigErrors){
			fprintf(errorStream, "\n\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, " $\n\n");
		jmp emergencyExit;
	}
	emergencyExit:{
		funlockfile(errorStream);
		closeErrorStream();
		ret;
	}
}

