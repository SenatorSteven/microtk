
/*!
	future updates:
		+set an icon.
		+add specific/static monitor support.
		+add sliding text setting for very long text.
		+detect when the entire desktop is covered with a set of window and change the color from transparent to solid or color A to B.
		+add islands/sections, either static or programmable.
		+add a peek command.
		+add support for custom window border size and color, text padding and text character amount capping.
		+add support for custom window background images, with vertical or horizontal scrolling should the user choose it.
		+support picking up icons when the tray icon window has been created post icon window creation.
		+support the xembed focus protocol on the systemTraySelectionWindow.
		+support the xembed tab focus chain protocol on the systemTraySelectionWindow.
		+support xembed accelerators on the systemTraySelectionWindow.
		+support the xembed modality protocol on the systemTraySelectionWindow.
		+support the xdnd protocol on the systemTraySelectionWindow.
		+support normal hints on the systemTraySelectionWindow.
		+support icon window transparency by effectively recreating every icon window in 32 bits.
		+draw the windows' contents only when actually visible.
		+add specific window support for system tray.
		+restore window properties should somebody change them.
		+restore window size and position should somebody change them.
		+support custom-sized bars on forceful window managers (like i3) using transparency.
		+use pointers to ordered tray icons instead of rearranging icons directly.
*/

/*!
	future feature list for matchANSISequence(), should we wanna use a proper set of ANSI codes to implement a terminal (select graphic rendition parameters only, must add the other ones later):
		v 0				Reset or normal													All attributes become turned off
		  1				Bold or increased intensity										As with faint, the color change is a PC (SCO / CGA) invention.
		  2				Faint, decreased intensity, or dim								May be implemented as a light font weight like bold.
		  3				Italic															Not widely supported. Sometimes treated as inverse or blink.
		  4				Underline														Style extensions exist for Kitty, VTE, mintty, iTerm2 and Konsole.
		  5				Slow blink														Sets blinking to less than 150 times per minute
		  6				Rapid blink														MS-DOS ANSI.SYS, 150+ per minute; not widely supported
		v 7				Reverse video or invert											Swap foreground and background colors; inconsistent emulation
		  8				Conceal or hide													Not widely supported.
		  9				Crossed-out, or strike											Characters legible but marked as if for deletion. Not supported in Terminal.app.
		  10			Primary (default) font
		  11–19			Alternative font												Select alternative font n − 10
		  20			Fraktur (Gothic)												Rarely supported
		  21			Doubly underlined; or: not bold									Double-underline per ECMA-48,  but instead disables bold intensity on several terminals, including in the Linux kernel's console before version 4.17.
		  22			Normal intensity												Neither bold nor faint; color changes where intensity is implemented as such.
		  23			Neither italic, nor blackletter
		  24			Not underlined													Neither singly nor doubly underlined
		  25			Not blinking													Turn blinking off
		  26			Proportional spacing											ITU T.61 and T.416, not known to be used on terminals
		  27			Not reversed
		  28			Reveal															Not concealed
		  29			Not crossed out
		v 30–37			Set foreground color
		v 38			Set foreground color											Next arguments are 5;n or 2;r;g;b
		v 39			Default foreground color										Implementation defined (according to standard)
		v 40–47			Set background color
		v 48			Set background color											Next arguments are 5;n or 2;r;g;b
		v 49			Default background color										Implementation defined (according to standard)
		  50			Disable proportional spacing									T.61 and T.416
		  51			Framed															Implemented as "emoji variation selector" in mintty.
		  52			Encircled
		  53			Overlined														Not supported in Terminal.app
		  54			Neither framed nor encircled
		  55			Not overlined
		  58			Set underline color												Not in standard; implemented in Kitty, VTE, mintty, and iTerm2. Next arguments are 5;n or 2;r;g;b.
		  59			Default underline color											Not in standard; implemented in Kitty, VTE, mintty, and iTerm2.
		  60			Ideogram underline or right side line							Rarely supported
		  61			Ideogram double underline, or double line on the right side		Rarely supported
		  62			Ideogram overline or left side line								Rarely supported
		  63			Ideogram double overline, or double line on the left side		Rarely supported
		  64			Ideogram stress marking											Rarely supported
		  65			No ideogram attributes											Reset the effects of all of 60–64
		  73			Superscript														Implemented only in mintty
		  74			Subscript														Implemented only in mintty
		  75			Neither superscript nor subscript								Implemented only in mintty
		v 90–97			Set bright foreground color										Not in standard; originally implemented by aixterm
		v 100–107		Set bright background color										Not in standard; originally implemented by aixterm
*/



























/*!includes:{*/
	#include <errno.h>
	#include <grp.h>
	#include <limits.h>
	#include <locale.h>
	#include <poll.h>
	#include <pthread.h>
	#include <pwd.h>
	#include <signal.h>
	#include <stdarg.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <sys/shm.h>
	#include <sys/stat.h>
	#include <sys/wait.h>
	#include <xcb/randr.h>
	#include <xcb/xfixes.h>
/*!}*/

/*!defines:{*/
	#define DEBUG /*-----------------------------------------*/ (false)

	#define PROGRAM_NAME /*----------------------------------*/ "microbar"

	#define WHICH_MONITOR_CONTENT(k, v, n, p) /*-------------*/ { \
		  v(none)           k(NONE##p) \
		, v(pointer)        k(POINTER##p) \
		, v(focused-window) k(FOCUSED_WINDOW##p) \
		, v(all)            k(ALL##p) \
		, n(NULL)           k(NULL##p) \
	}

	#define NUMBER_TYPE_CONTENT(k, v, n, p) /*---------------*/ { \
		  v(none)       k(NONE##p) \
		, v(integer)    k(INTEGER##p) \
		, v(percentage) k(PERCENTAGE##p) \
		, v(millimeter) k(MILLIMETER##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define POSITION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(bottom) k(BOTTOM##p) \
		, v(left)   k(LEFT##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define HORIZONTAL_ALIGNMENT_CONTENT(k, v, n, p) /*------*/ { \
		  v(none)   k(NONE##p) \
		, v(left)   k(LEFT##p) \
		, v(center) k(CENTER##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define VERTICAL_ALIGNMENT_CONTENT(k, v, n, p) /*--------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(center) k(CENTER##p) \
		, v(bottom) k(BOTTOM##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define CORNER_CONTENT(k, v, n, p) /*--------------------*/ { \
		  v(none)         k(NONE##p         = (b(0000))) \
		, v(top-left)     k(TOP_LEFT##p     = (b(0001))) \
		, v(top-right)    k(TOP_RIGHT##p    = (b(0010))) \
		, v(bottom-left)  k(BOTTOM_LEFT##p  = (b(0100))) \
		, v(bottom-right) k(BOTTOM_RIGHT##p = (b(1000))) \
		, n(NULL)         k(NULL##p) \
	}

	#define AXIS_CONTENT(k, v, n, p) /*----------------------*/ { \
		  v(none)       k(NONE##p) \
		, v(horizontal) k(HORIZONTAL##p) \
		, v(vertical)   k(VERTICAL##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define SYSTEM_TRAY_REQUEST_DOCK /*----------------------*/ (0)
	#define SYSTEM_TRAY_BEGIN_MESSAGE /*---------------------*/ (1)
	#define SYSTEM_TRAY_CANCEL_MESSAGE /*--------------------*/ (2)

	#define XEMBED_VERSION /*--------------------------------*/ (1)

	#define XEMBED_MAPPED /*---------------------------------*/ (b(00000001))

	#define XEMBED_EMBEDDED_NOTIFY /*------------------------*/ (0)
	#define XEMBED_WINDOW_ACTIVATE /*------------------------*/ (1)
	#define XEMBED_WINDOW_DEACTIVATE /*----------------------*/ (2)
	#define XEMBED_REQUEST_FOCUS /*--------------------------*/ (3)
	#define XEMBED_FOCUS_IN /*-------------------------------*/ (4)
	#define XEMBED_FOCUS_OUT /*------------------------------*/ (5)
	#define XEMBED_FOCUS_NEXT /*-----------------------------*/ (6)
	#define XEMBED_FOCUS_PREV /*-----------------------------*/ (7)
	#define XEMBED_GRAB_KEY /*-------------------------------*/ (8)
	#define XEMBED_UNGRAB_KEY /*-----------------------------*/ (9)
	#define XEMBED_MODALITY_ON /*----------------------------*/ (10)
	#define XEMBED_MODALITY_OFF /*---------------------------*/ (11)
	#define XEMBED_REGISTER_ACCELERATOR /*-------------------*/ (12)
	#define XEMBED_UNREGISTER_ACCELERATOR /*-----------------*/ (13)
	#define XEMBED_ACTIVATE_ACCELERATOR /*-------------------*/ (14)

	#define XEMBED_FOCUS_CURRENT /*--------------------------*/ (0)
	#define XEMBED_FOCUS_FIRST /*----------------------------*/ (1)
	#define XEMBED_FOCUS_LAST /*-----------------------------*/ (2)

	#define _STRING_TREE_NODE_CHILDREN_AMOUNT /*-------------*/ (14)
	#define STRING_TREE_NODE_CHILDREN_AMOUNT /*--------------*/ (_STRING_TREE_NODE_CHILDREN_AMOUNT > 28? 28 : _STRING_TREE_NODE_CHILDREN_AMOUNT)

	#define EMPTY_SHARED_STATUS /*---------------------------*/ (0)
	#define FULL_SHARED_STATUS /*----------------------------*/ (1)

	#define SHORTCUT_CODE_AMOUNT /*--------------------------*/ (256)

	#define SHORTCUT_STATE_CONTENT(k, v, n, p) /*------------*/ { \
		  v(none)    k(NONE##p    = (b(000))) \
		, v(press)   k(PRESS##p   = (b(001))) \
		, v(repeat)  k(REPEAT##p  = (b(010))) \
		, v(release) k(RELEASE##p = (b(100))) \
		, n(NULL)    k(NULL##p) \
	}

	#define NONE_INSTRUCTION_TYPE /*-------------------------*/ (b(000000))
	#define NAME_INSTRUCTION_TYPE /*-------------------------*/ (b(000001))
	#define NAME_LIST_INSTRUCTION_TYPE /*--------------------*/ (b(000010))
	#define NUMBER_INSTRUCTION_TYPE /*-----------------------*/ (b(000100))
	#define STRING_INSTRUCTION_TYPE /*-----------------------*/ (b(001000))
	#define IMAGE_INSTRUCTION_TYPE /*------------------------*/ (b(010000))
	#define END_INSTRUCTION_TYPE /*--------------------------*/ (b(100000))

	#define GLOBAL_SCOPES_INSTRUCTION_CONTENT(k, v, n, p) /*-*/ { \
		  v(scope1) k(SCOPE1##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define GLOBAL_INSTRUCTION_CONTENT(k, v, n, p) /*--------*/ { \
		  v(help)                k(HELP##p) \
		, v(expand)              k(EXPAND##p) \
		, v(contract)            k(CONTRACT##p) \
		, v(read-config)         k(READ_CONFIG##p) \
		, v(use-terminal)        k(USE_TERMINAL##p) \
		, v(use-messenger)       k(USE_MESSENGER##p) \
		, v(acquire-system-tray) k(ACQUIRE_SYSTEM_TRAY##p) \
		, v(set)                 k(SET##p) \
		, v(do)                  k(DO##p) \
		, v(grab-keycode)        k(GRAB_KEYCODE##p) \
		, v(grab-button)         k(GRAB_BUTTON##p) \
		, v(ungrab-keycode)      k(UNGRAB_KEYCODE##p) \
		, v(ungrab-button)       k(UNGRAB_BUTTON##p) \
		, v(stop)                k(STOP##p) \
		, n(NULL)                k(NULL##p) \
	}

	#define SCOPE1_SCOPE_INSTRUCTION_CONTENT(k, v, n, p) /*--*/ { \
		  v(help)     k(HELP##p) \
		, v(expand)   k(EXPAND##p) \
		, v(contract) k(CONTRACT##p) \
		, v(stop)     k(STOP##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define BOOLEAN_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)  k(NONE##p) \
		, v(true)  k(TRUE##p) \
		, v(false) k(FALSE##p) \
		, n(NULL)  k(NULL##p) \
	}

	#define VARIABLE_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)                        k(NONE##p) \
		, v(window-x)                    k(WINDOW_X##p) \
		, v(window-y)                    k(WINDOW_Y##p) \
		, v(window-x-offset)             k(WINDOW_X_OFFSET##p) \
		, v(window-y-offset)             k(WINDOW_Y_OFFSET##p) \
		, v(window-width)                k(WINDOW_WIDTH##p) \
		, v(window-height)               k(WINDOW_HEIGHT##p) \
		, v(window-position)             k(WINDOW_POSITION##p) \
		, v(window-horizontal-alignment) k(WINDOW_HORIZONTAL_ALIGNMENT##p) \
		, v(window-vertical-alignment)   k(WINDOW_VERTICAL_ALIGNMENT##p) \
		, v(window-background)           k(WINDOW_BACKGROUND##p) \
		, v(text-x-1)                    k(TEXT_X_1##p) \
		, v(text-y-1)                    k(TEXT_Y_1##p) \
		, v(text-x-offset-1)             k(TEXT_X_OFFSET_1##p) \
		, v(text-y-offset-1)             k(TEXT_Y_OFFSET_1##p) \
		, v(text-horizontal-alignment-1) k(TEXT_HORIZONTAL_ALIGNMENT_1##p) \
		, v(text-vertical-alignment-1)   k(TEXT_VERTICAL_ALIGNMENT_1##p) \
		, v(text-rotation-1)             k(TEXT_ROTATION_1##p) \
		, v(text-foreground-1)           k(TEXT_FOREGROUND_1##p) \
		, v(text-background-1)           k(TEXT_BACKGROUND_1##p) \
		, v(text-x-2)                    k(TEXT_X_2##p) \
		, v(text-y-2)                    k(TEXT_Y_2##p) \
		, v(text-x-offset-2)             k(TEXT_X_OFFSET_2##p) \
		, v(text-y-offset-2)             k(TEXT_Y_OFFSET_2##p) \
		, v(text-horizontal-alignment-2) k(TEXT_HORIZONTAL_ALIGNMENT_2##p) \
		, v(text-vertical-alignment-2)   k(TEXT_VERTICAL_ALIGNMENT_2##p) \
		, v(text-rotation-2)             k(TEXT_ROTATION_2##p) \
		, v(text-foreground-2)           k(TEXT_FOREGROUND_2##p) \
		, v(text-background-2)           k(TEXT_BACKGROUND_2##p) \
		, v(text-x-3)                    k(TEXT_X_3##p) \
		, v(text-y-3)                    k(TEXT_Y_3##p) \
		, v(text-x-offset-3)             k(TEXT_X_OFFSET_3##p) \
		, v(text-y-offset-3)             k(TEXT_Y_OFFSET_3##p) \
		, v(text-horizontal-alignment-3) k(TEXT_HORIZONTAL_ALIGNMENT_3##p) \
		, v(text-vertical-alignment-3)   k(TEXT_VERTICAL_ALIGNMENT_3##p) \
		, v(text-rotation-3)             k(TEXT_ROTATION_3##p) \
		, v(text-foreground-3)           k(TEXT_FOREGROUND_3##p) \
		, v(text-background-3)           k(TEXT_BACKGROUND_3##p) \
		, v(tray-window-x)               k(TRAY_WINDOW_X##p) \
		, v(tray-window-y)               k(TRAY_WINDOW_Y##p) \
		, v(tray-window-x-offset)        k(TRAY_WINDOW_X_OFFSET##p) \
		, v(tray-window-y-offset)        k(TRAY_WINDOW_Y_OFFSET##p) \
		, v(tray-window-background)      k(TRAY_WINDOW_BACKGROUND##p) \
		, v(tray-icon-x-offset)          k(TRAY_ICON_X_OFFSET##p) \
		, v(tray-icon-y-offset)          k(TRAY_ICON_Y_OFFSET##p) \
		, v(tray-icon-size)              k(TRAY_ICON_SIZE##p) \
		, v(tray-icon-padding)           k(TRAY_ICON_PADDING##p) \
		, v(command-1)                   k(COMMAND_1##p) \
		, v(command-2)                   k(COMMAND_2##p) \
		, v(command-3)                   k(COMMAND_3##p) \
		, v(interval)                    k(INTERVAL##p) \
		, v(font)                        k(FONT##p) \
		, n(NULL)                        k(NULL##p) \
	}

	#define COMMAND_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)              k(NONE##p) \
		, v(execute)           k(EXECUTE##p) \
		, v(show)              k(SHOW##p) \
		, v(hide)              k(HIDE##p) \
		, v(toggle-visibility) k(TOGGLE_VISIBILITY##p) \
		, v(draw)              k(DRAW##p) \
		, v(restart)           k(RESTART##p) \
		, v(exit)              k(EXIT##p) \
		, n(NULL)              k(NULL##p) \
	}

	#define MODIFIER_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)     k(NONE##p) \
		, v(shift)    k(SHIFT##p) \
		, v(caps)     k(CAPS##p) \
		, v(control)  k(CONTROL##p) \
		, v(mod-1)    k(MOD_1##p) \
		, v(mod-2)    k(MOD_2##p) \
		, v(mod-3)    k(MOD_3##p) \
		, v(mod-4)    k(MOD_4##p) \
		, v(mod-5)    k(MOD_5##p) \
		, v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NAME_LIST /*--------------------------------*/ (0)
	#define SUCCESS_NAME_LIST /*-----------------------------*/ (1)
	#define INVALID_NAME_NAME_LIST /*------------------------*/ (2)
	#define PREMATURE_END_NAME_LIST /*-----------------------*/ (3)

	#define MACRO_CONTENT(k, v, n, p) /*---------------------*/ { \
		  v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NUMBER /*-----------------------------------*/ (0)
	#define VALID_NUMBER_NUMBER /*---------------------------*/ (1)
	#define NON_NUMBER_NUMBER /*-----------------------------*/ (2)
	#define OVERFLOWN_NUMBER_NUMBER /*-----------------------*/ (3)
	#define DIVIDED_BY_ZERO_NUMBER /*------------------------*/ (4)

	#define NONE_MATCH_IMAGE /*------------------------------*/ (0)
	#define CANNOT_OPEN_MATCH_IMAGE /*-----------------------*/ (1)
	#define CANNOT_READ_MATCH_IMAGE /*-----------------------*/ (2)
	#define UNSUPPORTED_FORMAT_MATCH_IMAGE /*----------------*/ (3)
	#define BAD_HEADER_MATCH_IMAGE /*------------------------*/ (4)
	#define BAD_DEPTH_MATCH_IMAGE /*-------------------------*/ (5)
	#define BAD_COMPRESSION_MATCH_IMAGE /*-------------------*/ (6)
	#define UNSUPPORTED_HEIGHT_MATCH_IMAGE /*----------------*/ (7)
	#define BAD_SIZE_MATCH_IMAGE /*--------------------------*/ (8)
	#define FAILED_MATCH_IMAGE /*----------------------------*/ (9)
	#define BAD_PIXELS_MATCH_IMAGE /*------------------------*/ (10)
	#define BAD_IMAGE_MATCH_IMAGE /*-------------------------*/ (11)
	#define SUCCESS_MATCH_IMAGE /*---------------------------*/ (12)

	#define NONE_MATCH_COMMAND_ORIGIN /*---------------------*/ (0)
	#define PRESS_MATCH_COMMAND_ORIGIN /*--------------------*/ (1)
	#define RELEASE_MATCH_COMMAND_ORIGIN /*------------------*/ (2)
	#define CONFIG_MATCH_COMMAND_ORIGIN /*-------------------*/ (3)
	#define STDIN_MATCH_COMMAND_ORIGIN /*--------------------*/ (4)
	#define TRANSMITTER_MATCH_COMMAND_ORIGIN /*--------------*/ (5)

	#define NONE_MATCH_COMMAND_TYPE /*-----------------------*/ (0)
	#define TYPICAL_MATCH_COMMAND_TYPE /*--------------------*/ (1)
	#define RESTART_MATCH_COMMAND_TYPE /*--------------------*/ (2)
	#define EXIT_MATCH_COMMAND_TYPE /*-----------------------*/ (3)

	#define ROTATION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)        k(NONE##p) \
		, v(degrees-90)  k(DEGREES_90##p)  \
		, v(degrees-180) k(DEGREES_180##p) \
		, v(degrees-270) k(DEGREES_270##p) \
		, n(NULL)        k(NULL##p) \
	}

	#define INITWINDOWSYSTEM() /*----------------------------*/ local bool               initWindowSystem(WindowSystem *const windowSystem)
	#define CREATEWINDOWCIRCLEPIXMAP() /*--------------------*/ local bool               createWindowCirclePixmap(WindowSystem *const windowSystem, const uint radius, const uint32 foreground, const uint32 background)
	#define CREATEWINDOWS() /*-------------------------------*/ local bool               createWindows(WindowSystem *const windowSystem, const uint amount, const bool overrideRedirect, const uint32 eventMask)
	#define MAPWINDOWS() /*----------------------------------*/ local bool               mapWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences, const uint8 whichMonitor)
	#define CONFIGUREWINDOWS() /*----------------------------*/ local bool               configureWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences, const uint8 whichMonitor)
	#define DRAWWINDOWS() /*---------------------------------*/ local bool               drawWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences)
	#define UPDATEWINDOWS() /*-------------------------------*/ local bool               updateWindows(void *const arg)
	#define SETWINDOWPROPERTIES() /*-------------------------*/ local bool               setWindowProperties(WindowInfo *const windowInfo, const ElementPreferences *const windowPreferences, const int x, const int y, const uint width, const uint height)
	#define DRAWWINDOW() /*----------------------------------*/ local bool               drawWindow(WindowSystem *const windowSystem, const WindowInfo *const windowInfo, const ElementPreferences *const windowPreferences, Monitor *const monitor, ElementRectangle *windowRectangle)
	#define UNMAPWINDOWS() /*--------------------------------*/ local bool               unmapWindows(WindowSystem *const windowSystem)
	#define DESTROYWINDOWS() /*------------------------------*/ local bool               destroyWindows(WindowSystem *const windowSystem)
	#define GETRECTANGLE() /*--------------------------------*/ local bool               getRectangle(Monitor *const _monitor, const ElementRectangle *const parentRectangle, const ElementPreferences *const preferences, ElementRectangle *const rectangle)
	#define GETTYPEDNUMBER() /*------------------------------*/ local int                getTypedNumber(const int number, const uint8 type, const uint8 axis, const int size, Monitor *const monitor)
	#define FINDWINDOW() /*----------------------------------*/ local bool               findWindow(WindowSystem *const windowSystem, const xcb_window_t window)
	#define FINIWINDOWSYSTEM() /*----------------------------*/ local bool               finiWindowSystem(WindowSystem *const windowSystem)

	#define INITVISUALBUFFERSYSTEM() /*----------------------*/ local bool               initVisualBufferSystem(VisualBufferSystem *const visualBufferSystem)
	#define SETVISUALBUFFERCOMMAND() /*----------------------*/ local bool               setVisualBufferCommand(VisualBufferSystem *const visualBufferSystem, char *const commandStart, const uint32 commandToken)
	#define SETVISUALBUFFERFONT() /*-------------------------*/ local bool               setVisualBufferFont(VisualBufferSystem *const visualBufferSystem, const char *const fontStart)
	#define CREATEVISUALBUFFER() /*--------------------------*/ local bool               createVisualBuffer(VisualBufferSystem *const visualBufferSystem, const uint width, const uint height)
	#define DRAWVISUALBUFFER() /*----------------------------*/ local bool               drawVisualBuffer(VisualBufferSystem *const visualBufferSystem, ElementPreferences *const textPreferences, const uint8 textRotation)
	#define FINIVISUALBUFFERSYSTEM() /*----------------------*/ local bool               finiVisualBufferSystem(VisualBufferSystem *const visualBufferSystem)

	#define INITTRAYSYSTEM() /*------------------------------*/ local bool               initTraySystem(TraySystem *const traySystem)
	#define SETTRAYPARENT() /*-------------------------------*/ local bool               setTrayParent(TraySystem *const traySystem, const xcb_window_t parent)
	#define SETTRAYPOSITION() /*-----------------------------*/ local bool               setTrayPosition(TraySystem *const traySystem, const uint8 position)
	#define SETTRAYWINDOWX() /*------------------------------*/ local bool               setTrayWindowX(TraySystem *const traySystem, const int x)
	#define SETTRAYWINDOWY() /*------------------------------*/ local bool               setTrayWindowY(TraySystem *const traySystem, const int y)
	#define SETTRAYWINDOWXOFFSET() /*------------------------*/ local bool               setTrayWindowXOffset(TraySystem *const traySystem, const int xOffset)
	#define SETTRAYWINDOWYOFFSET() /*------------------------*/ local bool               setTrayWindowYOffset(TraySystem *const traySystem, const int yOffset)
	#define SETTRAYWINDOWBACKGROUND() /*---------------------*/ local bool               setTrayWindowBackground(TraySystem *const traySystem, const uint background)
	#define SETTRAYICONWINDOWXOFFSET() /*--------------------*/ local bool               setTrayIconWindowXOffset(TraySystem *const traySystem, const int xOffset)
	#define SETTRAYICONWINDOWYOFFSET() /*--------------------*/ local bool               setTrayIconWindowYOffset(TraySystem *const traySystem, const int yOffset)
	#define SETTRAYICONWINDOWSIZE() /*-----------------------*/ local bool               setTrayIconWindowSize(TraySystem *const traySystem, const uint size)
	#define SETTRAYICONWINDOWPADDING() /*--------------------*/ local bool               setTrayIconWindowPadding(TraySystem *const traySystem, const int padding)
	#define REPOSITIONTRAYICONS() /*-------------------------*/ local bool               repositionTrayIcons(TraySystem *const traySystem)
	#define ACQUIRETRAYSELECTION() /*------------------------*/ local bool               acquireTraySelection(TraySystem *const traySystem)
	#define CHANGETRAYORIENTATIONPROPERTY() /*---------------*/ local bool               changeTrayOrientationProperty(TraySystem *const traySystem)
	#define ADDTRAYICON() /*---------------------------------*/ local bool               addTrayIcon(TraySystem *const traySystem, const xcb_window_t window, const uint32 version)
	#define MAPTRAYICON() /*---------------------------------*/ local bool               mapTrayIcon(TraySystem *const traySystem, TrayIcon *const trayIcon)
	#define UNMAPTRAYICON() /*-------------------------------*/ local TrayIcon *         unmapTrayIcon(TraySystem *const traySystem, TrayIcon *const trayIcon)
	#define REMOVETRAYICON() /*------------------------------*/ local bool               removeTrayIcon(TraySystem *const traySystem, TrayIcon *const trayIcon)
	#define LOSETRAYSELECTION() /*---------------------------*/ local bool               loseTraySelection(TraySystem *const traySystem)
	#define FINDTRAYICONWINDOW() /*--------------------------*/ local TrayIcon *         findTrayIconWindow(TraySystem *const traySystem, const xcb_window_t window)
	#define FINITRAYSYSTEM() /*------------------------------*/ local bool               finiTraySystem(TraySystem *const traySystem)

	#define SETCONFIGVARIABLES() /*--------------------------*/ local void               setConfigVariables(void)
	#define READCONFIG() /*----------------------------------*/ local void               readConfig(const bool createConfigFile, const char *const configPath, int (*getNextConfigChar)(void *const arg), int (*getPreviousConfigChar)(void *const arg))
	#define IFGETC() /*--------------------------------------*/ local int                ifgetc(void *const system)
	#define MATCHNAMELIST() /*-------------------------------*/ local uint8              matchNameList(StringTreeSystem *const stringTreeSystem, const char *const statementWall, char **statementCurrentReturn, uint8 *const valueReturn)
	#define MATCHINTEGER() /*--------------------------------*/ local uint8              matchInteger(char **statementCurrent, const char *const statementWall, int64 *const returnValue)
	#define MATCHSTRING() /*---------------------------------*/ local bool               matchString(char **statementCurrent, char **stringReturn, uint32 *stringToken)
	#define MATCHIMAGE() /*----------------------------------*/ local uint8              matchImage(const char *const path, const char **errorMessage, Image *const image)
	#define MATCHANSISEQUENCE() /*---------------------------*/ local uint16 *           matchANSISequence(uint16 *const string, ANSIAttributes attributesInUse, ANSIAttributes *const attributesReturn)
	#define MATCHCOMMAND() /*--------------------------------*/ local uint8              matchCommand(const Command command, const char *const execute, const uint8 origin, const int32 field0, const int32 field1, const int32 field2, const int32 field3, const int32 field4)
	#define FREECONFIGVARIABLES() /*-------------------------*/ local void               freeConfigVariables(void)

	#define CREATECIRCLE() /*--------------------------------*/ local bool               createCircle(const int radius, const uint32 foreground, const uint32 background, Image *image)
	#define COMPOSITEIMAGES() /*-----------------------------*/ local void               compositeImages(void (*operation)(const uint32 *const, uint32 *const), const int sourceX, const int sourceY, Image *const source, int destinationX, int destinationY, Image *const destination)
	#define COMPOSITEIMAGESOVER() /*-------------------------*/ local void               compositeImagesOver(const uint32 *const source, uint32 *const destination)
	#define COMPOSITEIMAGESAND() /*--------------------------*/ local void               compositeImagesAnd(const uint32 *const source, uint32 *const destination)
	#define TWOPASSBOXBLUR() /*------------------------------*/ local void               twoPassBoxBlur(const int width, const int height, const int boxSize, uint32 *destinationData)
	#define ROTATEIMAGE() /*---------------------------------*/ local bool               rotateImage(const uint8 rotation, Image *const image, const bool deletePreviousData)

	#define XCB_SYNC() /*------------------------------------*/ local bool               xcb_sync(void)
	#define GETWINDOWCLASS() /*------------------------------*/ local uint8              getWindowClass(xcb_window_t window)
	#define GETFOCUSEDWINDOW() /*----------------------------*/ local xcb_window_t       getFocusedWindow(void)

	#define RESTART() /*-------------------------------------*/ local void               restart(const bool isInsideConfig)
	#define CLEANUP() /*-------------------------------------*/ local void               cleanup(void)
	#define CANCELTHREADS() /*-------------------------------*/ local void               cancelThreads(void)

	#define PRINTUNACCOUNTEDFORPOINTERS() /*-----------------*/ local void               printUnaccountedForPointers(const Pointer *current, const Pointer *wall)
	#define PRINTERROR() /*----------------------------------*/ local void               printError(const char *const message, ...)
	#define PRINTTITLEDERROR() /*----------------------------*/ local void               printTitledError(const char *const title, const char *const message)
	#define PRINTTITLEDQUOTEDERROR() /*----------------------*/ local void               printTitledQuotedError(const char *const title, const char *const argument, const char *const message)
	#define PRINTCONNECTIONERROR() /*------------------------*/ local void               printConnectionError(void)
	#define PRINTTITLEDNAMEDERROR() /*-----------------------*/ local void               printTitledNamedError(const char *const title, const char *const message, const char *const name)
	#define PRINTXERROR() /*---------------------------------*/ local void               printXError(const char *const *const name)
	#define PRINTTITLEDVALUEDERROR() /*----------------------*/ local void               printTitledValuedError(const char *const title, const char *const message, const uint value)
	#define PRINTCONFIGERROR() /*----------------------------*/ local void               printConfigError(const char *const type, const char *const message, const char finalStatementCharacter, const bool printLine, const bool printConfig, const bool printPointer, const bool printPattern, const char *const configPath, const uint statementLine, const char *const statementStart, const char *const statementWall, const Instruction *instructionStart, const Instruction *instructionCurrent, StringTreeSystem *const *const instructionDataStart, const char *const *currentScopeInstructionList, const StringTreeSystem *const currentScopeInstructionStringTreeSystem)

	#if DEBUG
		#define printCommand(s, c) /*---*/ (fprintf(DEFAULT_OUTPUT_STREAM, "%s%s: %s" s " command:%s %s\n", colorStart, programName, colorEvent, colorEnd, *(commandList + (c >= countof(commandList)? countof(commandList) - 1 : c))))
	#else
		#define printCommand(s, c) /*---*/ EMPTY_MACRO
	#endif
/*!}*/

/*!defs:{*/
	def enum ENUM_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	def enum ENUM_CONTENT(GLOBAL_INSTRUCTION);
	def enum ENUM_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	def enum ENUM_CONTENT(BOOLEAN);
	def enum ENUM_CONTENT(VARIABLE);
	def enum ENUM_CONTENT(COMMAND);
	def enum ENUM_CONTENT(MODIFIER);
	def enum ENUM_CONTENT(SHORTCUT_STATE);
	def enum ENUM_CONTENT(NUMBER_TYPE);
	def enum ENUM_CONTENT(POSITION);
	def enum ENUM_CONTENT(HORIZONTAL_ALIGNMENT);
	def enum ENUM_CONTENT(VERTICAL_ALIGNMENT);
	def enum ENUM_CONTENT(CORNER);
	def enum ENUM_CONTENT(AXIS);
	def enum ENUM_CONTENT(WHICH_MONITOR);
	def enum ENUM_CONTENT(ROTATION);
	def enum ENUM_CONTENT(MACRO);

	def struct{
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		int32 /*---------------*/ xOffset;
		int32 /*---------------*/ yOffset;
		int32 /*---------------*/ width;
		int32 /*---------------*/ height;
		int32 /*---------------*/ padding;
		int32 /*---------------*/ margin;
		uint8 /*---------------*/ xType;
		uint8 /*---------------*/ yType;
		uint8 /*---------------*/ xOffsetType;
		uint8 /*---------------*/ yOffsetType;
		uint8 /*---------------*/ widthType;
		uint8 /*---------------*/ heightType;
		uint8 /*---------------*/ paddingType;
		uint8 /*---------------*/ marginType;
		uint8 /*---------------*/ position;
		uint8 /*---------------*/ horizontalAlignment;
		uint8 /*---------------*/ verticalAlignment;
		uint8 /*---------------*/ pad0[3];
		bool /*----------------*/ clipChildren;
		uint8 /*---------------*/ cornerUsed;
		uint32 /*--------------*/ cornerRadius;
		uint32 /*--------------*/ foreground;
		uint32 /*--------------*/ background;
		uint32 /*--------------*/ selectedForeground;
		uint32 /*--------------*/ selectedBackground;
	} ElementPreferences;

	def struct{
		xcb_window_t /*--------*/ window;
		xcb_pixmap_t /*--------*/ bufferPixmap;
		xcb_pixmap_t /*--------*/ pixmap;
		xcb_gcontext_t /*------*/ gc;
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
		bool /*----------------*/ mapped;
		uint8 /*---------------*/ pad0[3];
	} WindowInfo;

	def struct{
		xcb_pixmap_t /*--------*/ circlePixmap;
		uint32 /*--------------*/ windowInfoSize;
		WindowInfo * /*--------*/ windowInfoStart;
		uint32 /*--------------*/ windowInfoToken;
		bool /*----------------*/ mapped;
		uint8 /*---------------*/ pad0[3];
	} WindowSystem;

	def struct{
		Monitor * /*-----------*/ monitor;
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
		uint32 /*--------------*/ horizontalPadding;
		uint32 /*--------------*/ verticalPadding;
		uint32 /*--------------*/ horizontalMargin;
		uint32 /*--------------*/ verticalMargin;
	} ElementRectangle;

	def struct{
		uint32 /*--------------*/ foreground;
		uint32 /*--------------*/ background;
	} ANSIAttributes;

	def struct{
		uint32 /*--------------*/ length;
		ANSIAttributes /*------*/ attributes;
	} TextSegment;

	def struct{
		char * /*--------------*/ commandStart;
		uint32 /*--------------*/ commandToken;
		xcb_pixmap_t /*--------*/ pixmap;
		xcb_pixmap_t /*--------*/ gc;
		xcb_font_t /*----------*/ font;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
	} VisualBufferSystem;

	def struct{
		xcb_window_t /*--------*/ window;
		uint32 /*--------------*/ version;
		bool /*----------------*/ mapped;
		uint8 /*---------------*/ pad0[3];
	} TrayIcon;

	def struct{
		xcb_window_t /*--------*/ window;
		uint32 /*--------------*/ id;
		uint32 /*--------------*/ length;
		uint32 /*--------------*/ timeout;
	} TrayIconMessage;

	def struct{
		xcb_window_t /*--------*/ parent;
		xcb_window_t /*--------*/ window;
		int32 /*---------------*/ windowX;
		int32 /*---------------*/ windowY;
		int32 /*---------------*/ windowXOffset;
		int32 /*---------------*/ windowYOffset;
		uint32 /*--------------*/ windowWidth;
		uint32 /*--------------*/ windowHeight;
		uint32 /*--------------*/ windowBackground;
		xcb_window_t /*--------*/ selectionWindow;
		xcb_timestamp_t /*-----*/ selectionTimestamp;
		bool /*----------------*/ isManager;
		bool /*----------------*/ mapped;
		uint8 /*---------------*/ position;
		uint8 /*---------------*/ pad0[1];
		int32 /*---------------*/ iconWindowXOffset;
		int32 /*---------------*/ iconWindowYOffset;
		uint32 /*--------------*/ iconWindowSize;
		int32 /*---------------*/ iconWindowPadding;
		uint32 /*--------------*/ iconSize;
		uint32 /*--------------*/ iconAllocated;
		TrayIcon * /*----------*/ iconStart;
		uint32 /*--------------*/ iconToken;
		uint32 /*--------------*/ iconMappedAmount;
		TrayIconMessage * /*---*/ iconMessageStart;
		uint32 /*--------------*/ iconMessageToken;
		uint32 /*--------------*/ iconMessageSize;
	} TraySystem;

	def struct{
		bool /*----------------*/ (*risingOperation)(void *const arg);
		void * /*--------------*/ risingOperationArgument;
		bool /*----------------*/ (*fallingOperation)(void *const arg);
		void * /*--------------*/ fallingOperationArgument;
		uint32 /*--------------*/ seconds;
		uint32 /*--------------*/ nanoseconds;
		bool /*----------------*/ loopOperation;
		bool /*----------------*/ restartTimer;
		uint8 /*---------------*/ pad0[1];
		bool /*----------------*/ running;
		bool /*----------------*/ quittingThread;
		bool /*----------------*/ mutexCreated;
		bool /*----------------*/ condCreated;
		bool /*----------------*/ threadCreated;
		pthread_mutex_t /*-----*/ mutex;
		pthread_cond_t /*------*/ cond;
		pthread_t /*-----------*/ thread;
	} SleepThreadSystem;

	def struct{
		uint8 /*---------------*/ letter;
		uint8 /*---------------*/ childrenAmount;
		uint16 /*--------------*/ offset[STRING_TREE_NODE_CHILDREN_AMOUNT];
	} StringTreeNode;

	def struct{
		const char *const * /*-*/ stringArray;
		uint32 /*--------------*/ dataSize;
		uint32 /*--------------*/ dataAllocated;
		StringTreeNode * /*----*/ dataStart;
		uint32 /*--------------*/ dataToken;
		uint8 /*---------------*/ counter;
		uint8 /*---------------*/ returnedCounter;
		uint8 /*---------------*/ pad0[2];
	} StringTreeSystem;

	def struct{
		uint32 /*--------------*/ size;
		uint32 /*--------------*/ allocated;
		char * /*--------------*/ start;
		char * /*--------------*/ current;
		uint32 /*--------------*/ token;
		uint8 /*---------------*/ pad0[1];
		bool /*----------------*/ threadCreated;
		bool /*----------------*/ operating;
		bool /*----------------*/ quittingThread;
		pthread_t /*-----------*/ thread;
	} STDINSystem;

	def struct{
		int32 /*---------------*/ shmID;
		uint32 /*--------------*/ shmToken;
		uint8 * /*-------------*/ start;
		uint8 * /*-------------*/ current;
		uint32 /*--------------*/ token;
		uint8 /*---------------*/ pad0[6];
		bool /*----------------*/ mutexCreated;
		bool /*----------------*/ condCreated;
		bool /*----------------*/ threadCreated;
		bool /*----------------*/ operating;
		bool /*----------------*/ quittingFromInside;
		bool /*----------------*/ quittingThread;
		pthread_mutex_t * /*---*/ mutex;
		pthread_cond_t * /*----*/ cond;
		pthread_t /*-----------*/ thread;
	} SharedMemorySystem;
/*!}*/

/*!globals:{*/
	local const char * /*-------------------*/ programName;
	local const char * /*-------------------*/ errorPath;
	local const char * /*-------------------*/ colorStart;
	local const char * /*-------------------*/ colorFatal;
	local const char * /*-------------------*/ colorError;
	local const char * /*-------------------*/ colorEvent;
	local const char * /*-------------------*/ colorEnd;
	local const char * /*-------------------*/ labelExamined;
	local const char * /*-------------------*/ connectionName;
	local const char * /*-------------------*/ configPath;
	local const char * /*-------------------*/ localeName;
	local const ModifierNode * /*-----------*/ eventModifierNode;
	local bool /*---------------------------*/ mustOpenErrorStream;
	local FILE * /*-------------------------*/ errorStream;
	local uint32 /*-------------------------*/ errorStreamToken;
	local volatile bool /*------------------*/ processingSignal;
	local bool /*---------------------------*/ quitting;
	local MemoryManagementSystem /*------------*/ memoryManagementSystem;
	local PermissionSystem /*---------------*/ permissionSystem;
	local bool /*---------------------------*/ globalsLockCreated;
	local pthread_rwlock_t /*---------------*/ globalsLock;
	local int /*----------------------------*/ screenNumber;
	local xcb_connection_t * /*-------------*/ connection;
	local uint32 /*-------------------------*/ connectionToken;
	local xcb_screen_t * /*-----------------*/ screen;
	local uint /*---------------------------*/ screenWidthInPixels;
	local uint /*---------------------------*/ screenHeightInPixels;
	local uint /*---------------------------*/ screenWidthInMillimeters;
	local uint /*---------------------------*/ screenHeightInMillimeters;
	local uint8 /*--------------------------*/ randrMajorOpcode;
	local uint8 /*--------------------------*/ randrBaseEvent;
	local uint8 /*--------------------------*/ randrBaseError;
	local uint8 /*--------------------------*/ xfixesMajorOpcode;
	local uint8 /*--------------------------*/ xfixesBaseEvent;
	local uint8 /*--------------------------*/ xfixesBaseError;
	local CommonAtoms /*--------------------*/ atom;
	local xcb_visualid_t /*-----------------*/ visual;
	local uint8 /*--------------------------*/ depth;
	local xcb_colormap_t /*-----------------*/ colormap;
	local MonitorSystem /*------------------*/ monitorSystem;
	local VisualBufferSystem /*-------------*/ visualBufferSystem1;
	local VisualBufferSystem /*-------------*/ visualBufferSystem2;
	local VisualBufferSystem /*-------------*/ visualBufferSystem3;
	local ElementPreferences /*-------------*/ windowPreferences;
	local ElementPreferences /*-------------*/ textPreferences1;
	local uint8 /*--------------------------*/ textRotation1;
	local ElementPreferences /*-------------*/ textPreferences2;
	local uint8 /*--------------------------*/ textRotation2;
	local ElementPreferences /*-------------*/ textPreferences3;
	local uint8 /*--------------------------*/ textRotation3;
	local uint8 /*--------------------------*/ whichMonitor;
	local WindowSystem /*-------------------*/ windowSystem;
	local TraySystem /*---------------------*/ traySystem;
	local SleepThreadSystem /*--------------*/ sleepThreadSystem;
	local StringTreeSystem /*---------------*/ globalScopesInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ globalInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ scope1ScopeInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ booleanStringTreeSystem;
	local StringTreeSystem /*---------------*/ variableStringTreeSystem;
	local StringTreeSystem /*---------------*/ commandStringTreeSystem;
	local StringTreeSystem /*---------------*/ modifierStringTreeSystem;
	local StringTreeSystem /*---------------*/ shortcutStateStringTreeSystem;
	local StringTreeSystem /*---------------*/ numberTypeStringTreeSystem;
	local StringTreeSystem /*---------------*/ positionStringTreeSystem;
	local StringTreeSystem /*---------------*/ horizontalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ verticalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ cornerStringTreeSystem;
	local StringTreeSystem /*---------------*/ whichMonitorStringTreeSystem;
	local StringTreeSystem /*---------------*/ rotationStringTreeSystem;
	local StringTreeSystem /*---------------*/ macroStringTreeSystem;
	local bool /*---------------------------*/ displaySimpleConfigErrors;
	local STDINSystem /*--------------------*/ stdinSystem;
	local SharedMemorySystem /*-------------*/ sharedMemorySystem;
	local ShortcutSystem /*-----------------*/ keycodeShortcutSystem;
	local ShortcutSystem /*-----------------*/ buttonShortcutSystem;
	local xcb_generic_event_t * /*----------*/ event;
	local uint32 /*-------------------------*/ eventToken;
	local int /*----------------------------*/ keyPressNextOffset;
	local int /*----------------------------*/ keyReleaseNextOffset;
	local int /*----------------------------*/ buttonPressNextOffset;
	local int /*----------------------------*/ buttonReleaseNextOffset;
	local uint8 /*--------------------------*/ shortcutCode;
	local uint16 /*-------------------------*/ shortcutModifier;
	local bool /*---------------------------*/ expectingSecondKeyRelease;
	local uint8 /*--------------------------*/ realKeyReleaseModifier;

	local const char *const /*--------------*/ globalScopesInstructionList[] = STRING_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	local const char *const /*--------------*/ globalInstructionList[] = STRING_CONTENT(GLOBAL_INSTRUCTION);
	local const char *const /*--------------*/ scope1ScopeInstructionList[] = STRING_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	local const char *const /*--------------*/ booleanList[] = STRING_CONTENT(BOOLEAN);
	local const char *const /*--------------*/ variableList[] = STRING_CONTENT(VARIABLE);
	local const char *const /*--------------*/ commandList[] = STRING_CONTENT(COMMAND);
	local const char *const /*--------------*/ modifierList[] = STRING_CONTENT(MODIFIER);
	local const char *const /*--------------*/ shortcutStateList[] = STRING_CONTENT(SHORTCUT_STATE);
	local const char *const /*--------------*/ numberTypeList[] = STRING_CONTENT(NUMBER_TYPE);
	local const char *const /*--------------*/ positionList[] = STRING_CONTENT(POSITION);
	local const char *const /*--------------*/ horizontalAlignmentList[] = STRING_CONTENT(HORIZONTAL_ALIGNMENT);
	local const char *const /*--------------*/ verticalAlignmentList[] = STRING_CONTENT(VERTICAL_ALIGNMENT);
	local const char *const /*--------------*/ cornerList[] = STRING_CONTENT(CORNER);
	local const char *const /*--------------*/ whichMonitorList[] = STRING_CONTENT(WHICH_MONITOR);
	local const char *const /*--------------*/ rotationList[] = STRING_CONTENT(ROTATION);
	local const char *const /*--------------*/ macroList[] = STRING_CONTENT(MACRO);

	local const Instruction /*--------------*/ helpInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ expandInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ contractInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ readConfigInstruction[] = {STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useTerminalInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useMessengerInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ acquireSystemTrayInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ setInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ doInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ stopInstruction[] = {END_INSTRUCTION_TYPE};

	local const Instruction /*--------------*/ windowXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowWidthSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowHeightSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowPositionSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textX1SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textY1SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textXOffset1SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textYOffset1SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textHorizontalAlignment1SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textVerticalAlignment1SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textRotation1SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textForeground1SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textBackground1SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textX2SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textY2SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textXOffset2SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textYOffset2SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textHorizontalAlignment2SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textVerticalAlignment2SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textRotation2SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textForeground2SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textBackground2SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textX3SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textY3SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textXOffset3SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textYOffset3SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textHorizontalAlignment3SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textVerticalAlignment3SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textRotation3SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textForeground3SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ textBackground3SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ trayWindowXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ trayWindowYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ trayWindowXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ trayWindowYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ trayWindowBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ trayIconXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ trayIconYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ trayIconSizeSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ trayIconPaddingSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ command1SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ command2SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ command3SetSubinstruction[] = {NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ intervalSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ fontSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};

	local StringTreeSystem *const *const /*-*/ helpInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ expandInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ contractInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ readConfigInstructionData = NULL;
	local StringTreeSystem *const /*--------*/ useTerminalInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ useMessengerInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ acquireSystemTrayInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ setInstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ doInstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabKeycodeInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabButtonInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabKeycodeInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabButtonInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const *const /*-*/ stopInstructionData = NULL;

	local StringTreeSystem *const /*--------*/ windowXSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowYSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowXOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowYOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowWidthSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowHeightSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowPositionSetSubinstructionData[] = {&variableStringTreeSystem, &positionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowHorizontalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &horizontalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowVerticalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &verticalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textX1SetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textY1SetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textXOffset1SetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textYOffset1SetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textHorizontalAlignment1SetSubinstructionData[] = {&variableStringTreeSystem, &horizontalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textVerticalAlignment1SetSubinstructionData[] = {&variableStringTreeSystem, &verticalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textRotation1SetSubinstructionData[] = {&variableStringTreeSystem, &rotationStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textForeground1SetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textBackground1SetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textX2SetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textY2SetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textXOffset2SetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textYOffset2SetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textHorizontalAlignment2SetSubinstructionData[] = {&variableStringTreeSystem, &horizontalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textVerticalAlignment2SetSubinstructionData[] = {&variableStringTreeSystem, &verticalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textRotation2SetSubinstructionData[] = {&variableStringTreeSystem, &rotationStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textForeground2SetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textBackground2SetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textX3SetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textY3SetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textXOffset3SetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textYOffset3SetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textHorizontalAlignment3SetSubinstructionData[] = {&variableStringTreeSystem, &horizontalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textVerticalAlignment3SetSubinstructionData[] = {&variableStringTreeSystem, &verticalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textRotation3SetSubinstructionData[] = {&variableStringTreeSystem, &rotationStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textForeground3SetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ textBackground3SetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ trayWindowXSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ trayWindowYSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ trayWindowXOffsetSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ trayWindowYOffsetSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ trayWindowBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ trayIconXOffsetSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ trayIconYOffsetSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ trayIconSizeSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ trayIconPaddingSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ command1SetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ command2SetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ command3SetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ intervalSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ fontSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeDoSubinstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};

	#define getInstruction(i) /*-----*/ (i##Instruction)
	#define getInstructionData(i) /*-*/ (i##InstructionData)
	#define getGlobalScope(i) /*-----*/ { \
		  get##i(help) \
		, get##i(expand) \
		, get##i(contract) \
		, get##i(readConfig) \
		, get##i(useTerminal) \
		, get##i(useMessenger) \
		, get##i(acquireSystemTray) \
		, get##i(set) \
		, get##i(do) \
		, get##i(grabKeycode) \
		, get##i(grabButton) \
		, get##i(ungrabKeycode) \
		, get##i(ungrabButton) \
		, get##i(stop) \
	}
/*!}*/

int main(int argumentAmount, const char *const *argument){
	setGlobals:{
		programName /*---------------*/ = *argument;
		errorPath /*-----------------*/ = NULL;
		colorStart /*----------------*/ = MESSAGE_START;
		colorFatal /*----------------*/ = MESSAGE_FATAL;
		colorError /*----------------*/ = MESSAGE_ERROR;
		colorEvent /*----------------*/ = MESSAGE_EVENT;
		colorEnd /*------------------*/ = MESSAGE_END;
		connectionName /*------------*/ = NULL;
		configPath /*----------------*/ = NULL;
		localeName /*----------------*/ = setlocale(LC_ALL, "");
		mustOpenErrorStream /*-------*/ = false;
		errorStream /*---------------*/ = DEFAULT_ERROR_STREAM;
		errorStreamToken /*----------*/ = 0;
		quitting /*------------------*/ = false;
		connection /*----------------*/ = NULL;
		connectionToken /*-----------*/ = 0;
		event /*---------------------*/ = NULL;
		eventToken /*----------------*/ = 0;
		keyPressNextOffset /*--------*/ = 0;
		keyReleaseNextOffset /*------*/ = 0;
		buttonPressNextOffset /*-----*/ = 0;
		buttonReleaseNextOffset /*---*/ = 0;
		shortcutCode /*--------------*/ = 0;
		shortcutModifier /*----------*/ = XCB_NONE;
		expectingSecondKeyRelease /*-*/ = false;
		initMemorySystem();
		initPermissionSystem(&permissionSystem);
		initMonitorSystem(&monitorSystem);
		initWindowSystem(&windowSystem);
		initVisualBufferSystem(&visualBufferSystem1);
		initVisualBufferSystem(&visualBufferSystem2);
		initVisualBufferSystem(&visualBufferSystem3);
		initTraySystem(&traySystem);
		initSleepThreadSystem(&sleepThreadSystem);
		initStringTreeSystem(&globalScopesInstructionStringTreeSystem);
		initStringTreeSystem(&globalInstructionStringTreeSystem);
		initStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
		initStringTreeSystem(&booleanStringTreeSystem);
		initStringTreeSystem(&variableStringTreeSystem);
		initStringTreeSystem(&commandStringTreeSystem);
		initStringTreeSystem(&modifierStringTreeSystem);
		initStringTreeSystem(&shortcutStateStringTreeSystem);
		initStringTreeSystem(&numberTypeStringTreeSystem);
		initStringTreeSystem(&positionStringTreeSystem);
		initStringTreeSystem(&horizontalAlignmentStringTreeSystem);
		initStringTreeSystem(&verticalAlignmentStringTreeSystem);
		initStringTreeSystem(&cornerStringTreeSystem);
		initStringTreeSystem(&whichMonitorStringTreeSystem);
		initStringTreeSystem(&rotationStringTreeSystem);
		initStringTreeSystem(&macroStringTreeSystem);
		initSTDINSystem(&stdinSystem);
		initSharedMemorySystem(&sharedMemorySystem);
		initShortcutSystem(&keycodeShortcutSystem);
		initShortcutSystem(&buttonShortcutSystem);
		setConfigVariables();
		setPermissions(&permissionSystem);
		lowerPermissions(&permissionSystem);
		processingSignal = false;
		jmp getProgramArguments;
	}
	selectInput:{
		xcb_xfixes_select_selection_input(connection, (*screen).root, atom._NET_SYSTEM_TRAY_Sn, XCB_XFIXES_SELECTION_EVENT_MASK_SET_SELECTION_OWNER | XCB_XFIXES_SELECTION_EVENT_MASK_SELECTION_WINDOW_DESTROY | XCB_XFIXES_SELECTION_EVENT_MASK_SELECTION_CLIENT_CLOSE);
		xcb_flush(connection);
		jmp setupScreenProfile;
	}
	initSystems:{
		if(createMonitors(&monitorSystem)){
			createVisualBuffer(&visualBufferSystem1, screenWidthInPixels, screenHeightInPixels);
			createVisualBuffer(&visualBufferSystem2, screenWidthInPixels, screenHeightInPixels);
			createVisualBuffer(&visualBufferSystem3, screenWidthInPixels, screenHeightInPixels);
			if(createWindows(&windowSystem, monitorSystem.size, false, XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY)){
				setSleepThreadOperation(&sleepThreadSystem, &updateWindows, NULL, NULL, NULL, true, false);
				bootSleepThread(&sleepThreadSystem);
			}
		}
		bulkInsertString(&globalScopesInstructionStringTreeSystem, globalScopesInstructionList);
		bulkInsertString(&globalInstructionStringTreeSystem, globalInstructionList);
		bulkInsertString(&scope1ScopeInstructionStringTreeSystem, scope1ScopeInstructionList);
		bulkInsertString(&booleanStringTreeSystem, booleanList);
		bulkInsertString(&variableStringTreeSystem, variableList);
		bulkInsertString(&commandStringTreeSystem, commandList);
		bulkInsertString(&modifierStringTreeSystem, modifierList);
		bulkInsertString(&shortcutStateStringTreeSystem, shortcutStateList);
		bulkInsertString(&numberTypeStringTreeSystem, numberTypeList);
		bulkInsertString(&positionStringTreeSystem, positionList);
		bulkInsertString(&horizontalAlignmentStringTreeSystem, horizontalAlignmentList);
		bulkInsertString(&verticalAlignmentStringTreeSystem, verticalAlignmentList);
		bulkInsertString(&cornerStringTreeSystem, cornerList);
		bulkInsertString(&whichMonitorStringTreeSystem, whichMonitorList);
		bulkInsertString(&rotationStringTreeSystem, rotationList);
		bulkInsertString(&macroStringTreeSystem, macroList);
		jmp readConfig;
	}
	switchEvent:{
		#define XCB_ONE /*-*/ (1)
		if(((*event).response_type & ~b(10000000)) > XCB_NONE and ((*event).response_type & ~b(10000000)) < XCB_GE_GENERIC){
			printXEvent(baseEventName);
		}
		switch (*event).response_type & ~b(10000000) over
			to XCB_NONE: /*--------------*/ jmp errorEvent;
			to XCB_ONE: /*---------------*/ jmp unrecognizedEvent;
			to XCB_KEY_PRESS: /*---------*/ jmp keyPressEvent;
			to XCB_KEY_RELEASE: /*-------*/ jmp keyReleaseEvent;
			to XCB_BUTTON_PRESS: /*------*/ jmp buttonPressEvent;
			to XCB_BUTTON_RELEASE: /*----*/ jmp buttonReleaseEvent;
			to XCB_MOTION_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_ENTER_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_LEAVE_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*----------*/ jmp unexpectedEvent;
			to XCB_FOCUS_OUT: /*---------*/ jmp unexpectedEvent;
			to XCB_KEYMAP_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*-*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*-------*/ jmp unexpectedEvent;
			to XCB_VISIBILITY_NOTIFY: /*-*/ jmp unexpectedEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ jmp destroyNotifyEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ jmp unmapNotifyEvent;
			to XCB_MAP_NOTIFY: /*--------*/ jmp mapNotifyEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp mapRequestEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ jmp reparentNotifyEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ jmp eventLoop;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp eventLoop;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ jmp eventLoop;
			to XCB_SELECTION_CLEAR: /*---*/ jmp selectionClearEvent;
			to XCB_SELECTION_REQUEST: /*-*/ jmp eventLoop;
			to XCB_SELECTION_NOTIFY: /*--*/ jmp eventLoop;
			to XCB_COLORMAP_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CLIENT_MESSAGE: /*----*/ jmp clientMessageEvent;
			to XCB_MAPPING_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*--------*/ jmp genericEvent;
			off: /*----------------------*/ jmp extensionEvent;
		end
		#undef  XCB_ONE
	}
	keyReleaseEvent:{
		#define e /*-*/ ((xcb_key_release_event_t *)event)
		uint8 keycode = (*e).detail;
		uint16 modifier = (*e).state & b(11111111);
		if(getNextShortcut(&keycodeShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &keyReleaseNextOffset)){
			xcb_query_keymap_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_keymap_unchecked(connection), NULL);
			uint32 token = pushPointer(reply, "query keymap reply", iFree);
			if(reply){
				const bool keyIsPressed = !!(*((*reply).keys + (*e).detail / 8) & (1 << (*e).detail % 8));
				free(reply);
				popPointer(token);
				if(keyIsPressed){
					keyReleaseNextOffset = 0;
					jmp eventLoop;
				}
			}
			jmp matchCommandRelease;
		}
		if(keycode != shortcutCode and modifier == shortcutModifier){
			expectingSecondKeyRelease = true;
			realKeyReleaseModifier = shortcutModifier;
			jmp eventLoop;
		}
		if(keycode == shortcutCode and modifier != shortcutModifier){
			if(!expectingSecondKeyRelease){
				jmp eventLoop;
			}
			keycode = shortcutCode;
			modifier = realKeyReleaseModifier;
			expectingSecondKeyRelease = false;
			keyReleaseNextOffset = 0;
			if(getNextShortcut(&keycodeShortcutSystem, true, keycode, modifier, &keyReleaseNextOffset)){
				jmp matchCommandRelease;
			}
		}
		jmp eventLoop;
		#undef  e
	}
	buttonPressEvent:{
		#define e /*-*/ ((xcb_button_press_event_t *)event)
		if(getNextShortcut(&buttonShortcutSystem, false, (*e).detail, (*e).state & b(11111111), &buttonPressNextOffset)){
			jmp matchCommandPress;
		}
		jmp eventLoop;
		#undef  e
	}
	buttonReleaseEvent:{
		#define e /*-*/ ((xcb_button_release_event_t *)event)
		if(getNextShortcut(&buttonShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &buttonReleaseNextOffset)){
			jmp matchCommandRelease;
		}
		jmp eventLoop;
		#undef  e
	}
	{
		uint8 commandOrigin;
		matchCommandPress:{
			commandOrigin = PRESS_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommandRelease:{
			commandOrigin = RELEASE_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommand: switch matchCommand((*eventModifierNode).command, (*eventModifierNode).string, commandOrigin, (*eventModifierNode).field0, (*eventModifierNode).field1, (*eventModifierNode).field2, (*eventModifierNode).field3, (*eventModifierNode).field4) over
			to TYPICAL_MATCH_COMMAND_TYPE:{
				jmp eventLoopCheckShortcuts;
			}
			to RESTART_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp readConfig;
			}
			to EXIT_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp mainEmergencyExit;
			}
			off:{
				jmp eventLoopCheckShortcuts;
			}
		end
	}
	destroyNotifyEvent:{
		#define e /*-*/ ((xcb_destroy_notify_event_t *)event)
		removeTrayIcon(&traySystem, findTrayIconWindow(&traySystem, (*e).window));
		jmp eventLoop;
		#undef  e
	}
	unmapNotifyEvent:{
		#define e /*-*/ ((xcb_unmap_notify_event_t *)event)
		unmapTrayIcon(&traySystem, findTrayIconWindow(&traySystem, (*e).window));
		jmp eventLoop;
		#undef  e
	}
	mapNotifyEvent:{
		#define e /*-*/ ((xcb_map_notify_event_t *)event)
		mapTrayIcon(&traySystem, findTrayIconWindow(&traySystem, (*e).window));
		jmp eventLoop;
		#undef  e
	}
	mapRequestEvent:{
		#define e /*-*/ ((xcb_map_request_event_t *)event)
		mapTrayIcon(&traySystem, findTrayIconWindow(&traySystem, (*e).window));
		jmp eventLoop;
		#undef  e
	}
	reparentNotifyEvent:{
		#define e /*-*/ ((xcb_reparent_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		TrayIcon *trayIcon;
		if((trayIcon = findTrayIconWindow(&traySystem, eventWindow))){
			if((*e).parent != traySystem.window){
				removeTrayIcon(&traySystem, trayIcon);
				jmp eventLoop;
			}
			mapTrayIcon(&traySystem, trayIcon);
			jmp eventLoop;
		}
		if((*e).parent == traySystem.window){
			if(addTrayIcon(&traySystem, eventWindow, 0)){
				mapTrayIcon(&traySystem, findTrayIconWindow(&traySystem, eventWindow));
			}
		}
		jmp eventLoop;
		#undef  e
	}
	selectionClearEvent:{
		#define e /*-*/ ((xcb_selection_clear_event_t *)event)
		if((*e).selection == atom._NET_SYSTEM_TRAY_Sn){
			loseTraySelection(&traySystem);
		}
		jmp eventLoop;
		#undef  e
	}
	clientMessageEvent:{
		#define e /*-*/ ((xcb_client_message_event_t *)event)
		const xcb_atom_t type = (*e).type;
		const xcb_window_t eventWindow = (*e).window;
		if(eventWindow == traySystem.selectionWindow){
			if(type == atom._NET_SYSTEM_TRAY_OPCODE){
				if(traySystem.isManager){
					const uint32 *const data = (*e).data.data32;
					const uint8 systemTrayOperation = *(data + 1);
					const xcb_window_t window = *(data + 2);
					switch systemTrayOperation over
						to SYSTEM_TRAY_REQUEST_DOCK:{
							xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property(connection, false, window, atom._XEMBED_INFO, XCB_GET_PROPERTY_TYPE_ANY, 0, 0xFFFFFFFF), NULL);
							uint32 token = pushPointer(reply, "get property reply", iFree);
							if(reply){
								if(xcb_get_property_value_length(reply) == 2 * sizeof(uint32)){
									uint32 *value = xcb_get_property_value(reply);
									uint32 version = *(value + 0);
									addTrayIcon(&traySystem, window, version);
								}
								free(reply);
								popPointer(token);
							}
							jmp eventLoop;
						}
						to SYSTEM_TRAY_BEGIN_MESSAGE:{
							jmp eventLoop;
						}
						to SYSTEM_TRAY_CANCEL_MESSAGE:{
							jmp eventLoop;
						}
						off:{
							jmp eventLoop;
						}
					end
				}
				jmp eventLoop;
			}
			if(type == atom._NET_SYSTEM_TRAY_MESSAGE_DATA){
				jmp eventLoop;
			}
			if(type == atom._XEMBED){
				switch (*e).format over
					to bitsof(uint8):{
						jmp eventLoop;
					}
					to bitsof(uint16):{
						jmp eventLoop;
					}
					to bitsof(uint32):{
						jmp eventLoop;
					}
				end
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  e
	}
	genericEvent:{
		#define e /*-*/ ((xcb_ge_generic_event_t *)event)
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  e
	}
	extensionEvent:{
		#define isExtensionEvent(e) /*-*/ (eventType >= e##BaseEvent and eventType < e##BaseEvent + countof(e##EventName) - 1)
		const uint8 eventType = (*event).response_type & ~b(10000000);
		if(isExtensionEvent(randr)) /*--*/ jmp switchRandrEvent;
		if(isExtensionEvent(xfixes)) /*-*/ jmp switchXfixesEvent;
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  isExtensionEvent
	}
	switchRandrEvent:{
		printXEvent(randrEventName);
		switch ((*event).response_type & ~b(10000000)) - randrBaseEvent over
			to XCB_RANDR_SCREEN_CHANGE_NOTIFY:
			to XCB_RANDR_NOTIFY:{
				quitSleepThread(&sleepThreadSystem);
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
					printTitledError("pthread error", "could not lock globals write lock");
				}
				{
					int screenNumber;
					xcb_connection_t *const connection = xcb_connect_to_display_with_auth_info(connectionName, NULL, &screenNumber);
					uint32 token = pushPointer(connection, "X connection", iXCBDisconnect);
					if(connection){
						xcb_screen_t *const screen = xcb_setup_roots_iterator(xcb_get_setup(connection)).data + screenNumber;
						if(screen){
							screenWidthInPixels = (*screen).width_in_pixels;
							screenHeightInPixels = (*screen).height_in_pixels;
							screenWidthInMillimeters = (*screen).width_in_millimeters;
							screenHeightInMillimeters = (*screen).height_in_millimeters;
						}else{
							screenWidthInPixels = 0;
							screenHeightInPixels = 0;
							screenWidthInMillimeters = 0;
							screenHeightInMillimeters = 0;
						}
						xcb_disconnect(connection);
						popPointer(token);
					}
				}
				if(createMonitors(&monitorSystem)){
					const bool mapped = windowSystem.mapped;
					createVisualBuffer(&visualBufferSystem1, screenWidthInPixels, screenHeightInPixels);
					createVisualBuffer(&visualBufferSystem2, screenWidthInPixels, screenHeightInPixels);
					createVisualBuffer(&visualBufferSystem3, screenWidthInPixels, screenHeightInPixels);
					setTrayParent(&traySystem, XCB_NONE);
					if(createWindows(&windowSystem, monitorSystem.size, false, XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY)){
						setTrayParent(&traySystem, (*windowSystem.windowInfoStart).window);
						if(mapped){
							drawVisualBuffer(&visualBufferSystem1, &textPreferences1, textRotation1);
							drawVisualBuffer(&visualBufferSystem2, &textPreferences2, textRotation2);
							drawVisualBuffer(&visualBufferSystem3, &textPreferences3, textRotation3);
							mapWindows(&windowSystem, &monitorSystem, &windowPreferences, whichMonitor);
						}
					}
				}
				bootSleepThread(&sleepThreadSystem);
				jmp signalSleepThreadLoop;
				signalSleepThreadLoop:{
					if(!signalSleepThread(&sleepThreadSystem)){
						jmp signalSleepThreadLoop;
					}
					jmp eventLoop;
				}
			}
			off:{
				jmp unrecognizedEvent;
			}
		end
	}
	switchXfixesEvent:{
		printXEvent(xfixesEventName);
		switch ((*event).response_type & ~b(10000000)) - xfixesBaseEvent over
			to XCB_XFIXES_SELECTION_NOTIFY: /*-*/ jmp eventLoop;
			to XCB_XFIXES_CURSOR_NOTIFY: /*----*/ jmp eventLoop;
			off: /*----------------------------*/ jmp unrecognizedEvent;
		end
	}
	unrecognizedEvent:{
		printTitledValuedError("X event error", "unrecognized event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unexpectedEvent:{
		printTitledValuedError("unexpected X event", "unexpected event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unhandledEvent:{
		printTitledValuedError("X event error", "unhandled event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	mainEmergencyExit:{
		cleanup();
		ret 0;
	}
}
SETWINDOWPROPERTIES(){
	xcb_window_t window;
	uint32 desktop;
	pid_t pid;
	char hostname[256];
	xcb_atom_t type[1];
	xcb_atom_t state[1];
	struct{
		uint32 /*-*/ flags;
		int32 /*--*/ x;
		int32 /*--*/ y;
		int32 /*--*/ width;
		int32 /*--*/ height;
		int32 /*--*/ minWidth;
		int32 /*--*/ minHeight;
		int32 /*--*/ maxWidth;
		int32 /*--*/ maxHeight;
		int32 /*--*/ widthInc;
		int32 /*--*/ heightInc;
		int32 /*--*/ minAspectNumerator;
		int32 /*--*/ minAspectDenominarator;
		int32 /*--*/ maxAspectNumerator;
		int32 /*--*/ maxAspectDenominarator;
		int32 /*--*/ baseWidth;
		int32 /*--*/ baseHeight;
		int32 /*--*/ winGravity;
	} normalHints;
	struct{
		uint32 /*-*/ flags;
		uint32 /*-*/ input;
		uint32 /*-*/ initialState;
	} hints;
	struct{
		uint32 /*-*/ left;
		uint32 /*-*/ right;
		uint32 /*-*/ top;
		uint32 /*-*/ bottom;
		uint32 /*-*/ leftStartY;
		uint32 /*-*/ leftEndY;
		uint32 /*-*/ rightStartY;
		uint32 /*-*/ rightEndY;
		uint32 /*-*/ topStartX;
		uint32 /*-*/ topEndX;
		uint32 /*-*/ bottomStartX;
		uint32 /*-*/ bottomEndX;
	} strut;
	if(!windowInfo or !(*windowInfo).window){
		ret false;
	}
	window = (*windowInfo).window;
	desktop = 0xFFFFFFFF;
	pid = getpid();
	*hostname = '\0';
	if(gethostname(hostname, countof(hostname)) != GETHOSTNAME_SUCCESS){
		printTitledError("get hostname error", "could not get hostname");
	}
	*(type + 0) = atom._NET_WM_WINDOW_TYPE_DOCK;
	*(state + 0) = atom._NET_WM_STATE_STICKY;
	normalHints.flags = USER_POSITION_NORMAL_HINT | USER_SIZE_NORMAL_HINT | PROGRAM_MINIMUM_SIZE_NORMAL_HINT | PROGRAM_MAXIMUM_SIZE_NORMAL_HINT | PROGRAM_RESIZE_INCREMENT_NORMAL_HINT | PROGRAM_ASPECT_NORMAL_HINT | PROGRAM_BASE_SIZE_NORMAL_HINT | PROGRAM_WINDOW_GRAVITY_NORMAL_HINT;
	normalHints.x = x;
	normalHints.y = y;
	normalHints.width = width;
	normalHints.height = height;
	normalHints.minWidth = width;
	normalHints.minHeight = height;
	normalHints.maxWidth = width;
	normalHints.maxHeight = height;
	normalHints.baseWidth = width;
	normalHints.baseHeight = height;
	normalHints.widthInc = 0;
	normalHints.heightInc = 0;
	normalHints.minAspectNumerator = 1;
	normalHints.minAspectDenominarator = 1;
	normalHints.maxAspectNumerator = 1;
	normalHints.maxAspectDenominarator = 1;
	normalHints.winGravity = XCB_GRAVITY_NORTH_WEST;
	hints.flags = INPUT_HINT | STATE_HINT;
	hints.input = false;
	hints.initialState = NORMAL_STATE;
	if((*windowPreferences).position){
		strut.left = 0;
		strut.right = 0;
		strut.top = 0;
		strut.bottom = 0;
		strut.leftStartY = 0;
		strut.leftEndY = 0;
		strut.rightStartY = 0;
		strut.rightEndY = 0;
		strut.topStartX = 0;
		strut.topEndX = 0;
		strut.bottomStartX = 0;
		strut.bottomEndX = 0;
		switch (*windowPreferences).position over
			to TOP_POSITION:{
				strut.top = height;
				strut.topStartX = x;
				strut.topEndX = x + width;
				brk;
			}
			to BOTTOM_POSITION:{
				strut.bottom = height;
				strut.bottomStartX = x;
				strut.bottomEndX = x + width;
				brk;
			}
			to LEFT_POSITION:{
				strut.left = width;
				strut.leftStartY = y;
				strut.leftEndY = y + height;
				brk;
			}
			to RIGHT_POSITION:{
				strut.right = width;
				strut.rightStartY = y;
				strut.rightEndY = y + height;
				brk;
			}
			off:{
				brk;
			}
		end
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_ICON_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_NORMAL_HINTS, atom.WM_SIZE_HINTS, bitsof(uint32), sizeof(normalHints) / sizeof(uint32), &normalHints);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_HINTS, atom.WM_HINTS, bitsof(uint32), sizeof(hints) / sizeof(uint32), &hints);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_CLASS, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME "\0" PROGRAM_NAME "\0"), PROGRAM_NAME "\0" PROGRAM_NAME "\0");
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_CLIENT_MACHINE, XCB_ATOM_STRING, bitsof(uint8), findStringLength(hostname), hostname);
	if(localeName){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_LOCALE_NAME, XCB_ATOM_STRING, bitsof(uint8), findStringLength(localeName), localeName);
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_ICON_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	if(desktop == 0xFFFFFFFF){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_DESKTOP, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &desktop);
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_WINDOW_TYPE, XCB_ATOM_ATOM, bitsof(uint32), countof(type), type);
	if(*state){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STATE, XCB_ATOM_ATOM, bitsof(uint32), countof(state), state);
	}
	if((*windowPreferences).position){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STRUT, XCB_ATOM_CARDINAL, bitsof(uint32), 4, &strut);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STRUT_PARTIAL, XCB_ATOM_CARDINAL, bitsof(uint32), 12, &strut);
	}
	/*! xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_ICON, , , , ); */
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_PID, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &pid);
	ret true;
}
DRAWWINDOW(){
	ElementRectangle _windowRectangle;
	ElementRectangle textRectangle1;
	ElementRectangle textRectangle2;
	ElementRectangle textRectangle3;
	bool hasTextRectangle1;
	bool hasTextRectangle2;
	bool hasTextRectangle3;
	if(!windowSystem or !windowInfo or !windowPreferences or (!monitor and !windowRectangle)){
		ret false;
	}
	jmp getRectangles;
	getRectangles:{
		if(!windowRectangle){
			windowRectangle = &_windowRectangle;
			if(!getRectangle(monitor, NULL, windowPreferences, windowRectangle) or !(*windowRectangle).width or !(*windowRectangle).height){
				ret false;
			}
		}
		hasTextRectangle1 = getRectangle(NULL, windowRectangle, &textPreferences1, &textRectangle1) and textRectangle1.width and textRectangle1.height;
		hasTextRectangle2 = getRectangle(NULL, windowRectangle, &textPreferences2, &textRectangle2) and textRectangle2.width and textRectangle2.height;
		hasTextRectangle3 = getRectangle(NULL, windowRectangle, &textPreferences3, &textRectangle3) and textRectangle3.width and textRectangle3.height;
		jmp drawWindow;
	}
	drawWindow:{
		const xcb_pixmap_t circlePixmap = (*windowSystem).circlePixmap;
		const xcb_pixmap_t pixmap = (*windowInfo).bufferPixmap;
		const xcb_gcontext_t gc = (*windowInfo).gc;
		const uint width = (*windowRectangle).width;
		const uint height = (*windowRectangle).height;
		fillDrawable(pixmap, gc, 0, 0, width, height, (*windowPreferences).background);
		if(circlePixmap){
			const uint8 cornerUsed = (*windowPreferences).cornerUsed;
			const uint radius = (*windowPreferences).cornerRadius;
			const uint size = radius + 1;
			if(cornerUsed & TOP_LEFT_CORNER) /*-----*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, 0     , 0     , 0           , 0            , size, size);
			if(cornerUsed & TOP_RIGHT_CORNER) /*----*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, radius, 0     , width - size, 0            , size, size);
			if(cornerUsed & BOTTOM_LEFT_CORNER) /*--*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, 0     , radius, 0           , height - size, size, size);
			if(cornerUsed & BOTTOM_RIGHT_CORNER) /*-*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, radius, radius, width - size, height - size, size, size);
		}
		jmp drawWindowElements;
	}
	drawWindowElements:{
		if(hasTextRectangle1 and visualBufferSystem1.pixmap){
			xcb_copy_area(connection, visualBufferSystem1.pixmap, (*windowInfo).bufferPixmap, (*windowInfo).gc, 0, 0, textRectangle1.x, textRectangle1.y, textRectangle1.width, textRectangle1.height);
		}
		if(hasTextRectangle2 and visualBufferSystem2.pixmap){
			xcb_copy_area(connection, visualBufferSystem2.pixmap, (*windowInfo).bufferPixmap, (*windowInfo).gc, 0, 0, textRectangle2.x, textRectangle2.y, textRectangle2.width, textRectangle2.height);
		}
		if(hasTextRectangle3 and visualBufferSystem3.pixmap){
			xcb_copy_area(connection, visualBufferSystem3.pixmap, (*windowInfo).bufferPixmap, (*windowInfo).gc, 0, 0, textRectangle3.x, textRectangle3.y, textRectangle3.width, textRectangle3.height);
		}
		jmp clearArea;
	}
	clearArea:{
		xcb_copy_area(connection, (*windowInfo).bufferPixmap, (*windowInfo).pixmap, (*windowInfo).gc, 0, 0, 0, 0, (*windowInfo).width, (*windowInfo).height);
		if((*windowSystem).mapped){
			xcb_clear_area(connection, false, (*windowInfo).window, 0, 0, 0, 0);
		}
		ret true;
	}
}
INITVISUALBUFFERSYSTEM(){
	if(!visualBufferSystem){
		ret false;
	}
	(*visualBufferSystem).commandStart = NULL;
	(*visualBufferSystem).commandToken = 0;
	(*visualBufferSystem).pixmap = XCB_NONE;
	(*visualBufferSystem).gc = XCB_NONE;
	(*visualBufferSystem).font = XCB_NONE;
	(*visualBufferSystem).font = XCB_NONE;
	(*visualBufferSystem).width = 0;
	(*visualBufferSystem).height = 0;
	ret true;
}
SETVISUALBUFFERCOMMAND(){
	if(!visualBufferSystem or !commandStart){
		ret false;
	}
	free((*visualBufferSystem).commandStart);
	popPointer((*visualBufferSystem).commandToken);
	(*visualBufferSystem).commandStart = commandStart;
	(*visualBufferSystem).commandToken = commandToken;
	ret true;
}
SETVISUALBUFFERFONT(){
	xcb_void_cookie_t cookie;
	xcb_generic_error_t *error;
	uint32 token;
	if(!visualBufferSystem or !fontStart){
		ret false;
	}
	if((*visualBufferSystem).font){
		xcb_close_font(connection, (*visualBufferSystem).font);
	}
	(*visualBufferSystem).font = xcb_generate_id(connection);
	cookie = xcb_open_font_checked(connection, (*visualBufferSystem).font, findStringLength(fontStart), fontStart);
	error = xcb_request_check(connection, cookie);
	token = pushPointer(error, "open font error", iFree);
	if(error){
		xcb_open_font(connection, (*visualBufferSystem).font, lengthof("fixed"), "fixed");
		free(error);
		popPointer(token);
	}
	if((*visualBufferSystem).gc){
		xcb_change_gc(connection, (*visualBufferSystem).gc, XCB_GC_FONT, &(*visualBufferSystem).font);
	}
	ret !error;
}
CREATEVISUALBUFFER(){
	struct{
		xcb_font_t /*-*/ font;
		uint32 /*-----*/ generateExpose;
	} gcValueList;
	if(!visualBufferSystem or !width or !height){
		ret false;
	}
	(*visualBufferSystem).width = width;
	(*visualBufferSystem).height = height;
	if((*visualBufferSystem).width > (*visualBufferSystem).height){
		(*visualBufferSystem).height = (*visualBufferSystem).width;
	}else{
		(*visualBufferSystem).width = (*visualBufferSystem).height;
	}
	gcValueList.generateExpose = false;
	gcValueList.font = (*visualBufferSystem).font;
	if((*visualBufferSystem).gc){
		xcb_free_gc(connection, (*visualBufferSystem).gc);
	}
	if((*visualBufferSystem).pixmap){
		xcb_free_pixmap(connection, (*visualBufferSystem).pixmap);
	}
	(*visualBufferSystem).pixmap = xcb_generate_id(connection);
	(*visualBufferSystem).gc = xcb_generate_id(connection);
	xcb_create_pixmap(connection, depth, (*visualBufferSystem).pixmap, (*screen).root, (*visualBufferSystem).width, (*visualBufferSystem).height);
	xcb_create_gc(connection, (*visualBufferSystem).gc, (*visualBufferSystem).pixmap, (!!gcValueList.font * XCB_GC_FONT) | XCB_GC_GRAPHICS_EXPOSURES, &gcValueList);
	ret true;
}
DRAWVISUALBUFFER(){
	#define TEXT_SEGMENT_AMOUNT /*-----*/ (8)
	#define TEXT_SEGMENT_BLOCK_SIZE /*-*/ (8)
	uint textLength;
	uint16 textStart[TEXT_SEGMENT_AMOUNT * 256];
	uint textSegmentAllocated;
	uint textSegmentSize;
	TextSegment *textSegmentStart;
	uint32 textSegmentToken;
	xcb_query_text_extents_cookie_t stringCookie;
	uint cookieSize;
	xcb_query_text_extents_cookie_t *cookieStart;
	uint32 cookieToken;
	int x;
	int y;
	uint width;
	uint height;
	if(!visualBufferSystem or !(*visualBufferSystem).commandStart or !(*visualBufferSystem).font or !textPreferences){
		ret false;
	}
	jmp getText;
	getText:{
		FILE *const file = popen((*visualBufferSystem).commandStart, "r");
		uint32 token = pushPointer(file, "pipe to executed command pointer", pclose);
		uint8 utf8Start[2 * countof(textStart)];
		uint utf8Length;
		*utf8Start = '\0';
		if(file){
			const bool success = !!fgets((void *)utf8Start, countof(utf8Start), file);
			pclose(file);
			popPointer(token);
			if(!success and *utf8Start){
				printTitledError("file text error", "could not get text to display");
				ret false;
			}
		}
		utf8Length = findStringLength(utf8Start);
		if(utf8Length > countof(utf8Start)){
			utf8Length = countof(utf8Start);
		}
		textLength = UTF8ToUCS2(utf8Start, utf8Length, textStart, countof(textStart));
		jmp getTextSequences;
	}
	getTextSequences:{
		uint16 *textCurrent = textStart;
		uint16 *const textWall = textCurrent + textLength;
		uint16 *stringCurrent = textStart;
		uint16 *previousSegmentStart;
		ANSIAttributes currentAttributes;
		currentAttributes.foreground = (*textPreferences).foreground;
		currentAttributes.background = (*textPreferences).background;
		textSegmentAllocated = 0;
		textSegmentSize = TEXT_SEGMENT_BLOCK_SIZE;
		textSegmentStart = malloc(textSegmentSize * sizeof(TextSegment));
		textSegmentToken = pushPointer(textSegmentStart, "text segment pointer", iFree);
		if(!textSegmentStart){
			printTitledError("memory allocation error", "could not allocate memory for text segments");
			ret false;
		}
		previousSegmentStart = stringCurrent;
		(*(textSegmentStart + textSegmentAllocated)).attributes = currentAttributes;
		inc textSegmentAllocated;
		cookieSize = 0;
		jmp getTextSequenceLoop;
		getTextSequenceLoop:{
			if(textCurrent < textWall){
				if(*textCurrent == ASCII_TO_UCS2('\x1b')){
					uint16 *segmentStart;
					if((segmentStart = matchANSISequence(textCurrent, currentAttributes, &currentAttributes))){
						if(textSegmentAllocated){
							const uint length = stringCurrent - previousSegmentStart;
							(*(textSegmentStart + textSegmentAllocated - 1)).length = length;
							cookieSize += length / 255 + !!(length % 255);
						}
						if(textSegmentAllocated == textSegmentSize){
							void *temp;
							textSegmentSize += TEXT_SEGMENT_BLOCK_SIZE;
							temp = realloc(textSegmentStart, textSegmentSize * sizeof(TextSegment));
							updatePointer(textSegmentToken, temp);
							if(!temp){
								printTitledError("memory allocation error", "could not allocate memory for text segments");
								free(textSegmentStart);
								popPointer(textSegmentToken);
								ret false;
							}
							textSegmentStart = temp;
						}
						previousSegmentStart = stringCurrent;
						(*(textSegmentStart + textSegmentAllocated)).attributes = currentAttributes;
						inc textSegmentAllocated;
						textCurrent = segmentStart;
						jmp getTextSequenceLoop;
					}
				}
				*stringCurrent = *textCurrent;
				inc stringCurrent;
				inc textCurrent;
				jmp getTextSequenceLoop;
			}
			if(textSegmentAllocated){
				const uint length = stringCurrent - previousSegmentStart;
				(*(textSegmentStart + textSegmentAllocated - 1)).length = length;
				cookieSize += length / 255 + !!(length % 255);
			}
			stringCookie = xcb_query_text_extents_unchecked(connection, (*visualBufferSystem).font, stringCurrent - textStart, (void *)textStart);
			jmp querySubstringsTextExtents;
		}
	}
	querySubstringsTextExtents:{
		TextSegment *current = textSegmentStart;
		TextSegment *const wall = current + textSegmentAllocated;
		uint16 *textCurrent = textStart;
		xcb_query_text_extents_cookie_t *cookieCurrent;
		cookieStart = malloc(cookieSize * sizeof(xcb_query_text_extents_cookie_t));
		cookieToken = pushPointer(cookieStart, "text segment cookie pointer", iFree);
		if(!cookieStart){
			printTitledError("memory allocation error", "could not allocate memory for text segment cookies");
			free(textSegmentStart);
			popPointer(textSegmentToken);
			ret false;
		}
		cookieCurrent = cookieStart;
		jmp querySubstringTextExtentsLoop;
		querySubstringTextExtentsLoop:{
			if(current < wall){
				uint length = (*current).length;
				jmp querySubstringPartTextExtentsLoop;
				querySubstringPartTextExtentsLoop:{
					if(length){
						uint l = length;
						if(l > 255){
							l = 255;
						}
						*cookieCurrent = xcb_query_text_extents_unchecked(connection, (*visualBufferSystem).font, l, (void *)textCurrent);
						inc cookieCurrent;
						textCurrent += l;
						length -= l;
						jmp querySubstringPartTextExtentsLoop;
					}
					inc current;
					jmp querySubstringTextExtentsLoop;
				}
			}
			jmp getStringTextExtents;
		}
	}
	getStringTextExtents:{
		xcb_query_text_extents_reply_t *const reply = xcb_wait_for_reply(connection, stringCookie, NULL);
		uint32 token = pushPointer(reply, "drawVisualBuffer() query text extents reply", iFree);
		if(!reply){
			free(cookieStart);
			popPointer(cookieToken);
			free(textSegmentStart);
			popPointer(textSegmentToken);
			ret false;
		}
		x = 0;
		y = (*reply).font_ascent;
		width = (*reply).overall_width;
		height = (*reply).font_ascent + (*reply).font_descent;
		(*textPreferences).width = width;
		(*textPreferences).widthType = INTEGER_NUMBER_TYPE;
		(*textPreferences).height = height;
		(*textPreferences).heightType = INTEGER_NUMBER_TYPE;
		free(reply);
		popPointer(token);
		jmp getSubstringsTextExtents;
	}
	getSubstringsTextExtents:{
		TextSegment *current = textSegmentStart;
		TextSegment *const wall = current + textSegmentAllocated;
		uint16 *textCurrent = textStart;
		xcb_query_text_extents_cookie_t *cookieCurrent = cookieStart;
		jmp getSubstringTextExtentsLoop;
		getSubstringTextExtentsLoop:{
			if(current < wall){
				uint length = (*current).length;
				xcb_change_gc(connection, (*visualBufferSystem).gc, XCB_GC_FOREGROUND | XCB_GC_BACKGROUND, &(*current).attributes);
				jmp getSubstringPartTextExtentsLoop;
				getSubstringPartTextExtentsLoop:{
					if(length){
						xcb_query_text_extents_reply_t *const reply = xcb_wait_for_reply(connection, *cookieCurrent, NULL);
						uint32 token = pushPointer(reply, "drawVisualBuffer() query text extents reply", iFree);
						uint l = length;
						if(l > 255){
							l = 255;
						}
						if(reply){
							xcb_image_text_16(connection, l, (*visualBufferSystem).pixmap, (*visualBufferSystem).gc, x, y, (void *)textCurrent);
							x += (*reply).overall_width;
							free(reply);
							popPointer(token);
						}
						inc cookieCurrent;
						textCurrent += l;
						length -= l;
						jmp getSubstringPartTextExtentsLoop;
					}
					inc current;
					jmp getSubstringTextExtentsLoop;
				}
			}
			free(cookieStart);
			popPointer(cookieToken);
			free(textSegmentStart);
			popPointer(textSegmentToken);
			jmp rotateText;
		}
	}
	rotateText:{
		xcb_get_image_reply_t *reply;
		uint32 token;
		if(!textRotation){
			ret true;
		}
		if(width > (*visualBufferSystem).width){
			width = (*visualBufferSystem).width;
		}
		if(height > (*visualBufferSystem).height){
			height = (*visualBufferSystem).height;
		}
		reply = xcb_wait_for_reply(connection, xcb_get_image_unchecked(connection, XCB_IMAGE_FORMAT_Z_PIXMAP, (*visualBufferSystem).pixmap, 0, 0, width, height, 0xFFFFFFFF), NULL);
		token = pushPointer(reply, "get image reply", iFree);
		if(reply){
			Image image;
			image.width = width;
			image.height = height;
			image.dataSize = xcb_get_image_data_length(reply);
			image.dataStart = xcb_get_image_data(reply);
			image.dataToken = 0;
			if(rotateImage(textRotation, &image, false)){
				xcb_put_image(connection, XCB_IMAGE_FORMAT_Z_PIXMAP, (*visualBufferSystem).pixmap, (*visualBufferSystem).gc, image.width, image.height, 0, 0, 0, depth, image.dataSize, image.dataStart);
				(*textPreferences).width = width;
				(*textPreferences).height = height;
				free(image.dataStart);
				popPointer(image.dataToken);
			}
			free(reply);
			popPointer(token);
		}
		ret true;
	}
	#undef  TEXT_SEGMENT_BLOCK_SIZE
	#undef  TEXT_SEGMENT_AMOUNT
}
FINIVISUALBUFFERSYSTEM(){
	if(!visualBufferSystem){
		ret false;
	}
	if((*visualBufferSystem).gc){
		xcb_free_gc(connection, (*visualBufferSystem).gc);
		(*visualBufferSystem).gc = XCB_NONE;
	}
	if((*visualBufferSystem).font){
		xcb_close_font(connection, (*visualBufferSystem).font);
		(*visualBufferSystem).font = XCB_NONE;
	}
	if((*visualBufferSystem).pixmap){
		xcb_free_pixmap(connection, (*visualBufferSystem).pixmap);
		(*visualBufferSystem).pixmap = XCB_NONE;
	}
	free((*visualBufferSystem).commandStart);
	popPointer((*visualBufferSystem).commandToken);
	(*visualBufferSystem).commandStart = NULL;
	(*visualBufferSystem).commandToken = 0;
	(*visualBufferSystem).width = 0;
	(*visualBufferSystem).height = 0;
	ret true;
}
INITTRAYSYSTEM(){
	#define _NET_SYSTEM_TRAY_ORIENTATION_HORZ /*-*/ (0)
	#define _NET_SYSTEM_TRAY_ORIENTATION_VERT /*-*/ (1)
	#define TRAY_ICON_BLOCK_SIZE /*--------------*/ (4)
	#define TRAY_ICON_MESSAGE_BLOCK_SIZE /*------*/ (4)
	if(!traySystem){
		ret false;
	}
	(*traySystem).parent = XCB_NONE;
	(*traySystem).window = XCB_NONE;
	(*traySystem).windowX = 0;
	(*traySystem).windowY = 0;
	(*traySystem).windowXOffset = 0;
	(*traySystem).windowYOffset = 0;
	(*traySystem).windowWidth = 0;
	(*traySystem).windowHeight = 0;
	(*traySystem).windowBackground = 0x00000000;
	(*traySystem).selectionWindow = XCB_NONE;
	(*traySystem).selectionTimestamp = XCB_CURRENT_TIME;
	(*traySystem).isManager = false;
	(*traySystem).mapped = false;
	(*traySystem).position = NONE_POSITION;
	(*traySystem).iconWindowXOffset = 0;
	(*traySystem).iconWindowYOffset = 0;
	(*traySystem).iconWindowSize = 0;
	(*traySystem).iconWindowPadding = 0;
	(*traySystem).iconSize = 0;
	(*traySystem).iconAllocated = 0;
	(*traySystem).iconStart = NULL;
	(*traySystem).iconToken = 0;
	(*traySystem).iconMappedAmount = 0;
	(*traySystem).iconMessageStart = NULL;
	(*traySystem).iconMessageToken = 0;
	(*traySystem).iconMessageSize = 0;
	ret true;
}
SETTRAYPARENT(){
	bool shouldMap;
	if(!traySystem){
		ret false;
	}
	shouldMap = ((*traySystem).parent == XCB_NONE and (*traySystem).mapped);
	(*traySystem).parent = parent;
	if((*traySystem).parent == (*screen).root){
		(*traySystem).parent = XCB_NONE;
	}
	if((*traySystem).mapped){
		if((*traySystem).parent){
			xcb_reparent_window(connection, (*traySystem).window, (*traySystem).parent, (*traySystem).windowX + (*traySystem).windowXOffset, (*traySystem).windowY + (*traySystem).windowYOffset);
			if(shouldMap){
				xcb_map_window(connection, (*traySystem).window);
			}
		}else{
			xcb_unmap_window(connection, (*traySystem).window);
			xcb_reparent_window(connection, (*traySystem).window, (*screen).root, 0, 0);
		}
	}
	ret true;
}
SETTRAYPOSITION(){
	if(!traySystem or !position){
		ret false;
	}
	(*traySystem).position = position;
	repositionTrayIcons(traySystem);
	ret true;
}
SETTRAYWINDOWX(){
	if(!traySystem){
		ret false;
	}
	(*traySystem).windowX = x;
	if((*traySystem).mapped){
		struct{
			int32 /*--*/ x;
		} valueList;
		valueList.x = (*traySystem).windowX + (*traySystem).windowXOffset;
		xcb_configure_window(connection, (*traySystem).window, XCB_CONFIG_WINDOW_X, &valueList);
	}
	ret true;
}
SETTRAYWINDOWY(){
	if(!traySystem){
		ret false;
	}
	(*traySystem).windowY = y;
	if((*traySystem).mapped){
		struct{
			int32 /*--*/ y;
		} valueList;
		valueList.y = (*traySystem).windowY + (*traySystem).windowYOffset;
		xcb_configure_window(connection, (*traySystem).window, XCB_CONFIG_WINDOW_Y, &valueList);
	}
	ret true;
}
SETTRAYWINDOWXOFFSET(){
	if(!traySystem){
		ret false;
	}
	(*traySystem).windowXOffset = xOffset;
	if((*traySystem).mapped){
		struct{
			int32 /*--*/ x;
		} valueList;
		valueList.x = (*traySystem).windowX + (*traySystem).windowXOffset;
		xcb_configure_window(connection, (*traySystem).window, XCB_CONFIG_WINDOW_X, &valueList);
	}
	ret true;
}
SETTRAYWINDOWYOFFSET(){
	if(!traySystem){
		ret false;
	}
	(*traySystem).windowYOffset = yOffset;
	if((*traySystem).mapped){
		struct{
			int32 /*--*/ y;
		} valueList;
		valueList.y = (*traySystem).windowY + (*traySystem).windowYOffset;
		xcb_configure_window(connection, (*traySystem).window, XCB_CONFIG_WINDOW_Y, &valueList);
	}
	ret true;
}
SETTRAYWINDOWBACKGROUND(){
	if(!traySystem){
		ret false;
	}
	(*traySystem).windowBackground = background;
	if((*traySystem).window){
		struct{
			uint32 /*--*/ backgroundColor;
		} valueList;
		valueList.backgroundColor = (*traySystem).windowBackground;
		xcb_change_window_attributes(connection, (*traySystem).window, XCB_CW_BACK_PIXEL, &valueList);
	}
	ret true;
}
SETTRAYICONWINDOWXOFFSET(){
	if(!traySystem){
		ret false;
	}
	(*traySystem).iconWindowXOffset = xOffset;
	repositionTrayIcons(traySystem);
	ret true;
}
SETTRAYICONWINDOWYOFFSET(){
	if(!traySystem){
		ret false;
	}
	(*traySystem).iconWindowYOffset = yOffset;
	repositionTrayIcons(traySystem);
	ret true;
}
SETTRAYICONWINDOWSIZE(){
	if(!traySystem or !size){
		ret false;
	}
	(*traySystem).iconWindowSize = size;
	repositionTrayIcons(traySystem);
	ret true;
}
SETTRAYICONWINDOWPADDING(){
	if(!traySystem){
		ret false;
	}
	(*traySystem).iconWindowPadding = padding;
	repositionTrayIcons(traySystem);
	ret true;
}
REPOSITIONTRAYICONS(){
	TrayIcon *start;
	TrayIcon *current;
	TrayIcon *wall;
	if(!traySystem or !(*traySystem).position or !(*traySystem).iconWindowSize or !(*traySystem).iconMappedAmount){
		ret false;
	}
	start = (*traySystem).iconStart;
	current = start;
	wall = current + (*traySystem).iconMappedAmount;
	(*traySystem).windowWidth = (*traySystem).iconWindowSize + ((*traySystem).position < LEFT_POSITION) * ((*traySystem).iconMappedAmount - 1) * ((*traySystem).iconWindowPadding + (*traySystem).iconWindowSize);
	(*traySystem).windowHeight = (*traySystem).iconWindowSize + ((*traySystem).position >= LEFT_POSITION) * ((*traySystem).iconMappedAmount - 1) * ((*traySystem).iconWindowPadding + (*traySystem).iconWindowSize);
	xcb_configure_window(connection, (*traySystem).window, XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &(*traySystem).windowWidth);
	jmp resizeTrayIconWindowLoop;
	resizeTrayIconWindowLoop:{
		if(current < wall){
			struct{
				int32 /*--*/ x;
				int32 /*--*/ y;
				uint32 /*-*/ width;
				uint32 /*-*/ height;
			} valueList;
			valueList.x = (*traySystem).iconWindowXOffset + ((*traySystem).position < LEFT_POSITION) * (current - start) * ((*traySystem).iconWindowSize + (*traySystem).iconWindowPadding);
			valueList.y = (*traySystem).iconWindowYOffset + ((*traySystem).position >= LEFT_POSITION) * (current - start) * ((*traySystem).iconWindowSize + (*traySystem).iconWindowPadding);
			valueList.width = (*traySystem).iconWindowSize;
			valueList.height = (*traySystem).iconWindowSize;
			xcb_discard_reply(connection, xcb_configure_window_checked(connection, (*current).window, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &valueList));
			inc current;
			jmp resizeTrayIconWindowLoop;
		}
		ret true;
	}
}
ACQUIRETRAYSELECTION(){
	uint32 valueList;
	xcb_get_selection_owner_reply_t *reply;
	uint32 token;
	if(!traySystem or (*traySystem).isManager){
		ret false;
	}
	(*traySystem).selectionWindow = xcb_generate_id(connection);
	(*traySystem).selectionTimestamp = getTimestamp();
	valueList = XCB_EVENT_MASK_PROPERTY_CHANGE;
	xcb_create_window(connection, XCB_COPY_FROM_PARENT, (*traySystem).selectionWindow, (*screen).root, -1, -1, 1, 1, 0, XCB_WINDOW_CLASS_INPUT_ONLY, (*screen).root_visual, XCB_CW_EVENT_MASK, &valueList);
	xcb_set_selection_owner(connection, (*traySystem).selectionWindow, atom._NET_SYSTEM_TRAY_Sn, (*traySystem).selectionTimestamp);
	xcb_sync();
	reply = xcb_wait_for_reply(connection, xcb_get_selection_owner_unchecked(connection, atom._NET_SYSTEM_TRAY_Sn), NULL);
	token = pushPointer(reply, "get selection owner reply", iFree);
	if(reply){
		if((*reply).owner == (*traySystem).selectionWindow){
			(*traySystem).isManager = true;
			changeTrayOrientationProperty(traySystem);
		}
		free(reply);
		popPointer(token);
	}
	ret (*traySystem).isManager;
}
CHANGETRAYORIENTATIONPROPERTY(){
	uint32 orientation;
	if(!traySystem or !(*traySystem).isManager or !(*traySystem).position or !(*traySystem).selectionWindow){
		ret false;
	}
	if((*traySystem).position < LEFT_POSITION){
		orientation = _NET_SYSTEM_TRAY_ORIENTATION_HORZ;
	}else{
		orientation = _NET_SYSTEM_TRAY_ORIENTATION_VERT;
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*traySystem).selectionWindow, atom._NET_SYSTEM_TRAY_ORIENTATION, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &orientation);
	ret true;
}
ADDTRAYICON(){
	TrayIcon *trayIcon;
	if(!traySystem or !(*traySystem).isManager or findTrayIconWindow(traySystem, window)){
		ret false;
	}
	if((*traySystem).iconAllocated == (*traySystem).iconSize){
		void *temp;
		(*traySystem).iconSize += TRAY_ICON_BLOCK_SIZE;
		temp = realloc((*traySystem).iconStart, (*traySystem).iconSize * sizeof(TrayIcon));
		updatePointer((*traySystem).iconToken, temp);
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for tray icons");
			(*traySystem).iconSize -= TRAY_ICON_BLOCK_SIZE;
			ret false;
		}
		(*traySystem).iconStart = temp;
	}
	trayIcon = (*traySystem).iconStart + (*traySystem).iconAllocated;
	(*trayIcon).window = window;
	(*trayIcon).version = version;
	(*trayIcon).mapped = false;
	if(!(*traySystem).window){
		struct{
			uint32 /*---------*/ backgroundColor;
			uint32 /*---------*/ borderColor;
			uint32 /*---------*/ eventMask;
			xcb_colormap_t /*-*/ colormap;
		} valueList;
		(*traySystem).window = xcb_generate_id(connection);
		valueList.backgroundColor = (*traySystem).windowBackground;
		valueList.borderColor = 0x00000000;
		valueList.eventMask = XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY | XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT;
		valueList.colormap = (*screen).default_colormap;
		xcb_create_window(connection, (*screen).root_depth, (*traySystem).window, (*screen).root, 0, 0, 1, 1, 0, XCB_WINDOW_CLASS_INPUT_OUTPUT, (*screen).root_visual, XCB_CW_BACK_PIXEL | XCB_CW_BORDER_PIXEL | XCB_CW_EVENT_MASK | XCB_CW_COLORMAP, &valueList);
	}
	xcb_discard_reply(connection, xcb_reparent_window_checked(connection, (*trayIcon).window, (*traySystem).window, 0, 0));
	inc (*traySystem).iconAllocated;
	ret true;
}
MAPTRAYICON(){
	TrayIcon *newTrayIcon;
	if(!traySystem or !(*traySystem).position or !(*traySystem).iconWindowSize or !trayIcon or (*trayIcon).mapped){
		ret false;
	}
	newTrayIcon = trayIcon;
	jmp moveIconDown;
	moveIconDown:{
		const TrayIcon temp = *newTrayIcon;
		TrayIcon *const lastMappedIcon = (*traySystem).iconStart + (*traySystem).iconMappedAmount;
		*newTrayIcon = *lastMappedIcon;
		*lastMappedIcon = temp;
		newTrayIcon = lastMappedIcon;
		jmp configureIcon;
	}
	configureIcon:{
		struct{
			int32 /*--*/ x;
			int32 /*--*/ y;
			uint32 /*-*/ width;
			uint32 /*-*/ height;
		} valueList;
		valueList.x = (*traySystem).iconWindowXOffset + ((*traySystem).position < LEFT_POSITION) * (newTrayIcon - (*traySystem).iconStart) * ((*traySystem).iconWindowSize + (*traySystem).iconWindowPadding);
		valueList.y = (*traySystem).iconWindowYOffset + ((*traySystem).position >= LEFT_POSITION) * (newTrayIcon - (*traySystem).iconStart) * ((*traySystem).iconWindowSize + (*traySystem).iconWindowPadding);
		valueList.width = (*traySystem).iconWindowSize;
		valueList.height = (*traySystem).iconWindowSize;
		xcb_discard_reply(connection, xcb_configure_window_checked(connection, (*newTrayIcon).window, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &valueList));
		xcb_discard_reply(connection, xcb_map_window_checked(connection, (*newTrayIcon).window));
		(*newTrayIcon).mapped = true;
		inc (*traySystem).iconMappedAmount;
		jmp updateTrayWindow;
	}
	updateTrayWindow:{
		if(!(*traySystem).mapped and (*traySystem).parent){
			xcb_reparent_window(connection, (*traySystem).window, (*traySystem).parent, (*traySystem).windowX + (*traySystem).windowXOffset, (*traySystem).windowY + (*traySystem).windowYOffset);
		}
		(*traySystem).windowWidth = (*traySystem).iconWindowSize + ((*traySystem).position < LEFT_POSITION) * ((*traySystem).iconMappedAmount - 1) * ((*traySystem).iconWindowPadding + (*traySystem).iconWindowSize);
		(*traySystem).windowHeight = (*traySystem).iconWindowSize + ((*traySystem).position >= LEFT_POSITION) * ((*traySystem).iconMappedAmount - 1) * ((*traySystem).iconWindowPadding + (*traySystem).iconWindowSize);
		xcb_configure_window(connection, (*traySystem).window, XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &(*traySystem).windowWidth);
		if(!(*traySystem).mapped and (*traySystem).parent){
			xcb_configure_window(connection, (*traySystem).window, XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &(*traySystem).windowWidth);
			xcb_map_window(connection, (*traySystem).window);
			(*traySystem).mapped = true;
		}
		jmp notifyIcon;
	}
	notifyIcon:{
		xcb_client_message_event_t message;
		message.response_type = XCB_CLIENT_MESSAGE;
		message.format = 32;
		message.window = (*trayIcon).window;
		message.type = atom._XEMBED;
		*(message.data.data32 + 0) = getTimestamp();
		*(message.data.data32 + 1) = XEMBED_EMBEDDED_NOTIFY;
		*(message.data.data32 + 2) = 0;
		*(message.data.data32 + 3) = (*traySystem).parent;
		*(message.data.data32 + 4) = (*trayIcon).version;
		xcb_discard_reply(connection, xcb_send_event_checked(connection, false, message.window, XCB_EVENT_MASK_NO_EVENT, &message));
		*(message.data.data32 + 1) = XEMBED_WINDOW_ACTIVATE;
		*(message.data.data32 + 2) = XEMBED_MAPPED;
		*(message.data.data32 + 3) = 0;
		*(message.data.data32 + 4) = 0;
		xcb_discard_reply(connection, xcb_send_event_checked(connection, false, message.window, XCB_EVENT_MASK_NO_EVENT, &message));
		ret true;
	}
}
UNMAPTRAYICON(){
	TrayIcon *start;
	TrayIcon *current;
	TrayIcon *wall;
	TrayIcon temp;
	if(!traySystem or !trayIcon or !(*trayIcon).mapped){
		ret NULL;
	}
	jmp unmapTrayIcon;
	unmapTrayIcon:{
		xcb_discard_reply(connection, xcb_unmap_window_checked(connection, (*trayIcon).window));
		(*trayIcon).mapped = false;
		start = (*traySystem).iconStart;
		current = trayIcon;
		wall = start + (*traySystem).iconMappedAmount;
		temp = *trayIcon;
		jmp shiftIconLeftLoop;
	}
	shiftIconLeftLoop:{
		if(inc current < wall){
			struct{
				int32 /*-*/ x;
				int32 /*-*/ y;
			} valueList;
			valueList.x = (*traySystem).iconWindowXOffset + ((*traySystem).position < LEFT_POSITION) * (current - start - 1) * ((*traySystem).iconWindowSize + (*traySystem).iconWindowPadding);
			valueList.y = (*traySystem).iconWindowYOffset + ((*traySystem).position >= LEFT_POSITION) * (current - start - 1) * ((*traySystem).iconWindowSize + (*traySystem).iconWindowPadding);
			xcb_discard_reply(connection, xcb_configure_window_checked(connection, (*current).window, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y, &valueList));
			*(current - 1) = *current;
			jmp shiftIconLeftLoop;
		}
		*(current - 1) = temp;
		jmp updateTrayWindow;
	}
	updateTrayWindow:{
		if(!(dec (*traySystem).iconMappedAmount)){
			if((*traySystem).mapped){
				xcb_unmap_window(connection, (*traySystem).window);
				xcb_reparent_window(connection, (*traySystem).window, (*screen).root, 0, 0);
				(*traySystem).mapped = false;
			}
		}else{
			(*traySystem).windowWidth = (*traySystem).iconWindowSize + ((*traySystem).position < LEFT_POSITION) * ((*traySystem).iconMappedAmount - 1) * ((*traySystem).iconWindowPadding + (*traySystem).iconWindowSize);
			(*traySystem).windowHeight = (*traySystem).iconWindowSize + ((*traySystem).position >= LEFT_POSITION) * ((*traySystem).iconMappedAmount - 1) * ((*traySystem).iconWindowPadding + (*traySystem).iconWindowSize);
			xcb_configure_window(connection, (*traySystem).window, XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &(*traySystem).windowWidth);
		}
		ret wall - 1;
	}
}
REMOVETRAYICON(){
	TrayIcon *newTrayIcon;
	if(!traySystem or !trayIcon){
		ret false;
	}
	if(!(newTrayIcon = unmapTrayIcon(traySystem, trayIcon))){
		newTrayIcon = trayIcon;
	}
	xcb_discard_reply(connection, xcb_reparent_window_checked(connection, (*newTrayIcon).window, (*screen).root, 0, 0));
	shiftMemory(newTrayIcon + 1, ((*traySystem).iconStart + (*traySystem).iconAllocated - newTrayIcon - 1) * sizeof(TrayIcon), -(int)sizeof(TrayIcon));
	dec (*traySystem).iconAllocated;
	ret true;
}
LOSETRAYSELECTION(){
	TrayIcon *current;
	TrayIcon *wall;
	if(!traySystem or !(*traySystem).isManager){
		ret false;
	}
	current = (*traySystem).iconStart;
	wall = current + (*traySystem).iconAllocated;
	if((*traySystem).window){
		xcb_unmap_window(connection, (*traySystem).window);
	}
	xcb_set_selection_owner(connection, XCB_NONE, atom._NET_SYSTEM_TRAY_Sn, getTimestamp());
	jmp returnTrayIconLoop;
	returnTrayIconLoop:{
		if(current < wall){
			xcb_discard_reply(connection, xcb_unmap_window_checked(connection, (*current).window));
			xcb_discard_reply(connection, xcb_reparent_window_checked(connection, (*current).window, (*screen).root, 0, 0));
			inc current;
			jmp returnTrayIconLoop;
		}
		xcb_destroy_window(connection, (*traySystem).selectionWindow);
		(*traySystem).selectionWindow = XCB_NONE;
		(*traySystem).selectionTimestamp = XCB_CURRENT_TIME;
		(*traySystem).isManager = false;
		ret true;
	}
}
FINDTRAYICONWINDOW(){
	TrayIcon *current;
	TrayIcon *wall;
	if(!traySystem or !(*traySystem).iconAllocated){
		ret false;
	}
	current = (*traySystem).iconStart;
	wall = current + (*traySystem).iconAllocated;
	jmp findTrayIconWindowLoop;
	findTrayIconWindowLoop:{
		if(current < wall){
			if((*current).window == window){
				ret current;
			}
			inc current;
			jmp findTrayIconWindowLoop;
		}
		ret NULL;
	}
}
FINITRAYSYSTEM(){
	if(!traySystem){
		ret false;
	}
	loseTraySelection(traySystem);
	(*traySystem).parent = XCB_NONE;
	(*traySystem).windowX = 0;
	(*traySystem).windowY = 0;
	(*traySystem).windowXOffset = 0;
	(*traySystem).windowYOffset = 0;
	(*traySystem).windowWidth = 0;
	(*traySystem).windowHeight = 0;
	(*traySystem).windowBackground = 0x00000000;
	(*traySystem).selectionTimestamp = XCB_CURRENT_TIME;
	(*traySystem).mapped = false;
	(*traySystem).position = NONE_POSITION;
	(*traySystem).iconWindowXOffset = 0;
	(*traySystem).iconWindowYOffset = 0;
	(*traySystem).iconWindowSize = 0;
	(*traySystem).iconWindowPadding = 0;
	free((*traySystem).iconMessageStart);
	popPointer((*traySystem).iconMessageToken);
	(*traySystem).iconMessageStart = NULL;
	(*traySystem).iconMessageToken = 0;
	(*traySystem).iconMessageSize = 0;
	free((*traySystem).iconStart);
	popPointer((*traySystem).iconToken);
	(*traySystem).iconSize = 0;
	(*traySystem).iconAllocated = 0;
	(*traySystem).iconStart = NULL;
	(*traySystem).iconToken = 0;
	(*traySystem).iconMappedAmount = 0;
	if((*traySystem).window){
		xcb_destroy_window(connection, (*traySystem).window);
		(*traySystem).window = XCB_NONE;
	}
	ret true;
	#undef  TRAY_ICON_MESSAGE_BLOCK_SIZE
	#undef  TRAY_ICON_BLOCK_SIZE
	#undef  _NET_SYSTEM_TRAY_ORIENTATION_VERT
	#undef  _NET_SYSTEM_TRAY_ORIENTATION_HORZ
}
SETCONFIGVARIABLES(){
	setElementPreferences(&windowPreferences);
	whichMonitor = ALL_WHICH_MONITOR;
	setElementPreferences(&textPreferences1);
	textRotation1 = NONE_ROTATION;
	setElementPreferences(&textPreferences2);
	textRotation2 = NONE_ROTATION;
	setElementPreferences(&textPreferences3);
	textRotation3 = NONE_ROTATION;
	setTrayWindowX(&traySystem, 0);
	setTrayWindowY(&traySystem, 0);
	setTrayWindowXOffset(&traySystem, 0);
	setTrayWindowYOffset(&traySystem, 0);
	setTrayWindowBackground(&traySystem, 0x00000000);
	setTrayIconWindowXOffset(&traySystem, 0);
	setTrayIconWindowYOffset(&traySystem, 0);
	setTrayIconWindowSize(&traySystem, 1);
	setTrayIconWindowPadding(&traySystem, 0);
	setVisualBufferCommand(&visualBufferSystem1, NULL, 0);
	setVisualBufferFont(&visualBufferSystem1, NULL);
	setVisualBufferCommand(&visualBufferSystem2, NULL, 0);
	setVisualBufferFont(&visualBufferSystem2, NULL);
	setVisualBufferCommand(&visualBufferSystem3, NULL, 0);
	setVisualBufferFont(&visualBufferSystem3, NULL);
	setSleepThreadSleepTime(&sleepThreadSystem, 0);
	ret;
}
READCONFIG(){
	#define STATEMENT_BLOCK_SIZE /*-*/ (256)
	#define DEFAULT_CONFIG_PATH /*--*/ ("/etc/" PROGRAM_NAME "/" PROGRAM_NAME ".conf")
	const Instruction *const *currentScopeInstruction = globalScopeInstruction;
	const char *const *currentScopeInstructionList = globalInstructionList;
	const Instruction *instructionStart;
	const Instruction *instructionStartCopy;
	const Instruction *instructionCurrent;
	const Instruction *name0Instruction;
	const Instruction *name1Instruction;
	const Instruction *name2Instruction;
	const Instruction *name3Instruction;
	const Instruction *name4Instruction;
	const Instruction *nameList0Instruction;
	const Instruction *nameList1Instruction;
	const Instruction *nameList2Instruction;
	const Instruction *nameList3Instruction;
	const Instruction *nameList4Instruction;
	const Instruction *integer0Instruction;
	const Instruction *integer1Instruction;
	const Instruction *integer2Instruction;
	const Instruction *integer3Instruction;
	const Instruction *integer4Instruction;
	const Instruction *string0Instruction;
	const Instruction *string1Instruction;
	const Instruction *string2Instruction;
	const Instruction *string3Instruction;
	const Instruction *string4Instruction;
	const Instruction *image0Instruction;
	const Instruction *image1Instruction;
	const Instruction *image2Instruction;
	const Instruction *image3Instruction;
	const Instruction *image4Instruction;
	const char *imageErrorMessage;
	FILE *configFile = NULL;
	uint32 configFileToken;
	void *system = NULL;
	uint statementSize = STATEMENT_BLOCK_SIZE;
	char *statementStart = NULL;
	uint32 statementToken = 0;
	char *statementCurrent;
	char *statementWall = NULL;
	char *statementConcreteWall;
	uint8 name0Return;
	uint8 name1Return;
	uint8 name2Return;
	uint8 name3Return;
	uint8 name4Return;
	uint8 nameList0Return;
	uint8 nameList1Return;
	uint8 nameList2Return;
	uint8 nameList3Return;
	uint8 nameList4Return;
	int64 integer0Return;
	int64 integer1Return;
	int64 integer2Return;
	int64 integer3Return;
	int64 integer4Return;
	char *string0Return = NULL;
	uint32 string0Token = 0;
	char *string1Return = NULL;
	uint32 string1Token = 0;
	char *string2Return = NULL;
	uint32 string2Token = 0;
	char *string3Return = NULL;
	uint32 string3Token = 0;
	char *string4Return = NULL;
	uint32 string4Token = 0;
	Image image0Return;
	Image image1Return;
	Image image2Return;
	Image image3Return;
	Image image4Return;
	JmpPoint jmpPoint;
	uint fileLine = 1;
	uint statementLine = 0;
	char fileChar;
	uint itemAmount;
	char quote = '\0';
	uint currentScopeInstructionListSize = countof(globalInstructionList) - 1;
	StringTreeSystem *const *const *currentScopeInstructionData = globalScopeInstructionData;
	StringTreeSystem *const *instructionDataStart;
	StringTreeSystem *const *instructionDataStartCopy;
	StringTreeSystem *const *instructionDataCurrent;
	StringTreeSystem *currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
	image0Return.dataStart = NULL;
	image0Return.dataToken = 0;
	image1Return.dataStart = NULL;
	image1Return.dataToken = 0;
	image2Return.dataStart = NULL;
	image2Return.dataToken = 0;
	image3Return.dataStart = NULL;
	image3Return.dataToken = 0;
	image4Return.dataStart = NULL;
	image4Return.dataToken = 0;
	jmp setupPointers;
	setupPointers:{
		if(getNextConfigChar == &ifgetc){
			if(!createConfigFile){
				DIR *const dir = opendir(configPath);
				uint32 token = pushPointer(dir, "config directory argument", closedir);
				if(dir){
					closedir(dir);
					popPointer(token);
					printConfigError("config error", "config file is directory", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
			}
			configFile = fopen(configPath, "r");
			configFileToken = pushPointer(configFile, "config file", fclose);
			if(!configFile){
				#define BUFFER_SIZE /*-*/ (4096)
				FILE *defaultConfigFile;
				uint32 defaultConfigFileToken;
				if(!createConfigFile){
					printConfigError("config error", "could not open config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				configFile = fopen(configPath, "w");
				configFileToken = pushPointer(configFile, "config file", fclose);
				if(!configFile){
					printConfigError("config error", "could not create config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				defaultConfigFile = fopen(DEFAULT_CONFIG_PATH, "r");
				defaultConfigFileToken = pushPointer(defaultConfigFile, "default config file", fclose);
				if(!defaultConfigFile){
					remove(configPath);
					printTitledNamedError("config file error", "could not copy default configuration file from", DEFAULT_CONFIG_PATH);
					jmp configEmergencyExit;
				}
				copyConfigFileLoop:{
					char buffer[BUFFER_SIZE];
					size_t bytesRead;
					if((bytesRead = fread(buffer, sizeof(*buffer), sizeof(buffer), defaultConfigFile))){
						if(fwrite(buffer, sizeof(*buffer), bytesRead, configFile) != bytesRead){
							fclose(defaultConfigFile);
							popPointer(defaultConfigFileToken);
							remove(configPath);
							printTitledError("config copying error", "could not copy default config file correctly");
							jmp configEmergencyExit;
						}
						jmp copyConfigFileLoop;
					}
				}
				fclose(defaultConfigFile);
				popPointer(defaultConfigFileToken);
				fclose(configFile);
				popPointer(configFileToken);
				if(!(configFile = fopen(configPath, "r"))){
					printTitledError("config error", "could not open newly written file");
					jmp configEmergencyExit;
				}
				#undef  BUFFER_SIZE
			}
		}
		statementStart = malloc(statementSize * sizeof(char));
		statementToken = pushPointer(statementStart, "statement pointer", iFree);
		if(!statementStart){
			printTitledError("config error", "could not store user data");
			jmp configEmergencyExit;
		}
		if(getNextConfigChar == &ifgetc){
			system = configFile;
		}elif(getNextConfigChar == &getNextSTDINCharacter){
			system = &stdinSystem;
		}elif(getNextConfigChar == &getNextSharedMemoryCharacter){
			system = &sharedMemorySystem;
		}
		jmp getStatementStart;
	}
	getStatementStart:{
		#define EOF_N1 /*----------------------------*/ (EOF)
		#define ZER_00 /*----------------------------*/ ('\0')
		#define EOT_04 /*----------------------------*/ (0x04)
		#define ALR_07 /*----------------------------*/ ('\a')
		#define BSP_08 /*----------------------------*/ ('\b')
		#define TAB_09 /*----------------------------*/ ('\t')
		#define NLN_10 /*----------------------------*/ ('\n')
		#define VTB_11 /*----------------------------*/ ('\v')
		#define FFD_12 /*----------------------------*/ ('\f')
		#define CRE_13 /*----------------------------*/ ('\r')
		#define ESC_27 /*----------------------------*/ ('\e')
		#define SPC_32 /*----------------------------*/ (' ')
		#define DQT_34 /*----------------------------*/ ('\"')
		#define SQT_39 /*----------------------------*/ ('\'')
		#define AST_42 /*----------------------------*/ ('*')
		#define FSL_47 /*----------------------------*/ ('/')
		#define ZER_48 /*----------------------------*/ ('0')
		#define SCL_59 /*----------------------------*/ (';')
		#define QMK_63 /*----------------------------*/ ('?')
		#define BSL_92 /*----------------------------*/ ('\\')
		#define LOA_97 /*----------------------------*/ ('a')
		#define LOB_98 /*----------------------------*/ ('b')
		#define LOF_102 /*---------------------------*/ ('f')
		#define LON_110 /*---------------------------*/ ('n')
		#define LOR_114 /*---------------------------*/ ('r')
		#define LOT_116 /*---------------------------*/ ('t')
		#define LOV_118 /*---------------------------*/ ('v')
		#define OCB_123 /*---------------------------*/ ('{')
		#define BAR_124 /*---------------------------*/ ('|')
		#define CCB_125 /*---------------------------*/ ('}')
		#define GET_STATEMENT_JMP_POINT /*-----------*/ (0)
		#define STORE_WHITESPACE_JMP_POINT /*--------*/ (1)
		#define CHECK_COMMENT_JMP_POINT /*-----------*/ (2)
		#define STORE_BAR_JMP_POINT /*---------------*/ (3)
		#define GET_DOUBLE_QUOTATION_JMP_POINT /*----*/ (4)
		#define GET_SINGLE_QUOTATION_JMP_POINT /*----*/ (5)
		#define HANDLE_ESCAPE_CHARACTER_JMP_POINT /*-*/ (6)
		#define ENTER_SCOPE_JMP_POINT /*-------------*/ (7)
		#define GET_STATEMENT_END_JMP_POINT /*-------*/ (8)
		statementCurrent = statementStart;
		statementConcreteWall = statementStart + statementSize * sizeof(char);
		statementLine = 0;
		itemAmount = 0;
		free(string0Return);
		popPointer(string0Token);
		free(string1Return);
		popPointer(string1Token);
		free(string2Return);
		popPointer(string2Token);
		free(string3Return);
		popPointer(string3Token);
		free(string4Return);
		popPointer(string4Token);
		free(image0Return.dataStart);
		popPointer(image0Return.dataToken);
		free(image1Return.dataStart);
		popPointer(image1Return.dataToken);
		free(image2Return.dataStart);
		popPointer(image2Return.dataToken);
		free(image3Return.dataStart);
		popPointer(image3Return.dataToken);
		free(image4Return.dataStart);
		popPointer(image4Return.dataToken);
		name0Instruction = NULL;
		name1Instruction = NULL;
		name2Instruction = NULL;
		name3Instruction = NULL;
		name4Instruction = NULL;
		nameList0Instruction = NULL;
		nameList1Instruction = NULL;
		nameList2Instruction = NULL;
		nameList3Instruction = NULL;
		nameList4Instruction = NULL;
		integer0Instruction = NULL;
		integer1Instruction = NULL;
		integer2Instruction = NULL;
		integer3Instruction = NULL;
		integer4Instruction = NULL;
		string0Instruction = NULL;
		string1Instruction = NULL;
		string2Instruction = NULL;
		string3Instruction = NULL;
		string4Instruction = NULL;
		image0Instruction = NULL;
		image1Instruction = NULL;
		image2Instruction = NULL;
		image3Instruction = NULL;
		image4Instruction = NULL;
		string0Return = NULL;
		string0Token = 0;
		string1Return = NULL;
		string1Token = 0;
		string2Return = NULL;
		string2Token = 0;
		string3Return = NULL;
		string3Token = 0;
		string4Return = NULL;
		string4Token = 0;
		image0Return.dataStart = NULL;
		image0Return.dataToken = 0;
		image1Return.dataStart = NULL;
		image1Return.dataToken = 0;
		image2Return.dataStart = NULL;
		image2Return.dataToken = 0;
		image3Return.dataStart = NULL;
		image3Return.dataToken = 0;
		image4Return.dataStart = NULL;
		image4Return.dataToken = 0;
		jmp getStatement;
	}
	getStatement: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp checkCommentStoreCharacter;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	getDoubleQuotation: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getDoubleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getDoubleQuotationStoreCharacter;
		to DQT_34: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getDoubleQuotationStoreCharacter;
	end
	getSingleQuotation: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getSingleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getSingleQuotationStoreCharacter;
		to SQT_39: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getSingleQuotationStoreCharacter;
	end
	handleEscapeCharacter: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to DQT_34: /*--*/ fileChar = '\"'; /*-----------------*/ jmp storeEscapedCharacter;
		to SQT_39: /*--*/ fileChar = '\''; /*-----------------*/ jmp storeEscapedCharacter;
		to ZER_48: /*--*/ fileChar = '\0'; /*-----------------*/ jmp storeEscapedCharacter;
		to QMK_63: /*--*/ fileChar = '\?'; /*-----------------*/ jmp storeEscapedCharacter;
		to BSL_92: /*--*/ fileChar = '\\'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOA_97: /*--*/ fileChar = '\a'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOB_98: /*--*/ fileChar = '\b'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOF_102: /*-*/ fileChar = '\f'; /*-----------------*/ jmp storeEscapedCharacter;
		to LON_110: /*-*/ fileChar = '\n'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOR_114: /*-*/ fileChar = '\r'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOT_116: /*-*/ fileChar = '\t'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOV_118: /*-*/ fileChar = '\v'; /*-----------------*/ jmp storeEscapedCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	checkComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to AST_42: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreSingleLineComment;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	ignoreMultipleLineComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to AST_42: /*--*/ /*----------------------------------*/ jmp checkMultipleLineCommentEnd;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	end
	checkMultipleLineCommentEnd: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	end
	ignoreSingleLineComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreSingleLineComment;
	end
	endOfFile:{
		if(statementCurrent == statementStart){
			jmp successfulConfig;
		}
		if(getPreviousConfigChar){
			getPreviousConfigChar(system);
		}
		jmp completeStatement;
	}
	storeWhitespace:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp getStatement;
		}
		inc itemAmount;
		fileChar = '\0';
		jmp getStatementStoreCharacter;
	}
	completeStatement:{
		if(statementCurrent <= statementStart){
			jmp getStatement;
		}
		if(!*(statementCurrent - 1)){
			jmp getStatementEnd;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = GET_STATEMENT_END_JMP_POINT;
		jmp storeCharacter;
	}
	handleOpeningBracket:{
		if(statementCurrent <= statementStart){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray opening bracket error", "could not enter nameless scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(*(statementCurrent - 1)){
			inc itemAmount;
			fileChar = '\0';
			jmpPoint = ENTER_SCOPE_JMP_POINT;
			jmp storeCharacter;
		}
		jmp enterScope;
	}
	enterScope:{
		StringTreeSystem *stringTreeSystem;
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(currentScopeInstruction == globalScopeInstruction){
			stringTreeSystem = &globalScopesInstructionStringTreeSystem;
		}else{
			printConfigError("invalid scope error", "no scopes inside current scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(!findStringTreeString(stringTreeSystem, &statementCurrent)){
			printConfigError("invalid scope error", "invalid scope name", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(itemAmount > 1){
			/*! missing space between final argument and scope imminent */
			printConfigError("scope argument error", "too many arguments", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, (void *)1, (void *)1, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		currentScopeInstruction = scope1ScopeInstruction;
		currentScopeInstructionData = scope1ScopeInstructionData;
		currentScopeInstructionList = scope1ScopeInstructionList;
		currentScopeInstructionStringTreeSystem = &scope1ScopeInstructionStringTreeSystem;
		currentScopeInstructionListSize = countof(scope1ScopeInstructionList) - 1;
		jmp getStatementStart;
	}
	attemptStoreBar:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp storeBar;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = STORE_BAR_JMP_POINT;
		jmp storeCharacter;
	}
	storeBar:{
		fileChar = '|';
		jmpPoint = STORE_WHITESPACE_JMP_POINT;
		jmp storeCharacter;
	}
	handleClosingBracket:{
		if(statementCurrent > statementStart){
			if(getNextConfigChar != &ifgetc){
				getPreviousConfigChar(system);
				jmp completeStatement;
			}
			fseek(configFile, -1, SEEK_CUR);
			jmp completeStatement;
		}
		if(currentScopeInstruction == globalScopeInstruction){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray closing bracket error", "could not drop to previous config scope", '}', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(currentScopeInstruction == scope1ScopeInstruction){
			currentScopeInstruction = globalScopeInstruction;
			currentScopeInstructionData = globalScopeInstructionData;
			currentScopeInstructionList = globalInstructionList;
			currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
			currentScopeInstructionListSize = countof(globalInstructionList) - 1;
		}
		jmp getStatementStart;
	}
	storeEscapedCharacter:{
		*(statementCurrent - 1) = fileChar;
		if(quote == '\"'){
			jmp getDoubleQuotation;
		}
		jmp getSingleQuotation;
	}
	getStatementStoreCharacter:{
		jmpPoint = GET_STATEMENT_JMP_POINT;
		jmp storeCharacter;
	}
	getDoubleQuotationStoreCharacter:{
		jmpPoint = GET_DOUBLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	getSingleQuotationStoreCharacter:{
		jmpPoint = GET_SINGLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	handleEscapeCharacterStoreCharacter:{
		jmpPoint = HANDLE_ESCAPE_CHARACTER_JMP_POINT;
		jmp storeCharacter;
	}
	checkCommentStoreCharacter:{
		jmpPoint = CHECK_COMMENT_JMP_POINT;
		jmp storeCharacter;
	}
	storeCharacter:{
		if(statementCurrent >= statementConcreteWall){
			const uint offset = statementCurrent - statementStart;
			void *temp;
			statementSize += STATEMENT_BLOCK_SIZE;
			temp = realloc(statementStart, statementSize * sizeof(char));
			updatePointer(statementToken, temp);
			if(!temp){
				printConfigError("memory allocation error", "could not allocate memory for config statement", ';', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				statementSize -= STATEMENT_BLOCK_SIZE;
				jmp getStatementStart;
			}
			statementStart = temp;
			statementCurrent = statementStart + offset;
			statementConcreteWall = statementStart + statementSize * sizeof(char);
		}
		if(jmpPoint != CHECK_COMMENT_JMP_POINT and !statementLine){
			statementLine = fileLine;
		}
		*statementCurrent = fileChar;
		inc statementCurrent;
		switch jmpPoint over
			to GET_STATEMENT_JMP_POINT: /*-----------*/ jmp getStatement;
			to STORE_WHITESPACE_JMP_POINT: /*--------*/ jmp storeWhitespace;
			to CHECK_COMMENT_JMP_POINT: /*-----------*/ jmp checkComment;
			to STORE_BAR_JMP_POINT: /*---------------*/ jmp storeBar;
			to GET_DOUBLE_QUOTATION_JMP_POINT: /*----*/ jmp getDoubleQuotation;
			to GET_SINGLE_QUOTATION_JMP_POINT: /*----*/ jmp getSingleQuotation;
			to HANDLE_ESCAPE_CHARACTER_JMP_POINT: /*-*/ jmp handleEscapeCharacter;
			to ENTER_SCOPE_JMP_POINT: /*-------------*/ jmp enterScope;
			off: /*----------------------------------*/ jmp getStatementEnd;
		end
	}
	getStatementEnd:{
		if(statementCurrent > statementStart) /*-*/ jmp findStatement;
		if(!feof(configFile)) /*-----------------*/ jmp getStatementStart;
		/*---------------------------------------*/ jmp successfulConfig;
		#undef  GET_STATEMENT_END_JMP_POINT
		#undef  ENTER_SCOPE_JMP_POINT
		#undef  HANDLE_ESCAPE_CHARACTER_JMP_POINT
		#undef  GET_SINGLE_QUOTATION_JMP_POINT
		#undef  GET_DOUBLE_QUOTATION_JMPPOINT
		#undef  STORE_BAR_JMP_POINT
		#undef  CHECK_COMMENT_JMP_POINT
		#undef  STORE_WHITESPACE_JMP_POINT
		#undef  GET_STATEMENT_JMP_POINT
		#undef  CCB_125
		#undef  BAR_124
		#undef  OCB_123
		#undef  LOV_118
		#undef  LOT_116
		#undef  LOR_114
		#undef  LON_110
		#undef  LOF_102
		#undef  LOB_98
		#undef  LOA_97
		#undef  BSL_92
		#undef  QMK_63
		#undef  SCL_59
		#undef  ZER_48
		#undef  FSL_47
		#undef  AST_42
		#undef  SQT_39
		#undef  DQT_34
		#undef  SPC_32
		#undef  ESC_27
		#undef  CRE_13
		#undef  FFD_12
		#undef  VTB_11
		#undef  NLN_10
		#undef  TAB_09
		#undef  BSP_08
		#undef  ALR_07
		#undef  EOT_04
		#undef  ZER_00
		#undef  EOF_N1
	}
	findStatement:{
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(!findStringTreeString(currentScopeInstructionStringTreeSystem, &statementCurrent)){
			printConfigError("config error", "unrecognized instruction", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp printAllInstructionPatterns;
		}
		instructionStart = *(currentScopeInstruction + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionStartCopy = instructionStart;
		instructionCurrent = instructionStart;
		instructionDataStart = *(currentScopeInstructionData + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionDataStartCopy = instructionDataStart;
		instructionDataCurrent = instructionDataStart;
		if(*instructionCurrent == NONE_INSTRUCTION_TYPE){
			jmp unimplementedInstruction;
		}
		if(statementCurrent >= statementWall and *instructionCurrent != END_INSTRUCTION_TYPE){
			printConfigError("config error", "missing instruction body", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		inc statementCurrent;
		jmp switchInstructionLoop;
	}
	switchInstructionLoop: switch *instructionCurrent over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp unimplementedInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp matchName;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp matchNameList;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp matchInteger;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp matchString;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp matchImageString;
		off: /*---------------------------*/ jmp endOfInstruction;
	end
	unimplementedInstruction:{
		printConfigError("implementation error", "using unimplemented instruction", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchName:{
		char *s;
		uint8 *namePointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!name0Instruction){
			namePointer = &name0Return;
			name0Instruction = instructionCurrent;
		}elif(!name1Instruction){
			namePointer = &name1Return;
			name1Instruction = instructionCurrent;
		}elif(!name2Instruction){
			namePointer = &name2Return;
			name2Instruction = instructionCurrent;
		}elif(!name3Instruction){
			namePointer = &name3Return;
			name3Instruction = instructionCurrent;
		}else{
			namePointer = &name4Return;
			name4Instruction = instructionCurrent;
		}
		s = statementCurrent;
		if(!findStringTreeString(*instructionDataCurrent, &s)){
			printConfigError("match string error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		statementCurrent = s;
		inc statementCurrent;
		*namePointer = (**instructionDataCurrent).returnedCounter;
		jmp advanceDataInstruction;
	}
	matchNameList:{
		uint8 *nameListPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!nameList0Instruction){
			nameListPointer = &nameList0Return;
			nameList0Instruction = instructionCurrent;
		}elif(!nameList1Instruction){
			nameListPointer = &nameList1Return;
			nameList1Instruction = instructionCurrent;
		}elif(!nameList2Instruction){
			nameListPointer = &nameList2Return;
			nameList2Instruction = instructionCurrent;
		}elif(!nameList3Instruction){
			nameListPointer = &nameList3Return;
			nameList3Instruction = instructionCurrent;
		}else{
			nameListPointer = &nameList4Return;
			nameList4Instruction = instructionCurrent;
		}
		switch matchNameList(*instructionDataCurrent, statementWall, &statementCurrent, nameListPointer) over
			to INVALID_NAME_NAME_LIST: /*--*/ jmp invalidNameNameList;
			to PREMATURE_END_NAME_LIST: /*-*/ jmp prematureEndNameList;
			off: /*------------------------*/ jmp advanceDataInstruction;
		end
	}
	invalidNameNameList:{
		printConfigError("bar list error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	prematureEndNameList:{
		printConfigError("bar list error", "missing final name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchInteger:{
		int64 *integerPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!integer0Instruction){
			integerPointer = &integer0Return;
			integer0Instruction = instructionCurrent;
		}elif(!integer1Instruction){
			integerPointer = &integer1Return;
			integer1Instruction = instructionCurrent;
		}elif(!integer2Instruction){
			integerPointer = &integer2Return;
			integer2Instruction = instructionCurrent;
		}elif(!integer3Instruction){
			integerPointer = &integer3Return;
			integer3Instruction = instructionCurrent;
		}else{
			integerPointer = &integer4Return;
			integer4Instruction = instructionCurrent;
		}
		switch matchInteger(&statementCurrent, statementWall, integerPointer) over
			to NON_NUMBER_NUMBER: /*-------*/ jmp printNonNumberError;
			to OVERFLOWN_NUMBER_NUMBER: /*-*/ jmp printOverflownNumberError;
			to DIVIDED_BY_ZERO_NUMBER: /*--*/ jmp printDividedByZeroNumberError;
			off: /*------------------------*/ jmp advanceInstruction;
		end
	}
	printNonNumberError:{
		printConfigError("match integer error", "not a number", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printOverflownNumberError:{
		printConfigError("match integer error", "integer overflow", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printDividedByZeroNumberError:{
		printConfigError("match integer error", "integer divided by zero", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchString:{
		char **stringPointer;
		uint32 *stringTokenPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!string0Instruction){
			stringPointer = &string0Return;
			stringTokenPointer = &string0Token;
			string0Instruction = instructionCurrent;
		}elif(!string1Instruction){
			stringPointer = &string1Return;
			stringTokenPointer = &string1Token;
			string1Instruction = instructionCurrent;
		}elif(!string2Instruction){
			stringPointer = &string2Return;
			stringTokenPointer = &string2Token;
			string2Instruction = instructionCurrent;
		}elif(!string3Instruction){
			stringPointer = &string3Return;
			stringTokenPointer = &string3Token;
			string3Instruction = instructionCurrent;
		}else{
			stringPointer = &string4Return;
			stringTokenPointer = &string4Token;
			string4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, stringPointer, stringTokenPointer)){
			printConfigError("match string error", "could not allocate string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		jmp advanceInstruction;
	}
	matchImageString:{
		char *string = NULL;
		uint32 token = 0;
		Image *imagePointer;
		uint8 matchImageReturn;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!image0Instruction){
			imagePointer = &image0Return;
			image0Instruction = instructionCurrent;
		}elif(!image1Instruction){
			imagePointer = &image1Return;
			image1Instruction = instructionCurrent;
		}elif(!image2Instruction){
			imagePointer = &image2Return;
			image2Instruction = instructionCurrent;
		}elif(!image3Instruction){
			imagePointer = &image3Return;
			image3Instruction = instructionCurrent;
		}else{
			imagePointer = &image4Return;
			image4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, &string, &token)){
			printConfigError("match image error", "could not allocate image string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		matchImageReturn = matchImage(string, &imageErrorMessage, &image0Return);
		free(string);
		popPointer(token);
		switch matchImageReturn over
			to CANNOT_OPEN_MATCH_IMAGE: /*--------*/ jmp printCannotOpenReadConfig;
			to CANNOT_READ_MATCH_IMAGE: /*--------*/ jmp printCannotReadReadConfig;
			to UNSUPPORTED_FORMAT_MATCH_IMAGE: /*-*/ jmp printUnsupportedFormatReadConfig;
			to BAD_HEADER_MATCH_IMAGE: /*---------*/ jmp printBadHeaderReadConfig;
			to BAD_DEPTH_MATCH_IMAGE: /*----------*/ jmp printBadDepthReadConfig;
			to BAD_COMPRESSION_MATCH_IMAGE: /*----*/ jmp printBadCompressionReadConfig;
			to UNSUPPORTED_HEIGHT_MATCH_IMAGE: /*-*/ jmp printUnsupportedHeightReadConfig;
			to BAD_SIZE_MATCH_IMAGE: /*-----------*/ jmp printBadSizeReadConfig;
			to FAILED_MATCH_IMAGE: /*-------------*/ jmp printFailedReadConfig;
			to BAD_PIXELS_MATCH_IMAGE: /*---------*/ jmp printBadPixelsReadConfig;
			to BAD_IMAGE_MATCH_IMAGE: /*----------*/ jmp printBadImageReadConfig;
			off: /*-------------------------------*/ jmp advanceInstruction;
		end
	}
	printCannotOpenReadConfig:{
		printConfigError("match image error", "could not open image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printCannotReadReadConfig:{
		printConfigError("match image error", "could not read image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedFormatReadConfig:{
		printConfigError("match image error", "image file not bmp", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadHeaderReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadDepthReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadCompressionReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedHeightReadConfig:{
		printConfigError("match image error", "negative height is not supported", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadSizeReadConfig:{
		printConfigError("match image error", "could not traverse image past the header", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printFailedReadConfig:{
		printConfigError("match image error", "could not allocate pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadPixelsReadConfig:{
		printConfigError("match image error", "could not read pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadImageReadConfig:{
		printConfigError("match image error", "image is broken", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	endOfInstruction:{
		if(instructionStart == setInstruction){
			#define applySubinstruction(s, i) /*-*/ instructionStart = s##i##Subinstruction; instructionDataStart = s##i##SubinstructionData
			switch name0Return over
				to WINDOW_X_VARIABLE: /*--------------------*/ applySubinstruction(windowX, Set); /*-------------------*/ jmp assessSubinstruction;
				to WINDOW_Y_VARIABLE: /*--------------------*/ applySubinstruction(windowY, Set); /*-------------------*/ jmp assessSubinstruction;
				to WINDOW_X_OFFSET_VARIABLE: /*-------------*/ applySubinstruction(windowXOffset, Set); /*-------------*/ jmp assessSubinstruction;
				to WINDOW_Y_OFFSET_VARIABLE: /*-------------*/ applySubinstruction(windowYOffset, Set); /*-------------*/ jmp assessSubinstruction;
				to WINDOW_WIDTH_VARIABLE: /*----------------*/ applySubinstruction(windowWidth, Set); /*---------------*/ jmp assessSubinstruction;
				to WINDOW_HEIGHT_VARIABLE: /*---------------*/ applySubinstruction(windowHeight, Set); /*--------------*/ jmp assessSubinstruction;
				to WINDOW_POSITION_VARIABLE: /*-------------*/ applySubinstruction(windowPosition, Set); /*------------*/ jmp assessSubinstruction;
				to WINDOW_HORIZONTAL_ALIGNMENT_VARIABLE: /*-*/ applySubinstruction(windowHorizontalAlignment, Set); /*-*/ jmp assessSubinstruction;
				to WINDOW_VERTICAL_ALIGNMENT_VARIABLE: /*---*/ applySubinstruction(windowVerticalAlignment, Set); /*---*/ jmp assessSubinstruction;
				to WINDOW_BACKGROUND_VARIABLE: /*-----------*/ applySubinstruction(windowBackground, Set); /*----------*/ jmp assessSubinstruction;
				to TEXT_X_1_VARIABLE: /*--------------------*/ applySubinstruction(textX1, Set); /*--------------------*/ jmp assessSubinstruction;
				to TEXT_Y_1_VARIABLE: /*--------------------*/ applySubinstruction(textY1, Set); /*--------------------*/ jmp assessSubinstruction;
				to TEXT_X_OFFSET_1_VARIABLE: /*-------------*/ applySubinstruction(textXOffset1, Set); /*--------------*/ jmp assessSubinstruction;
				to TEXT_Y_OFFSET_1_VARIABLE: /*-------------*/ applySubinstruction(textYOffset1, Set); /*--------------*/ jmp assessSubinstruction;
				to TEXT_HORIZONTAL_ALIGNMENT_1_VARIABLE: /*-*/ applySubinstruction(textHorizontalAlignment1, Set); /*--*/ jmp assessSubinstruction;
				to TEXT_VERTICAL_ALIGNMENT_1_VARIABLE: /*---*/ applySubinstruction(textVerticalAlignment1, Set); /*----*/ jmp assessSubinstruction;
				to TEXT_ROTATION_1_VARIABLE: /*-------------*/ applySubinstruction(textRotation1, Set); /*-------------*/ jmp assessSubinstruction;
				to TEXT_FOREGROUND_1_VARIABLE: /*-----------*/ applySubinstruction(textForeground1, Set); /*-----------*/ jmp assessSubinstruction;
				to TEXT_BACKGROUND_1_VARIABLE: /*-----------*/ applySubinstruction(textBackground1, Set); /*-----------*/ jmp assessSubinstruction;
				to TEXT_X_2_VARIABLE: /*--------------------*/ applySubinstruction(textX2, Set); /*--------------------*/ jmp assessSubinstruction;
				to TEXT_Y_2_VARIABLE: /*--------------------*/ applySubinstruction(textY2, Set); /*--------------------*/ jmp assessSubinstruction;
				to TEXT_X_OFFSET_2_VARIABLE: /*-------------*/ applySubinstruction(textXOffset2, Set); /*--------------*/ jmp assessSubinstruction;
				to TEXT_Y_OFFSET_2_VARIABLE: /*-------------*/ applySubinstruction(textYOffset2, Set); /*--------------*/ jmp assessSubinstruction;
				to TEXT_HORIZONTAL_ALIGNMENT_2_VARIABLE: /*-*/ applySubinstruction(textHorizontalAlignment2, Set); /*--*/ jmp assessSubinstruction;
				to TEXT_VERTICAL_ALIGNMENT_2_VARIABLE: /*---*/ applySubinstruction(textVerticalAlignment2, Set); /*----*/ jmp assessSubinstruction;
				to TEXT_ROTATION_2_VARIABLE: /*-------------*/ applySubinstruction(textRotation2, Set); /*-------------*/ jmp assessSubinstruction;
				to TEXT_FOREGROUND_2_VARIABLE: /*-----------*/ applySubinstruction(textForeground2, Set); /*-----------*/ jmp assessSubinstruction;
				to TEXT_BACKGROUND_2_VARIABLE: /*-----------*/ applySubinstruction(textBackground2, Set); /*-----------*/ jmp assessSubinstruction;
				to TEXT_X_3_VARIABLE: /*--------------------*/ applySubinstruction(textX3, Set); /*--------------------*/ jmp assessSubinstruction;
				to TEXT_Y_3_VARIABLE: /*--------------------*/ applySubinstruction(textY3, Set); /*--------------------*/ jmp assessSubinstruction;
				to TEXT_X_OFFSET_3_VARIABLE: /*-------------*/ applySubinstruction(textXOffset3, Set); /*--------------*/ jmp assessSubinstruction;
				to TEXT_Y_OFFSET_3_VARIABLE: /*-------------*/ applySubinstruction(textYOffset3, Set); /*--------------*/ jmp assessSubinstruction;
				to TEXT_HORIZONTAL_ALIGNMENT_3_VARIABLE: /*-*/ applySubinstruction(textHorizontalAlignment3, Set); /*--*/ jmp assessSubinstruction;
				to TEXT_VERTICAL_ALIGNMENT_3_VARIABLE: /*---*/ applySubinstruction(textVerticalAlignment3, Set); /*----*/ jmp assessSubinstruction;
				to TEXT_ROTATION_3_VARIABLE: /*-------------*/ applySubinstruction(textRotation3, Set); /*-------------*/ jmp assessSubinstruction;
				to TEXT_FOREGROUND_3_VARIABLE: /*-----------*/ applySubinstruction(textForeground3, Set); /*-----------*/ jmp assessSubinstruction;
				to TEXT_BACKGROUND_3_VARIABLE: /*-----------*/ applySubinstruction(textBackground3, Set); /*-----------*/ jmp assessSubinstruction;
				to TRAY_WINDOW_X_VARIABLE: /*---------------*/ applySubinstruction(trayWindowX, Set); /*---------------*/ jmp assessSubinstruction;
				to TRAY_WINDOW_Y_VARIABLE: /*---------------*/ applySubinstruction(trayWindowY, Set); /*---------------*/ jmp assessSubinstruction;
				to TRAY_WINDOW_X_OFFSET_VARIABLE: /*--------*/ applySubinstruction(trayWindowXOffset, Set); /*---------*/ jmp assessSubinstruction;
				to TRAY_WINDOW_Y_OFFSET_VARIABLE: /*--------*/ applySubinstruction(trayWindowYOffset, Set); /*---------*/ jmp assessSubinstruction;
				to TRAY_WINDOW_BACKGROUND_VARIABLE: /*------*/ applySubinstruction(trayWindowBackground, Set); /*------*/ jmp assessSubinstruction;
				to TRAY_ICON_X_OFFSET_VARIABLE: /*----------*/ applySubinstruction(trayIconXOffset, Set); /*-----------*/ jmp assessSubinstruction;
				to TRAY_ICON_Y_OFFSET_VARIABLE: /*----------*/ applySubinstruction(trayIconYOffset, Set); /*-----------*/ jmp assessSubinstruction;
				to TRAY_ICON_SIZE_VARIABLE: /*--------------*/ applySubinstruction(trayIconSize, Set); /*--------------*/ jmp assessSubinstruction;
				to TRAY_ICON_PADDING_VARIABLE: /*-----------*/ applySubinstruction(trayIconPadding, Set); /*-----------*/ jmp assessSubinstruction;
				to COMMAND_1_VARIABLE: /*-------------------*/ applySubinstruction(command1, Set); /*------------------*/ jmp assessSubinstruction;
				to COMMAND_2_VARIABLE: /*-------------------*/ applySubinstruction(command2, Set); /*------------------*/ jmp assessSubinstruction;
				to COMMAND_3_VARIABLE: /*-------------------*/ applySubinstruction(command3, Set); /*------------------*/ jmp assessSubinstruction;
				to INTERVAL_VARIABLE: /*--------------------*/ applySubinstruction(interval, Set); /*------------------*/ jmp assessSubinstruction;
				to FONT_VARIABLE: /*------------------------*/ applySubinstruction(font, Set); /*----------------------*/ jmp assessSubinstruction;
				off: /*-------------------------------------*/ /*------------------------------------------------------*/ brk;
			end
		}
		if(instructionStart == doInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, Do); jmp assessSubinstruction;
				off: /*----------------*/ /*-----------------------------*/ brk;
			end
		}
		if(instructionStart == grabKeycodeInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabKeycode); jmp assessSubinstruction;
				off: /*----------------*/ /*--------------------------------------*/ brk;
			end
		}
		if(instructionStart == grabButtonInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabButton); jmp assessSubinstruction;
				off: /*----------------*/ /*-------------------------------------*/ brk;
			end
			#undef  applySubinstruction
		}
		if(statementCurrent < statementWall){
			printConfigError("config error", "extra parameters error", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(instructionStartCopy == helpInstruction){
			printError("%s%s: %s: line %u: %s%s:%s %s:\n", colorStart, programName, configPath, statementLine, colorError, "config help menu", colorEnd, displaySimpleConfigErrors? "contracted" : "expanded");
			jmp printAllInstructionPatterns;
		}
		if(instructionStartCopy == expandInstruction){
			displaySimpleConfigErrors = false;
			jmp getStatementStart;
		}
		if(instructionStartCopy == contractInstruction){
			displaySimpleConfigErrors = true;
			jmp getStatementStart;
		}
		if(instructionStartCopy == readConfigInstruction){
			readConfig(false, string0Return, &ifgetc, NULL);
			jmp getStatementStart;
		}
		if(instructionStartCopy == useTerminalInstruction){
			switch name0Return over
				to TRUE_BOOLEAN:{
					if(!connectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == useMessengerInstruction){
			switch name0Return over
				to TRUE_BOOLEAN:{
					if(!connectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == acquireSystemTrayInstruction){
			switch name0Return over
				to TRUE_BOOLEAN:{
					if(!acquireTraySelection(&traySystem)){
						printConfigError("config error", "could not acquire tray selection", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					if(windowSystem.windowInfoStart){
						setTrayParent(&traySystem, (*windowSystem.windowInfoStart).window);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!loseTraySelection(&traySystem)){
						printConfigError("config error", "could not lose tray selection", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					setTrayParent(&traySystem, XCB_NONE);
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == setInstruction){
			switch name0Return over
				to WINDOW_X_VARIABLE:{
					windowPreferences.x = integer0Return;
					windowPreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_Y_VARIABLE:{
					windowPreferences.y = integer0Return;
					windowPreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_X_OFFSET_VARIABLE:{
					windowPreferences.xOffset = integer0Return;
					windowPreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_Y_OFFSET_VARIABLE:{
					windowPreferences.yOffset = integer0Return;
					windowPreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_WIDTH_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					windowPreferences.width = integer0Return;
					windowPreferences.widthType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_HEIGHT_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					windowPreferences.height = integer0Return;
					windowPreferences.heightType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_POSITION_VARIABLE:{
					windowPreferences.position = name1Return;
					if(setTrayPosition(&traySystem, windowPreferences.position)){
						changeTrayOrientationProperty(&traySystem);
					}
					jmp getStatementStart;
				}
				to WINDOW_HORIZONTAL_ALIGNMENT_VARIABLE:{
					windowPreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_VERTICAL_ALIGNMENT_VARIABLE:{
					windowPreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_BACKGROUND_VARIABLE:{
					windowPreferences.background = integer0Return;
					jmp getStatementStart;
				}
				to TEXT_X_1_VARIABLE:{
					textPreferences1.x = integer0Return;
					textPreferences1.xType = name1Return;
					jmp getStatementStart;
				}
				to TEXT_Y_1_VARIABLE:{
					textPreferences1.y = integer0Return;
					textPreferences1.yType = name1Return;
					jmp getStatementStart;
				}
				to TEXT_X_OFFSET_1_VARIABLE:{
					textPreferences1.xOffset = integer0Return;
					textPreferences1.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to TEXT_Y_OFFSET_1_VARIABLE:{
					textPreferences1.yOffset = integer0Return;
					textPreferences1.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to TEXT_HORIZONTAL_ALIGNMENT_1_VARIABLE:{
					textPreferences1.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to TEXT_VERTICAL_ALIGNMENT_1_VARIABLE:{
					textPreferences1.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to TEXT_ROTATION_1_VARIABLE:{
					textRotation1 = name1Return;
					jmp getStatementStart;
				}
				to TEXT_FOREGROUND_1_VARIABLE:{
					textPreferences1.foreground = integer0Return;
					jmp getStatementStart;
				}
				to TEXT_BACKGROUND_1_VARIABLE:{
					textPreferences1.background = integer0Return;
					jmp getStatementStart;
				}
				to TEXT_X_2_VARIABLE:{
					textPreferences2.x = integer0Return;
					textPreferences2.xType = name1Return;
					jmp getStatementStart;
				}
				to TEXT_Y_2_VARIABLE:{
					textPreferences2.y = integer0Return;
					textPreferences2.yType = name1Return;
					jmp getStatementStart;
				}
				to TEXT_X_OFFSET_2_VARIABLE:{
					textPreferences2.xOffset = integer0Return;
					textPreferences2.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to TEXT_Y_OFFSET_2_VARIABLE:{
					textPreferences2.yOffset = integer0Return;
					textPreferences2.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to TEXT_HORIZONTAL_ALIGNMENT_2_VARIABLE:{
					textPreferences2.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to TEXT_VERTICAL_ALIGNMENT_2_VARIABLE:{
					textPreferences2.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to TEXT_ROTATION_2_VARIABLE:{
					textRotation2 = name1Return;
					jmp getStatementStart;
				}
				to TEXT_FOREGROUND_2_VARIABLE:{
					textPreferences2.foreground = integer0Return;
					jmp getStatementStart;
				}
				to TEXT_BACKGROUND_2_VARIABLE:{
					textPreferences2.background = integer0Return;
					jmp getStatementStart;
				}
				to TEXT_X_3_VARIABLE:{
					textPreferences3.x = integer0Return;
					textPreferences3.xType = name1Return;
					jmp getStatementStart;
				}
				to TEXT_Y_3_VARIABLE:{
					textPreferences3.y = integer0Return;
					textPreferences3.yType = name1Return;
					jmp getStatementStart;
				}
				to TEXT_X_OFFSET_3_VARIABLE:{
					textPreferences3.xOffset = integer0Return;
					textPreferences3.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to TEXT_Y_OFFSET_3_VARIABLE:{
					textPreferences3.yOffset = integer0Return;
					textPreferences3.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to TEXT_HORIZONTAL_ALIGNMENT_3_VARIABLE:{
					textPreferences3.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to TEXT_VERTICAL_ALIGNMENT_3_VARIABLE:{
					textPreferences3.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to TEXT_ROTATION_3_VARIABLE:{
					textRotation3 = name1Return;
					jmp getStatementStart;
				}
				to TEXT_FOREGROUND_3_VARIABLE:{
					textPreferences3.foreground = integer0Return;
					jmp getStatementStart;
				}
				to TEXT_BACKGROUND_3_VARIABLE:{
					textPreferences3.background = integer0Return;
					jmp getStatementStart;
				}
				to TRAY_WINDOW_X_VARIABLE:{
					setTrayWindowX(&traySystem, integer0Return);
					jmp getStatementStart;
				}
				to TRAY_WINDOW_Y_VARIABLE:{
					setTrayWindowY(&traySystem, integer0Return);
					jmp getStatementStart;
				}
				to TRAY_WINDOW_X_OFFSET_VARIABLE:{
					setTrayWindowXOffset(&traySystem, integer0Return);
					jmp getStatementStart;
				}
				to TRAY_WINDOW_Y_OFFSET_VARIABLE:{
					setTrayWindowYOffset(&traySystem, integer0Return);
					jmp getStatementStart;
				}
				to TRAY_WINDOW_BACKGROUND_VARIABLE:{
					setTrayWindowBackground(&traySystem, integer0Return);
					jmp getStatementStart;
				}
				to TRAY_ICON_X_OFFSET_VARIABLE:{
					setTrayIconWindowXOffset(&traySystem, integer0Return);
					jmp getStatementStart;
				}
				to TRAY_ICON_Y_OFFSET_VARIABLE:{
					setTrayIconWindowYOffset(&traySystem, integer0Return);
					jmp getStatementStart;
				}
				to TRAY_ICON_SIZE_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					setTrayIconWindowSize(&traySystem, integer0Return);
					jmp getStatementStart;
				}
				to TRAY_ICON_PADDING_VARIABLE:{
					setTrayIconWindowPadding(&traySystem, integer0Return);
					jmp getStatementStart;
				}
				to COMMAND_1_VARIABLE:{
					if(setVisualBufferCommand(&visualBufferSystem1, string0Return, string0Token)){
						string0Return = NULL;
						string0Token = 0;
					}
					jmp getStatementStart;
				}
				to COMMAND_2_VARIABLE:{
					if(setVisualBufferCommand(&visualBufferSystem2, string0Return, string0Token)){
						string0Return = NULL;
						string0Token = 0;
					}
					jmp getStatementStart;
				}
				to COMMAND_3_VARIABLE:{
					if(setVisualBufferCommand(&visualBufferSystem3, string0Return, string0Token)){
						string0Return = NULL;
						string0Token = 0;
					}
					jmp getStatementStart;
				}
				to INTERVAL_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					setSleepThreadSleepTime(&sleepThreadSystem, integer0Return);
					jmp getStatementStart;
				}
				to FONT_VARIABLE:{
					if(!setVisualBufferFont(&visualBufferSystem1, string0Return) or !setVisualBufferFont(&visualBufferSystem2, string0Return) or !setVisualBufferFont(&visualBufferSystem3, string0Return)){
						printError("%s%s: %s%s:%s %s \"%s\"\n", colorStart, programName, colorError, "open font error", colorEnd, "could not open font", string0Return);
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == doInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			end
			switch matchCommand(name0Return, string0Return, getNextConfigChar == &ifgetc? CONFIG_MATCH_COMMAND_ORIGIN : getNextConfigChar == &getNextSTDINCharacter? STDIN_MATCH_COMMAND_ORIGIN : TRANSMITTER_MATCH_COMMAND_ORIGIN, field0, field1, field2, field3, field4) over
				to TYPICAL_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to RESTART_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to EXIT_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				off:{
					printConfigError("config error", "do subinstruction not implemented yet", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionStart, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == grabKeycodeInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			end
			if(!insertShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_key_checked(connection, true, (*screen).root, nameList0Return, integer0Return, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab key on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == grabButtonInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			end
			if(!insertShortcut(&buttonShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_button_checked(connection, true, (*screen).root, XCB_EVENT_MASK_NO_EVENT, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, integer0Return, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab button on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabKeycodeInstruction){
			if(!removeShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find key to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_key_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab key from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabButtonInstruction){
			if(!removeShortcut(&buttonShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find button to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_button_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab button from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == stopInstruction){
			jmp successfulConfig;
		}
		jmp getStatementStart;
	}
	advanceInstruction:{
		inc instructionCurrent;
		jmp switchInstructionLoop;
	}
	advanceDataInstruction:{
		inc instructionCurrent;
		inc instructionDataCurrent;
		jmp switchInstructionLoop;
	}
	assessSubinstruction:{
		instructionCurrent = instructionStart + (instructionCurrent - instructionStartCopy);
		instructionDataCurrent = instructionDataStart + (instructionDataCurrent - instructionDataStartCopy);
		if(statementCurrent < statementWall){
			jmp switchInstructionLoop;
		}
		jmp printMissingArgumentError;
	}
	printMissingArgumentError:{
		printConfigError("config error", "missing argument error", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printAllInstructionPatterns:{
		const char *const *const wall = currentScopeInstructionList + currentScopeInstructionListSize;
		const char *const *current = currentScopeInstructionList;
		const Instruction *const *in = currentScopeInstruction;
		StringTreeSystem *const *const *da = currentScopeInstructionData;
		jmp printExpandedHelpInstructions;
		printExpandedHelpInstructions:{
			const Instruction *n = *in - 1;
			StringTreeSystem *const *d = *da;
			printError("\tpattern | %s", *current);
			jmp printHelpInstructionParametersLoop;
			printHelpInstructionParametersLoop: switch *(inc n) over
				to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
				to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
				to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
				to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
				to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
				to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
				off: /*---------------------------*/ jmp printHelpInstructionParametersLoopExit;
			end
			noneInstruction:{
				printError(" <unimplemented>");
				jmp printHelpInstructionParametersLoopExit;
			}
			nameInstruction:{
				if(displaySimpleConfigErrors){
					printError(" name");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" (%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
					printNameLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameLoop;
						}
						printError(")");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			nameListInstruction:{
				if(displaySimpleConfigErrors){
					printError(" list");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" ((%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
					printNameListOnceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListOnceLoop;
						}
						stringArray = (**d).stringArray;
						printError(")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
						inc stringArray;
						jmp printNameListTwiceLoop;
					}
					printNameListTwiceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListTwiceLoop;
						}
						printError("))*(?![\\s]*[|]))");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			numberInstruction:{
				if(displaySimpleConfigErrors){
					printError(" number");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
				jmp printHelpInstructionParametersLoop;
			}
			stringInstruction:{
				if(displaySimpleConfigErrors){
					printError(" string");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
			imageInstruction:{
				if(displaySimpleConfigErrors){
					printError(" image");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
		}
		printHelpInstructionParametersLoopExit:{
			inc in;
			inc da;
			if(displaySimpleConfigErrors){
				printError("\n");
			}else{
				printError(" $\n");
			}
			if(inc current < wall){
				jmp printExpandedHelpInstructions;
			}
			printError("\n");
			jmp getStatementStart;
		}
	}
	successfulConfig:{
		if(currentScopeInstruction != globalScopeInstruction){
			*statementCurrent = '\0';
			statementWall = statementCurrent;
			statementLine = fileLine;
			if(fileLine != 1){
				dec statementLine;
			}
			printConfigError("config error", "missing closing scope bracket", '\0', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		jmp configEmergencyExit;
	}
	configEmergencyExit:{
		if(configFile and fileLine == 1 and !statementLine){
			printConfigError("config warning", "empty config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		free(statementStart);
		popPointer(statementToken);
		if(configFile){
			fclose(configFile);
			popPointer(configFileToken);
		}
		jmp postReadConfig;
	}
	postReadConfig:{
		if(!configureWindows(&windowSystem, &monitorSystem, &windowPreferences, whichMonitor)){
			if(windowSystem.mapped){
				drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
			}
		}
		xcb_flush(connection);
		ret;
	}
	#undef  DEFAULT_CONFIG_PATH
	#undef  STATEMENT_BLOCK_SIZE
}
MATCHANSISEQUENCE(){
	#define ASCII_TO_UCS2(c) /*----------*/ ((c) << 8)
	#define BLACK_ANSI_COLOR /*----------*/ (0xFF000000)
	#define RED_ANSI_COLOR /*------------*/ (0xFFCD0000)
	#define GREEN_ANSI_COLOR /*----------*/ (0xFF00CD00)
	#define YELLOW_ANSI_COLOR /*---------*/ (0xFFCDCD00)
	#define BLUE_ANSI_COLOR /*-----------*/ (0xFF0000CD)
	#define MAGENTA_ANSI_COLOR /*--------*/ (0xFFCD00CD)
	#define CYAN_ANSI_COLOR /*-----------*/ (0xFF00CDCD)
	#define WHITE_ANSI_COLOR /*----------*/ (0xFFE5E5E5)
	#define BRIGHT_BLACK_ANSI_COLOR /*---*/ (0xFF7F7F7F)
	#define BRIGHT_RED_ANSI_COLOR /*-----*/ (0xFFFF0000)
	#define BRIGHT_GREEN_ANSI_COLOR /*---*/ (0xFF00FF00)
	#define BRIGHT_YELLOW_ANSI_COLOR /*--*/ (0xFFFFFF00)
	#define BRIGHT_BLUE_ANSI_COLOR /*----*/ (0xFF0000FF)
	#define BRIGHT_MAGENTA_ANSI_COLOR /*-*/ (0xFFFF00FF)
	#define BRIGHT_CYAN_ANSI_COLOR /*----*/ (0xFF00FFFF)
	#define BRIGHT_WHITE_ANSI_COLOR /*---*/ (0xFFFFFFFF)
	uint16 *s;
	uint code;
	ANSIAttributes attributes;
	bool hasReachedEnd;
	if(!string or !attributesReturn){
		ret NULL;
	}
	if(*string != ASCII_TO_UCS2('\x1b') or *(string + 1) != ASCII_TO_UCS2('[')){
		ret string;
	}
	attributes = attributesInUse;
	s = string + 2;
	hasReachedEnd = false;
	jmp pieceTogetherCode;
	pieceTogetherCode:{
		const uint16 *const sStart = s;
		code = 0;
		jmp pieceTogetherCodeLoop;
		pieceTogetherCodeLoop:{
			uint16 c = *s;
			if(c & b(0000000011111111)){
				ret NULL;
			}
			c >>= 8;
			if(c >= '0' and c <= '9'){
				code = code * 10 + c - 48;
				inc s;
				jmp pieceTogetherCodeLoop;
			}
			if(c == ';'){
				if(s == sStart){
					ret NULL;
				}
				inc s;
				jmp matchCode;
			}
			if(c == 'm'){
				hasReachedEnd = true;
				inc s;
				jmp matchCode;
			}
			ret NULL;
		}
	}
	matchCode:{
		if(code > 107){
			ret NULL;
		}
		switch code over
			to 0: /*---*/ /*-----------------------------------------------------*/ jmp resetAttributes;
			to 7: /*---*/ /*-----------------------------------------------------*/ jmp swapForegroundBackground;
			to 30: /*--*/ attributes.foreground = BLACK_ANSI_COLOR; /*-----------*/ jmp advancePointer;
			to 31: /*--*/ attributes.foreground = RED_ANSI_COLOR; /*-------------*/ jmp advancePointer;
			to 32: /*--*/ attributes.foreground = GREEN_ANSI_COLOR; /*-----------*/ jmp advancePointer;
			to 33: /*--*/ attributes.foreground = YELLOW_ANSI_COLOR; /*----------*/ jmp advancePointer;
			to 34: /*--*/ attributes.foreground = BLUE_ANSI_COLOR; /*------------*/ jmp advancePointer;
			to 35: /*--*/ attributes.foreground = MAGENTA_ANSI_COLOR; /*---------*/ jmp advancePointer;
			to 36: /*--*/ attributes.foreground = CYAN_ANSI_COLOR; /*------------*/ jmp advancePointer;
			to 37: /*--*/ attributes.foreground = WHITE_ANSI_COLOR; /*-----------*/ jmp advancePointer;
			to 38: /*--*/ /*-----------------------------------------------------*/ jmp pickCustomColor;
			to 39: /*--*/ attributes.foreground = attributesInUse.foreground; /*-*/ jmp advancePointer;
			to 40: /*--*/ attributes.background = BLACK_ANSI_COLOR; /*-----------*/ jmp advancePointer;
			to 41: /*--*/ attributes.background = RED_ANSI_COLOR; /*-------------*/ jmp advancePointer;
			to 42: /*--*/ attributes.background = GREEN_ANSI_COLOR; /*-----------*/ jmp advancePointer;
			to 43: /*--*/ attributes.background = YELLOW_ANSI_COLOR; /*----------*/ jmp advancePointer;
			to 44: /*--*/ attributes.background = BLUE_ANSI_COLOR; /*------------*/ jmp advancePointer;
			to 45: /*--*/ attributes.background = MAGENTA_ANSI_COLOR; /*---------*/ jmp advancePointer;
			to 46: /*--*/ attributes.background = CYAN_ANSI_COLOR; /*------------*/ jmp advancePointer;
			to 47: /*--*/ attributes.background = WHITE_ANSI_COLOR; /*-----------*/ jmp advancePointer;
			to 48: /*--*/ /*-----------------------------------------------------*/ jmp pickCustomColor;
			to 49: /*--*/ attributes.background = attributesInUse.background; /*-*/ jmp advancePointer;
			to 90: /*--*/ attributes.foreground = BRIGHT_BLACK_ANSI_COLOR; /*----*/ jmp advancePointer;
			to 91: /*--*/ attributes.foreground = BRIGHT_RED_ANSI_COLOR; /*------*/ jmp advancePointer;
			to 92: /*--*/ attributes.foreground = BRIGHT_GREEN_ANSI_COLOR; /*----*/ jmp advancePointer;
			to 93: /*--*/ attributes.foreground = BRIGHT_YELLOW_ANSI_COLOR; /*---*/ jmp advancePointer;
			to 94: /*--*/ attributes.foreground = BRIGHT_BLUE_ANSI_COLOR; /*-----*/ jmp advancePointer;
			to 95: /*--*/ attributes.foreground = BRIGHT_MAGENTA_ANSI_COLOR; /*--*/ jmp advancePointer;
			to 96: /*--*/ attributes.foreground = BRIGHT_CYAN_ANSI_COLOR; /*-----*/ jmp advancePointer;
			to 97: /*--*/ attributes.foreground = BRIGHT_WHITE_ANSI_COLOR; /*----*/ jmp advancePointer;
			to 100: /*-*/ attributes.background = BRIGHT_BLACK_ANSI_COLOR; /*----*/ jmp advancePointer;
			to 101: /*-*/ attributes.background = BRIGHT_RED_ANSI_COLOR; /*------*/ jmp advancePointer;
			to 102: /*-*/ attributes.background = BRIGHT_GREEN_ANSI_COLOR; /*----*/ jmp advancePointer;
			to 103: /*-*/ attributes.background = BRIGHT_YELLOW_ANSI_COLOR; /*---*/ jmp advancePointer;
			to 104: /*-*/ attributes.background = BRIGHT_BLUE_ANSI_COLOR; /*-----*/ jmp advancePointer;
			to 105: /*-*/ attributes.background = BRIGHT_MAGENTA_ANSI_COLOR; /*--*/ jmp advancePointer;
			to 106: /*-*/ attributes.background = BRIGHT_CYAN_ANSI_COLOR; /*-----*/ jmp advancePointer;
			to 107: /*-*/ attributes.background = BRIGHT_WHITE_ANSI_COLOR; /*----*/ jmp advancePointer;
			off: /*----*/ /*-----------------------------------------------------*/ jmp advancePointer;
		end
	}
	resetAttributes:{
		attributes.foreground = attributesInUse.foreground;
		attributes.background = attributesInUse.background;
		jmp advancePointer;
	}
	swapForegroundBackground:{
		const uint32 foreground = attributes.foreground;
		attributes.foreground = attributes.background;
		attributes.background = foreground;
		jmp advancePointer;
	}
	pickCustomColor:{
		const bool use8BitColors = *s != ASCII_TO_UCS2('2');
		uint32 color = 0;
		uint32 finalColor = 0x000000FF;
		if((*s != ASCII_TO_UCS2('5') and *s != ASCII_TO_UCS2('2')) or *(s + 1) != ASCII_TO_UCS2(';')){
			ret NULL;
		}
		s += 2;
		jmp pieceTogetherCustomColor;
		pieceTogetherCustomColor:{
			const uint16 *sStart = s;
			color = 0;
			jmp pieceTogetherCustomColorLoop;
			pieceTogetherCustomColorLoop:{
				uint16 c = *s;
				if(c & b(0000000011111111)){
					ret NULL;
				}
				c >>= 8;
				if(c >= '0' and c <= '9'){
					color = color * 10 + c - 48;
					inc s;
					jmp pieceTogetherCustomColorLoop;
				}
				if(c == ';'){
					if(s == sStart){
						ret NULL;
					}
					inc s;
					jmp pickCustomColorMode;
				}
				if(c == 'm'){
					if(s == sStart){
						ret NULL;
					}
					if(!use8BitColors and !(finalColor & 0x00FF0000)){
						ret NULL;
					}
					hasReachedEnd = true;
					inc s;
					jmp pickCustomColorMode;
				}
				ret NULL;
			}
		}
		pickCustomColorMode:{
			if(use8BitColors){
				jmp match8BitColor;
			}
			jmp match24BitColor;
		}
		match8BitColor:{
			if(color <= 15){
				switch color over
					to 0: /*--*/ finalColor = BLACK_ANSI_COLOR; /*----------*/ jmp setCustomColor;
					to 1: /*--*/ finalColor = RED_ANSI_COLOR; /*------------*/ jmp setCustomColor;
					to 2: /*--*/ finalColor = GREEN_ANSI_COLOR; /*----------*/ jmp setCustomColor;
					to 3: /*--*/ finalColor = YELLOW_ANSI_COLOR; /*---------*/ jmp setCustomColor;
					to 4: /*--*/ finalColor = BLUE_ANSI_COLOR; /*-----------*/ jmp setCustomColor;
					to 5: /*--*/ finalColor = MAGENTA_ANSI_COLOR; /*--------*/ jmp setCustomColor;
					to 6: /*--*/ finalColor = CYAN_ANSI_COLOR; /*-----------*/ jmp setCustomColor;
					to 7: /*--*/ finalColor = WHITE_ANSI_COLOR; /*----------*/ jmp setCustomColor;
					to 8: /*--*/ finalColor = BRIGHT_BLACK_ANSI_COLOR; /*---*/ jmp setCustomColor;
					to 9: /*--*/ finalColor = BRIGHT_RED_ANSI_COLOR; /*-----*/ jmp setCustomColor;
					to 10: /*-*/ finalColor = BRIGHT_GREEN_ANSI_COLOR; /*---*/ jmp setCustomColor;
					to 11: /*-*/ finalColor = BRIGHT_YELLOW_ANSI_COLOR; /*--*/ jmp setCustomColor;
					to 12: /*-*/ finalColor = BRIGHT_BLUE_ANSI_COLOR; /*----*/ jmp setCustomColor;
					to 13: /*-*/ finalColor = BRIGHT_MAGENTA_ANSI_COLOR; /*-*/ jmp setCustomColor;
					to 14: /*-*/ finalColor = BRIGHT_CYAN_ANSI_COLOR; /*----*/ jmp setCustomColor;
					off: /*---*/ finalColor = BRIGHT_WHITE_ANSI_COLOR; /*---*/ jmp setCustomColor;
				end
			}
			if(color <= 231){
				uint32 red;
				uint32 green;
				uint32 blue;
				color -= 16;
				red = color / 36;
				color = color - red * 36;
				green = color / 6;
				color = color - green * 6;
				blue = color;
				switch red over
					to 0: /*-*/ red = 0x00 << 16; brk;
					to 1: /*-*/ red = 0x5F << 16; brk;
					to 2: /*-*/ red = 0x87 << 16; brk;
					to 3: /*-*/ red = 0xAF << 16; brk;
					to 4: /*-*/ red = 0xD7 << 16; brk;
					off: /*--*/ red = 0xFF << 16; brk;
				end
				switch green over
					to 0: /*-*/ green = 0x00 << 8; brk;
					to 1: /*-*/ green = 0x5F << 8; brk;
					to 2: /*-*/ green = 0x87 << 8; brk;
					to 3: /*-*/ green = 0xAF << 8; brk;
					to 4: /*-*/ green = 0xD7 << 8; brk;
					off: /*--*/ green = 0xFF << 8; brk;
				end
				switch blue over
					to 0: /*-*/ blue = 0x00 << 0; brk;
					to 1: /*-*/ blue = 0x5F << 0; brk;
					to 2: /*-*/ blue = 0x87 << 0; brk;
					to 3: /*-*/ blue = 0xAF << 0; brk;
					to 4: /*-*/ blue = 0xD7 << 0; brk;
					off: /*--*/ blue = 0xFF << 0; brk;
				end
				finalColor = 0xFF000000 | red | green | blue;
				jmp setCustomColor;
			}
			if(color <= 255){
				color = 2 + (color - 232) * 11;
				finalColor = 0xFF000000 | (color << 16) | (color << 8) | (color << 0);
				jmp setCustomColor;
			}
			ret NULL;
		}
		match24BitColor:{
			if(color > 255){
				ret NULL;
			}
			finalColor <<= bitsof(uint8);
			if(finalColor & 0xFF000000){
				finalColor |= color;
				jmp setCustomColor;
			}
			if(finalColor & 0x00FF0000){
				finalColor |= color;
				jmp pieceTogetherCustomColor;
			}
			finalColor |= color;
			jmp pieceTogetherCustomColor;
		}
		setCustomColor:{
			if(code == 38){
				attributes.foreground = finalColor;
				jmp advancePointer;
			}
			attributes.background = finalColor;
			jmp advancePointer;
		}
	}
	advancePointer:{
		if(hasReachedEnd){
			*attributesReturn = attributes;
			ret s;
		}
		jmp pieceTogetherCode;
	}
	#undef  BRIGHT_WHITE_ANSI_COLOR
	#undef  BRIGHT_CYAN_ANSI_COLOR
	#undef  BRIGHT_MAGENTA_ANSI_COLOR
	#undef  BRIGHT_BLUE_ANSI_COLOR
	#undef  BRIGHT_YELLOW_ANSI_COLOR
	#undef  BRIGHT_GREEN_ANSI_COLOR
	#undef  BRIGHT_RED_ANSI_COLOR
	#undef  BRIGHT_BLACK_ANSI_COLOR
	#undef  WHITE_ANSI_COLOR
	#undef  CYAN_ANSI_COLOR
	#undef  MAGENTA_ANSI_COLOR
	#undef  BLUE_ANSI_COLOR
	#undef  YELLOW_ANSI_COLOR
	#undef  GREEN_ANSI_COLOR
	#undef  RED_ANSI_COLOR
	#undef  BLACK_ANSI_COLOR
}
MATCHCOMMAND(){
	uint8 commandReturned = TYPICAL_MATCH_COMMAND_TYPE;
	(void)field0;
	(void)field1;
	(void)field2;
	(void)field3;
	(void)field4;
	switch origin over
		to PRESS_MATCH_COMMAND_ORIGIN:{
			printCommand("press", command);
			if(!((*eventModifierNode).onState & PRESS_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to RELEASE_MATCH_COMMAND_ORIGIN:{
			printCommand("release", command);
			if(!((*eventModifierNode).onState & RELEASE_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to CONFIG_MATCH_COMMAND_ORIGIN:{
			printCommand("config", command);
			jmp matchCommand;
		}
		to STDIN_MATCH_COMMAND_ORIGIN:{
			printCommand("stdin", command);
			jmp matchCommand;
		}
		to TRANSMITTER_MATCH_COMMAND_ORIGIN:{
			printCommand("transmitter", command);
			jmp matchCommand;
		}
		off:{
			jmp emergencyExit;
		}
	end
	matchCommand: switch command over
		to NONE_COMMAND: /*--------------*/ jmp noneCommand;
		to EXECUTE_COMMAND: /*-----------*/ jmp executeCommand;
		to SHOW_COMMAND: /*--------------*/ jmp showCommand;
		to HIDE_COMMAND: /*--------------*/ jmp hideCommand;
		to TOGGLE_VISIBILITY_COMMAND: /*-*/ jmp toggleVisibilityCommand;
		to DRAW_COMMAND: /*--------------*/ jmp drawCommand;
		to RESTART_COMMAND: /*-----------*/ jmp restartCommand;
		to EXIT_COMMAND: /*--------------*/ jmp exitCommand;
		off: /*--------------------------*/ jmp unrecognizedCommand;
	end
	noneCommand:{
		jmp emergencyExit;
	}
	executeCommand:{
		spawnProcess(execute);
		jmp emergencyExit;
	}
	showCommand:{
		drawVisualBuffer(&visualBufferSystem1, &textPreferences1, textRotation1);
		drawVisualBuffer(&visualBufferSystem2, &textPreferences2, textRotation2);
		drawVisualBuffer(&visualBufferSystem3, &textPreferences3, textRotation3);
		mapWindows(&windowSystem, &monitorSystem, &windowPreferences, whichMonitor);
		signalSleepThread(&sleepThreadSystem);
		jmp emergencyExit;
	}
	hideCommand:{
		unmapWindows(&windowSystem);
		jmp emergencyExit;
	}
	toggleVisibilityCommand:{
		if(!windowSystem.mapped){
			jmp showCommand;
		}
		jmp hideCommand;
	}
	drawCommand:{
		drawVisualBuffer(&visualBufferSystem1, &textPreferences1, textRotation1);
		drawVisualBuffer(&visualBufferSystem2, &textPreferences2, textRotation2);
		drawVisualBuffer(&visualBufferSystem3, &textPreferences3, textRotation3);
		drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		jmp emergencyExit;
	}
	restartCommand:{
		commandReturned = RESTART_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	exitCommand:{
		commandReturned = EXIT_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	unrecognizedCommand:{
		printTitledValuedError("command error", "executed unrecognized command with type", command);
		jmp emergencyExit;
	}
	emergencyExit:{
		ret commandReturned;
	}
}
CLEANUP(){
	free(event);
	popPointer(eventToken);
	event = NULL;
	eventToken = 0;
	finiSharedMemorySystem(&sharedMemorySystem);
	finiSTDINSystem(&stdinSystem);
	finiSleepThreadSystem(&sleepThreadSystem);
	cancelThreads();
	ungrabShortcuts();
	freeConfigVariables();
	finiTraySystem(&traySystem);
	finiVisualBufferSystem(&visualBufferSystem3);
	finiVisualBufferSystem(&visualBufferSystem2);
	finiVisualBufferSystem(&visualBufferSystem1);
	finiWindowSystem(&windowSystem);
	finiMonitorSystem(&monitorSystem);
	if(connection){
		xcb_flush(connection);
		xcb_disconnect(connection);
		popPointer(connectionToken);
		connection = NULL;
		connectionToken = 0;
	}
	finiShortcutSystem(&buttonShortcutSystem);
	finiShortcutSystem(&keycodeShortcutSystem);
	finiStringTreeSystem(&macroStringTreeSystem);
	finiStringTreeSystem(&rotationStringTreeSystem);
	finiStringTreeSystem(&whichMonitorStringTreeSystem);
	finiStringTreeSystem(&cornerStringTreeSystem);
	finiStringTreeSystem(&verticalAlignmentStringTreeSystem);
	finiStringTreeSystem(&horizontalAlignmentStringTreeSystem);
	finiStringTreeSystem(&positionStringTreeSystem);
	finiStringTreeSystem(&numberTypeStringTreeSystem);
	finiStringTreeSystem(&shortcutStateStringTreeSystem);
	finiStringTreeSystem(&modifierStringTreeSystem);
	finiStringTreeSystem(&commandStringTreeSystem);
	finiStringTreeSystem(&variableStringTreeSystem);
	finiStringTreeSystem(&booleanStringTreeSystem);
	finiStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
	finiStringTreeSystem(&globalInstructionStringTreeSystem);
	finiStringTreeSystem(&globalScopesInstructionStringTreeSystem);
	finiPermissionSystem(&permissionSystem);
	if(memoryManagementSystem.allocated > 1){
		printError("%s%s: %s%s:%s %s", colorStart, programName, colorError, "warning", colorEnd, "program exited with unaccounted for data pointers, namely:\n");
		printUnaccountedForPointers(memoryManagementSystem.data + 1, memoryManagementSystem.data + memoryManagementSystem.allocated);
	}
	finiMemorySystem();
	closeErrorStream();
	exit(EXIT_SUCCESS);
}
PRINTCONFIGERROR(){
	const char *statementCurrent = statementStart;
	const uint itemAmountWall = instructionCurrent - instructionStart;
	uint itemAmount = 0;
	uint spaceAmount = 0;
	StringTreeSystem *const *data;
	if(!openErrorStream()){
		ret;
	}
	flockfile(errorStream);
	fprintf(errorStream, "%s%s: %s: ", colorStart, programName, configPath);
	if(printLine){
		fprintf(errorStream, "line %u: ", statementLine);
	}
	fprintf(errorStream, "%s%s:%s %s", colorError, type, colorEnd, message);
	if(printConfig){
		fprintf(errorStream, ":\n\t config |");
	}else{
		fprintf(errorStream, "\n");
		jmp emergencyExit;
	}
	jmp printStatementItemLoop;
	printStatementItemLoop:{
		if(statementCurrent < statementWall){
			fprintf(errorStream, " %s", statementCurrent);
			jmp pushOutTermLoop;
			pushOutTermLoop:{
				if(*(inc statementCurrent)){
					jmp pushOutTermLoop;
				}
				inc statementCurrent;
			}
			if(itemAmount == itemAmountWall and instructionStart){
				spaceAmount = statementCurrent - statementStart;
			}
			inc itemAmount;
			jmp printStatementItemLoop;
		}
		if(spaceAmount == 0 and finalStatementCharacter != ';'){
			fprintf(errorStream, " ");
		}
		fprintf(errorStream, "%c\n", finalStatementCharacter);
		jmp printPattern;
	}
	printPattern:{
		if(printPointer){
			if(spaceAmount == statementCurrent - statementStart){
				dec spaceAmount;
			}
			fprintf(errorStream, "\t        |%*c^\n", inc spaceAmount, ' ');
		}
		if(!printPattern or !instructionStart){
			fprintf(errorStream, "\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, "\n\tpattern | %s", *(currentScopeInstructionList + (*currentScopeInstructionStringTreeSystem).returnedCounter));
		dec instructionStart;
		data = instructionDataStart;
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoop: switch *(inc instructionStart) over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
		off: /*---------------------------*/ jmp printInstructionParameterLoopExit;
	end
	noneInstruction:{
		fprintf(errorStream, " <unimplemented>");
		jmp printInstructionParameterLoopExit;
	}
	nameInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " name");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " (%s", *stringArray);
			inc stringArray;
			jmp printNameLoop;
			printNameLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
				}
				fprintf(errorStream, ")");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	nameListInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " list");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " ((%s", *stringArray);
			inc stringArray;
			jmp printNameListOnceLoop;
			printNameListOnceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
				}
				stringArray = (**data).stringArray;
				fprintf(errorStream, ")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
				inc stringArray;
				jmp printNameListTwiceLoop;
			}
			printNameListTwiceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListTwiceLoop;
				}
				fprintf(errorStream, "))*(?![\\s]*[|]))");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	numberInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " number");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
		jmp printInstructionParameterLoop;
	}
	stringInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " string");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	imageInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " image");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	printTilde:{
		fprintf(errorStream, " ~");
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoopExit:{
		if(displaySimpleConfigErrors){
			fprintf(errorStream, "\n\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, " $\n\n");
		jmp emergencyExit;
	}
	emergencyExit:{
		funlockfile(errorStream);
		closeErrorStream();
		ret;
	}
}

