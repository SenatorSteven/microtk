
/*!
	shrinking windows per 16 pixels still causes trouble when trying to shrink tiny window (moves it when it shouldn't be moved)... but only when using diagonals.
*/

/*!
	add mechanism to attach and detach window on top of virtual root or entire system.
*/

/*!
	opening gedit when it was last maximized causes incorrect placement that's not even in the same monitor.
*/

/*!
	after going fullscreen with window, popup subwindows appear transiently. if you focus out and then in again the problem solves itself.
*/

/*!
	using restackVirtualRootBelow() might cause fullscreen window stacking issues, but only visual issues.
*/

/*!
	moving fullscreen between desktops might cause issues.
*/

/*!
	workarea is not set properly if windows are, say, next to each other yet obscuring the top part of multiple monitors.
*/

/*!
	if state is changed into demands attention, raise it (above, none).
*/

/*!
	what happens to old client positions when screen is updated? write a function for that.
*/

/*!
	future updates:
		properly get the wm selection and leave another wm take over.
		move clients out of view instead of unmapping to allow for compositor tricks.
		continue the session as if a wm just stopped operating. act similarly for existing clients.
		support everything in the icccm and then ewmh.
		support modality when restacking.
		lose all focus on click of the desktop.
*/

/*!
	respect window gravities on configure request.
*/

/*!
	support having more desktop names than the desktop amount.
*/

/*!
	    x draw _NET_WM_VISIBLE_NAME. if none, draw _NET_WM_NAME. if none, draw WM_NAME.
	    x use _NET_WM_VISIBLE_ICON_NAME. if none, use _NET_WM_ICON_NAME. if none, use WM_ICON_NAME.

	v     use normal hint position
	    x use normal hint size
	v     use normal hint min size
	v     use normal hint max size
	    x use normal hint inc size
	    x use normal hint min aspect
	    x use normal hint max aspect
	v     use normal hint base size
	    x use normal hint window gravity

	v     use hint input
	v     use hint initial state
	    x use hint icon pixmap
	    x use hint icon window
	    x use hint icon position
	    x use hint icon mask
	    x use hint window group
	v     use hint urgency

	    x use class

	v     use transient for window

	v     use protocol WM_TAKE_FOCUS
	v     use protocol WM_DELETE_WINDOW
	    x use protocol _NET_WM_PING
	    x use protocol _NET_WM_SYNC_REQUEST

	    x use colormap windows

	    x use client machine

	    x register a window on the session manager
	    x use client id
	    x use client leader
	    x use window role

	v     use state

	v     use desktop

	v     use window type

	v     use window state

	v     use allowed actions

	v     use window strut

	    x use icon geometry

	    x use icon

	v     use pid

	    x use handled icons

	v     use user time

	v     use frame extents
*/



























/*!includes:{*/
	#include <errno.h>
	#include <grp.h>
	#include <limits.h>
	#include <locale.h>
	#include <poll.h>
	#include <pthread.h>
	#include <pwd.h>
	#include <signal.h>
	#include <stdarg.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <sys/shm.h>
	#include <sys/stat.h>
	#include <sys/wait.h>
	#include <xcb/randr.h>
	#include <xcb/shape.h>
	#include <xcb/xfixes.h>
/*!}*/

/*!defines:{*/
	#define DEBUG /*-----------------------------------------*/ (false)

	#define PROGRAM_NAME /*----------------------------------*/ "microwm"

	#define WHICH_MONITOR_CONTENT(k, v, n, p) /*-------------*/ { \
		  v(none)           k(NONE##p) \
		, v(pointer)        k(POINTER##p) \
		, v(focused-window) k(FOCUSED_WINDOW##p) \
		, v(all)            k(ALL##p) \
		, v(self)           k(SELF##p) \
		, n(NULL)           k(NULL##p) \
	}

	#define NUMBER_TYPE_CONTENT(k, v, n, p) /*---------------*/ { \
		  v(none)       k(NONE##p) \
		, v(integer)    k(INTEGER##p) \
		, v(percentage) k(PERCENTAGE##p) \
		, v(millimeter) k(MILLIMETER##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define POSITION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(bottom) k(BOTTOM##p) \
		, v(left)   k(LEFT##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define HORIZONTAL_ALIGNMENT_CONTENT(k, v, n, p) /*------*/ { \
		  v(none)   k(NONE##p) \
		, v(left)   k(LEFT##p) \
		, v(center) k(CENTER##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define VERTICAL_ALIGNMENT_CONTENT(k, v, n, p) /*--------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(center) k(CENTER##p) \
		, v(bottom) k(BOTTOM##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define CORNER_CONTENT(k, v, n, p) /*--------------------*/ { \
		  v(none)         k(NONE##p         = (b(0000))) \
		, v(top-left)     k(TOP_LEFT##p     = (b(0001))) \
		, v(top-right)    k(TOP_RIGHT##p    = (b(0010))) \
		, v(bottom-left)  k(BOTTOM_LEFT##p  = (b(0100))) \
		, v(bottom-right) k(BOTTOM_RIGHT##p = (b(1000))) \
		, n(NULL)         k(NULL##p) \
	}

	#define AXIS_CONTENT(k, v, n, p) /*----------------------*/ { \
		  v(none)       k(NONE##p) \
		, v(horizontal) k(HORIZONTAL##p) \
		, v(vertical)   k(VERTICAL##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define _STRING_TREE_NODE_CHILDREN_AMOUNT /*-------------*/ (14)
	#define STRING_TREE_NODE_CHILDREN_AMOUNT /*--------------*/ (_STRING_TREE_NODE_CHILDREN_AMOUNT > 28? 28 : _STRING_TREE_NODE_CHILDREN_AMOUNT)

	#define EMPTY_SHARED_STATUS /*---------------------------*/ (0)
	#define FULL_SHARED_STATUS /*----------------------------*/ (1)

	#define SHORTCUT_CODE_AMOUNT /*--------------------------*/ (256)

	#define SHORTCUT_STATE_CONTENT(k, v, n, p) /*------------*/ { \
		  v(none)    k(NONE##p    = (b(000))) \
		, v(press)   k(PRESS##p   = (b(001))) \
		, v(repeat)  k(REPEAT##p  = (b(010))) \
		, v(release) k(RELEASE##p = (b(100))) \
		, n(NULL)    k(NULL##p) \
	}

	#define NONE_INSTRUCTION_TYPE /*-------------------------*/ (b(000000))
	#define NAME_INSTRUCTION_TYPE /*-------------------------*/ (b(000001))
	#define NAME_LIST_INSTRUCTION_TYPE /*--------------------*/ (b(000010))
	#define NUMBER_INSTRUCTION_TYPE /*-----------------------*/ (b(000100))
	#define STRING_INSTRUCTION_TYPE /*-----------------------*/ (b(001000))
	#define IMAGE_INSTRUCTION_TYPE /*------------------------*/ (b(010000))
	#define END_INSTRUCTION_TYPE /*--------------------------*/ (b(100000))

	#define GLOBAL_SCOPES_INSTRUCTION_CONTENT(k, v, n, p) /*-*/ { \
		  v(scope1) k(SCOPE1##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define GLOBAL_INSTRUCTION_CONTENT(k, v, n, p) /*--------*/ { \
		  v(help)           k(HELP##p) \
		, v(expand)         k(EXPAND##p) \
		, v(contract)       k(CONTRACT##p) \
		, v(read-config)    k(READ_CONFIG##p) \
		, v(use-terminal)   k(USE_TERMINAL##p) \
		, v(use-messenger)  k(USE_MESSENGER##p) \
		, v(set)            k(SET##p) \
		, v(do)             k(DO##p) \
		, v(grab-keycode)   k(GRAB_KEYCODE##p) \
		, v(grab-button)    k(GRAB_BUTTON##p) \
		, v(ungrab-keycode) k(UNGRAB_KEYCODE##p) \
		, v(ungrab-button)  k(UNGRAB_BUTTON##p) \
		, v(stop)           k(STOP##p) \
		, n(NULL)           k(NULL##p) \
	}

	#define SCOPE1_SCOPE_INSTRUCTION_CONTENT(k, v, n, p) /*--*/ { \
		  v(help)     k(HELP##p) \
		, v(expand)   k(EXPAND##p) \
		, v(contract) k(CONTRACT##p) \
		, v(stop)     k(STOP##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define BOOLEAN_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)  k(NONE##p) \
		, v(true)  k(TRUE##p) \
		, v(false) k(FALSE##p) \
		, n(NULL)  k(NULL##p) \
	}

	#define VARIABLE_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none) k(NONE##p) \
		, n(NULL) k(NULL##p) \
	}

	#define COMMAND_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)                                 k(NONE##p) \
		, v(execute)                              k(EXECUTE##p) \
		, v(focus)                                k(FOCUS##p) \
		, v(motion-move)                          k(MOTION_MOVE##p) \
		, v(motion-resize)                        k(MOTION_RESIZE##p) \
		, v(place-top)                            k(PLACE_TOP##p) \
		, v(place-bottom)                         k(PLACE_BOTTOM##p) \
		, v(place-left)                           k(PLACE_LEFT##p) \
		, v(place-right)                          k(PLACE_RIGHT##p) \
		, v(place-top-left)                       k(PLACE_TOP_LEFT##p) \
		, v(place-top-right)                      k(PLACE_TOP_RIGHT##p) \
		, v(place-bottom-left)                    k(PLACE_BOTTOM_LEFT##p) \
		, v(place-bottom-right)                   k(PLACE_BOTTOM_RIGHT##p) \
		, v(place-center)                         k(PLACE_CENTER##p) \
		, v(place-full)                           k(PLACE_FULL##p) \
		, v(move)                                 k(MOVE##p) \
		, v(resize)                               k(RESIZE##p) \
		, v(enter-maximized)                      k(ENTER_MAXIMIZED##p) \
		, v(leave-maximized)                      k(LEAVE_MAXIMIZED##p) \
		, v(toggle-maximized)                     k(TOGGLE_MAXIMIZED##p) \
		, v(enter-fullscreen)                     k(ENTER_FULLSCREEN##p) \
		, v(leave-fullscreen)                     k(LEAVE_FULLSCREEN##p) \
		, v(toggle-fullscreen)                    k(TOGGLE_FULLSCREEN##p) \
		, v(show-desktop)                         k(SHOW_DESKTOP##p) \
		, v(hide-desktop)                         k(HIDE_DESKTOP##p) \
		, v(toggle-desktop)                       k(TOGGLE_DESKTOP##p) \
		, v(go-to-workspace)                      k(GO_TO_WORKSPACE##p) \
		, v(go-to-next-workspace)                 k(GO_TO_NEXT_WORKSPACE##p) \
		, v(go-to-previous-workspace)             k(GO_TO_PREVIOUS_WORKSPACE##p) \
		, v(move-window-to-workspace)             k(MOVE_WINDOW_TO_WORKSPACE##p) \
		, v(move-window-to-next-workspace)        k(MOVE_WINDOW_TO_NEXT_WORKSPACE##p) \
		, v(move-window-to-previous-workspace)    k(MOVE_WINDOW_TO_PREVIOUS_WORKSPACE##p) \
		, v(go-to-workspace-with-window)          k(GO_TO_WORKSPACE_WITH_WINDOW##p) \
		, v(go-to-next-workspace-with-window)     k(GO_TO_NEXT_WORKSPACE_WITH_WINDOW##p) \
		, v(go-to-previous-workspace-with-window) k(GO_TO_PREVIOUS_WORKSPACE_WITH_WINDOW##p) \
		, v(close)                                k(CLOSE##p) \
		, v(kill)                                 k(KILL##p) \
		, v(restart)                              k(RESTART##p) \
		, v(exit)                                 k(EXIT##p) \
		, n(NULL)                                 k(NULL##p) \
	}

	#define MODIFIER_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)     k(NONE##p) \
		, v(shift)    k(SHIFT##p) \
		, v(caps)     k(CAPS##p) \
		, v(control)  k(CONTROL##p) \
		, v(mod-1)    k(MOD_1##p) \
		, v(mod-2)    k(MOD_2##p) \
		, v(mod-3)    k(MOD_3##p) \
		, v(mod-4)    k(MOD_4##p) \
		, v(mod-5)    k(MOD_5##p) \
		, v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NAME_LIST /*--------------------------------*/ (0)
	#define SUCCESS_NAME_LIST /*-----------------------------*/ (1)
	#define INVALID_NAME_NAME_LIST /*------------------------*/ (2)
	#define PREMATURE_END_NAME_LIST /*-----------------------*/ (3)

	#define MACRO_CONTENT(k, v, n, p) /*---------------------*/ { \
		  v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NUMBER /*-----------------------------------*/ (0)
	#define VALID_NUMBER_NUMBER /*---------------------------*/ (1)
	#define NON_NUMBER_NUMBER /*-----------------------------*/ (2)
	#define OVERFLOWN_NUMBER_NUMBER /*-----------------------*/ (3)
	#define DIVIDED_BY_ZERO_NUMBER /*------------------------*/ (4)

	#define NONE_MATCH_IMAGE /*------------------------------*/ (0)
	#define CANNOT_OPEN_MATCH_IMAGE /*-----------------------*/ (1)
	#define CANNOT_READ_MATCH_IMAGE /*-----------------------*/ (2)
	#define UNSUPPORTED_FORMAT_MATCH_IMAGE /*----------------*/ (3)
	#define BAD_HEADER_MATCH_IMAGE /*------------------------*/ (4)
	#define BAD_DEPTH_MATCH_IMAGE /*-------------------------*/ (5)
	#define BAD_COMPRESSION_MATCH_IMAGE /*-------------------*/ (6)
	#define UNSUPPORTED_HEIGHT_MATCH_IMAGE /*----------------*/ (7)
	#define BAD_SIZE_MATCH_IMAGE /*--------------------------*/ (8)
	#define FAILED_MATCH_IMAGE /*----------------------------*/ (9)
	#define BAD_PIXELS_MATCH_IMAGE /*------------------------*/ (10)
	#define BAD_IMAGE_MATCH_IMAGE /*-------------------------*/ (11)
	#define SUCCESS_MATCH_IMAGE /*---------------------------*/ (12)

	#define NONE_MATCH_COMMAND_ORIGIN /*---------------------*/ (0)
	#define PRESS_MATCH_COMMAND_ORIGIN /*--------------------*/ (1)
	#define RELEASE_MATCH_COMMAND_ORIGIN /*------------------*/ (2)
	#define CONFIG_MATCH_COMMAND_ORIGIN /*-------------------*/ (3)
	#define STDIN_MATCH_COMMAND_ORIGIN /*--------------------*/ (4)
	#define TRANSMITTER_MATCH_COMMAND_ORIGIN /*--------------*/ (5)

	#define NONE_MATCH_COMMAND_TYPE /*-----------------------*/ (0)
	#define TYPICAL_MATCH_COMMAND_TYPE /*--------------------*/ (1)
	#define RESTART_MATCH_COMMAND_TYPE /*--------------------*/ (2)
	#define EXIT_MATCH_COMMAND_TYPE /*-----------------------*/ (3)

	#define ROTATION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)        k(NONE##p) \
		, v(degrees-90)  k(DEGREES_90##p)  \
		, v(degrees-180) k(DEGREES_180##p) \
		, v(degrees-270) k(DEGREES_270##p) \
		, n(NULL)        k(NULL##p) \
	}

	#define INITPOINTERSYSTEM() /*---------------------------*/ local bool               initPointerSystem(PointerSystem *const pointerSystem)
	#define SETPOINTER() /*----------------------------------*/ local bool               setPointer(PointerSystem *const pointerSystem)
	#define FINIPOINTERSYSTEM() /*---------------------------*/ local bool               finiPointerSystem(PointerSystem *const pointerSystem)

	#define INITCURSORSYSTEM() /*----------------------------*/ local bool               initCursorSystem(CursorSystem *const cursorSystem)
	#define SETCURSOR() /*-----------------------------------*/ local bool               setCursor(CursorSystem *const cursorSystem, const uint8 cursorGlyph, const uint32 foreground, const uint32 background)
	#define FINICURSORSYSTEM() /*----------------------------*/ local bool               finiCursorSystem(CursorSystem *const cursorSystem)

	#define INITWALLPAPERSYSTEM() /*-------------------------*/ local bool               initWallpaperSystem(WallpaperSystem *const wallpaperSystem)
	#define SETWALLPAPERCOLOR() /*---------------------------*/ local bool               setWallpaperColor(WallpaperSystem *const wallpaperSystem, MonitorSystem *const monitorSystem, const uint32 color)
	#define SETWALLPAPERPIXMAP() /*--------------------------*/ local bool               setWallpaperPixmap(WallpaperSystem *const wallpaperSystem, MonitorSystem *const monitorSystem, const xcb_atom_t pixmapProperty)
	#define CREATEWALLPAPER() /*-----------------------------*/ local bool               createWallpaper(WallpaperSystem *const wallpaperSystem, MonitorSystem *const monitorSystem, const uint width, const uint height)
	#define FINIWALLPAPERSYSTEM() /*-------------------------*/ local bool               finiWallpaperSystem(WallpaperSystem *const wallpaperSystem)

	#define INITCLIENTSYSTEM() /*----------------------------*/ local bool               initClientSystem(ClientSystem *const clientSystem)
	#define CREATECLIENT() /*--------------------------------*/ local bool               createClient(ClientSystem *const clientSystem, const CursorSystem *const cursorSystem, const xcb_window_t window, const int x, const int y, const uint width, const uint height, const uint border, uint8 class, const bool overrideRedirect)
	#define SETDEFAULTCLIENTWINDOWTYPE() /*------------------*/ local bool               setDefaultClientWindowType(ClientSystem *const clientSystem, Client *const client)
	#define UPDATECLIENTSTATE() /*---------------------------*/ local bool               updateClientState(ClientSystem *const clientSystem, Client *const client, const uint8 action, uint16 state)
	#define CHANGECLIENTSTATE() /*---------------------------*/ local bool               changeClientState(ClientSystem *const clientSystem, Client *const client)
	#define SETCLIENTALLOWEDACTIONS() /*---------------------*/ local bool               setClientAllowedActions(ClientSystem *const clientSystem, Client *const client)
	#define CHANGECLIENTALLOWEDACTIONS() /*------------------*/ local bool               changeClientAllowedActions(ClientSystem *const clientSystem, Client *const client)
	#define SETCLIENTORDERTYPE() /*--------------------------*/ local bool               setClientOrderType(ClientSystem *const clientSystem, Client *const client)
	#define MOVERESIZECLIENT() /*----------------------------*/ local bool               moveResizeClient(ClientSystem *const clientSystem, Client *const client, int x, int y, int width, int height, const bool force, const bool treatAsNormal, const bool useMinimumHints, const bool useMaximumHints, const bool repositionAfterwards, const uint8 windowGravity)
	#define SENDCLIENTCONFIGUREEVENT() /*--------------------*/ local bool               sendClientConfigureEvent(ClientSystem *const clientSystem, Client *const client)
	#define RESTACKCLIENT() /*-------------------------------*/ local bool               restackClient(ClientSystem *const clientSystem, Client *const client, const uint8 stackMode, const xcb_window_t sibling)
	#define CONFIGURECLIENT() /*-----------------------------*/ local bool               configureClient(ClientSystem *const clientSystem, Client *const client)
	#define ASSIGNCLIENTSTRUT() /*---------------------------*/ local bool               assignClientStrut(ClientSystem *const clientSystem, MonitorSystem *const monitorSystem, Client *const client)
	#define GETFOCUSEDCLIENT() /*----------------------------*/ local Client *           getFocusedClient(ClientSystem *const clientSystem)
	#define SETFOCUSEDCLIENT() /*----------------------------*/ local bool               setFocusedClient(ClientSystem *const clientSystem, Client *const client, const uint currentDesktop)
	#define OFFERCLIENTFOCUS() /*----------------------------*/ local bool               offerClientFocus(ClientSystem *const clientSystem, Client *const client)
	#define FOCUSCLIENT() /*---------------------------------*/ local bool               focusClient(ClientSystem *const clientSystem, Client *const client)
	#define CHANGEACTIVEWINDOW() /*--------------------------*/ local bool               changeActiveWindow(ClientSystem *const clientSystem)
	#define SETMOTIONCLIENT() /*-----------------------------*/ local bool               setMotionClient(ClientSystem *const clientSystem, Client *const client, const uint8 motionAction, const uint8 motionGravity, const int x, const int y)
	#define UNSETMOTIONCLIENT() /*---------------------------*/ local bool               unsetMotionClient(ClientSystem *const clientSystem)
	#define CLOSECLIENT() /*---------------------------------*/ local bool               closeClient(ClientSystem *const clientSystem, Client *const client, const uint8 command)
	#define LOSEFOCUS() /*-----------------------------------*/ local bool               loseFocus(ClientSystem *const clientSystem)
	#define UNFOCUSCLIENT() /*-------------------------------*/ local bool               unfocusClient(ClientSystem *const clientSystem)
	#define UNMAPCLIENT() /*---------------------------------*/ local bool               unmapClient(ClientSystem *const clientSystem, Client *const client, const uint8 state)
	#define DESTROYCLIENT() /*-------------------------------*/ local bool               destroyClient(ClientSystem *const clientSystem, Client *const client)
	#define ISVALIDCLIENT() /*-------------------------------*/ local bool               isValidClient(ClientSystem *const clientSystem, const Client *const client)
	#define FINDCLIENTWINDOW() /*----------------------------*/ local Client *           findClientWindow(ClientSystem *const clientSystem, const xcb_window_t window)
	#define FINDCLIENTCONTAINER() /*-------------------------*/ local Client *           findClientContainer(ClientSystem *const clientSystem, const xcb_window_t window)
	#define FINDCONFIGUREDCLIENTWINDOW() /*------------------*/ local Client *           findConfiguredClientWindow(ClientSystem *const clientSystem, const xcb_window_t window)
	#define FINDORDEREDCLIENTOFFSET() /*---------------------*/ local uint *             findOrderedClientOffset(ClientSystem *const clientSystem, const Client *const client)
	#define FINDBELOWCLIENT() /*-----------------------------*/ local Client *           findBelowClient(ClientSystem *const clientSystem, const Client *const client)
	#define FINDABOVEDESKTOPCLIENT() /*----------------------*/ local Client *           findAboveDesktopClient(ClientSystem *const clientSystem, const Client *const client)
	#define FINDBELOWDESKTOPCLIENT() /*----------------------*/ local Client *           findBelowDesktopClient(ClientSystem *const clientSystem, const Client *const client)
	#define FINDMODALTRANSIENTFORCLIENT() /*-----------------*/ local Client *           findModalTransientForClient(ClientSystem *const clientSystem, const Client *const client)
	#define FINDBELOWMANAGEDCLIENT() /*----------------------*/ local Client *           findBelowManagedClient(ClientSystem *const clientSystem, const Client *const client)
	#define FINICLIENTSYSTEM() /*----------------------------*/ local bool               finiClientSystem(ClientSystem *const clientSystem)

	#define INITVIRTUALROOTSYSTEM() /*-----------------------*/ local bool               initVirtualRootSystem(VirtualRootSystem *const virtualRootSystem)
	#define SETVIRTUALROOTAMOUNT() /*------------------------*/ local bool               setVirtualRootAmount(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, CursorSystem *const cursorSystem, const uint size)
	#define SETVIRTUALROOTWORKAREA() /*----------------------*/ local bool               setVirtualRootWorkarea(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem)
	#define CHANGEVIRTUALROOTWORKAREA() /*-------------------*/ local bool               changeVirtualRootWorkarea(VirtualRootSystem *const virtualRootSystem)
	#define SETVIRTUALROOTNAMES() /*-------------------------*/ local bool               setVirtualRootNames(VirtualRootSystem *const virtualRootSystem)
	#define SETVIRTUALROOTNAME() /*--------------------------*/ local bool               setVirtualRootName(VirtualRootSystem *const virtualRootSystem, const uint32 which, const uint8 *const name, const uint length)
	#define SETVIRTUALROOTNUMBERNAME() /*--------------------*/ local bool               setVirtualRootNumberName(VirtualRootSystem *const virtualRootSystem, const uint32 which, uint number)
	#define GOTOVIRTUALROOT() /*-----------------------------*/ local bool               gotoVirtualRoot(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, const uint32 which, const bool loseClientFocus)
	#define CONFIGUREFULLSCREENVIRTUALROOTCLIENTS() /*-------*/ local bool               configureFullscreenVirtualRootClients(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, const uint32 which)
	#define RESIZEVIRTUALROOT() /*---------------------------*/ local bool               resizeVirtualRoot(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, WallpaperSystem *const wallpaperSystem, ClientSystem *const clientSystem, const uint width, const uint height)
	#define SETVIRTUALROOTGLOBALEDGEOFFSET() /*--------------*/ local bool               setVirtualRootGlobalEdgeOffset(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem)
	#define SETVIRTUALROOTWALLPAPER() /*---------------------*/ local bool               setVirtualRootWallpaper(VirtualRootSystem *const virtualRootSystem, WallpaperSystem *const wallpaperSystem)
	#define RESTACKVIRTUALROOTBELOW() /*---------------------*/ local bool               restackVirtualRootBelow(VirtualRootSystem *const virtualRootSystem)
	#define MAPVIRTUALROOTS() /*-----------------------------*/ local bool               mapVirtualRoots(VirtualRootSystem *const virtualRootSystem)
	#define SETCLIENTVIRTUALROOT() /*------------------------*/ local bool               setClientVirtualRoot(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, Client *const client, const uint32 which)
	#define CHANGEVIRTUALROOTCLIENTDESKTOP() /*--------------*/ local bool               changeVirtualRootClientDesktop(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, Client *const client)
	#define MOVECLIENTTOVIRTUALROOT() /*---------------------*/ local bool               moveClientToVirtualRoot(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client, const uint32 which, const bool loseClientFocus)
	#define CONFIGUREVIRTUALROOTCLIENT() /*------------------*/ local bool               configureVirtualRootClient(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, Client *const client)
	#define RESTACKVIRTUALROOTCLIENT() /*--------------------*/ local bool               restackVirtualRootClient(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, Client *const client, const uint8 stackMode, const xcb_window_t sibling)
	#define ADDVIRTUALROOTCLIENTWORKAREA() /*----------------*/ local bool               addVirtualRootClientWorkarea(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client)
	#define UPDATEVIRTUALROOTSTRUTEDCLIENTS() /*-------------*/ local bool               updateVirtualRootStrutedClients(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client, const uint8 action)
	#define REMOVEVIRTUALROOTCLIENTWORKAREA() /*-------------*/ local bool               removeVirtualRootClientWorkarea(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client)
	#define MAXIMIZECLIENT() /*------------------------------*/ local bool               maximizeClient(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client, const uint8 whichMonitor)
	#define UNMAXIMIZECLIENT() /*----------------------------*/ local bool               unmaximizeClient(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client)
	#define FULLSCREENCLIENT() /*----------------------------*/ local bool               fullscreenClient(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client, const uint8 whichMonitor)
	#define UNFULLSCREENCLIENT() /*--------------------------*/ local bool               unfullscreenClient(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client)
	#define MOVERESIZEWORKAREACLIENT() /*--------------------*/ local bool               moveResizeWorkareaClient(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client, const uint8 whichMonitor, const uint8 workareaPosition)
	#define UPDATEVIRTUALROOTWORKAREACLIENT() /*-------------*/ local bool               updateVirtualRootWorkareaClient(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client)
	#define UPDATEVIRTUALROOTWORKAREACLIENTS() /*------------*/ local bool               updateVirtualRootWorkareaClients(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem)
	#define SHOWVIRTUALROOTDESKTOP() /*----------------------*/ local bool               showVirtualRootDesktop(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, const uint32 which, const bool showDesktop)
	#define DESTROYVIRTUALROOT() /*--------------------------*/ local bool               destroyVirtualRoot(VirtualRootSystem *const virtualRootSystem, VirtualRoot *const virtualRoot)
	#define ISVALIDVIRTUALROOT() /*--------------------------*/ local bool               isValidVirtualRoot(VirtualRootSystem *const virtualRootSystem, const VirtualRoot *const virtualRoot)
	#define FINDVIRTUALROOT() /*-----------------------------*/ local VirtualRoot *      findVirtualRoot(VirtualRootSystem *const virtualRootSystem, const xcb_window_t window)
	#define FINDORDEREDVIRTUALROOTCLIENTOFFSET() /*----------*/ local uint *             findOrderedVirtualRootClientOffset(VirtualRootSystem *const virtualRootSystem, VirtualRoot *const virtualRoot, ClientSystem *const clientSystem, const xcb_window_t window)
	#define FINDPOSITIONEDORDEREDVIRTUALROOTCLIENT() /*------*/ local Client *           findPositionedOrderedVirtualRootClient(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, const uint32 which, const int x, const int y)
	#define FINIVIRTUALROOTSYSTEM() /*-----------------------*/ local bool               finiVirtualRootSystem(VirtualRootSystem *const virtualRootSystem)

	#define INITCLIENTLISTSYSTEM() /*------------------------*/ local bool               initClientListSystem(ClientListSystem *const clientListSystem)
	#define SETCLIENTLISTPROPERTY() /*-----------------------*/ local bool               setClientListProperty(ClientListSystem *const clientListSystem, const xcb_atom_t property)
	#define ADDCLIENTLISTWINDOW() /*-------------------------*/ local bool               addClientListWindow(ClientListSystem *const clientListSystem, const xcb_window_t window)
	#define CONFIGURECLIENTLISTCLIENT() /*-------------------*/ local bool               configureClientListClient(ClientListSystem *const clientListSystem, ClientSystem *const clientSystem, Client *const client)
	#define RESTACKCLIENTLISTWINDOW() /*---------------------*/ local bool               restackClientListWindow(ClientListSystem *const clientListSystem, const xcb_window_t window, const uint8 stackMode, const xcb_window_t sibling)
	#define CHANGECLIENTLISTPROPERTY() /*--------------------*/ local bool               changeClientListProperty(ClientListSystem *const clientListSystem)
	#define REMOVECLIENTLISTWINDOW() /*----------------------*/ local bool               removeClientListWindow(ClientListSystem *const clientListSystem, const xcb_window_t window)
	#define FINDCLIENTLISTWINDOW() /*------------------------*/ local xcb_window_t *     findClientListWindow(ClientListSystem *const clientListSystem, const xcb_window_t window)
	#define FINICLIENTLISTSYSTEM() /*------------------------*/ local bool               finiClientListSystem(ClientListSystem *const clientListSystem)

	#define INITWINDOWMANAGERSYSTEM() /*---------------------*/ local bool               initWindowManagerSystem(void)
	#define SETNETSUPPORTED() /*-----------------------------*/ local bool               setNetSupported(void)
	#define STORECLIENTPROPERTIES() /*-----------------------*/ local bool               storeClientProperties(Client *const client)
	#define STORECLIENTPROPERTY() /*-------------------------*/ local bool               storeClientProperty(Client *const client, const xcb_atom_t property, uint length, const void *value)
	#define REALLOCATEPROPERTY() /*--------------------------*/ local bool               reallocateProperty(const uint itemSize, const uint length, const void *const value, const char *const label, uint *const sizeReturn, uint8 **const startReturn, uint32 *const tokenReturn)
	#define UNSTORECLIENTPROPERTY() /*-----------------------*/ local bool               unstoreClientProperty(Client *const client, const xcb_atom_t property)
	#define FINDOWNEDWINDOW() /*-----------------------------*/ local bool               findOwnedWindow(const xcb_window_t window)
	#define FINIWINDOWMANAGERSYSTEM() /*---------------------*/ local bool               finiWindowManagerSystem(void)

	#define SETWINDOWPROPERTIES() /*-------------------------*/ local bool               setWindowProperties(WindowInfo *const windowInfo, const ElementPreferences *const windowPreferences, const int x, const int y, const uint width, const uint height)
	#define DRAWWINDOW() /*----------------------------------*/ local bool               drawWindow(WindowSystem *const windowSystem, const WindowInfo *const windowInfo, const ElementPreferences *const windowPreferences, Monitor *const monitor, ElementRectangle *windowRectangle)

	#define SETCONFIGVARIABLES() /*--------------------------*/ local void               setConfigVariables(void)
	#define READCONFIG() /*----------------------------------*/ local void               readConfig(const bool createConfigFile, const char *const configPath, int (*getNextConfigChar)(void *const arg), int (*getPreviousConfigChar)(void *const arg))
	#define IFGETC() /*--------------------------------------*/ local int                ifgetc(void *const system)
	#define MATCHNAMELIST() /*-------------------------------*/ local uint8              matchNameList(StringTreeSystem *const stringTreeSystem, const char *const statementWall, char **statementCurrentReturn, uint8 *const valueReturn)
	#define MATCHINTEGER() /*--------------------------------*/ local uint8              matchInteger(char **statementCurrent, const char *const statementWall, int64 *const returnValue)
	#define MATCHSTRING() /*---------------------------------*/ local bool               matchString(char **statementCurrent, char **stringReturn, uint32 *stringToken)
	#define MATCHIMAGE() /*----------------------------------*/ local uint8              matchImage(const char *const path, const char **errorMessage, Image *const image)
	#define MATCHCOMMAND() /*--------------------------------*/ local uint8              matchCommand(const Command command, const char *const execute, const uint8 origin, const int32 field0, const int32 field1, const int32 field2, const int32 field3, const int32 field4)
	#define FREECONFIGVARIABLES() /*-------------------------*/ local void               freeConfigVariables(void)

	#define CREATECIRCLE() /*--------------------------------*/ local bool               createCircle(const int radius, const uint32 foreground, const uint32 background, Image *image)
	#define COMPOSITEIMAGES() /*-----------------------------*/ local void               compositeImages(void (*operation)(const uint32 *const, uint32 *const), const int sourceX, const int sourceY, Image *const source, int destinationX, int destinationY, Image *const destination)
	#define COMPOSITEIMAGESOVER() /*-------------------------*/ local void               compositeImagesOver(const uint32 *const source, uint32 *const destination)
	#define COMPOSITEIMAGESAND() /*--------------------------*/ local void               compositeImagesAnd(const uint32 *const source, uint32 *const destination)
	#define TWOPASSBOXBLUR() /*------------------------------*/ local void               twoPassBoxBlur(const int width, const int height, const int boxSize, uint32 *destinationData)
	#define ROTATEIMAGE() /*---------------------------------*/ local bool               rotateImage(const uint8 rotation, Image *const image, const bool deletePreviousData)

	#define XCB_SYNC() /*------------------------------------*/ local bool               xcb_sync(void)
	#define GETWINDOWCLASS() /*------------------------------*/ local uint8              getWindowClass(xcb_window_t window)
	#define GETFOCUSEDWINDOW() /*----------------------------*/ local xcb_window_t       getFocusedWindow(void)

	#define RESTART() /*-------------------------------------*/ local void               restart(const bool isInsideConfig)
	#define CLEANUP() /*-------------------------------------*/ local void               cleanup(void)
	#define CANCELTHREADS() /*-------------------------------*/ local void               cancelThreads(void)

	#define PRINTUNACCOUNTEDFORPOINTERS() /*-----------------*/ local void               printUnaccountedForPointers(const Pointer *current, const Pointer *wall)
	#define PRINTERROR() /*----------------------------------*/ local void               printError(const char *const message, ...)
	#define PRINTTITLEDERROR() /*----------------------------*/ local void               printTitledError(const char *const title, const char *const message)
	#define PRINTTITLEDQUOTEDERROR() /*----------------------*/ local void               printTitledQuotedError(const char *const title, const char *const argument, const char *const message)
	#define PRINTCONNECTIONERROR() /*------------------------*/ local void               printConnectionError(void)
	#define PRINTTITLEDNAMEDERROR() /*-----------------------*/ local void               printTitledNamedError(const char *const title, const char *const message, const char *const name)
	#define PRINTXERROR() /*---------------------------------*/ local void               printXError(const char *const *const name)
	#define PRINTTITLEDVALUEDERROR() /*----------------------*/ local void               printTitledValuedError(const char *const title, const char *const message, const uint value)
	#define PRINTCONFIGERROR() /*----------------------------*/ local void               printConfigError(const char *const type, const char *const message, const char finalStatementCharacter, const bool printLine, const bool printConfig, const bool printPointer, const bool printPattern, const char *const configPath, const uint statementLine, const char *const statementStart, const char *const statementWall, const Instruction *instructionStart, const Instruction *instructionCurrent, StringTreeSystem *const *const instructionDataStart, const char *const *currentScopeInstructionList, const StringTreeSystem *const currentScopeInstructionStringTreeSystem)

	#if DEBUG
		#define printCommand(s, c) /*---*/ (fprintf(DEFAULT_OUTPUT_STREAM, "%s%s: %s" s " command:%s %s\n", colorStart, programName, colorEvent, colorEnd, *(commandList + (c >= countof(commandList)? countof(commandList) - 1 : c))))
	#else
		#define printCommand(s, c) /*---*/ EMPTY_MACRO
	#endif
/*!}*/









/*!*/

#define DIRECTION_CONTENT(k, v, n, p) /*------------------*/ { \
	  v(none)  k(NONE##p  = (b(0000))) \
	, v(up)    k(UP##p    = (b(0001))) \
	, v(down)  k(DOWN##p  = (b(0010))) \
	, v(left)  k(LEFT##p  = (b(0100))) \
	, v(right) k(RIGHT##p = (b(1000))) \
	, n(NULL)  k(NULL##p) \
}









/*!defs:{*/
	def enum ENUM_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	def enum ENUM_CONTENT(GLOBAL_INSTRUCTION);
	def enum ENUM_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	def enum ENUM_CONTENT(BOOLEAN);
	def enum ENUM_CONTENT(VARIABLE);
	def enum ENUM_CONTENT(COMMAND);
	def enum ENUM_CONTENT(MODIFIER);
	def enum ENUM_CONTENT(SHORTCUT_STATE);
	def enum ENUM_CONTENT(NUMBER_TYPE);
	def enum ENUM_CONTENT(POSITION);
	def enum ENUM_CONTENT(HORIZONTAL_ALIGNMENT);
	def enum ENUM_CONTENT(VERTICAL_ALIGNMENT);
	def enum ENUM_CONTENT(CORNER);
	def enum ENUM_CONTENT(AXIS);
	def enum ENUM_CONTENT(WHICH_MONITOR);
	def enum ENUM_CONTENT(DIRECTION);
	def enum ENUM_CONTENT(ROTATION);
	def enum ENUM_CONTENT(MACRO);

	def struct{
		uint32 /*--------------*/ timestamp;
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
	} PointerSystem;

	def struct{
		xcb_font_t /*----------*/ cursorFont;
		xcb_cursor_t /*--------*/ cursor;
	} CursorSystem;

	def struct{
		xcb_pixmap_t /*--------*/ pixmap;
		xcb_gcontext_t /*------*/ gc;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
		uint32 /*--------------*/ color;
		xcb_pixmap_t /*--------*/ wallpaperPixmap;
		uint32 /*--------------*/ wallpaperWidth;
		uint32 /*--------------*/ wallpaperHeight;
	} WallpaperSystem;

	def struct{
		uint8 /*---------------*/ pad0[3];
		bool /*----------------*/ inUse;
		xcb_window_t /*--------*/ container;
		xcb_window_t /*--------*/ window;
		xcb_pixmap_t /*--------*/ pixmap;
		xcb_gcontext_t /*------*/ gc;
		int32 /*---------------*/ containerX;
		int32 /*---------------*/ containerY;
		uint32 /*--------------*/ containerWidth;
		uint32 /*--------------*/ containerHeight;
		uint32 /*--------------*/ containerBorder;
		int32 /*---------------*/ windowX;
		int32 /*---------------*/ windowY;
		uint32 /*--------------*/ windowWidth;
		uint32 /*--------------*/ windowHeight;
		uint32 /*--------------*/ windowBorder;
		int32 /*---------------*/ strutX;
		int32 /*---------------*/ strutY;
		uint32 /*--------------*/ strutWidth;
		uint32 /*--------------*/ strutHeight;
		int32 /*---------------*/ oldContainerX;
		int32 /*---------------*/ oldContainerY;
		uint32 /*--------------*/ oldContainerWidth;
		uint32 /*--------------*/ oldContainerHeight;
		uint32 /*--------------*/ oldContainerBorder;
		uint8 * /*-------------*/ nameStart;
		uint32 /*--------------*/ nameToken;
		uint32 /*--------------*/ nameSize;
		uint8 * /*-------------*/ iconNameStart;
		uint32 /*--------------*/ iconNameToken;
		uint32 /*--------------*/ iconNameSize;
		uint32 /*--------------*/ normalHintsFlags;
		int32 /*---------------*/ normalHintsX;
		int32 /*---------------*/ normalHintsY;
		int32 /*---------------*/ normalHintsWidth;
		int32 /*---------------*/ normalHintsHeight;
		int32 /*---------------*/ normalHintsMinWidth;
		int32 /*---------------*/ normalHintsMinHeight;
		int32 /*---------------*/ normalHintsMaxWidth;
		int32 /*---------------*/ normalHintsMaxHeight;
		int32 /*---------------*/ normalHintsWidthInc;
		int32 /*---------------*/ normalHintsHeightInc;
		int32 /*---------------*/ normalHintsMinAspectNumerator;
		int32 /*---------------*/ normalHintsMinAspectDenominator;
		int32 /*---------------*/ normalHintsMaxAspectNumerator;
		int32 /*---------------*/ normalHintsMaxAspectDenominator;
		int32 /*---------------*/ normalHintsBaseWidth;
		int32 /*---------------*/ normalHintsBaseHeight;
		int32 /*---------------*/ normalHintsWindowGravity;
		uint32 /*--------------*/ hintsInput;
		uint32 /*--------------*/ hintsInitialState;
		xcb_pixmap_t /*--------*/ hintsIconPixmap;
		xcb_window_t /*--------*/ hintsIconWindow;
		int32 /*---------------*/ hintsIconX;
		int32 /*---------------*/ hintsIconY;
		xcb_pixmap_t /*--------*/ hintsIconMask;
		xcb_window_t /*--------*/ hintsWindowGroup;
		uint32 /*--------------*/ hintsUrgency;
		xcb_window_t /*--------*/ transientFor;
		uint8 * /*-------------*/ classStart;
		uint32 /*--------------*/ classToken;
		uint32 /*--------------*/ classSize;
		xcb_atom_t * /*--------*/ protocolStart;
		uint32 /*--------------*/ protocolToken;
		uint32 /*--------------*/ protocolSize;
		xcb_window_t * /*------*/ colormapWindowStart;
		uint32 /*--------------*/ colormapWindowToken;
		uint32 /*--------------*/ colormapWindowSize;
		uint8 * /*-------------*/ clientMachineStart;
		uint32 /*--------------*/ clientMachineToken;
		uint32 /*--------------*/ clientMachineSize;
		uint8 * /*-------------*/ clientIDStart;
		uint32 /*--------------*/ clientIDToken;
		uint32 /*--------------*/ clientIDSize;
		xcb_window_t /*--------*/ clientLeader;
		uint32 /*--------------*/ desktop;
		uint32 /*--------------*/ stateState;
		xcb_window_t /*--------*/ stateIcon;
		uint8 * /*-------------*/ windowRoleStart;
		uint32 /*--------------*/ windowRoleToken;
		uint32 /*--------------*/ windowRoleSize;
		uint8 * /*-------------*/ visibleNameStart;
		uint32 /*--------------*/ visibleNameToken;
		uint32 /*--------------*/ visibleNameSize;
		uint8 * /*-------------*/ visibleIconNameStart;
		uint32 /*--------------*/ visibleIconNameToken;
		uint32 /*--------------*/ visibleIconNameSize;
		xcb_atom_t * /*--------*/ windowTypeStart;
		uint32 /*--------------*/ windowTypeToken;
		uint32 /*--------------*/ windowTypeSize;
		xcb_atom_t * /*--------*/ stateStart;
		uint32 /*--------------*/ stateToken;
		uint32 /*--------------*/ stateSize;
		xcb_atom_t * /*--------*/ allowedActionStart;
		uint32 /*--------------*/ allowedActionToken;
		uint32 /*--------------*/ allowedActionSize;
		uint32 /*--------------*/ strutLeft;
		uint32 /*--------------*/ strutRight;
		uint32 /*--------------*/ strutTop;
		uint32 /*--------------*/ strutBottom;
		uint32 /*--------------*/ strutLeftStartY;
		uint32 /*--------------*/ strutLeftEndY;
		uint32 /*--------------*/ strutRightStartY;
		uint32 /*--------------*/ strutRightEndY;
		uint32 /*--------------*/ strutTopStartX;
		uint32 /*--------------*/ strutTopEndX;
		uint32 /*--------------*/ strutBottomStartX;
		uint32 /*--------------*/ strutBottomEndX;
		uint32 /*--------------*/ iconGeometryX;
		uint32 /*--------------*/ iconGeometryY;
		uint32 /*--------------*/ iconGeometryWidth;
		uint32 /*--------------*/ iconGeometryHeight;
		uint32 * /*------------*/ iconStart;
		uint32 /*--------------*/ iconToken;
		uint32 /*--------------*/ iconSize;
		uint64 /*--------------*/ userTime;
		uint32 /*--------------*/ pid;
		uint32 /*--------------*/ frameExtentsLeft;
		uint32 /*--------------*/ frameExtentsRight;
		uint32 /*--------------*/ frameExtentsTop;
		uint32 /*--------------*/ frameExtentsBottom;
		uint8 /*---------------*/ protocol;
		uint8 /*---------------*/ windowType;
		uint16 /*--------------*/ state;
		uint16 /*--------------*/ allowedAction;
		bool /*----------------*/ strut;
		bool /*----------------*/ handledIcons;
		uint8 /*---------------*/ propertyPreference;
		uint8 /*---------------*/ orderType;
		uint8 /*---------------*/ option;
		uint8 /*---------------*/ workareaPosition;
	} Client;

	def struct{
		Client * /*------------*/ clientStart;
		uint32 /*--------------*/ clientToken;
		uint32 /*--------------*/ clientSize;
		uint32 /*--------------*/ clientAllocated;
		uint32 /*--------------*/ clientNotInUseOffset;
		uint32 /*--------------*/ orderedClientOffsetSize;
		uint32 /*--------------*/ orderedClientOffsetAllocated;
		uint * /*--------------*/ orderedClientOffsetStart;
		uint32 /*--------------*/ orderedClientOffsetToken;
		uint8 /*---------------*/ pad0[6];
		uint8 /*---------------*/ motionAction;
		uint8 /*---------------*/ motionGravity;
		int32 /*---------------*/ motionStartingX;
		int32 /*---------------*/ motionStartingY;
		int32 /*---------------*/ motionX;
		int32 /*---------------*/ motionY;
		int32 /*---------------*/ motionWidth;
		int32 /*---------------*/ motionHeight;
		uint32 /*--------------*/ recentlyConfiguredClientOffset;
		uint32 /*--------------*/ motionClientOffset;
		uint32 /*--------------*/ focusedClientOffset;
	} ClientSystem;

	def struct{
		int32 /*---------------*/ top;
		int32 /*---------------*/ bottom;
		int32 /*---------------*/ left;
		int32 /*---------------*/ right;
	} EdgeOffset;

	def struct{
		uint32 /*--------------*/ orderedClientOffsetSize;
		uint32 /*--------------*/ orderedClientOffsetAllocated;
		uint * /*--------------*/ orderedClientOffsetStart;
		uint32 /*--------------*/ orderedClientOffsetToken;
		uint32 /*--------------*/ nameSize;
		uint8 * /*-------------*/ nameStart;
		uint32 /*--------------*/ nameToken;
		uint32 /*--------------*/ workareaEdgeOffsetSize;
		EdgeOffset * /*--------*/ workareaEdgeOffsetStart;
		uint32 /*--------------*/ workareaEdgeOffsetToken;
		xcb_window_t /*--------*/ window;
		xcb_pixmap_t /*--------*/ pixmap;
		xcb_gcontext_t /*------*/ gc;
	} VirtualRoot;

	def struct{
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
	} Viewport;

	def struct{
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
	} Workarea;

	def struct{
		uint32 /*--------------*/ virtualRootSize;
		uint32 /*--------------*/ virtualRootAllocated;
		VirtualRoot * /*-------*/ virtualRootStart;
		uint32 /*--------------*/ virtualRootToken;
		uint32 /*--------------*/ workareaEdgeOffsetSize;
		EdgeOffset * /*--------*/ workareaEdgeOffsetStart;
		uint32 /*--------------*/ workareaEdgeOffsetToken;
		uint32 /*--------------*/ windowSize;
		xcb_window_t * /*------*/ windowStart;
		uint32 /*--------------*/ windowToken;
		uint32 /*--------------*/ viewportSize;
		Viewport * /*----------*/ viewportStart;
		uint32 /*--------------*/ viewportToken;
		uint32 /*--------------*/ desktopNamesSize;
		uint8 * /*-------------*/ desktopNamesStart;
		uint32 /*--------------*/ desktopNamesToken;
		uint32 /*--------------*/ workareaSize;
		Workarea * /*----------*/ workareaStart;
		uint32 /*--------------*/ workareaToken;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
		uint32 /*--------------*/ currentDesktop;
		uint32 /*--------------*/ showingDesktop;
		uint32 /*--------------*/ desktopLayoutColumns;
		uint32 /*--------------*/ desktopLayoutRows;
		uint8 /*---------------*/ desktopLayoutOrientation;
		uint8 /*---------------*/ desktopLayoutStartingCorner;
		bool /*----------------*/ mapped;
		uint8 /*---------------*/ pad1[1];
	} VirtualRootSystem;

	def struct{
		uint32 /*--------------*/ clientSize;
		uint32 /*--------------*/ clientAllocated;
		xcb_window_t * /*------*/ clientStart;
		uint32 /*--------------*/ clientToken;
		xcb_atom_t /*----------*/ property;
	} ClientListSystem;

	def struct{
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		int32 /*---------------*/ xOffset;
		int32 /*---------------*/ yOffset;
		int32 /*---------------*/ width;
		int32 /*---------------*/ height;
		int32 /*---------------*/ padding;
		int32 /*---------------*/ margin;
		uint8 /*---------------*/ xType;
		uint8 /*---------------*/ yType;
		uint8 /*---------------*/ xOffsetType;
		uint8 /*---------------*/ yOffsetType;
		uint8 /*---------------*/ widthType;
		uint8 /*---------------*/ heightType;
		uint8 /*---------------*/ paddingType;
		uint8 /*---------------*/ marginType;
		uint8 /*---------------*/ position;
		uint8 /*---------------*/ horizontalAlignment;
		uint8 /*---------------*/ verticalAlignment;
		uint8 /*---------------*/ pad0[3];
		bool /*----------------*/ clipChildren;
		uint8 /*---------------*/ cornerUsed;
		uint32 /*--------------*/ cornerRadius;
		uint32 /*--------------*/ foreground;
		uint32 /*--------------*/ background;
		uint32 /*--------------*/ selectedForeground;
		uint32 /*--------------*/ selectedBackground;
	} ElementPreferences;

	def struct{
		xcb_window_t /*--------*/ window;
		xcb_pixmap_t /*--------*/ bufferPixmap;
		xcb_pixmap_t /*--------*/ pixmap;
		xcb_gcontext_t /*------*/ gc;
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
		bool /*----------------*/ mapped;
		uint8 /*---------------*/ pad0[3];
	} WindowInfo;

	def struct{
		xcb_pixmap_t /*--------*/ circlePixmap;
		uint32 /*--------------*/ windowInfoSize;
		WindowInfo * /*--------*/ windowInfoStart;
		uint32 /*--------------*/ windowInfoToken;
		bool /*----------------*/ mapped;
		uint8 /*---------------*/ pad0[3];
	} WindowSystem;

	def struct{
		Monitor * /*-----------*/ monitor;
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
		uint32 /*--------------*/ horizontalPadding;
		uint32 /*--------------*/ verticalPadding;
		uint32 /*--------------*/ horizontalMargin;
		uint32 /*--------------*/ verticalMargin;
	} ElementRectangle;

	def struct{
		bool /*----------------*/ (*risingOperation)(void *const arg);
		void * /*--------------*/ risingOperationArgument;
		bool /*----------------*/ (*fallingOperation)(void *const arg);
		void * /*--------------*/ fallingOperationArgument;
		uint32 /*--------------*/ seconds;
		uint32 /*--------------*/ nanoseconds;
		bool /*----------------*/ loopOperation;
		bool /*----------------*/ restartTimer;
		uint8 /*---------------*/ pad0[1];
		bool /*----------------*/ running;
		bool /*----------------*/ quittingThread;
		bool /*----------------*/ mutexCreated;
		bool /*----------------*/ condCreated;
		bool /*----------------*/ threadCreated;
		pthread_mutex_t /*-----*/ mutex;
		pthread_cond_t /*------*/ cond;
		pthread_t /*-----------*/ thread;
	} SleepThreadSystem;

	def struct{
		uint8 /*---------------*/ letter;
		uint8 /*---------------*/ childrenAmount;
		uint16 /*--------------*/ offset[STRING_TREE_NODE_CHILDREN_AMOUNT];
	} StringTreeNode;

	def struct{
		const char *const * /*-*/ stringArray;
		uint32 /*--------------*/ dataSize;
		uint32 /*--------------*/ dataAllocated;
		StringTreeNode * /*----*/ dataStart;
		uint32 /*--------------*/ dataToken;
		uint8 /*---------------*/ counter;
		uint8 /*---------------*/ returnedCounter;
		uint8 /*---------------*/ pad0[2];
	} StringTreeSystem;

	def struct{
		uint32 /*--------------*/ size;
		uint32 /*--------------*/ allocated;
		char * /*--------------*/ start;
		char * /*--------------*/ current;
		uint32 /*--------------*/ token;
		uint8 /*---------------*/ pad0[1];
		bool /*----------------*/ threadCreated;
		bool /*----------------*/ operating;
		bool /*----------------*/ quittingThread;
		pthread_t /*-----------*/ thread;
	} STDINSystem;

	def struct{
		int32 /*---------------*/ shmID;
		uint32 /*--------------*/ shmToken;
		uint8 * /*-------------*/ start;
		uint8 * /*-------------*/ current;
		uint32 /*--------------*/ token;
		uint8 /*---------------*/ pad0[6];
		bool /*----------------*/ mutexCreated;
		bool /*----------------*/ condCreated;
		bool /*----------------*/ threadCreated;
		bool /*----------------*/ operating;
		bool /*----------------*/ quittingFromInside;
		bool /*----------------*/ quittingThread;
		pthread_mutex_t * /*---*/ mutex;
		pthread_cond_t * /*----*/ cond;
		pthread_t /*-----------*/ thread;
	} SharedMemorySystem;
/*!}*/

/*!globals:{*/
	local const char * /*-------------------*/ programName;
	local const char * /*-------------------*/ errorPath;
	local const char * /*-------------------*/ colorStart;
	local const char * /*-------------------*/ colorFatal;
	local const char * /*-------------------*/ colorError;
	local const char * /*-------------------*/ colorEvent;
	local const char * /*-------------------*/ colorEnd;
	local const char * /*-------------------*/ labelExamined;
	local const char * /*-------------------*/ connectionName;
	local const char * /*-------------------*/ configPath;
	local const char * /*-------------------*/ localeName;
	local const ModifierNode * /*-----------*/ eventModifierNode;
	local bool /*---------------------------*/ mustOpenErrorStream;
	local FILE * /*-------------------------*/ errorStream;
	local uint32 /*-------------------------*/ errorStreamToken;
	local volatile bool /*------------------*/ processingSignal;
	local bool /*---------------------------*/ quitting;
	local MemoryManagementSystem /*------------*/ memoryManagementSystem;
	local PermissionSystem /*---------------*/ permissionSystem;
	local bool /*---------------------------*/ globalsLockCreated;
	local pthread_rwlock_t /*---------------*/ globalsLock;
	local int /*----------------------------*/ screenNumber;
	local xcb_connection_t * /*-------------*/ connection;
	local uint32 /*-------------------------*/ connectionToken;
	local xcb_screen_t * /*-----------------*/ screen;
	local uint /*---------------------------*/ screenWidthInPixels;
	local uint /*---------------------------*/ screenHeightInPixels;
	local uint /*---------------------------*/ screenWidthInMillimeters;
	local uint /*---------------------------*/ screenHeightInMillimeters;
	local uint8 /*--------------------------*/ randrMajorOpcode;
	local uint8 /*--------------------------*/ randrBaseEvent;
	local uint8 /*--------------------------*/ randrBaseError;
	local uint8 /*--------------------------*/ shapeMajorOpcode;
	local uint8 /*--------------------------*/ shapeBaseEvent;
	local uint8 /*--------------------------*/ shapeBaseError;
	local uint8 /*--------------------------*/ xfixesMajorOpcode;
	local uint8 /*--------------------------*/ xfixesBaseEvent;
	local uint8 /*--------------------------*/ xfixesBaseError;
	local CommonAtoms /*--------------------*/ atom;
	local xcb_visualid_t /*-----------------*/ visual;
	local uint8 /*--------------------------*/ depth;
	local xcb_colormap_t /*-----------------*/ colormap;
	local MonitorSystem /*------------------*/ monitorSystem;
	local PointerSystem /*------------------*/ pointerSystem;
	local CursorSystem /*-------------------*/ cursorSystem;
	local WallpaperSystem /*----------------*/ wallpaperSystem;
	local ClientSystem /*-------------------*/ clientSystem;
	local VirtualRootSystem /*--------------*/ virtualRootSystem;
	local ClientListSystem /*---------------*/ clientListSystem;
	local ClientListSystem /*---------------*/ clientListStackingSystem;
	local xcb_window_t /*-------------------*/ previousWMSelectionWindow;
	local xcb_window_t /*-------------------*/ wmSelectionWindow;
	local xcb_timestamp_t /*----------------*/ wmSelectionTimestamp;
	local xcb_window_t /*-------------------*/ wmCheckWindow;
	local xcb_window_t /*-------------------*/ defaultFocusWindow;
	local xcb_window_t /*-------------------*/ glassWindow;
	local bool /*---------------------------*/ focusOnClick;
	local bool /*---------------------------*/ focusOnHover;
	local ElementPreferences /*-------------*/ windowPreferences;
	local uint8 /*--------------------------*/ whichMonitor;
	local WindowSystem /*-------------------*/ windowSystem;
	local SleepThreadSystem /*--------------*/ sleepThreadSystem;
	local StringTreeSystem /*---------------*/ globalScopesInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ globalInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ scope1ScopeInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ booleanStringTreeSystem;
	local StringTreeSystem /*---------------*/ variableStringTreeSystem;
	local StringTreeSystem /*---------------*/ commandStringTreeSystem;
	local StringTreeSystem /*---------------*/ modifierStringTreeSystem;
	local StringTreeSystem /*---------------*/ shortcutStateStringTreeSystem;
	local StringTreeSystem /*---------------*/ numberTypeStringTreeSystem;
	local StringTreeSystem /*---------------*/ horizontalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ verticalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ cornerStringTreeSystem;
	local StringTreeSystem /*---------------*/ whichMonitorStringTreeSystem;
	local StringTreeSystem /*---------------*/ directionStringTreeSystem;
	local StringTreeSystem /*---------------*/ macroStringTreeSystem;
	local bool /*---------------------------*/ displaySimpleConfigErrors;
	local STDINSystem /*--------------------*/ stdinSystem;
	local SharedMemorySystem /*-------------*/ sharedMemorySystem;
	local ShortcutSystem /*-----------------*/ keycodeShortcutSystem;
	local ShortcutSystem /*-----------------*/ buttonShortcutSystem;
	local xcb_generic_event_t * /*----------*/ event;
	local uint32 /*-------------------------*/ eventToken;
	local int /*----------------------------*/ keyPressNextOffset;
	local int /*----------------------------*/ keyReleaseNextOffset;
	local int /*----------------------------*/ buttonPressNextOffset;
	local int /*----------------------------*/ buttonReleaseNextOffset;
	local uint8 /*--------------------------*/ shortcutCode;
	local uint16 /*-------------------------*/ shortcutModifier;
	local bool /*---------------------------*/ expectingSecondKeyRelease;
	local uint8 /*--------------------------*/ realKeyReleaseModifier;

	local const char *const /*--------------*/ globalScopesInstructionList[] = STRING_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	local const char *const /*--------------*/ globalInstructionList[] = STRING_CONTENT(GLOBAL_INSTRUCTION);
	local const char *const /*--------------*/ scope1ScopeInstructionList[] = STRING_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	local const char *const /*--------------*/ booleanList[] = STRING_CONTENT(BOOLEAN);
	local const char *const /*--------------*/ variableList[] = STRING_CONTENT(VARIABLE);
	local const char *const /*--------------*/ commandList[] = STRING_CONTENT(COMMAND);
	local const char *const /*--------------*/ modifierList[] = STRING_CONTENT(MODIFIER);
	local const char *const /*--------------*/ shortcutStateList[] = STRING_CONTENT(SHORTCUT_STATE);
	local const char *const /*--------------*/ numberTypeList[] = STRING_CONTENT(NUMBER_TYPE);
	local const char *const /*--------------*/ horizontalAlignmentList[] = STRING_CONTENT(HORIZONTAL_ALIGNMENT);
	local const char *const /*--------------*/ verticalAlignmentList[] = STRING_CONTENT(VERTICAL_ALIGNMENT);
	local const char *const /*--------------*/ cornerList[] = STRING_CONTENT(CORNER);
	local const char *const /*--------------*/ whichMonitorList[] = STRING_CONTENT(WHICH_MONITOR);
	local const char *const /*--------------*/ directionList[] = STRING_CONTENT(DIRECTION);
	local const char *const /*--------------*/ macroList[] = STRING_CONTENT(MACRO);

	local const Instruction /*--------------*/ helpInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ expandInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ contractInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ readConfigInstruction[] = {STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useTerminalInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useMessengerInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ setInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ doInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ stopInstruction[] = {END_INSTRUCTION_TYPE};

	local const Instruction /*--------------*/ executeDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeLeftDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeRightDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopLeftDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopRightDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomLeftDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomRightDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeCenterDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeFullDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ moveDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ resizeDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ enterMaximizedDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ toggleMaximizedDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ enterFullscreenDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ toggleFullscreenDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ goToWorkspaceDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ moveWindowToWorkspaceDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ goToWorkspaceWithWindowDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeLeftGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeRightGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopLeftGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopRightGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomLeftGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomRightGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeCenterGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeFullGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ moveGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ resizeGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ enterMaximizedGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ toggleMaximizedGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ enterFullscreenGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ toggleFullscreenGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ goToWorkspaceGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ moveWindowToWorkspaceGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ goToWorkspaceWithWindowGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeLeftGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeRightGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopLeftGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopRightGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomLeftGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomRightGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeCenterGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeFullGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ moveGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ resizeGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ enterMaximizedGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ toggleMaximizedGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ enterFullscreenGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ toggleFullscreenGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ goToWorkspaceGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ moveWindowToWorkspaceGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ goToWorkspaceWithWindowGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};

	local StringTreeSystem *const *const /*-*/ helpInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ expandInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ contractInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ readConfigInstructionData = NULL;
	local StringTreeSystem *const /*--------*/ useTerminalInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ useMessengerInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ setInstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ doInstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabKeycodeInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabButtonInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabKeycodeInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabButtonInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const *const /*-*/ stopInstructionData = NULL;

	local StringTreeSystem *const /*--------*/ executeDoSubinstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeLeftDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeRightDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopLeftDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopRightDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomLeftDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomRightDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeCenterDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeFullDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ moveDoSubinstructionData[] = {&commandStringTreeSystem, &directionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ resizeDoSubinstructionData[] = {&commandStringTreeSystem, &directionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ enterMaximizedDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ toggleMaximizedDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ enterFullscreenDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ toggleFullscreenDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ goToWorkspaceDoSubinstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ moveWindowToWorkspaceDoSubinstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ goToWorkspaceWithWindowDoSubinstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeLeftGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeRightGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopLeftGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopRightGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomLeftGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomRightGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeCenterGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeFullGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ moveGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &directionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ resizeGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &directionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ enterMaximizedGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ toggleMaximizedGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ enterFullscreenGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ toggleFullscreenGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ goToWorkspaceGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ moveWindowToWorkspaceGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ goToWorkspaceWithWindowGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeLeftGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeRightGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopLeftGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopRightGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomLeftGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomRightGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeCenterGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeFullGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ moveGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &directionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ resizeGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &directionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ enterMaximizedGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ toggleMaximizedGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ enterFullscreenGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ toggleFullscreenGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ goToWorkspaceGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ moveWindowToWorkspaceGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ goToWorkspaceWithWindowGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};

	#define getInstruction(i) /*-----*/ (i##Instruction)
	#define getInstructionData(i) /*-*/ (i##InstructionData)
	#define getGlobalScope(i) /*-----*/ { \
		  get##i(help) \
		, get##i(expand) \
		, get##i(contract) \
		, get##i(readConfig) \
		, get##i(useTerminal) \
		, get##i(useMessenger) \
		, get##i(set) \
		, get##i(do) \
		, get##i(grabKeycode) \
		, get##i(grabButton) \
		, get##i(ungrabKeycode) \
		, get##i(ungrabButton) \
		, get##i(stop) \
	}
/*!}*/









#define CONTAINER_EVENT_MASK /*---------------------------*/ (XCB_EVENT_MASK_ENTER_WINDOW | XCB_EVENT_MASK_RESIZE_REDIRECT | XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY | XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT | XCB_EVENT_MASK_PROPERTY_CHANGE)
#define WINDOW_EVENT_MASK /*------------------------------*/ (XCB_EVENT_MASK_STRUCTURE_NOTIFY | XCB_EVENT_MASK_FOCUS_CHANGE | XCB_EVENT_MASK_PROPERTY_CHANGE | XCB_EVENT_MASK_COLOR_MAP_CHANGE)

#define NONE_MOTION_ACTION /*-----------------------------*/ (0)
#define MOVE_MOTION_ACTION /*-----------------------------*/ (1)
#define RESIZE_MOTION_ACTION /*---------------------------*/ (2)

#define SIZE_TOPLEFT_MOVERESIZE /*------------------------*/ (0)
#define SIZE_TOP_MOVERESIZE /*----------------------------*/ (1)
#define SIZE_TOPRIGHT_MOVERESIZE /*-----------------------*/ (2)
#define SIZE_RIGHT_MOVERESIZE /*--------------------------*/ (3)
#define SIZE_BOTTOMRIGHT_MOVERESIZE /*--------------------*/ (4)
#define SIZE_BOTTOM_MOVERESIZE /*-------------------------*/ (5)
#define SIZE_BOTTOMLEFT_MOVERESIZE /*---------------------*/ (6)
#define SIZE_LEFT_MOVERESIZE /*---------------------------*/ (7)
#define MOVE_MOVERESIZE /*--------------------------------*/ (8)
#define SIZE_KEYBOARD_MOVERESIZE /*-----------------------*/ (9)
#define MOVE_KEYBOARD_MOVERESIZE /*-----------------------*/ (10)

#define CLIENT_BLOCK_SIZE /*------------------------------*/ (256)

#define NONE_DESKTOP /*-----------------------------------*/ (0xFFFFFFFE)

#define NONE_CLIENT_PROTOCOL /*---------------------------*/ (b(0000))
#define TAKE_FOCUS_CLIENT_PROTOCOL /*---------------------*/ (b(0001))
#define DELETE_WINDOW_CLIENT_PROTOCOL /*------------------*/ (b(0010))
#define PING_CLIENT_PROTOCOL /*---------------------------*/ (b(0100))
#define SYNC_CLIENT_PROTOCOL /*---------------------------*/ (b(1000))

#define NONE_WINDOW_TYPE /*-------------------------------*/ (b(00000000))
#define DESKTOP_WINDOW_TYPE /*----------------------------*/ (b(00000001))
#define DOCK_WINDOW_TYPE /*-------------------------------*/ (b(00000010))
#define TOOLBAR_WINDOW_TYPE /*----------------------------*/ (b(00000100))
#define MENU_WINDOW_TYPE /*-------------------------------*/ (b(00001000))
#define UTILITY_WINDOW_TYPE /*----------------------------*/ (b(00010000))
#define SPLASH_WINDOW_TYPE /*-----------------------------*/ (b(00100000))
#define DIALOG_WINDOW_TYPE /*-----------------------------*/ (b(01000000))
#define NORMAL_WINDOW_TYPE /*-----------------------------*/ (b(10000000))

#define NONE_STATE /*-------------------------------------*/ (b(000000000000))
#define MODAL_STATE /*------------------------------------*/ (b(000000000001))
#define STICKY_STATE /*-----------------------------------*/ (b(000000000010))
#define MAXIMIZED_HORZ_STATE /*---------------------------*/ (b(000000000100))
#define MAXIMIZED_VERT_STATE /*---------------------------*/ (b(000000001000))
#define SHADED_STATE /*-----------------------------------*/ (b(000000010000))
#define SKIP_TASKBAR_STATE /*-----------------------------*/ (b(000000100000))
#define SKIP_PAGER_STATE /*-------------------------------*/ (b(000001000000))
#define HIDDEN_STATE /*-----------------------------------*/ (b(000010000000))
#define FULLSCREEN_STATE /*-------------------------------*/ (b(000100000000))
#define ABOVE_STATE /*------------------------------------*/ (b(001000000000))
#define BELOW_STATE /*------------------------------------*/ (b(010000000000))
#define DEMANDS_ATTENTION_STATE /*------------------------*/ (b(100000000000))

#define NONE_ALLOWED_ACTION /*----------------------------*/ (b(0000000000))
#define MOVE_ALLOWED_ACTION /*----------------------------*/ (b(0000000001))
#define RESIZE_ALLOWED_ACTION /*--------------------------*/ (b(0000000010))
#define MINIMIZE_ALLOWED_ACTION /*------------------------*/ (b(0000000100))
#define SHADE_ALLOWED_ACTION /*---------------------------*/ (b(0000001000))
#define STICK_ALLOWED_ACTION /*---------------------------*/ (b(0000010000))
#define MAXIMIZE_HORZ_ALLOWED_ACTION /*-------------------*/ (b(0000100000))
#define MAXIMIZE_VERT_ALLOWED_ACTION /*-------------------*/ (b(0001000000))
#define FULLSCREEN_ALLOWED_ACTION /*----------------------*/ (b(0010000000))
#define CHANGE_DESKTOP_ALLOWED_ACTION /*------------------*/ (b(0100000000))
#define CLOSE_ALLOWED_ACTION /*---------------------------*/ (b(1000000000))

#define NONE_STRUT /*-------------------------------------*/ (0)
#define TOP_STRUT /*--------------------------------------*/ (1)
#define BOTTOM_STRUT /*-----------------------------------*/ (2)
#define LEFT_STRUT /*-------------------------------------*/ (3)
#define RIGHT_STRUT /*------------------------------------*/ (4)

#define NONE_USER_TIME /*---------------------------------*/ (0x100000000)
#define UNFOCUSED_USER_TIME /*----------------------------*/ (0)

#define NONE_PROPERTY_PREFERENCE /*-----------------------*/ (b(000))
#define NAME_PROPERTY_PREFERENCE /*-----------------------*/ (b(001))
#define ICON_NAME_PROPERTY_PREFERENCE /*------------------*/ (b(010))
#define STRUT_PROPERTY_PREFERENCE /*----------------------*/ (b(100))

#define NONE_ORDER_TYPE /*--------------------------------*/ (0)
#define FULLSCREEN_ORDER_TYPE /*--------------------------*/ (1)
#define ABOVE_ORDER_TYPE /*-------------------------------*/ (2)
#define DOCK_ORDER_TYPE /*--------------------------------*/ (3)
#define NORMAL_ORDER_TYPE /*------------------------------*/ (4)
#define BELOW_ORDER_TYPE /*-------------------------------*/ (5)
#define DESKTOP_ORDER_TYPE /*-----------------------------*/ (6)

#define NONE_CLIENT_OPTION /*-----------------------------*/ (b(0000))
#define OVERRIDE_REDIRECT_CLIENT_OPTION /*----------------*/ (b(0001))
#define TEMPORARILY_UNMAPPED_CLIENT_OPTION /*-------------*/ (b(0010))
#define HORIZONTALLY_MAXIMIZED_CLIENT_OPTION /*-----------*/ (b(0100))
#define VERTICALLY_MAXIMIZED_CLIENT_OPTION /*-------------*/ (b(1000))

#define _NET_WM_STATE_REMOVE /*---------------------------*/ (0)
#define _NET_WM_STATE_ADD /*------------------------------*/ (1)
#define _NET_WM_STATE_TOGGLE /*---------------------------*/ (2)

#define NONE_CLOSE_CLIENT_COMMAND /*----------------------*/ (0)
#define CLOSE_CLOSE_CLIENT_COMMAND /*---------------------*/ (1)
#define KILL_CLOSE_CLIENT_COMMAND /*----------------------*/ (2)

#define _NET_WM_ORIENTATION_HORZ /*-----------------------*/ (0)
#define _NET_WM_ORIENTATION_VERT /*-----------------------*/ (1)

#define _NET_WM_TOPLEFT /*--------------------------------*/ (0)
#define _NET_WM_TOPRIGHT /*-------------------------------*/ (1)
#define _NET_WM_BOTTOMRIGHT /*----------------------------*/ (2)
#define _NET_WM_BOTTOMLEFT /*-----------------------------*/ (3)

#define NONE_WORKAREA_POSITION /*-------------------------*/ (0)
#define TOP_WORKAREA_POSITION /*--------------------------*/ (1)
#define BOTTOM_WORKAREA_POSITION /*-----------------------*/ (2)
#define LEFT_WORKAREA_POSITION /*-------------------------*/ (3)
#define RIGHT_WORKAREA_POSITION /*------------------------*/ (4)
#define TOP_LEFT_WORKAREA_POSITION /*---------------------*/ (5)
#define TOP_RIGHT_WORKAREA_POSITION /*--------------------*/ (6)
#define BOTTOM_LEFT_WORKAREA_POSITION /*------------------*/ (7)
#define BOTTOM_RIGHT_WORKAREA_POSITION /*-----------------*/ (8)
#define CENTER_WORKAREA_POSITION /*-----------------------*/ (9)
#define FULL_WORKAREA_POSITION /*-------------------------*/ (10)

#define NONE_WINDOW_GRAVITY /*----------------------------*/ (0)
#define NORTH_POINT_WINDOW_GRAVITY /*---------------------*/ (1)
#define NORTH_SIDE_WINDOW_GRAVITY /*----------------------*/ (2)
#define SOUTH_POINT_WINDOW_GRAVITY /*---------------------*/ (3)
#define SOUTH_SIDE_WINDOW_GRAVITY /*----------------------*/ (4)
#define WEST_POINT_WINDOW_GRAVITY /*----------------------*/ (5)
#define WEST_SIDE_WINDOW_GRAVITY /*-----------------------*/ (6)
#define EAST_POINT_WINDOW_GRAVITY /*----------------------*/ (7)
#define EAST_SIDE_WINDOW_GRAVITY /*-----------------------*/ (8)
#define NORTH_WEST_POINT_WINDOW_GRAVITY /*----------------*/ (9)
#define NORTH_EAST_POINT_WINDOW_GRAVITY /*----------------*/ (10)
#define SOUTH_WEST_POINT_WINDOW_GRAVITY /*----------------*/ (11)
#define SOUTH_EAST_POINT_WINDOW_GRAVITY /*----------------*/ (12)
#define CENTER_POINT_WINDOW_GRAVITY /*--------------------*/ (13)

#define NONE_UPDATE_WORKAREA_ACTION /*--------------------*/ (0)
#define ADD_UPDATE_WORKAREA_ACTION /*---------------------*/ (1)
#define REMOVE_UPDATE_WORKAREA_ACTION /*------------------*/ (2)

#define CURSOR_GLYPH_CONTENT(k, v, n, p) /*---------------*/ { \
	  v(none)                              k(NONE##p) \
	, v(arrow)                             k(ARROW##p) \
	, v(arrow-down)                        k(ARROW_DOWN##p) \
	, v(arrow-up)                          k(ARROW_UP##p) \
	, v(boat)                              k(BOAT##p) \
	, v(bogosity)                          k(BOGOSITY##p) \
	, v(bottom-left-corner)                k(BOTTOM_LEFT_CORNER##p) \
	, v(bottom-right-corner)               k(BOTTOM_RIGHT_CORNER##p) \
	, v(bottom-side)                       k(BOTTOM_SIDE##p) \
	, v(bottom-tee)                        k(BOTTOM_TEE##p) \
	, v(box-spiral)                        k(BOX_SPIRAL##p) \
	, v(center-pointer)                    k(CENTER_POINTER##p) \
	, v(circle)                            k(CIRCLE##p) \
	, v(clock)                             k(CLOCK##p) \
	, v(coffee-mug)                        k(COFFEE_MUG##p) \
	, v(cross)                             k(CROSS##p) \
	, v(cross-reverse)                     k(CROSS_REVERSE##p) \
	, v(crosshair)                         k(CROSSHAIR##p) \
	, v(diamond-cross)                     k(DIAMOND_CROSS##p) \
	, v(dot)                               k(DOT##p) \
	, v(dot-box)                           k(DOT_BOX##p) \
	, v(double-arrow)                      k(DOUBLE_ARROW##p) \
	, v(draft-large)                       k(DRAFT_LARGE##p) \
	, v(draft-small)                       k(DRAFT_SMALL##p) \
	, v(draped-box)                        k(DRAPED_BOX##p) \
	, v(exchange)                          k(EXCHANGE##p) \
	, v(fleur)                             k(FLEUR##p) \
	, v(gobbler)                           k(GOBBLER##p) \
	, v(gumby)                             k(GUMBY##p) \
	, v(hand-1)                            k(HAND_1##p) \
	, v(hand-2)                            k(HAND_2##p) \
	, v(heart)                             k(HEART##p) \
	, v(icon)                              k(ICON##p) \
	, v(iron-cross)                        k(IRON_CROSS##p) \
	, v(left-pointer)                      k(LEFT_POINTER##p) \
	, v(left-side)                         k(LEFT_SIDE##p) \
	, v(left-tee)                          k(LEFT_TEE##p) \
	, v(left-button)                       k(LEFT_BUTTON##p) \
	, v(lower-left-angle)                  k(LOWER_LEFT_ANGLE##p) \
	, v(lower-right-angle)                 k(LOWER_RIGHT_ANGLE##p) \
	, v(man)                               k(MAN##p) \
	, v(middle-button)                     k(MIDDLE_BUTTON##p) \
	, v(mouse)                             k(MOUSE##p) \
	, v(pencil)                            k(PENCIL##p) \
	, v(pirate)                            k(PIRATE##p) \
	, v(plus)                              k(PLUS##p) \
	, v(question-arrow)                    k(QUESTION_ARROW##p) \
	, v(right-pointer)                     k(RIGHT_POINTER##p) \
	, v(right-side)                        k(RIGHT_SIDE##p) \
	, v(right-tee)                         k(RIGHT_TEE##p) \
	, v(right-button)                      k(RIGHT_BUTTON##p) \
	, v(rtl-logo)                          k(RTL_LOGO##p) \
	, v(sailboat)                          k(SAILBOAT##p) \
	, v(scrollbar-down-arrow)              k(SCROLLBAR_DOWN_ARROW##p) \
	, v(scrollbar-horizontal-double-arrow) k(SCROLLBAR_HORIZONTAL_DOUBLE_ARROW##p) \
	, v(scrollbar-left-arrow)              k(SCROLLBAR_LEFT_ARROW##p) \
	, v(scrollbar-right-arrow)             k(SCROLLBAR_RIGHT_ARROW##p) \
	, v(scrollbar-up-arrow)                k(SCROLLBAR_UP_ARROW##p) \
	, v(scrollbar-vertical-double-arrow)   k(SCROLLBAR_VERTICAL_DOUBLE_ARROW##p) \
	, v(shuttle)                           k(SHUTTLE##p) \
	, v(sizing)                            k(SIZING##p) \
	, v(spider)                            k(SPIDER##p) \
	, v(spray-can)                         k(SPRAY_CAN##p) \
	, v(star)                              k(STAR##p) \
	, v(target)                            k(TARGET##p) \
	, v(target-cross)                      k(TARGET_CROSS##p) \
	, v(top-left-arrow)                    k(TOP_LEFT_ARROW##p) \
	, v(top-left-corner)                   k(TOP_LEFT_CORNER##p) \
	, v(top-right-corner)                  k(TOP_RIGHT_CORNER##p) \
	, v(top-side)                          k(TOP_SIDE##p) \
	, v(top-tee)                           k(TOP_TEE##p) \
	, v(trek)                              k(TREK##p) \
	, v(upper-left-angle)                  k(UPPER_LEFT_ANGLE##p) \
	, v(umbrella)                          k(UMBRELLA##p) \
	, v(upper-right-angle)                 k(UPPER_RIGHT_ANGLE##p) \
	, v(watch)                             k(WATCH##p) \
	, v(xterm)                             k(XTERM##p) \
	, n(NULL)                              k(NULL##p) \
}

#define COPYWINDOWPROPERTIES() /*-------------------------*/ local bool            copyWindowProperties(const xcb_window_t source, const xcb_window_t destination)
#define PROPERTYEXISTS() /*-------------------------------*/ local bool            propertyExists(const xcb_window_t window, const xcb_atom_t property)
#define PROPERTYIS() /*-----------------------------------*/ local bool            propertyIs(const xcb_window_t window, const xcb_atom_t property, const xcb_atom_t type, const uint length, const void *const value)
#define RESETPROPERTY() /*--------------------------------*/ local bool            resetProperty(const xcb_window_t window, const xcb_atom_t property, const xcb_atom_t type, const uint itemSize, const uint itemAmount, const void *const value)

def enum ENUM_CONTENT(CURSOR_GLYPH);

local const char *const /*-*/ cursorGlyphList[] = STRING_CONTENT(CURSOR_GLYPH);

COPYWINDOWPROPERTIES();
PROPERTYEXISTS();
PROPERTYIS();
RESETPROPERTY();

COPYWINDOWPROPERTIES(){
	const xcb_atom_t *current;
	const xcb_atom_t *wall;
	xcb_list_properties_reply_t *reply;
	uint32 token;
	uint length;
	jmp getPropertyList;
	getPropertyList:{
		reply = xcb_wait_for_reply(connection, xcb_list_properties(connection, source), NULL);
		token = pushPointer(reply, "copyWindowProperties() list properties reply", iFree);
		if(!reply){
			jmp emergencyExit;
		}
		jmp assessReply;
	}
	assessReply:{
		if(!(length = xcb_list_properties_atoms_length(reply))){
			jmp emergencyExit;
		}
		current = xcb_list_properties_atoms(reply);
		wall = current + length;
		jmp copyPropertyLoop;
	}
	copyPropertyLoop:{
		xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property(connection, false, source, *current, XCB_GET_PROPERTY_TYPE_ANY, 0, 0xFFFFFFFF), NULL);
		uint32 token = pushPointer(reply, "copyWindowProperties() get property reply", iFree);
		if(reply){
			const uint size = (*reply).format / 8;
			uint length = xcb_get_property_value_length(reply);
			if(size){
				length /= size;
			}
			xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, destination, *current, (*reply).type, (*reply).format, length, xcb_get_property_value(reply)));
			free(reply);
			popPointer(token);
		}
		if(inc current < wall){
			jmp copyPropertyLoop;
		}
		jmp emergencyExit;
	}
	emergencyExit:{
		free(reply);
		popPointer(token);
		ret true;
	}
}
PROPERTYEXISTS(){
	xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property(connection, false, window, property, XCB_GET_PROPERTY_TYPE_ANY, 0, 0xFFFFFFFF), NULL);
	uint32 token = pushPointer(reply, "propertyExists() get property reply", iFree);
	free(reply);
	popPointer(token);
	ret !!reply;
}
PROPERTYIS(){
	xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property(connection, false, window, property, type, 0, 0xFFFFFFFF), NULL);
	uint32 token = pushPointer(reply, "propertyIs() get property reply", iFree);
	bool equal = false;
	if(reply){
		if(xcb_get_property_value_length(reply) != (int)length){
			free(reply);
			popPointer(token);
			ret equal;
		}
		equal = compareMemory(xcb_get_property_value(reply), value, length);
		free(reply);
		popPointer(token);
	}
	ret equal;
}
RESETPROPERTY(){
	if(propertyIs(window, property, type, itemAmount * itemSize, value)){
		ret false;
	}
	xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, window, property, type, itemSize * 8, itemAmount, value));
	ret true;
}



























#define MAPCLIENT() /*-------------------------------*/ local bool            mapClient(ClientSystem *const clientSystem, MonitorSystem *const monitorSystem, Client *const client, const uint8 whichMonitor)

MAPCLIENT();

MAPCLIENT(){
	if(!clientSystem or !monitorSystem or !(*monitorSystem).size or !isValidClient(clientSystem, client) or (*client).stateState == NORMAL_STATE or !whichMonitor or whichMonitor >= ALL_WHICH_MONITOR){
		ret false;
	}
	if((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION){
		(*client).stateState = NORMAL_STATE;
		ret true;
	}
	if((*client).stateState == WITHDRAWN_STATE){
		Monitor *monitor;
		if(!(monitor = getWhichMonitor(monitorSystem, whichMonitor))){
			ret false;
		}
		xcb_discard_reply(connection, xcb_reparent_window_checked(connection, (*client).window, (*client).container, (*client).windowX, (*client).windowY));
		setDefaultClientWindowType(clientSystem, client);
		if(setClientAllowedActions(clientSystem, client)){
			changeClientAllowedActions(clientSystem, client);
		}
		setClientOrderType(clientSystem, client);









		if(!(*client).strut){
			int workareaX;
			int workareaY;
			int workareaWidth;
			int workareaHeight;
			int width = 0;
			int height = 0;



			if((*client).desktop != NONE_DESKTOP and (*client).desktop != 0xFFFFFFFF){
				const uint monitorOffset = monitor - (*monitorSystem).start;
				const EdgeOffset *const outerEdgeOffset = virtualRootSystem.workareaEdgeOffsetStart + monitorOffset;
				const EdgeOffset *const innerEdgeOffset = (*(virtualRootSystem.virtualRootStart + (*client).desktop)).workareaEdgeOffsetStart + monitorOffset;
				workareaX = (*monitor).leftX + (*outerEdgeOffset).left + (*innerEdgeOffset).left;
				workareaY = (*monitor).topY + (*outerEdgeOffset).top + (*innerEdgeOffset).top;
				workareaWidth = (*monitor).width - (*outerEdgeOffset).left - (*innerEdgeOffset).left - (*innerEdgeOffset).right - (*outerEdgeOffset).right;
				workareaHeight = (*monitor).height - (*outerEdgeOffset).top - (*innerEdgeOffset).top - (*innerEdgeOffset).bottom - (*outerEdgeOffset).bottom;
			}else{
				workareaX = (*monitor).leftX;
				workareaY = (*monitor).topY;
				workareaWidth = (*monitor).width;
				workareaHeight = (*monitor).height;
			}



			if((*client).normalHintsFlags & PROGRAM_BASE_SIZE_NORMAL_HINT){
				width = (*client).normalHintsBaseWidth;
				height = (*client).normalHintsBaseHeight;
			}elif((*client).normalHintsFlags & PROGRAM_MINIMUM_SIZE_NORMAL_HINT and (*client).normalHintsFlags & PROGRAM_MAXIMUM_SIZE_NORMAL_HINT){
				if((*client).normalHintsMinWidth == (*client).normalHintsMaxWidth){
					width = (*client).normalHintsMinWidth;
				}
				if((*client).normalHintsMinHeight == (*client).normalHintsMaxHeight){
					height = (*client).normalHintsMinHeight;
				}
			}
			if(width){
				width += 2 * (*client).containerBorder;
			}
			if(height){
				height += 2 * (*client).containerBorder;
			}
			if(!width or width > workareaWidth){
				if((*client).windowType & DIALOG_WINDOW_TYPE){
					width = workareaWidth * 2 / 4;
				}else{
					width = workareaWidth * 3 / 4;
				}
			}
			if(!height or height > workareaHeight){
				if((*client).windowType & DIALOG_WINDOW_TYPE){
					height = workareaHeight * 2 / 4;
				}else{
					height = workareaHeight * 3 / 4;
				}
			}
			moveResizeClient(clientSystem, client, workareaX + (workareaWidth - width) / 2, workareaY + (workareaHeight - height) / 2, width, height, true, true, true, true, true, CENTER_POINT_WINDOW_GRAVITY);
		}









		(*client).stateState = (*client).hintsInitialState;
		xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_FRAME_EXTENTS, XCB_ATOM_CARDINAL, bitsof(uint32), 4, &(*client).frameExtentsLeft));
	}
	if((*client).stateState == NORMAL_STATE){
		if(updateClientState(clientSystem, client, _NET_WM_STATE_REMOVE, HIDDEN_STATE)){
			changeClientState(clientSystem, client);
		}









		restackClient(clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE);
		configureClient(clientSystem, client);



		configureVirtualRootClient(&virtualRootSystem, clientSystem, client);

		/*!*/

		if((*client).strut){
			moveResizeClient(clientSystem, client, (*client).strutX, (*client).strutY, (*client).strutWidth, (*client).strutHeight, true, false, false, false, false, NONE_WINDOW_GRAVITY);
		}
		if(!(*client).strut){
			updateVirtualRootWorkareaClient(&virtualRootSystem, monitorSystem, clientSystem, client);
		}

		/*!*/









		/*!*/

		if(addVirtualRootClientWorkarea(&virtualRootSystem, monitorSystem, clientSystem, client)){
			updateVirtualRootStrutedClients(&virtualRootSystem, monitorSystem, clientSystem, client, ADD_UPDATE_WORKAREA_ACTION);
			updateVirtualRootWorkareaClients(&virtualRootSystem, monitorSystem, clientSystem);
			if(setVirtualRootWorkarea(&virtualRootSystem, monitorSystem)){
				changeVirtualRootWorkarea(&virtualRootSystem);
			}
		}









		xcb_discard_reply(connection, xcb_map_window_checked(connection, (*client).window));
		xcb_map_window(connection, (*client).container);
		if((*client).windowType & (TOOLBAR_WINDOW_TYPE | UTILITY_WINDOW_TYPE | DIALOG_WINDOW_TYPE | NORMAL_WINDOW_TYPE) and (*client).userTime != UNFOCUSED_USER_TIME){
			xcb_discard_reply(connection, xcb_set_input_focus_checked(connection, XCB_INPUT_FOCUS_POINTER_ROOT, (*client).window, getTimestamp()));
		}
	}
	xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom.WM_STATE, atom.WM_STATE, bitsof(uint32), 2, &(*client).stateState));
	ret true;
}



























int main(int argumentAmount, const char *const *argument){
	setGlobals:{
		programName /*---------------*/ = *argument;
		errorPath /*-----------------*/ = NULL;
		colorStart /*----------------*/ = MESSAGE_START;
		colorFatal /*----------------*/ = MESSAGE_FATAL;
		colorError /*----------------*/ = MESSAGE_ERROR;
		colorEvent /*----------------*/ = MESSAGE_EVENT;
		colorEnd /*------------------*/ = MESSAGE_END;
		connectionName /*------------*/ = NULL;
		configPath /*----------------*/ = NULL;
		localeName /*----------------*/ = setlocale(LC_ALL, "");
		mustOpenErrorStream /*-------*/ = false;
		errorStream /*---------------*/ = DEFAULT_ERROR_STREAM;
		errorStreamToken /*----------*/ = 0;
		quitting /*------------------*/ = false;
		connection /*----------------*/ = NULL;
		connectionToken /*-----------*/ = 0;
		event /*---------------------*/ = NULL;
		eventToken /*----------------*/ = 0;
		keyPressNextOffset /*--------*/ = 0;
		keyReleaseNextOffset /*------*/ = 0;
		buttonPressNextOffset /*-----*/ = 0;
		buttonReleaseNextOffset /*---*/ = 0;
		shortcutCode /*--------------*/ = 0;
		shortcutModifier /*----------*/ = XCB_NONE;
		expectingSecondKeyRelease /*-*/ = false;
		initMemorySystem();
		initPermissionSystem(&permissionSystem);
		initMonitorSystem(&monitorSystem);
		initPointerSystem(&pointerSystem);
		initCursorSystem(&cursorSystem);
		initWallpaperSystem(&wallpaperSystem);
		initClientSystem(&clientSystem);
		initVirtualRootSystem(&virtualRootSystem);
		initClientListSystem(&clientListSystem);
		initClientListSystem(&clientListStackingSystem);
		initWindowSystem(&windowSystem);
		initSleepThreadSystem(&sleepThreadSystem);
		initStringTreeSystem(&globalScopesInstructionStringTreeSystem);
		initStringTreeSystem(&globalInstructionStringTreeSystem);
		initStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
		initStringTreeSystem(&booleanStringTreeSystem);
		initStringTreeSystem(&variableStringTreeSystem);
		initStringTreeSystem(&commandStringTreeSystem);
		initStringTreeSystem(&modifierStringTreeSystem);
		initStringTreeSystem(&shortcutStateStringTreeSystem);
		initStringTreeSystem(&numberTypeStringTreeSystem);
		initStringTreeSystem(&horizontalAlignmentStringTreeSystem);
		initStringTreeSystem(&verticalAlignmentStringTreeSystem);
		initStringTreeSystem(&cornerStringTreeSystem);
		initStringTreeSystem(&whichMonitorStringTreeSystem);
		initStringTreeSystem(&directionStringTreeSystem);
		initStringTreeSystem(&macroStringTreeSystem);
		initSTDINSystem(&stdinSystem);
		initSharedMemorySystem(&sharedMemorySystem);
		initShortcutSystem(&keycodeShortcutSystem);
		initShortcutSystem(&buttonShortcutSystem);
		setConfigVariables();
		setPermissions(&permissionSystem);
		lowerPermissions(&permissionSystem);
		processingSignal = false;
		jmp getProgramArguments;
	}
	initSystems:{
		xcb_get_selection_owner_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_selection_owner_unchecked(connection, atom.WM_Sn), NULL);
		uint32 token = pushPointer(reply, "initSystems: get selection owner reply", iFree);
		struct{
			uint32 /*-*/ eventMask;
		} valueList;
		previousWMSelectionWindow = XCB_NONE;
		if(reply){
			if((*reply).owner){
				xcb_generic_error_t *error;
				uint32 token;
				previousWMSelectionWindow = (*reply).owner;
				valueList.eventMask = XCB_EVENT_MASK_STRUCTURE_NOTIFY;
				error = xcb_request_check(connection, xcb_change_window_attributes_checked(connection, previousWMSelectionWindow, XCB_CW_EVENT_MASK, &valueList));
				token = pushPointer(error, "initSystems: change window attributes error", iFree);
				if(error){
					previousWMSelectionWindow = XCB_NONE;
					free(error);
					popPointer(token);
				}
			}
			free(reply);
			popPointer(token);
		}
		wmSelectionWindow = xcb_generate_id(connection);
		wmSelectionTimestamp = XCB_NONE;
		valueList.eventMask = XCB_EVENT_MASK_PROPERTY_CHANGE;
		xcb_create_window(connection, XCB_COPY_FROM_PARENT, wmSelectionWindow, (*screen).root, -1, -1, 1, 1, 0, XCB_WINDOW_CLASS_INPUT_ONLY, (*screen).root_visual, XCB_CW_EVENT_MASK, &valueList);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, wmSelectionWindow, atom.MICRO_INIT, XCB_ATOM_ATOM, bitsof(xcb_atom_t), 0, NULL);
		createMonitors(&monitorSystem);
		bulkInsertString(&globalScopesInstructionStringTreeSystem, globalScopesInstructionList);
		bulkInsertString(&globalInstructionStringTreeSystem, globalInstructionList);
		bulkInsertString(&scope1ScopeInstructionStringTreeSystem, scope1ScopeInstructionList);
		bulkInsertString(&booleanStringTreeSystem, booleanList);
		bulkInsertString(&variableStringTreeSystem, variableList);
		bulkInsertString(&commandStringTreeSystem, commandList);
		bulkInsertString(&modifierStringTreeSystem, modifierList);
		bulkInsertString(&shortcutStateStringTreeSystem, shortcutStateList);
		bulkInsertString(&numberTypeStringTreeSystem, numberTypeList);
		bulkInsertString(&horizontalAlignmentStringTreeSystem, horizontalAlignmentList);
		bulkInsertString(&verticalAlignmentStringTreeSystem, verticalAlignmentList);
		bulkInsertString(&cornerStringTreeSystem, cornerList);
		bulkInsertString(&whichMonitorStringTreeSystem, whichMonitorList);
		bulkInsertString(&directionStringTreeSystem, directionList);
		bulkInsertString(&macroStringTreeSystem, macroList);
		jmp readConfig;
	}
	switchEvent:{
		#define XCB_ONE /*-*/ (1)
		if(((*event).response_type & ~b(10000000)) > XCB_NONE and ((*event).response_type & ~b(10000000)) < XCB_GE_GENERIC){
			printXEvent(baseEventName);
		}
		switch (*event).response_type & ~b(10000000) over
			to XCB_NONE: /*--------------*/ jmp errorEvent;
			to XCB_ONE: /*---------------*/ jmp unrecognizedEvent;
			to XCB_KEY_PRESS: /*---------*/ jmp keyPressEvent;
			to XCB_KEY_RELEASE: /*-------*/ jmp keyReleaseEvent;
			to XCB_BUTTON_PRESS: /*------*/ jmp buttonPressEvent;
			to XCB_BUTTON_RELEASE: /*----*/ jmp buttonReleaseEvent;
			to XCB_MOTION_NOTIFY: /*-----*/ jmp motionNotifyEvent;
			to XCB_ENTER_NOTIFY: /*------*/ jmp enterNotifyEvent;
			to XCB_LEAVE_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*----------*/ jmp focusInEvent;
			to XCB_FOCUS_OUT: /*---------*/ jmp eventLoop;
			to XCB_KEYMAP_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*-*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*-------*/ jmp unexpectedEvent;
			to XCB_VISIBILITY_NOTIFY: /*-*/ jmp unexpectedEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ jmp createNotifyEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ jmp destroyNotifyEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ jmp unmapNotifyEvent;
			to XCB_MAP_NOTIFY: /*--------*/ jmp mapNotifyEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp mapRequestEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ jmp reparentNotifyEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ jmp configureNotifyEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp configureRequestEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp resizeRequestEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ jmp circulateNotifyEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp circulateRequestEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ jmp propertyNotifyEvent;
			to XCB_SELECTION_CLEAR: /*---*/ jmp selectionClearEvent;
			to XCB_SELECTION_REQUEST: /*-*/ jmp eventLoop;
			to XCB_SELECTION_NOTIFY: /*--*/ jmp eventLoop;
			to XCB_COLORMAP_NOTIFY: /*---*/ jmp colormapNotifyEvent;
			to XCB_CLIENT_MESSAGE: /*----*/ jmp clientMessageEvent;
			to XCB_MAPPING_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*--------*/ jmp genericEvent;
			off: /*----------------------*/ jmp extensionEvent;
		end
		#undef  XCB_ONE
	}
	keyReleaseEvent:{
		#define e /*-*/ ((xcb_key_release_event_t *)event)
		uint8 keycode = (*e).detail;
		uint16 modifier = (*e).state & b(11111111);
		if(clientSystem.motionAction){
			jmp motionRelease;
		}
		if(getNextShortcut(&keycodeShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &keyReleaseNextOffset)){
			xcb_query_keymap_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_keymap_unchecked(connection), NULL);
			uint32 token = pushPointer(reply, "query keymap reply", iFree);
			if(reply){
				const bool keyIsPressed = !!(*((*reply).keys + (*e).detail / 8) & (1 << (*e).detail % 8));
				free(reply);
				popPointer(token);
				if(keyIsPressed){
					keyReleaseNextOffset = 0;
					jmp eventLoop;
				}
			}
			jmp matchCommandRelease;
		}
		if(keycode != shortcutCode and modifier == shortcutModifier){
			expectingSecondKeyRelease = true;
			realKeyReleaseModifier = shortcutModifier;
			jmp eventLoop;
		}
		if(keycode == shortcutCode and modifier != shortcutModifier){
			if(!expectingSecondKeyRelease){
				jmp eventLoop;
			}
			keycode = shortcutCode;
			modifier = realKeyReleaseModifier;
			expectingSecondKeyRelease = false;
			keyReleaseNextOffset = 0;
			if(getNextShortcut(&keycodeShortcutSystem, true, keycode, modifier, &keyReleaseNextOffset)){
				jmp matchCommandRelease;
			}
		}
		jmp eventLoop;
		#undef  e
	}
	buttonPressEvent:{
		#define e /*-*/ ((xcb_button_press_event_t *)event)
		if(focusOnClick){
			Client *client;
			if((client = findClientWindow(&clientSystem, (*e).event)) or (client = findClientContainer(&clientSystem, (*e).event))){
				xcb_discard_reply(connection, xcb_set_input_focus_checked(connection, XCB_INPUT_FOCUS_POINTER_ROOT, (*client).window, getTimestamp()));
			}
		}
		if(getNextShortcut(&buttonShortcutSystem, false, (*e).detail, (*e).state & b(11111111), &buttonPressNextOffset)){
			jmp matchCommandPress;
		}
		jmp eventLoop;
		#undef  e
	}
	buttonReleaseEvent:{
		#define e /*-*/ ((xcb_button_release_event_t *)event)
		if(clientSystem.motionAction){
			jmp motionRelease;
		}
		if(getNextShortcut(&buttonShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &buttonReleaseNextOffset)){
			jmp matchCommandRelease;
		}
		jmp eventLoop;
		#undef  e
	}
	{
		uint8 commandOrigin;
		matchCommandPress:{
			commandOrigin = PRESS_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommandRelease:{
			commandOrigin = RELEASE_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommand: switch matchCommand((*eventModifierNode).command, (*eventModifierNode).string, commandOrigin, (*eventModifierNode).field0, (*eventModifierNode).field1, (*eventModifierNode).field2, (*eventModifierNode).field3, (*eventModifierNode).field4) over
			to TYPICAL_MATCH_COMMAND_TYPE:{
				jmp eventLoopCheckShortcuts;
			}
			to RESTART_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp readConfig;
			}
			to EXIT_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp mainEmergencyExit;
			}
			off:{
				jmp eventLoopCheckShortcuts;
			}
		end
	}
	motionRelease:{
		#define e /*-*/ ((xcb_key_release_event_t *)event)
		unsetMotionClient(&clientSystem);
		jmp eventLoop;
		#undef  e
	}
	motionNotifyEvent:{
		#define e /*-*/ ((xcb_motion_notify_event_t *)event)
		switch clientSystem.motionAction over
			to NONE_MOTION_ACTION: /*---*/ jmp eventLoop;
			to MOVE_MOTION_ACTION: /*---*/ jmp moveMotion;
			to RESIZE_MOTION_ACTION: /*-*/ jmp resizeMotion;
			off: /*---------------------*/ jmp eventLoop;
		end
	}
	moveMotion:{
		Client *const client = clientSystem.clientStart + clientSystem.motionClientOffset;
		int deltaX;
		int deltaY;
		if(!isValidClient(&clientSystem, client)){
			jmp eventLoop;
		}
		deltaX = (*e).root_x - clientSystem.motionStartingX;
		deltaY = (*e).root_y - clientSystem.motionStartingY;
		clientSystem.motionStartingX = (*e).root_x;
		clientSystem.motionStartingY = (*e).root_y;
		moveResizeClient(&clientSystem, client, (*client).containerX + deltaX, (*client).containerY + deltaY, (*client).containerWidth + 2 * (*client).containerBorder, (*client).containerHeight + 2 * (*client).containerBorder, false, true, false, false, false, clientSystem.motionGravity);
		jmp eventLoop;
	}
	resizeMotion:{
		Client *const client = clientSystem.clientStart + clientSystem.motionClientOffset;
		int deltaX;
		int deltaY;
		if(!isValidClient(&clientSystem, client)){
			jmp eventLoop;
		}
		deltaX = (*e).root_x - clientSystem.motionStartingX;
		deltaY = (*e).root_y - clientSystem.motionStartingY;
		switch clientSystem.motionGravity over
			to NONE_WINDOW_GRAVITY: /*-------------*/ /*---------*/ /*---------*/ jmp eventLoop;
			to NORTH_SIDE_WINDOW_GRAVITY: /*-------*/ deltaX *=  0; deltaY *=  1; brk;
			to SOUTH_SIDE_WINDOW_GRAVITY: /*-------*/ deltaX *=  0; deltaY *= -1; brk;
			to WEST_SIDE_WINDOW_GRAVITY: /*--------*/ deltaX *=  1; deltaY *=  0; brk;
			to EAST_SIDE_WINDOW_GRAVITY: /*--------*/ deltaX *= -1; deltaY *=  0; brk;
			to NORTH_WEST_POINT_WINDOW_GRAVITY: /*-*/ deltaX *=  1; deltaY *=  1; brk;
			to NORTH_EAST_POINT_WINDOW_GRAVITY: /*-*/ deltaX *= -1; deltaY *=  1; brk;
			to SOUTH_WEST_POINT_WINDOW_GRAVITY: /*-*/ deltaX *=  1; deltaY *= -1; brk;
			to SOUTH_EAST_POINT_WINDOW_GRAVITY: /*-*/ deltaX *= -1; deltaY *= -1; brk;
			off: /*--------------------------------*/ /*---------*/ /*---------*/ jmp eventLoop;
		end
		moveResizeClient(&clientSystem, client, clientSystem.motionX, clientSystem.motionY, clientSystem.motionWidth + deltaX, clientSystem.motionHeight + deltaY, false, true, true, false, false, clientSystem.motionGravity);
		clientSystem.motionX = (*client).containerX;
		clientSystem.motionY = (*client).containerY;
		jmp eventLoop;
		#undef  e
	}
	enterNotifyEvent:{
		#define e /*-*/ ((xcb_enter_notify_event_t *)event)
		Client *client;
		if(!focusOnHover){
			jmp eventLoop;
		}
		if((client = findClientContainer(&clientSystem, (*e).event)) or (client = findClientWindow(&clientSystem, (*e).event))){
			setFocusedClient(&clientSystem, client, virtualRootSystem.currentDesktop);
		}
		jmp eventLoop;
		#undef  e
	}
	focusInEvent:{
		#define e /*-*/ ((xcb_focus_in_event_t *)event)
		const xcb_window_t eventWindow = (*e).event;
		Client *client;
		if((*e).mode != XCB_NOTIFY_MODE_NORMAL and (*e).mode != XCB_NOTIFY_MODE_WHILE_GRABBED){
			jmp eventLoop;
		}
		if((client = findClientWindow(&clientSystem, eventWindow))){
			if(focusClient(&clientSystem, client)){
				if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
					configureClient(&clientSystem, client);
					configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
					if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}
				gotoVirtualRoot(&virtualRootSystem, &clientSystem, (*client).desktop, false);
				changeActiveWindow(&clientSystem);
			}
			jmp eventLoop;
		}
		if((client = findClientContainer(&clientSystem, eventWindow))){
			xcb_discard_reply(connection, xcb_set_input_focus_checked(connection, XCB_INPUT_FOCUS_POINTER_ROOT, (*client).window, getTimestamp()));
			jmp eventLoop;
		}
		if(eventWindow == (*screen).root){
			xcb_set_input_focus(connection, XCB_INPUT_FOCUS_POINTER_ROOT, defaultFocusWindow, getTimestamp());
		}
		unfocusClient(&clientSystem);
		changeActiveWindow(&clientSystem);
		jmp eventLoop;
		#undef  e
	}
	createNotifyEvent:{
		#define e /*-*/ ((xcb_create_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		if(findVirtualRoot(&virtualRootSystem, eventWindow)){
			copyWindowProperties((*screen).root, eventWindow);
			jmp eventLoop;
		}
		if(findOwnedWindow(eventWindow) or findClientContainer(&clientSystem, eventWindow) or findClientWindow(&clientSystem, eventWindow)){
			jmp eventLoop;
		}
		if((*e).parent == (*screen).root){
			if(createClient(&clientSystem, &cursorSystem, eventWindow, (*e).x, (*e).y, (*e).width, (*e).height, (*e).border_width, XCB_WINDOW_CLASS_COPY_FROM_PARENT, (*e).override_redirect)){
				storeClientProperties(findClientWindow(&clientSystem, eventWindow));
			}
			jmp eventLoop;
		}
		xcb_discard_reply(connection, xcb_kill_client_checked(connection, eventWindow));
		jmp eventLoop;
		#undef  e
	}
	destroyNotifyEvent:{
		#define e /*-*/ ((xcb_destroy_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		Client *client;
		if((client = findClientWindow(&clientSystem, eventWindow))){
			uint8 state = (*client).stateState;
			if(destroyClient(&clientSystem, client)){
				if(state == NORMAL_STATE){
					state = (*client).stateState;
					(*client).stateState = NORMAL_STATE;
					if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
						updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
						updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
						if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
							changeVirtualRootWorkarea(&virtualRootSystem);
						}
					}
					(*client).stateState = state;
				}
				if(removeClientListWindow(&clientListSystem, eventWindow)){
					changeClientListProperty(&clientListSystem);
				}
				if(removeClientListWindow(&clientListStackingSystem, eventWindow)){
					changeClientListProperty(&clientListStackingSystem);
				}
			}
			jmp eventLoop;
		}
		if(!wmSelectionTimestamp and eventWindow == previousWMSelectionWindow){
			if(!initWindowManagerSystem()){
				jmp mainEmergencyExit;
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  e
	}
	unmapNotifyEvent:{
		#define e /*-*/ ((xcb_unmap_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		Client *client;
		if((client = findClientWindow(&clientSystem, eventWindow))){
			uint8 state = (*client).stateState;
			if(unmapClient(&clientSystem, client, !!(*e).from_configure * ICONIC_STATE)){
				if(state == NORMAL_STATE){
					state = (*client).stateState;
					(*client).stateState = NORMAL_STATE;
					if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
						updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
						updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
						if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
							changeVirtualRootWorkarea(&virtualRootSystem);
						}
					}
					(*client).stateState = state;
				}
				if((*client).stateState == ICONIC_STATE){
					if(restackClientListWindow(&clientListSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE)){
						changeClientListProperty(&clientListSystem);
					}
					if(restackClientListWindow(&clientListStackingSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}else{
					if((*client).desktop != 0xFFFFFFFF){
						moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, NONE_DESKTOP, true);
					}
					if(removeClientListWindow(&clientListSystem, eventWindow)){
						changeClientListProperty(&clientListSystem);
					}
					if(removeClientListWindow(&clientListStackingSystem, eventWindow)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  e
	}
	mapNotifyEvent:{
		#define e /*-*/ ((xcb_map_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		Client *client;
		if((client = findClientWindow(&clientSystem, eventWindow))){
			if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION)){
				jmp eventLoop;
			}
			if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION)){
				if((*client).desktop == NONE_DESKTOP){
					if(setClientVirtualRoot(&virtualRootSystem, &clientSystem, client, virtualRootSystem.currentDesktop)){
						changeVirtualRootClientDesktop(&virtualRootSystem, &clientSystem, client);
					}
				}
			}
			if(mapClient(&clientSystem, &monitorSystem, client, POINTER_WHICH_MONITOR)){
/*!
				if((*client).stateState == NORMAL_STATE){
					configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
					if(!(*client).strut){
						updateVirtualRootWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, client);
					}
					if(addVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
						updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, ADD_UPDATE_WORKAREA_ACTION);
						updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
						if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
							changeVirtualRootWorkarea(&virtualRootSystem);
						}
					}
				}
*/
				if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION) and !(*client).strut){
					if(!findClientListWindow(&clientListSystem, eventWindow)){
						if(addClientListWindow(&clientListSystem, eventWindow)){
							if((*client).stateState == ICONIC_STATE){
								restackClientListWindow(&clientListSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE);
							}
							changeClientListProperty(&clientListSystem);
						}
					}else{
						if((*client).stateState == NORMAL_STATE){
							if(restackClientListWindow(&clientListSystem, eventWindow, XCB_STACK_MODE_ABOVE, XCB_NONE)){
								changeClientListProperty(&clientListSystem);
							}
						}
					}
					if(!findClientListWindow(&clientListStackingSystem, eventWindow)){
						if(addClientListWindow(&clientListStackingSystem, eventWindow)){
							if((*client).stateState == ICONIC_STATE){
								restackClientListWindow(&clientListStackingSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE);
							}
							changeClientListProperty(&clientListStackingSystem);
						}
					}else{
						if((*client).stateState == NORMAL_STATE){
							if(restackClientListWindow(&clientListStackingSystem, eventWindow, XCB_STACK_MODE_ABOVE, XCB_NONE)){
								changeClientListProperty(&clientListStackingSystem);
							}
						}
					}
				}
			}
		}
		jmp eventLoop;
		#undef  e
	}
	mapRequestEvent:{
		#define e /*-*/ ((xcb_map_request_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		Client *client;
		if((client = findClientWindow(&clientSystem, eventWindow))){
			if((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION){
				jmp eventLoop;
			}
			if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION)){
				if((*client).desktop == NONE_DESKTOP){
					if(setClientVirtualRoot(&virtualRootSystem, &clientSystem, client, virtualRootSystem.currentDesktop)){
						changeVirtualRootClientDesktop(&virtualRootSystem, &clientSystem, client);
					}
				}
			}
			if(mapClient(&clientSystem, &monitorSystem, client, POINTER_WHICH_MONITOR)){
/*!
				if((*client).stateState == NORMAL_STATE){
					configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
					if(!(*client).strut){
						updateVirtualRootWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, client);
					}
					if(addVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
						updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, ADD_UPDATE_WORKAREA_ACTION);
						updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
						if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
							changeVirtualRootWorkarea(&virtualRootSystem);
						}
					}
				}
*/
				if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION) and !(*client).strut){
					if(!findClientListWindow(&clientListSystem, eventWindow)){
						if(addClientListWindow(&clientListSystem, eventWindow)){
							if((*client).stateState == ICONIC_STATE){
								restackClientListWindow(&clientListSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE);
							}
							changeClientListProperty(&clientListSystem);
						}
					}else{
						if((*client).stateState == NORMAL_STATE){
							if(restackClientListWindow(&clientListSystem, eventWindow, XCB_STACK_MODE_ABOVE, XCB_NONE)){
								changeClientListProperty(&clientListSystem);
							}
						}
					}
					if(!findClientListWindow(&clientListStackingSystem, eventWindow)){
						if(addClientListWindow(&clientListStackingSystem, eventWindow)){
							if((*client).stateState == ICONIC_STATE){
								restackClientListWindow(&clientListStackingSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE);
							}
							changeClientListProperty(&clientListStackingSystem);
						}
					}else{
						if((*client).stateState == NORMAL_STATE){
							if(restackClientListWindow(&clientListStackingSystem, eventWindow, XCB_STACK_MODE_ABOVE, XCB_NONE)){
								changeClientListProperty(&clientListStackingSystem);
							}
						}
					}
				}
			}
		}
		jmp eventLoop;
		#undef  e
	}
	reparentNotifyEvent:{
		#define e /*-*/ ((xcb_reparent_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		const xcb_window_t parentWindow = (*e).parent;
		if(parentWindow == (*screen).root){
			xcb_get_geometry_cookie_t geometryCookie;
			xcb_get_window_attributes_cookie_t attributesCookie;
			xcb_get_geometry_reply_t *geometryReply;
			uint32 geometryToken;
			xcb_get_window_attributes_reply_t *attributesReply;
			uint32 attributesToken;
			int x;
			int y;
			uint width;
			uint height;
			uint border;
			uint8 class;
			bool overrideRedirect;
			bool mapped;
			if(findOwnedWindow(eventWindow) or findClientContainer(&clientSystem, eventWindow) or findClientWindow(&clientSystem, eventWindow)){
				jmp eventLoop;
			}
			geometryCookie = xcb_get_geometry(connection, eventWindow);
			attributesCookie = xcb_get_window_attributes(connection, eventWindow);
			geometryReply = xcb_get_geometry_reply(connection, geometryCookie, NULL);
			geometryToken = pushPointer(geometryReply, "get geometry reply", iFree);
			attributesReply = xcb_get_window_attributes_reply(connection, attributesCookie, NULL);
			attributesToken = pushPointer(attributesReply, "get window attributes reply", iFree);
			x = 0;
			y = 0;
			width = 1;
			height = 1;
			border = 0;
			class = XCB_WINDOW_CLASS_COPY_FROM_PARENT;
			overrideRedirect = false;
			mapped = false;
			if(geometryReply){
				x = (*geometryReply).x;
				y = (*geometryReply).y;
				width = (*geometryReply).width;
				height = (*geometryReply).height;
				border = (*geometryReply).border_width;
				free(geometryReply);
				popPointer(geometryToken);
			}
			if(attributesReply){
				class = (*attributesReply)._class;
				overrideRedirect = (*attributesReply).override_redirect;
				mapped = (*attributesReply).map_state != XCB_MAP_STATE_UNMAPPED;
				free(attributesReply);
				popPointer(attributesToken);
			}
/*!
			if(createClient(&clientSystem, &cursorSystem, eventWindow, x, y, width, height, border, class, overrideRedirect)){
				Client *const client = findClientWindow(&clientSystem, eventWindow);
				storeClientProperties(client);
				if(client and mapped){
					if((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION){
						jmp eventLoop;
					}
					if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION)){
						if((*client).desktop == NONE_DESKTOP){
							if(setClientVirtualRoot(&virtualRootSystem, &clientSystem, client, virtualRootSystem.currentDesktop)){
								changeVirtualRootClientDesktop(&virtualRootSystem, &clientSystem, client);
							}
						}
					}
					if(mapClient(&clientSystem, &monitorSystem, client, POINTER_WHICH_MONITOR)){
						if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION) and !(*client).strut){
							if(!findClientListWindow(&clientListSystem, eventWindow)){
								if(addClientListWindow(&clientListSystem, eventWindow)){
									if((*client).stateState == ICONIC_STATE){
										restackClientListWindow(&clientListSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE);
									}
									changeClientListProperty(&clientListSystem);
								}
							}else{
								if((*client).stateState == NORMAL_STATE){
									if(restackClientListWindow(&clientListSystem, eventWindow, XCB_STACK_MODE_ABOVE, XCB_NONE)){
										changeClientListProperty(&clientListSystem);
									}
								}
							}
							if(!findClientListWindow(&clientListStackingSystem, eventWindow)){
								if(addClientListWindow(&clientListStackingSystem, eventWindow)){
									if((*client).stateState == ICONIC_STATE){
										restackClientListWindow(&clientListStackingSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE);
									}
									changeClientListProperty(&clientListStackingSystem);
								}
							}else{
								if((*client).stateState == NORMAL_STATE){
									if(restackClientListWindow(&clientListStackingSystem, eventWindow, XCB_STACK_MODE_ABOVE, XCB_NONE)){
										changeClientListProperty(&clientListStackingSystem);
									}
								}
							}
						}
					}
				}
			}
*/
			jmp eventLoop;
		}else{
			Client *client;
			if((client = findClientWindow(&clientSystem, eventWindow))){
/*!
				uint8 state = (*client).stateState;
				if(destroyClient(&clientSystem, client)){
					if(state == NORMAL_STATE){
						state = (*client).stateState;
						(*client).stateState = NORMAL_STATE;
						if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
							updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
							updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
							if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
								changeVirtualRootWorkarea(&virtualRootSystem);
							}
						}
						(*client).stateState = state;
					}
					if(removeClientListWindow(&clientListSystem, eventWindow)){
						changeClientListProperty(&clientListSystem);
					}
					if(removeClientListWindow(&clientListStackingSystem, eventWindow)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}
*/
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  e
	}
	configureNotifyEvent:{
		#define e /*-*/ ((xcb_configure_notify_event_t *)event)
		Client *client;
		if((client = findConfiguredClientWindow(&clientSystem, (*e).window))){
			xcb_window_t sibling;
			uint8 stackMode;
			if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION)){
				xcb_configure_window(connection, (*client).container, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &(*client).containerX);
				jmp eventLoop;
			}
			(*client).windowX = (*e).x;
			(*client).windowY = (*e).y;
			(*client).windowWidth = (*e).width;
			(*client).windowHeight = (*e).height;
			(*client).windowBorder = (*e).border_width;
			sibling = (*e).above_sibling;
			stackMode = XCB_STACK_MODE_BELOW;
			if(sibling){
				stackMode = XCB_STACK_MODE_ABOVE;
			}
			restackClient(&clientSystem, client, stackMode, sibling);
		}
		jmp eventLoop;
		#undef  e
	}
	configureRequestEvent:{
		#define e /*-*/ ((xcb_configure_request_event_t *)event)
		uint8 valueMask = (*e).value_mask;
		Client *client;
		if((client = findConfiguredClientWindow(&clientSystem, (*e).window))){
			if((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION or client == clientSystem.clientStart + clientSystem.motionClientOffset or (*client).stateState == ICONIC_STATE){
				jmp eventLoop;
			}
			if(!((*client).allowedAction & MOVE_ALLOWED_ACTION)){
				valueMask &= ~(XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y);
			}
			if(!((*client).allowedAction & RESIZE_ALLOWED_ACTION)){
				valueMask &= ~(XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT | XCB_CONFIG_WINDOW_BORDER_WIDTH);
			}
			if(false){
				valueMask &= ~(XCB_CONFIG_WINDOW_SIBLING | XCB_CONFIG_WINDOW_STACK_MODE);
			}
			if(valueMask & (XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT | XCB_CONFIG_WINDOW_BORDER_WIDTH)){
				uint32 windowValueList[3];
				uint32 containerValueList[5];
				void *windowCurrent = windowValueList;
				void *containerCurrent = containerValueList;
				if(valueMask & XCB_CONFIG_WINDOW_X){
					(*client).containerX = (*e).x;
					*(int32 *)containerCurrent = (*client).containerX;
					containerCurrent = (int32 *)containerCurrent + 1;
				}
				if(valueMask & XCB_CONFIG_WINDOW_Y){
					(*client).containerY = (*e).y;
					*(int32 *)containerCurrent = (*client).containerY;
					containerCurrent = (int32 *)containerCurrent + 1;
				}
				if(valueMask & XCB_CONFIG_WINDOW_BORDER_WIDTH){
					(*client).windowBorder = (*e).border_width;
					*(int32 *)windowCurrent = (*client).windowBorder;
					windowCurrent = (int32 *)windowCurrent + 1;
				}
				if(valueMask & XCB_CONFIG_WINDOW_WIDTH){
					(*client).windowWidth = (*e).width;
					*(int32 *)windowCurrent = (*client).windowWidth;
					windowCurrent = (int32 *)windowCurrent + 1;
					(*client).containerWidth = (*client).windowWidth + 2 * (*client).windowBorder + (*client).frameExtentsLeft + (*client).frameExtentsRight;
					*(int32 *)containerCurrent = (*client).containerWidth;
					containerCurrent = (int32 *)containerCurrent + 1;
				}
				if(valueMask & XCB_CONFIG_WINDOW_HEIGHT){
					(*client).windowHeight = (*e).height;
					*(int32 *)windowCurrent = (*client).windowHeight;
					windowCurrent = (int32 *)windowCurrent + 1;
					(*client).containerHeight = (*client).windowHeight + 2 * (*client).windowBorder + (*client).frameExtentsTop + (*client).frameExtentsBottom;
					*(int32 *)containerCurrent = (*client).containerHeight;
					containerCurrent = (int32 *)containerCurrent + 1;
				}
				if(valueMask & XCB_CONFIG_WINDOW_STACK_MODE){
					if(restackClient(&clientSystem, client, (*e).stack_mode, !!(valueMask & XCB_CONFIG_WINDOW_SIBLING) * (*e).sibling)){
						configureClient(&clientSystem, client);
						configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
						if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
							changeClientListProperty(&clientListStackingSystem);
						}
					}
				}
				xcb_discard_reply(connection, xcb_configure_window_checked(connection, (*client).window, valueMask & (XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT | XCB_CONFIG_WINDOW_BORDER_WIDTH), windowValueList));
				(*client).option &= ~(HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
				(*client).workareaPosition = NONE_WORKAREA_POSITION;
			}else{
				if(valueMask & (XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_STACK_MODE)){
					uint32 valueList[2];
					void *current = valueList;
					if(valueMask & XCB_CONFIG_WINDOW_X){
						(*client).containerX = (*e).x;
						*(int32 *)current = (*client).containerX;
						current = (int32 *)current + 1;
					}
					if(valueMask & XCB_CONFIG_WINDOW_Y){
						(*client).containerY = (*e).y;
						*(int32 *)current = (*client).containerY;
						current = (int32 *)current + 1;
					}
					if(valueMask & XCB_CONFIG_WINDOW_STACK_MODE){
						if(restackClient(&clientSystem, client, (*e).stack_mode, !!(valueMask & XCB_CONFIG_WINDOW_SIBLING) * (*e).sibling)){
							configureClient(&clientSystem, client);
							configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
							if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
								changeClientListProperty(&clientListStackingSystem);
							}
						}
					}
					(*client).option &= ~(HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
					(*client).workareaPosition = NONE_WORKAREA_POSITION;
				}
				sendClientConfigureEvent(&clientSystem, client);
			}
		}
		jmp eventLoop;
		#undef  e
	}
	resizeRequestEvent:{
		#define e /*-*/ ((xcb_resize_request_event_t *)event)
		/*!*/
		jmp eventLoop;
		#undef  e
	}
	circulateNotifyEvent:{
		#define e /*-*/ ((xcb_circulate_notify_event_t *)event)
		Client *client;
		if((client = findClientWindow(&clientSystem, (*e).event))){
			uint8 stackMode;
			if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION)){
				jmp eventLoop;
			}
			stackMode = XCB_STACK_MODE_BELOW;
			if((*e).place == XCB_PLACE_ON_TOP){
				stackMode = XCB_STACK_MODE_ABOVE;
			}
			restackClient(&clientSystem, client, stackMode, XCB_NONE);
			if(stackMode == XCB_STACK_MODE_BELOW){
				restackVirtualRootBelow(&virtualRootSystem);
			}
		}
		jmp eventLoop;
		#undef  e
	}
	circulateRequestEvent:{
		#define e /*-*/ ((xcb_circulate_request_event_t *)event)
		Client *client;
		if((client = findClientWindow(&clientSystem, (*e).event))){
			uint8 stackMode;
			if((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION){
				jmp eventLoop;
			}
			stackMode = XCB_STACK_MODE_BELOW;
			if((*e).place == XCB_PLACE_ON_TOP){
				stackMode = XCB_STACK_MODE_ABOVE;
			}
			if(restackClient(&clientSystem, client, stackMode, XCB_NONE)){
				configureClient(&clientSystem, client);
				configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
				if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
					changeClientListProperty(&clientListStackingSystem);
				}
			}
		}
		jmp eventLoop;
		#undef  e
	}
	propertyNotifyEvent:{
		#define e /*-*/ ((xcb_property_notify_event_t *)event)
		const xcb_atom_t eventWindow = (*e).window;
		const xcb_atom_t property = (*e).atom;
		Client *client;
		VirtualRoot *virtualRoot;
		if(!eventWindow or !property){
			jmp eventLoop;
		}
		if(eventWindow == (*screen).root){
			xcb_get_property_reply_t *reply;
			uint32 token;
			uint32 desktopLayoutOrientation = _NET_WM_ORIENTATION_HORZ;
			uint32 desktopLayoutColumns = 0;
			uint32 desktopLayoutRows = 0;
			uint32 desktopLayoutStartingCorner = _NET_WM_TOPLEFT;
			reply = xcb_wait_for_reply(connection, xcb_get_property_unchecked(connection, false, eventWindow, property, XCB_GET_PROPERTY_TYPE_ANY, 0, 0xFFFFFFFF), NULL);
			token = pushPointer(reply, "propertyNotifyEvent: get property reply", iFree);
			if(reply){
				const uint size = (*reply).format / 8;
				const void *const value = xcb_get_property_value(reply);
				uint length = xcb_get_property_value_length(reply);
				VirtualRoot *current = virtualRootSystem.virtualRootStart;
				VirtualRoot *const wall = current + virtualRootSystem.virtualRootAllocated;
				if(property == atom._NET_DESKTOP_LAYOUT and (*e).state == XCB_PROPERTY_NEW_VALUE and length == 4 * sizeof(uint32)){
					desktopLayoutColumns = *((uint32 *)value + 1);
					desktopLayoutRows = *((uint32 *)value + 2);
					desktopLayoutOrientation = *((uint32 *)value + 0);
					desktopLayoutStartingCorner = *((uint32 *)value + 3);
				}
				if(size){
					length /= size;
				}
				jmp updateVirtualRootPropertyLoop;
				updateVirtualRootPropertyLoop:{
					if(current < wall){
						if((*e).state == XCB_PROPERTY_DELETE){
							xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*current).window, property));
						}else{
							xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*current).window, property, (*reply).type, (*reply).format, length, value));
						}
						inc current;
						jmp updateVirtualRootPropertyLoop;
					}
					free(reply);
					popPointer(token);
				}
			}
			if(property == atom.WM_ICON_SIZE){
				struct{
					uint32 /*-*/ minWidth;
					uint32 /*-*/ minHeight;
					uint32 /*-*/ maxWidth;
					uint32 /*-*/ maxHeight;
					uint32 /*-*/ widthInc;
					uint32 /*-*/ heightInc;
				} iconSize;
				iconSize.minWidth = 16;
				iconSize.minHeight = 16;
				iconSize.maxWidth = 16;
				iconSize.maxHeight = 16;
				iconSize.widthInc = 0;
				iconSize.heightInc = 0;
				resetProperty(eventWindow, property, XCB_ATOM_CARDINAL, sizeof(uint32), sizeof(iconSize) / sizeof(uint32), &iconSize);
				jmp eventLoop;
			}
			if(property == atom._NET_SUPPORTED){
				setNetSupported();
				jmp eventLoop;
			}
			if(property == atom._NET_CLIENT_LIST){
				resetProperty(eventWindow, property, XCB_ATOM_WINDOW, sizeof(xcb_window_t), clientListSystem.clientAllocated, clientListSystem.clientStart);
				jmp eventLoop;
			}
			if(property == atom._NET_CLIENT_LIST_STACKING){
				resetProperty(eventWindow, property, XCB_ATOM_WINDOW, sizeof(xcb_window_t), clientListStackingSystem.clientAllocated, clientListStackingSystem.clientStart);
				jmp eventLoop;
			}
			if(property == atom._NET_NUMBER_OF_DESKTOPS){
				resetProperty(eventWindow, property, XCB_ATOM_CARDINAL, sizeof(uint32), 1, &virtualRootSystem.virtualRootAllocated);
				jmp eventLoop;
			}
			if(property == atom._NET_DESKTOP_GEOMETRY){
				resetProperty((*screen).root, property, XCB_ATOM_CARDINAL, sizeof(uint32), 2, &virtualRootSystem.width);
				jmp eventLoop;
			}
			if(property == atom._NET_DESKTOP_VIEWPORT){
				resetProperty(eventWindow, property, XCB_ATOM_CARDINAL, sizeof(int32), 2 * virtualRootSystem.virtualRootAllocated, virtualRootSystem.viewportStart);
				jmp eventLoop;
			}
			if(property == atom._NET_CURRENT_DESKTOP){
				resetProperty(eventWindow, property, XCB_ATOM_CARDINAL, sizeof(uint32), 1, &virtualRootSystem.currentDesktop);
				jmp eventLoop;
			}
			if(property == atom._NET_DESKTOP_NAMES){
				resetProperty(eventWindow, property, atom.UTF8_STRING, sizeof(uint8), virtualRootSystem.desktopNamesSize, virtualRootSystem.desktopNamesStart);
				jmp eventLoop;
			}
			if(property == atom._NET_ACTIVE_WINDOW){
				Client *const client = getFocusedClient(&clientSystem);
				xcb_window_t activeWindow = XCB_NONE;
				if(client){
					activeWindow = (*client).window;
				}
				resetProperty(eventWindow, property, XCB_ATOM_WINDOW, sizeof(xcb_window_t), 1, &activeWindow);
				jmp eventLoop;
			}
			if(property == atom._NET_WORKAREA){
				resetProperty(eventWindow, property, XCB_ATOM_CARDINAL, sizeof(uint32), virtualRootSystem.virtualRootAllocated * 4, virtualRootSystem.workareaStart);
				jmp eventLoop;
			}
			if(property == atom._NET_SUPPORTING_WM_CHECK){
				resetProperty(eventWindow, property, XCB_ATOM_WINDOW, sizeof(xcb_window_t), 1, &wmCheckWindow);
				jmp eventLoop;
			}
			if(property == atom._NET_VIRTUAL_ROOTS){
				resetProperty(eventWindow, property, XCB_ATOM_WINDOW, sizeof(xcb_window_t), virtualRootSystem.virtualRootAllocated, virtualRootSystem.windowStart);
				jmp eventLoop;
			}
			if(property == atom._NET_DESKTOP_LAYOUT){
				virtualRootSystem.desktopLayoutColumns = desktopLayoutColumns;
				virtualRootSystem.desktopLayoutRows = desktopLayoutRows;
				virtualRootSystem.desktopLayoutOrientation = desktopLayoutOrientation;
				virtualRootSystem.desktopLayoutStartingCorner = desktopLayoutStartingCorner;
				jmp eventLoop;
			}
			if(property == atom._NET_SHOWING_DESKTOP){
				resetProperty(eventWindow, property, XCB_ATOM_CARDINAL, sizeof(uint32), 1, &virtualRootSystem.showingDesktop);
				jmp eventLoop;
			}
			if(property == atom._NET_WM_NAME){
				resetProperty(eventWindow, property, atom.UTF8_STRING, sizeof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
				jmp eventLoop;
			}
			if(property == atom._XROOTPMAP_ID){
				if(setWallpaperPixmap(&wallpaperSystem, &monitorSystem, atom._XROOTPMAP_ID)){
					setVirtualRootWallpaper(&virtualRootSystem, &wallpaperSystem);
				}
				jmp eventLoop;
			}
		}
		if((virtualRoot = findVirtualRoot(&virtualRootSystem, eventWindow))){
			xcb_get_property_reply_t *reply;
			uint32 token;
			if(!propertyExists((*screen).root, property)){
				if((*e).state == XCB_PROPERTY_NEW_VALUE){
					xcb_delete_property(connection, eventWindow, property);
				}
				jmp eventLoop;
			}
			reply = xcb_wait_for_reply(connection, xcb_get_property_unchecked(connection, false, (*screen).root, property, XCB_GET_PROPERTY_TYPE_ANY, 0, 0xFFFFFFFF), NULL);
			token = pushPointer(reply, "propertyNotifyEvent: get property reply", iFree);
			if(reply){
				const uint size = (*reply).format / 8;
				uint length = xcb_get_property_value_length(reply);
				if(size){
					length /= size;
				}
				resetProperty(eventWindow, property, (*reply).type, size, length, xcb_get_property_value(reply));
				free(reply);
				popPointer(token);
			}
			jmp eventLoop;
		}
		if((client = findClientWindow(&clientSystem, eventWindow))){
			if((*e).state == XCB_PROPERTY_DELETE){
				if((*client).container){
					xcb_delete_property(connection, (*client).container, property);
				}
				unstoreClientProperty(client, property);
			}else{
				xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property(connection, false, (*client).window, property, XCB_GET_PROPERTY_TYPE_ANY, 0, 0xFFFFFFFF), NULL);
				uint32 token = pushPointer(reply, "propertyNotifyEvent: get property reply", iFree);
				if(reply){
					const void *const value = xcb_get_property_value(reply);
					if((*client).container){
						const uint size = (*reply).format / 8;
						uint length = xcb_get_property_value_length(reply);
						if(size){
							length /= size;
						}
						xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*client).container, property, (*reply).type, (*reply).format, length, value);
					}
					storeClientProperty(client, property, xcb_get_property_value_length(reply), value);
					free(reply);
					popPointer(token);
				}
			}
			jmp eventLoop;
		}
		if((client = findClientContainer(&clientSystem, eventWindow))){
			xcb_get_property_reply_t *reply;
			uint32 token;
			if(!propertyExists((*client).window, property)){
				if((*e).state == XCB_PROPERTY_NEW_VALUE){
					xcb_delete_property(connection, (*client).container, property);
				}
				jmp eventLoop;
			}
			reply = xcb_wait_for_reply(connection, xcb_get_property(connection, false, (*client).window, property, XCB_GET_PROPERTY_TYPE_ANY, 0, 0xFFFFFFFF), NULL);
			token = pushPointer(reply, "propertyNotifyEvent: get property reply", iFree);
			if(reply){
				const uint size = (*reply).format / 8;
				uint length = xcb_get_property_value_length(reply);
				if(size){
					length /= size;
				}
				resetProperty((*client).container, property, (*reply).type, size, length, xcb_get_property_value(reply));
				free(reply);
				popPointer(token);
			}
			jmp eventLoop;
		}
		if(eventWindow == wmCheckWindow){
			if(property == atom._NET_WM_NAME){
				resetProperty(eventWindow, property, atom.UTF8_STRING, sizeof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
				jmp eventLoop;
			}
			if(property == atom._NET_SUPPORTING_WM_CHECK){
				resetProperty(eventWindow, property, XCB_ATOM_WINDOW, sizeof(xcb_window_t), 1, &wmCheckWindow);
				jmp eventLoop;
			}
			if(propertyExists(eventWindow, property)){
				xcb_delete_property(connection, eventWindow, property);
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		if(eventWindow == wmSelectionWindow){
			if(property == atom.MICRO_INIT){
				if((*e).state == XCB_PROPERTY_NEW_VALUE and !wmSelectionTimestamp){
					xcb_get_selection_owner_reply_t *reply;
					uint32 token;
					xcb_window_t owner = XCB_NONE;
					xcb_set_selection_owner(connection, wmSelectionWindow, atom.WM_Sn, getTimestamp());
					xcb_delete_property(connection, eventWindow, atom.MICRO_INIT);
					xcb_sync();
					reply = xcb_wait_for_reply(connection, xcb_get_selection_owner_unchecked(connection, atom.WM_Sn), NULL);
					token = pushPointer(reply, "propertyNotifyEvent: get selection owner reply", iFree);
					if(reply){
						owner = (*reply).owner;
						free(reply);
						popPointer(token);
					}
					if(!previousWMSelectionWindow){
						if(owner != wmSelectionWindow){
							printTitledError("selection error", "could not get ownership of WM_Sn selection");
							jmp mainEmergencyExit;
						}
						if(!initWindowManagerSystem()){
							jmp mainEmergencyExit;
						}
					}
				}
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  e
	}
	selectionClearEvent:{
		#define e /*-*/ ((xcb_selection_clear_event_t *)event)
		if((*e).selection == atom.WM_Sn and (*e).owner == wmSelectionWindow){
			jmp mainEmergencyExit;
		}
		jmp eventLoop;
		#undef  e
	}
	colormapNotifyEvent:{
		#define e /*-*/ ((xcb_colormap_notify_event_t *)event)
		jmp eventLoop;
		#undef  e
	}
	clientMessageEvent:{
		#define e /*------------------------*/ ((xcb_client_message_event_t *)event)
		#define NONE_SOURCE_INDICATION /*---*/ (0)
		#define NORMAL_SOURCE_INDICATION /*-*/ (1)
		#define PAGER_SOURCE_INDICATION /*--*/ (2)
		const xcb_window_t eventWindow = (*e).window;
		const xcb_atom_t property = (*e).type;
		const uint32 *const dataStart = (*e).data.data32;
		Client *client;
		if((*e).format != 32){
			jmp eventLoop;
		}
		if(!eventWindow){
			if(property == atom._NET_ACTIVE_WINDOW){
				switch *dataStart over
					to NONE_SOURCE_INDICATION: /*---*/ brk;
					to NORMAL_SOURCE_INDICATION: /*-*/ brk;
					to PAGER_SOURCE_INDICATION: /*--*/ brk;
					off: /*-------------------------*/ brk;
				end
				loseFocus(&clientSystem);
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		if(eventWindow == (*screen).root){
			if(property == atom._NET_NUMBER_OF_DESKTOPS){
				setVirtualRootAmount(&virtualRootSystem, &monitorSystem, &clientSystem, &cursorSystem, *dataStart);
				setVirtualRootWallpaper(&virtualRootSystem, &wallpaperSystem);
				jmp eventLoop;
			}
			if(property == atom._NET_DESKTOP_GEOMETRY){
				jmp eventLoop;
			}
			if(property == atom._NET_DESKTOP_VIEWPORT){
				jmp eventLoop;
			}
			if(property == atom._NET_CURRENT_DESKTOP){
				gotoVirtualRoot(&virtualRootSystem, &clientSystem, *dataStart, true);
				jmp eventLoop;
			}
			if(property == atom._NET_ACTIVE_WINDOW){
				switch *dataStart over
					to NONE_SOURCE_INDICATION: /*---*/ brk;
					to NORMAL_SOURCE_INDICATION: /*-*/ brk;
					to PAGER_SOURCE_INDICATION: /*--*/ brk;
					off: /*-------------------------*/ brk;
				end
				loseFocus(&clientSystem);
				jmp eventLoop;
			}
			if(property == atom._NET_SHOWING_DESKTOP){
				showVirtualRootDesktop(&virtualRootSystem, &clientSystem, virtualRootSystem.currentDesktop, *dataStart);
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		if((client = findClientWindow(&clientSystem, eventWindow))){
			if(property == atom.WM_CHANGE_STATE){
				uint8 state = (*client).stateState;
				if(state != NORMAL_STATE or *dataStart != ICONIC_STATE){
					jmp eventLoop;
				}
				if(unmapClient(&clientSystem, client, ICONIC_STATE)){
					if(state == NORMAL_STATE){
						state = (*client).stateState;
						(*client).stateState = NORMAL_STATE;
						if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
							updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
							updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
							if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
								changeVirtualRootWorkarea(&virtualRootSystem);
							}
						}
						(*client).stateState = state;
					}



					/*!*/



					if((*client).stateState == WITHDRAWN_STATE){
						if(removeClientListWindow(&clientListSystem, eventWindow)){
							changeClientListProperty(&clientListSystem);
						}
						if(removeClientListWindow(&clientListStackingSystem, eventWindow)){
							changeClientListProperty(&clientListStackingSystem);
						}
						if((*client).desktop != 0xFFFFFFFF){
							moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, NONE_DESKTOP, true);
						}
					}
				}
				jmp eventLoop;
			}
			if(property == atom.WM_COLORMAP_NOTIFY){
				jmp eventLoop;
			}
			if(property == atom._NET_ACTIVE_WINDOW){
				switch *dataStart over
					to NONE_SOURCE_INDICATION: /*---*/ brk;
					to NORMAL_SOURCE_INDICATION: /*-*/ brk;
					to PAGER_SOURCE_INDICATION: /*--*/ brk;
					off: /*-------------------------*/ brk;
				end
				setFocusedClient(&clientSystem, client, virtualRootSystem.currentDesktop);
				jmp eventLoop;
			}
			if(property == atom._NET_CLOSE_WINDOW){
				switch *(dataStart + 1) over
					to NONE_SOURCE_INDICATION: /*---*/ brk;
					to NORMAL_SOURCE_INDICATION: /*-*/ brk;
					to PAGER_SOURCE_INDICATION: /*--*/ brk;
					off: /*-------------------------*/ brk;
				end
				if(!closeClient(&clientSystem, client, CLOSE_CLOSE_CLIENT_COMMAND)){
					closeClient(&clientSystem, client, KILL_CLOSE_CLIENT_COMMAND);
				}
				jmp eventLoop;
			}
			if(property == atom._NET_MOVERESIZE_WINDOW){
				jmp eventLoop;
			}
			if(property == atom._NET_WM_MOVERESIZE){
				jmp eventLoop;
			}
			if(property == atom._NET_RESTACK_WINDOW){
				switch *dataStart over
					to NONE_SOURCE_INDICATION: /*---*/ brk;
					to NORMAL_SOURCE_INDICATION: /*-*/ brk;
					to PAGER_SOURCE_INDICATION: /*--*/ brk;
					off: /*-------------------------*/ brk;
				end
				if(restackClient(&clientSystem, client, *(dataStart + 2), *(dataStart + 1))){
					configureClient(&clientSystem, client);
					configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
					if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}
				jmp eventLoop;
			}
			if(property == atom._NET_REQUEST_FRAME_EXTENTS){
				if((*client).stateState == WITHDRAWN_STATE){
					xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, eventWindow, atom._NET_FRAME_EXTENTS, XCB_ATOM_CARDINAL, bitsof(uint32), 4, &(*client).frameExtentsLeft));
				}
				jmp eventLoop;
			}
			if(property == atom._NET_WM_DESKTOP){
				switch *(dataStart + 1) over
					to NONE_SOURCE_INDICATION: /*---*/ brk;
					to NORMAL_SOURCE_INDICATION: /*-*/ brk;
					to PAGER_SOURCE_INDICATION: /*--*/ brk;
					off: /*-------------------------*/ brk;
				end
				moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, *dataStart, true);
				jmp eventLoop;
			}
			if(property == atom._NET_WM_STATE){
				uint8 action;
				xcb_atom_t property0;
				xcb_atom_t property1;
				uint16 state;
				switch *(dataStart + 3) over
					to NONE_SOURCE_INDICATION: /*---*/ brk;
					to NORMAL_SOURCE_INDICATION: /*-*/ brk;
					to PAGER_SOURCE_INDICATION: /*--*/ brk;
					off: /*-------------------------*/ brk;
				end
				action = *(dataStart + 0);
				switch action over
					to _NET_WM_STATE_ADD: /*----*/ brk;
					to _NET_WM_STATE_REMOVE: /*-*/ brk;
					to _NET_WM_STATE_TOGGLE: /*-*/ brk;
					off: /*---------------------*/ jmp eventLoop;
				end
				property0 = *(dataStart + 1);
				property1 = *(dataStart + 2);
				state = NONE_STATE;
				if(property0){
					if(property0 == atom._NET_WM_STATE_MODAL){
						state |= MODAL_STATE;
					}elif(property0 == atom._NET_WM_STATE_STICKY){
						state |= STICKY_STATE;
					}elif(property0 == atom._NET_WM_STATE_MAXIMIZED_HORZ){
						state |= MAXIMIZED_HORZ_STATE;
					}elif(property0 == atom._NET_WM_STATE_MAXIMIZED_VERT){
						state |= MAXIMIZED_VERT_STATE;
					}elif(property0 == atom._NET_WM_STATE_SHADED){
						state |= SHADED_STATE;
					}elif(property0 == atom._NET_WM_STATE_SKIP_TASKBAR){
						state |= SKIP_TASKBAR_STATE;
					}elif(property0 == atom._NET_WM_STATE_SKIP_PAGER){
						state |= SKIP_PAGER_STATE;
					}elif(property0 == atom._NET_WM_STATE_HIDDEN){
						state |= HIDDEN_STATE;
					}elif(property0 == atom._NET_WM_STATE_FULLSCREEN){
						state |= FULLSCREEN_STATE;
					}elif(property0 == atom._NET_WM_STATE_ABOVE){
						state |= ABOVE_STATE;
					}elif(property0 == atom._NET_WM_STATE_BELOW){
						state |= BELOW_STATE;
					}elif(property0 == atom._NET_WM_STATE_DEMANDS_ATTENTION){
						state |= DEMANDS_ATTENTION_STATE;
					}
				}
				if(property1){
					if(property1 == atom._NET_WM_STATE_MODAL){
						state |= MODAL_STATE;
					}elif(property1 == atom._NET_WM_STATE_STICKY){
						state |= STICKY_STATE;
					}elif(property1 == atom._NET_WM_STATE_MAXIMIZED_HORZ){
						state |= MAXIMIZED_HORZ_STATE;
					}elif(property1 == atom._NET_WM_STATE_MAXIMIZED_VERT){
						state |= MAXIMIZED_VERT_STATE;
					}elif(property1 == atom._NET_WM_STATE_SHADED){
						state |= SHADED_STATE;
					}elif(property1 == atom._NET_WM_STATE_SKIP_TASKBAR){
						state |= SKIP_TASKBAR_STATE;
					}elif(property1 == atom._NET_WM_STATE_SKIP_PAGER){
						state |= SKIP_PAGER_STATE;
					}elif(property1 == atom._NET_WM_STATE_HIDDEN){
						state |= HIDDEN_STATE;
					}elif(property1 == atom._NET_WM_STATE_FULLSCREEN){
						state |= FULLSCREEN_STATE;
					}elif(property1 == atom._NET_WM_STATE_ABOVE){
						state |= ABOVE_STATE;
					}elif(property1 == atom._NET_WM_STATE_BELOW){
						state |= BELOW_STATE;
					}elif(property1 == atom._NET_WM_STATE_DEMANDS_ATTENTION){
						state |= DEMANDS_ATTENTION_STATE;
					}
				}
				state &= ~(MODAL_STATE | STICKY_STATE | SHADED_STATE | HIDDEN_STATE | ABOVE_STATE | BELOW_STATE | DEMANDS_ATTENTION_STATE);
				if(!state){
					jmp eventLoop;
				}
				if(state & MODAL_STATE){
					state &= ~(MODAL_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & STICKY_STATE){
					state &= ~(STICKY_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
					if((state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) == (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
						if(((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) != (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
							if(action == _NET_WM_STATE_ADD or action == _NET_WM_STATE_TOGGLE){
								maximizeClient(&virtualRootSystem, &monitorSystem, &clientSystem, client, POINTER_WHICH_MONITOR);
							}
						}else{
							if(action == _NET_WM_STATE_REMOVE or action == _NET_WM_STATE_TOGGLE){
								unmaximizeClient(&virtualRootSystem, &monitorSystem, &clientSystem, client);
							}
						}
					}
					state &= ~(MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & SHADED_STATE){
					state &= ~(SHADED_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & SKIP_TASKBAR_STATE){
					state &= ~(SKIP_TASKBAR_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & SKIP_PAGER_STATE){
					state &= ~(SKIP_PAGER_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & HIDDEN_STATE){
					state &= ~(HIDDEN_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & FULLSCREEN_STATE){
					if(!((*client).state & FULLSCREEN_STATE)){
						if(action == _NET_WM_STATE_ADD or action == _NET_WM_STATE_TOGGLE){
							if(fullscreenClient(&virtualRootSystem, &monitorSystem, &clientSystem, client, POINTER_WHICH_MONITOR)){
								if(setClientOrderType(&clientSystem, client)){
									if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
										configureClient(&clientSystem, client);
										configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
										if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
											changeClientListProperty(&clientListStackingSystem);
										}
									}
								}
							}
						}
					}else{
						if(action == _NET_WM_STATE_REMOVE or action == _NET_WM_STATE_TOGGLE){
							if(unfullscreenClient(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
								if(setClientOrderType(&clientSystem, client)){
									if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
										configureClient(&clientSystem, client);
										configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
										if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
											changeClientListProperty(&clientListStackingSystem);
										}
									}
								}
							}
						}
					}
					state &= ~(FULLSCREEN_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & ABOVE_STATE){
					/*!*/
					state &= ~(ABOVE_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & BELOW_STATE){
					/*!*/
					state &= ~(BELOW_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & DEMANDS_ATTENTION_STATE){
					/*!*/
					state &= ~(DEMANDS_ATTENTION_STATE);
				}
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  PAGER_SOURCE_INDICATION
		#undef  NORMAL_SOURCE_INDICATION
		#undef  NONE_SOURCE_INDICATION
		#undef  e
	}
	genericEvent:{
		#define e /*-*/ ((xcb_ge_generic_event_t *)event)
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  e
	}
	extensionEvent:{
		#define isExtensionEvent(e) /*-*/ (eventType >= e##BaseEvent and eventType < e##BaseEvent + countof(e##EventName) - 1)
		const uint8 eventType = (*event).response_type & ~b(10000000);
		if(isExtensionEvent(randr)) /*--*/ jmp switchRandrEvent;
		if(isExtensionEvent(shape)) /*--*/ jmp switchShapeEvent;
		if(isExtensionEvent(xfixes)) /*-*/ jmp switchXfixesEvent;
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  isExtensionEvent
	}
	switchRandrEvent:{
		printXEvent(randrEventName);
		switch ((*event).response_type & ~b(10000000)) - randrBaseEvent over
			to XCB_RANDR_SCREEN_CHANGE_NOTIFY:
			to XCB_RANDR_NOTIFY:{
				struct{
					int32 /*--*/ x;
					int32 /*--*/ y;
					uint32 /*-*/ width;
					uint32 /*-*/ height;
				} valueList;
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
					printTitledError("pthread error", "could not lock globals write lock");
				}
				{
					int screenNumber;
					xcb_connection_t *const connection = xcb_connect_to_display_with_auth_info(connectionName, NULL, &screenNumber);
					uint32 token = pushPointer(connection, "X connection", iXCBDisconnect);
					if(connection){
						xcb_screen_t *const screen = xcb_setup_roots_iterator(xcb_get_setup(connection)).data + screenNumber;
						if(screen){
							screenWidthInPixels = (*screen).width_in_pixels;
							screenHeightInPixels = (*screen).height_in_pixels;
							screenWidthInMillimeters = (*screen).width_in_millimeters;
							screenHeightInMillimeters = (*screen).height_in_millimeters;
						}else{
							screenWidthInPixels = 0;
							screenHeightInPixels = 0;
							screenWidthInMillimeters = 0;
							screenHeightInMillimeters = 0;
						}
						xcb_disconnect(connection);
						popPointer(token);
					}
				}
				valueList.x = 0;
				valueList.y = 0;
				valueList.width = screenWidthInPixels;
				valueList.height = screenHeightInPixels;
				xcb_configure_window(connection, glassWindow, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &valueList);
				createMonitors(&monitorSystem);
				createWallpaper(&wallpaperSystem, &monitorSystem, screenWidthInPixels, screenHeightInPixels);
				resizeVirtualRoot(&virtualRootSystem, &monitorSystem, &wallpaperSystem, &clientSystem, screenWidthInPixels, screenHeightInPixels);
				setVirtualRootWallpaper(&virtualRootSystem, &wallpaperSystem);
				/*! change root properties... maybe? do we change them already or no? */
				jmp eventLoop;
			}
			off:{
				jmp unrecognizedEvent;
			}
		end
	}
	switchShapeEvent:{
		printXEvent(shapeEventName);
		switch ((*event).response_type & ~b(10000000)) - shapeBaseEvent over
			to XCB_SHAPE_NOTIFY:{
				#define e /*-*/ ((xcb_shape_notify_event_t *)event)
				/*!*/
				jmp eventLoop;
				#undef  e
			}
			off:{
				jmp unrecognizedEvent;
			}
		end
	}
	switchXfixesEvent:{
		printXEvent(xfixesEventName);
		switch ((*event).response_type & ~b(10000000)) - xfixesBaseEvent over
			to XCB_XFIXES_SELECTION_NOTIFY: /*-*/ jmp eventLoop;
			to XCB_XFIXES_CURSOR_NOTIFY: /*----*/ jmp eventLoop;
			off: /*----------------------------*/ jmp unrecognizedEvent;
		end
	}
	unrecognizedEvent:{
		printTitledValuedError("X event error", "unrecognized event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unexpectedEvent:{
		printTitledValuedError("unexpected X event", "unexpected event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unhandledEvent:{
		printTitledValuedError("X event error", "unhandled event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	mainEmergencyExit:{
		cleanup();
		ret 0;
	}
}
INITPOINTERSYSTEM(){
	if(!pointerSystem){
		ret false;
	}
	(*pointerSystem).timestamp = XCB_CURRENT_TIME;
	(*pointerSystem).x = 0;
	(*pointerSystem).y = 0;
	ret true;
}
SETPOINTER(){
	xcb_timestamp_t timestamp;
	xcb_query_pointer_reply_t *reply;
	uint32 token;
	if(!pointerSystem){
		ret false;
	}
	timestamp = getTimestamp();
	if(timestamp == (*pointerSystem).timestamp){
		ret false;
	}
	reply = xcb_wait_for_reply(connection, xcb_query_pointer_unchecked(connection, (*screen).root), NULL);
	token = pushPointer(reply, "setPointer() query pointer reply", iFree);
	if(!reply){
		ret false;
	}
	(*pointerSystem).timestamp = timestamp;
	(*pointerSystem).x = (*reply).root_x;
	(*pointerSystem).y = (*reply).root_y;
	free(reply);
	popPointer(token);
	ret true;
}
FINIPOINTERSYSTEM(){
	if(!pointerSystem){
		ret false;
	}
	(*pointerSystem).timestamp = XCB_CURRENT_TIME;
	(*pointerSystem).x = 0;
	(*pointerSystem).y = 0;
	ret true;
}
INITCURSORSYSTEM(){
	if(!cursorSystem){
		ret false;
	}
	(*cursorSystem).cursorFont = XCB_NONE;
	(*cursorSystem).cursor = XCB_NONE;
	ret true;
}
SETCURSOR(){
	if(!cursorSystem or cursorGlyph > countof(cursorGlyphList) - 1){
		ret false;
	}
	if((*cursorSystem).cursor){
		xcb_free_cursor(connection, (*cursorSystem).cursor);
	}
	if((*cursorSystem).cursorFont){
		xcb_close_font(connection, (*cursorSystem).cursorFont);
	}
	(*cursorSystem).cursorFont = xcb_generate_id(connection);
	(*cursorSystem).cursor = xcb_generate_id(connection);
	xcb_open_font(connection, (*cursorSystem).cursorFont, lengthof("cursor"), "cursor");
	{
		const uint16 redForeground   = ((foreground & 0x00FF0000) >> 16) * 257;
		const uint16 greenForeground = ((foreground & 0x0000FF00) >>  8) * 257;
		const uint16 blueForeground  = ((foreground & 0x000000FF) >>  0) * 257;
		const uint16 redBackground   = ((background & 0x00FF0000) >> 16) * 257;
		const uint16 greenBackground = ((background & 0x0000FF00) >>  8) * 257;
		const uint16 blueBackground  = ((background & 0x000000FF) >>  0) * 257;
		xcb_create_glyph_cursor(connection, (*cursorSystem).cursor, (*cursorSystem).cursorFont, (*cursorSystem).cursorFont, 2 * cursorGlyph, 2 * cursorGlyph + 1, redForeground, greenForeground, blueForeground, redBackground, greenBackground, blueBackground);
	}
	ret true;
}
FINICURSORSYSTEM(){
	if(!cursorSystem){
		ret false;
	}
	if((*cursorSystem).cursor){
		xcb_free_cursor(connection, (*cursorSystem).cursor);
		(*cursorSystem).cursor = XCB_NONE;
	}
	if((*cursorSystem).cursorFont){
		xcb_close_font(connection, (*cursorSystem).cursorFont);
		(*cursorSystem).cursorFont = XCB_NONE;
	}
	ret true;
}
INITWALLPAPERSYSTEM(){
	if(!wallpaperSystem){
		ret false;
	}
	(*wallpaperSystem).pixmap = XCB_NONE;
	(*wallpaperSystem).gc = XCB_NONE;
	(*wallpaperSystem).width = 0;
	(*wallpaperSystem).height = 0;
	(*wallpaperSystem).color = 0x00000000;
	(*wallpaperSystem).wallpaperPixmap = XCB_NONE;
	(*wallpaperSystem).wallpaperWidth = 0;
	(*wallpaperSystem).wallpaperHeight = 0;
	ret true;
}
SETWALLPAPERCOLOR(){
	if(!wallpaperSystem or !monitorSystem or !(*monitorSystem).size){
		ret false;
	}
	(*wallpaperSystem).color = color;
	createWallpaper(wallpaperSystem, monitorSystem, (*wallpaperSystem).width, (*wallpaperSystem).height);
	ret true;
}
SETWALLPAPERPIXMAP(){
	xcb_pixmap_t pixmap;
	uint width;
	uint height;
	if(!wallpaperSystem or !monitorSystem or !(*monitorSystem).size or !pixmapProperty){
		ret false;
	}
	jmp getWallpaper;
	getWallpaper:{
		xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property_unchecked(connection, false, (*screen).root, pixmapProperty, XCB_ATOM_PIXMAP, 0, 0xFFFFFFFF), NULL);
		uint32 token = pushPointer(reply, "setWallpaperPixmap() get property reply", iFree);
		if(!reply){
			ret false;
		}
		pixmap = XCB_NONE;
		if(xcb_get_property_value_length(reply) == sizeof(xcb_pixmap_t)){
			pixmap = *(xcb_pixmap_t *)xcb_get_property_value(reply);
		}
		free(reply);
		popPointer(token);
		if(!pixmap){
			ret false;
		}
		jmp getWallpaperSize;
	}
	getWallpaperSize:{
		xcb_get_geometry_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_geometry(connection, pixmap), NULL);
		uint32 token = pushPointer(reply, "setWallpaperPixmap() get geometry reply", iFree);
		width = 0;
		height = 0;
		if(reply){
			width = (*reply).width;
			height = (*reply).height;
			free(reply);
			popPointer(token);
		}
		if(!width or !height){
			ret false;
		}
		jmp setWallpaper;
	}
	setWallpaper:{
		const xcb_gcontext_t gc = xcb_generate_id(connection);
		struct{
			uint32 /*-*/ generateExpose;
		} valueList;
		valueList.generateExpose = false;
		if((*wallpaperSystem).wallpaperPixmap){
			xcb_free_pixmap(connection, (*wallpaperSystem).wallpaperPixmap);
		}
		(*wallpaperSystem).wallpaperPixmap = xcb_generate_id(connection);
		(*wallpaperSystem).wallpaperWidth = width;
		(*wallpaperSystem).wallpaperHeight = height;
		xcb_create_pixmap(connection, (*screen).root_depth, (*wallpaperSystem).wallpaperPixmap, (*screen).root, width, height);
		xcb_create_gc(connection, gc, (*wallpaperSystem).wallpaperPixmap, XCB_GC_GRAPHICS_EXPOSURES, &valueList);
		fillDrawable((*wallpaperSystem).wallpaperPixmap, gc, 0, 0, width, height, (*wallpaperSystem).color);
		xcb_discard_reply(connection, xcb_copy_area_checked(connection, pixmap, (*wallpaperSystem).wallpaperPixmap, gc, 0, 0, 0, 0, width, height));
		xcb_free_gc(connection, gc);
		jmp createWallpaper;
	}
	createWallpaper:{
		createWallpaper(wallpaperSystem, monitorSystem, (*wallpaperSystem).width, (*wallpaperSystem).height);
		ret true;
	}
}
CREATEWALLPAPER(){
	struct{
		uint32 /*-*/ generateExpose;
	} valueList;
	if(!wallpaperSystem or !monitorSystem or !(*monitorSystem).size or !width or !height){
		ret false;
	}
	valueList.generateExpose = false;
	if((*wallpaperSystem).gc){
		xcb_free_gc(connection, (*wallpaperSystem).gc);
	}
	if((*wallpaperSystem).pixmap){
		xcb_free_pixmap(connection, (*wallpaperSystem).pixmap);
	}
	(*wallpaperSystem).pixmap = xcb_generate_id(connection);
	(*wallpaperSystem).gc = xcb_generate_id(connection);
	(*wallpaperSystem).width = width;
	(*wallpaperSystem).height = height;
	xcb_create_pixmap(connection, (*screen).root_depth, (*wallpaperSystem).pixmap, (*screen).root, (*wallpaperSystem).width, (*wallpaperSystem).height);
	xcb_create_gc(connection, (*wallpaperSystem).gc, (*wallpaperSystem).pixmap, XCB_GC_GRAPHICS_EXPOSURES, &valueList);
	fillDrawable((*wallpaperSystem).pixmap, (*wallpaperSystem).gc, 0, 0, (*wallpaperSystem).width, (*wallpaperSystem).height, (*wallpaperSystem).color);
	if((*wallpaperSystem).wallpaperPixmap){
		xcb_copy_area(connection, (*wallpaperSystem).wallpaperPixmap, (*wallpaperSystem).pixmap, (*wallpaperSystem).gc, 0, 0, 0, 0, (*wallpaperSystem).wallpaperWidth, (*wallpaperSystem).wallpaperHeight);
	}
	ret true;
}
FINIWALLPAPERSYSTEM(){
	if(!wallpaperSystem){
		ret false;
	}
	(*wallpaperSystem).wallpaperWidth = 0;
	(*wallpaperSystem).wallpaperHeight = 0;
	if((*wallpaperSystem).wallpaperPixmap){
		xcb_free_pixmap(connection, (*wallpaperSystem).wallpaperPixmap);
		(*wallpaperSystem).wallpaperPixmap = XCB_NONE;
	}
	(*wallpaperSystem).width = 0;
	(*wallpaperSystem).height = 0;
	(*wallpaperSystem).color = 0x00000000;
	if((*wallpaperSystem).gc){
		xcb_free_gc(connection, (*wallpaperSystem).gc);
		(*wallpaperSystem).gc = XCB_NONE;
	}
	if((*wallpaperSystem).pixmap){
		xcb_free_pixmap(connection, (*wallpaperSystem).pixmap);
		(*wallpaperSystem).pixmap = XCB_NONE;
	}
	ret true;
}
INITCLIENTSYSTEM(){
	if(!clientSystem){
		ret false;
	}
	(*clientSystem).clientSize = 0;
	(*clientSystem).clientAllocated = 0;
	(*clientSystem).clientNotInUseOffset = 0;
	(*clientSystem).clientStart = NULL;
	(*clientSystem).clientToken = 0;
	(*clientSystem).orderedClientOffsetSize = 0;
	(*clientSystem).orderedClientOffsetAllocated = 0;
	(*clientSystem).orderedClientOffsetStart = NULL;
	(*clientSystem).orderedClientOffsetToken = 0;
	(*clientSystem).motionAction = NONE_MOTION_ACTION;
	(*clientSystem).recentlyConfiguredClientOffset = 0;
	(*clientSystem).motionClientOffset = 0;
	(*clientSystem).focusedClientOffset = 0;
	ret true;
}
CREATECLIENT(){
	Client *client;
	if(!clientSystem){
		ret false;
	}
	if(!class or class == XCB_WINDOW_CLASS_COPY_FROM_PARENT){
		class = getWindowClass(window);
	}
	if(class != XCB_WINDOW_CLASS_INPUT_OUTPUT){
		ret false;
	}
	jmp addClient;
	addClient:{
		if((*clientSystem).clientAllocated == (*clientSystem).clientSize){
			void *temp;
			(*clientSystem).clientSize += CLIENT_BLOCK_SIZE;
			temp = realloc((*clientSystem).clientStart, (*clientSystem).clientSize * sizeof(Client));
			if(!(*clientSystem).clientToken){
				(*clientSystem).clientToken = pushPointer(temp, "client pointer", iFree);
			}else{
				updatePointer((*clientSystem).clientToken, temp);
			}
			if(!temp){
				printTitledError("memory allocation error", "could not allocate memory for clients");
				(*clientSystem).clientSize -= CLIENT_BLOCK_SIZE;
				ret false;
			}
			(*clientSystem).clientStart = temp;
			if(!(*clientSystem).clientAllocated){
				(*clientSystem).clientAllocated = 1;
				(*clientSystem).clientNotInUseOffset = 1;
				(*(*clientSystem).clientStart).inUse = false;
			}
		}
		if((*clientSystem).orderedClientOffsetAllocated == (*clientSystem).orderedClientOffsetSize){
			void *temp;
			(*clientSystem).orderedClientOffsetSize += CLIENT_BLOCK_SIZE;
			temp = realloc((*clientSystem).orderedClientOffsetStart, (*clientSystem).orderedClientOffsetSize * sizeof(uint));
			if(!(*clientSystem).orderedClientOffsetToken){
				(*clientSystem).orderedClientOffsetToken = pushPointer(temp, "ordered client offset pointer", iFree);
			}else{
				updatePointer((*clientSystem).orderedClientOffsetToken, temp);
			}
			if(!temp){
				printTitledError("memory allocation error", "could not allocate memory for ordered client offsets");
				(*clientSystem).orderedClientOffsetSize -= CLIENT_BLOCK_SIZE;
				ret false;
			}
			(*clientSystem).orderedClientOffsetStart = temp;
		}
		client = (*clientSystem).clientStart + (*clientSystem).clientNotInUseOffset;
		*((*clientSystem).orderedClientOffsetStart + (*clientSystem).orderedClientOffsetAllocated) = (*clientSystem).clientNotInUseOffset;
		inc (*clientSystem).orderedClientOffsetAllocated;
		if((*clientSystem).clientNotInUseOffset == (*clientSystem).clientAllocated){
			inc (*clientSystem).clientAllocated;
			inc (*clientSystem).clientNotInUseOffset;
			jmp setClient;
		}
		jmp findNextAvailableClientSlot;
	}
	findNextAvailableClientSlot:{
		const Client *current = client + 1;
		const Client *const wall = (*clientSystem).clientStart + (*clientSystem).clientAllocated;
		jmp findNextAvailableClientSlotLoop;
		findNextAvailableClientSlotLoop:{
			if(current < wall and (*current).inUse){
				inc current;
				jmp findNextAvailableClientSlotLoop;
			}
			(*clientSystem).clientNotInUseOffset = current - (*clientSystem).clientStart;
			jmp setClient;
		}
	}
	setClient:{
		(*client).container = XCB_NONE;
		(*client).window = window;
		(*client).pixmap = XCB_NONE;
		(*client).gc = XCB_NONE;
		(*client).windowX = x;
		(*client).windowY = y;
		(*client).windowWidth = width;
		(*client).windowHeight = height;
		(*client).windowBorder = border;
		(*client).propertyPreference = NONE_PROPERTY_PREFERENCE;
		(*client).nameStart = NULL;
		(*client).nameToken = 0;
		(*client).iconNameStart = NULL;
		(*client).iconNameToken = 0;
		(*client).normalHintsFlags = NONE_NORMAL_HINT;
		(*client).hintsInput = false;
		(*client).hintsInitialState = NORMAL_STATE;
		(*client).hintsIconPixmap = XCB_NONE;
		(*client).hintsIconWindow = XCB_NONE;
		(*client).hintsIconX = 0;
		(*client).hintsIconY = 0;
		(*client).hintsIconMask = XCB_NONE;
		(*client).hintsWindowGroup = XCB_NONE;
		(*client).hintsUrgency = false;
		(*client).classStart = NULL;
		(*client).classToken = 0;
		(*client).transientFor = XCB_NONE;
		(*client).protocol = NONE_CLIENT_PROTOCOL;
		(*client).protocolStart = NULL;
		(*client).protocolToken = 0;
		(*client).colormapWindowStart = NULL;
		(*client).colormapWindowToken = 0;
		(*client).clientMachineStart = NULL;
		(*client).clientMachineToken = 0;
		(*client).clientIDStart = NULL;
		(*client).clientIDToken = 0;
		(*client).clientLeader = XCB_NONE;
		(*client).windowRoleStart = NULL;
		(*client).windowRoleToken = 0;
		(*client).stateState = WITHDRAWN_STATE;
		(*client).stateIcon = XCB_NONE;
		(*client).visibleNameStart = NULL;
		(*client).visibleNameToken = 0;
		(*client).visibleIconNameStart = NULL;
		(*client).visibleIconNameToken = 0;
		(*client).desktop = NONE_DESKTOP;
		(*client).windowType = NONE_WINDOW_TYPE;
		(*client).windowTypeStart = NULL;
		(*client).windowTypeToken = 0;
		(*client).state = NONE_STATE;
		(*client).stateStart = NULL;
		(*client).stateToken = 0;
		(*client).allowedAction = NONE_ALLOWED_ACTION;
		(*client).allowedActionStart = NULL;
		(*client).allowedActionToken = 0;
		(*client).strut = NONE_STRUT;
		(*client).iconGeometryX = 0;
		(*client).iconGeometryY = 0;
		(*client).iconGeometryWidth = 0;
		(*client).iconGeometryHeight = 0;
		(*client).iconStart = NULL;
		(*client).iconToken = 0;
		(*client).pid = 0;
		(*client).handledIcons = false;
		(*client).userTime = NONE_USER_TIME;
		(*client).frameExtentsLeft = 0;
		(*client).frameExtentsRight = 0;
		(*client).frameExtentsTop = 0;
		(*client).frameExtentsBottom = 0;
		(*client).orderType = NONE_ORDER_TYPE;
		(*client).option = overrideRedirect * OVERRIDE_REDIRECT_CLIENT_OPTION;
		(*client).workareaPosition = NONE_WORKAREA_POSITION;
		(*client).inUse = true;
		jmp selectInput;
	}
	selectInput:{
		uint32 valueMask = XCB_CW_EVENT_MASK;
		struct{
			uint32 /*-------*/ eventMask;
			xcb_cursor_t /*-*/ cursor;
		} valueList;
		valueList.eventMask = WINDOW_EVENT_MASK;
		if(cursorSystem and (*cursorSystem).cursor){
			valueMask |= XCB_CW_CURSOR;
			valueList.cursor = (*cursorSystem).cursor;
		}
		xcb_discard_reply(connection, xcb_change_window_attributes_checked(connection, (*client).window, valueMask, &valueList));
		xcb_flush(connection);
		jmp createClientObjects;
	}
	createClientObjects:{
		if(!overrideRedirect){
			uint32 valueMask = XCB_CW_BACK_PIXEL | XCB_CW_BORDER_PIXEL | XCB_CW_EVENT_MASK | XCB_CW_COLORMAP;
			struct{
				uint32 /*---------*/ backgroundColor;
				uint32 /*---------*/ borderColor;
				uint32 /*---------*/ eventMask;
				xcb_colormap_t /*-*/ colormap;
				xcb_cursor_t /*---*/ cursor;
			} valueList;
			valueList.backgroundColor = 0xFF171717;
			valueList.borderColor = 0x00000000;
			valueList.eventMask = CONTAINER_EVENT_MASK;
			valueList.colormap = colormap;
			if(cursorSystem and (*cursorSystem).cursor){
				valueMask |= XCB_CW_CURSOR;
				valueList.cursor = (*cursorSystem).cursor;
			}
			(*client).container = xcb_generate_id(connection);
			(*client).containerX = x;
			(*client).containerY = y;
			(*client).containerWidth = width + 2 * border;
			(*client).containerHeight = height + 2 * border;
			(*client).containerBorder = 0;
			(*client).windowX = 0;
			(*client).windowY = 0;
			xcb_create_window(connection, depth, (*client).container, (*screen).root, (*client).containerX, (*client).containerY, (*client).containerWidth, (*client).containerHeight, (*client).containerBorder, XCB_WINDOW_CLASS_INPUT_OUTPUT, visual, valueMask, &valueList);
		}
		ret true;
	}
}
SETDEFAULTCLIENTWINDOWTYPE(){
	void *temp;
	xcb_atom_t a;
	uint8 type;
	if(!clientSystem or !isValidClient(clientSystem, client) or (*client).windowType){
		ret false;
	}
	if(!(*client).windowTypeStart){
		(*client).windowTypeSize = 0;
	}
	inc (*client).windowTypeSize;
	temp = realloc((*client).windowTypeStart, (*client).windowTypeSize * sizeof(xcb_atom_t));
	if(!(*client).windowTypeToken){
		(*client).windowTypeToken = pushPointer(temp, "client _NET_WM_WINDOW_TYPE pointer", iFree);
	}else{
		updatePointer((*client).windowTypeToken, temp);
	}
	if(!temp){
		printTitledError("memory allocation error", "could not allocate memory for client window type");
		dec (*client).windowTypeSize;
		ret false;
	}
	(*client).windowTypeStart = temp;
	if((*client).transientFor){
		a = atom._NET_WM_WINDOW_TYPE_DIALOG;
		type = DIALOG_WINDOW_TYPE;
	}else{
		a = atom._NET_WM_WINDOW_TYPE_NORMAL;
		type = NORMAL_WINDOW_TYPE;
	}
	*((*client).windowTypeStart + (*client).windowTypeSize - 1) = a;
	(*client).windowType |= type;
	ret true;
}
UPDATECLIENTSTATE(){
	uint stateSize;
	void *temp;
	uint32 token;
	xcb_atom_t *current;
	if(!clientSystem or !isValidClient(clientSystem, client) or !state){
		ret false;
	}
	if((state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) != (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) /*-*/ state &= ~(MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE);
	if((state & (ABOVE_STATE | BELOW_STATE)) == (ABOVE_STATE | BELOW_STATE)) /*-------------------------------------*/ state &= ~(BELOW_STATE);
	switch action over
		to _NET_WM_STATE_ADD: /*----*/ state |= (*client).state; /*---------*/ brk;
		to _NET_WM_STATE_REMOVE: /*-*/ state = (*client).state & ~state; /*-*/ brk;
		to _NET_WM_STATE_TOGGLE: /*-*/ state ^= (*client).state; /*---------*/ brk;
		off: /*---------------------*/ /*-----------------------------------*/ ret false;
	end
	if(state == (*client).state){
		ret false;
	}
	stateSize = !!(state & MODAL_STATE) + !!(state & STICKY_STATE) + !!(state & MAXIMIZED_HORZ_STATE) + !!(state & MAXIMIZED_VERT_STATE) + !!(state & SHADED_STATE) + !!(state & SKIP_TASKBAR_STATE) + !!(state & SKIP_PAGER_STATE) + !!(state & HIDDEN_STATE) + !!(state & FULLSCREEN_STATE) + !!(state & ABOVE_STATE) + !!(state & BELOW_STATE) + !!(state & DEMANDS_ATTENTION_STATE);
	temp = NULL;
	token = 0;
	if(stateSize){
		temp = malloc(stateSize * sizeof(xcb_atom_t));
		token = pushPointer(temp, "client _NET_WM_STATE pointer", iFree);
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for client state");
			ret false;
		}
		current = (xcb_atom_t *)temp - 1;
		if(state & MODAL_STATE) /*-------------*/ *(inc current) = atom._NET_WM_STATE_MODAL;
		if(state & STICKY_STATE) /*------------*/ *(inc current) = atom._NET_WM_STATE_STICKY;
		if(state & MAXIMIZED_HORZ_STATE) /*----*/ *(inc current) = atom._NET_WM_STATE_MAXIMIZED_HORZ;
		if(state & MAXIMIZED_VERT_STATE) /*----*/ *(inc current) = atom._NET_WM_STATE_MAXIMIZED_VERT;
		if(state & SHADED_STATE) /*------------*/ *(inc current) = atom._NET_WM_STATE_SHADED;
		if(state & SKIP_TASKBAR_STATE) /*------*/ *(inc current) = atom._NET_WM_STATE_SKIP_TASKBAR;
		if(state & SKIP_PAGER_STATE) /*--------*/ *(inc current) = atom._NET_WM_STATE_SKIP_PAGER;
		if(state & HIDDEN_STATE) /*------------*/ *(inc current) = atom._NET_WM_STATE_HIDDEN;
		if(state & FULLSCREEN_STATE) /*--------*/ *(inc current) = atom._NET_WM_STATE_FULLSCREEN;
		if(state & ABOVE_STATE) /*-------------*/ *(inc current) = atom._NET_WM_STATE_ABOVE;
		if(state & BELOW_STATE) /*-------------*/ *(inc current) = atom._NET_WM_STATE_BELOW;
		if(state & DEMANDS_ATTENTION_STATE) /*-*/ *(inc current) = atom._NET_WM_STATE_DEMANDS_ATTENTION;
	}
	free((*client).stateStart);
	popPointer((*client).stateToken);
	(*client).state = state;
	(*client).stateSize = stateSize;
	(*client).stateStart = temp;
	(*client).stateToken = token;
	ret true;
}
CHANGECLIENTSTATE(){
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	if(!(*client).state){
		xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, atom._NET_WM_STATE));
	}else{
		xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_WM_STATE, XCB_ATOM_ATOM, bitsof(xcb_atom_t), (*client).stateSize, (*client).stateStart));
	}
	ret true;
}
SETCLIENTALLOWEDACTIONS(){
	uint8 windowType;
	uint16 state;
	uint16 allowedAction;
	uint allowedActionSize;
	void *temp;
	uint32 token;
	xcb_atom_t *current;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	windowType = (*client).windowType;
	state = (*client).state;
	allowedAction = NONE_ALLOWED_ACTION;
	if(windowType & DESKTOP_WINDOW_TYPE) /*-*/ allowedAction |= NONE_ALLOWED_ACTION;
	if(windowType & DOCK_WINDOW_TYPE) /*----*/ allowedAction |= STICK_ALLOWED_ACTION | CHANGE_DESKTOP_ALLOWED_ACTION;
	if(windowType & TOOLBAR_WINDOW_TYPE) /*-*/ allowedAction |= MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION | MINIMIZE_ALLOWED_ACTION | SHADE_ALLOWED_ACTION | MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION | FULLSCREEN_ALLOWED_ACTION | CHANGE_DESKTOP_ALLOWED_ACTION | CLOSE_ALLOWED_ACTION;
	if(windowType & MENU_WINDOW_TYPE) /*----*/ allowedAction |= NONE_ALLOWED_ACTION;
	if(windowType & UTILITY_WINDOW_TYPE) /*-*/ allowedAction |= MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION | MINIMIZE_ALLOWED_ACTION | SHADE_ALLOWED_ACTION | MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION | FULLSCREEN_ALLOWED_ACTION | CHANGE_DESKTOP_ALLOWED_ACTION | CLOSE_ALLOWED_ACTION;
	if(windowType & SPLASH_WINDOW_TYPE) /*--*/ allowedAction |= STICK_ALLOWED_ACTION | CLOSE_ALLOWED_ACTION;
	if(windowType & DIALOG_WINDOW_TYPE) /*--*/ allowedAction |= MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION | MINIMIZE_ALLOWED_ACTION | SHADE_ALLOWED_ACTION | MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION | FULLSCREEN_ALLOWED_ACTION | CHANGE_DESKTOP_ALLOWED_ACTION | CLOSE_ALLOWED_ACTION;
	if(windowType & NORMAL_WINDOW_TYPE) /*--*/ allowedAction |= MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION | MINIMIZE_ALLOWED_ACTION | SHADE_ALLOWED_ACTION | MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION | FULLSCREEN_ALLOWED_ACTION | CHANGE_DESKTOP_ALLOWED_ACTION | CLOSE_ALLOWED_ACTION;
	if(state & MODAL_STATE) /*--------------------------------------------------------------------------------------*/ allowedAction &= ~(MINIMIZE_ALLOWED_ACTION | CHANGE_DESKTOP_ALLOWED_ACTION);
	if(state & STICKY_STATE) /*-------------------------------------------------------------------------------------*/ allowedAction &= ~(NONE_ALLOWED_ACTION);
	if((state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) == (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) /*-*/ allowedAction &= ~(MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION | SHADE_ALLOWED_ACTION | STICK_ALLOWED_ACTION);
	if(state & SHADED_STATE) /*-------------------------------------------------------------------------------------*/ allowedAction &= ~(RESIZE_ALLOWED_ACTION | MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION | FULLSCREEN_ALLOWED_ACTION);
	if(state & SKIP_TASKBAR_STATE) /*-------------------------------------------------------------------------------*/ allowedAction &= ~(NONE_ALLOWED_ACTION);
	if(state & SKIP_PAGER_STATE) /*---------------------------------------------------------------------------------*/ allowedAction &= ~(NONE_ALLOWED_ACTION);
	if(state & HIDDEN_STATE) /*-------------------------------------------------------------------------------------*/ allowedAction &= ~(SHADE_ALLOWED_ACTION | STICK_ALLOWED_ACTION | MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION | FULLSCREEN_ALLOWED_ACTION);
	if(state & FULLSCREEN_STATE) /*---------------------------------------------------------------------------------*/ allowedAction &= ~(MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION | SHADE_ALLOWED_ACTION | STICK_ALLOWED_ACTION);
	if(state & ABOVE_STATE) /*--------------------------------------------------------------------------------------*/ allowedAction &= ~(NONE_ALLOWED_ACTION);
	if(state & BELOW_STATE) /*--------------------------------------------------------------------------------------*/ allowedAction &= ~(NONE_ALLOWED_ACTION);
	if(allowedAction == (*client).allowedAction){
		ret false;
	}
	if(!allowedAction){
		free((*client).allowedActionStart);
		popPointer((*client).allowedActionSize);
		(*client).allowedAction = NONE_ALLOWED_ACTION;
		(*client).allowedActionStart = NULL;
		(*client).allowedActionSize = 0;
		ret true;
	}
	allowedActionSize = !!(allowedAction & MOVE_ALLOWED_ACTION) + !!(allowedAction & RESIZE_ALLOWED_ACTION) + !!(allowedAction & MINIMIZE_ALLOWED_ACTION) + !!(allowedAction & SHADE_ALLOWED_ACTION) + !!(allowedAction & STICK_ALLOWED_ACTION) + !!(allowedAction & MAXIMIZE_HORZ_ALLOWED_ACTION) + !!(allowedAction & MAXIMIZE_VERT_ALLOWED_ACTION) + !!(allowedAction & FULLSCREEN_ALLOWED_ACTION) + !!(allowedAction & CHANGE_DESKTOP_ALLOWED_ACTION) + !!(allowedAction & CLOSE_ALLOWED_ACTION);
	temp = malloc(allowedActionSize * sizeof(xcb_atom_t));
	token = pushPointer(temp, "client _NET_WM_ALLOWED_ACTIONS pointer", iFree);
	if(!temp){
		printTitledError("memory allocation error", "could not allocate memory for client allowed actions");
		ret false;
	}
	current = (xcb_atom_t *)temp - 1;
	if(allowedAction & MOVE_ALLOWED_ACTION) /*-----------*/ *(inc current) = atom._NET_WM_ACTION_MOVE;
	if(allowedAction & RESIZE_ALLOWED_ACTION) /*---------*/ *(inc current) = atom._NET_WM_ACTION_RESIZE;
	if(allowedAction & MINIMIZE_ALLOWED_ACTION) /*-------*/ *(inc current) = atom._NET_WM_ACTION_MINIMIZE;
	if(allowedAction & SHADE_ALLOWED_ACTION) /*----------*/ *(inc current) = atom._NET_WM_ACTION_SHADE;
	if(allowedAction & STICK_ALLOWED_ACTION) /*----------*/ *(inc current) = atom._NET_WM_ACTION_STICK;
	if(allowedAction & MAXIMIZE_HORZ_ALLOWED_ACTION) /*--*/ *(inc current) = atom._NET_WM_ACTION_MAXIMIZE_HORZ;
	if(allowedAction & MAXIMIZE_VERT_ALLOWED_ACTION) /*--*/ *(inc current) = atom._NET_WM_ACTION_MAXIMIZE_VERT;
	if(allowedAction & FULLSCREEN_ALLOWED_ACTION) /*-----*/ *(inc current) = atom._NET_WM_ACTION_FULLSCREEN;
	if(allowedAction & CHANGE_DESKTOP_ALLOWED_ACTION) /*-*/ *(inc current) = atom._NET_WM_ACTION_CHANGE_DESKTOP;
	if(allowedAction & CLOSE_ALLOWED_ACTION) /*----------*/ *(inc current) = atom._NET_WM_ACTION_CLOSE;
	free((*client).allowedActionStart);
	popPointer((*client).allowedActionToken);
	(*client).allowedAction = allowedAction;
	(*client).allowedActionSize = allowedActionSize;
	(*client).allowedActionStart = temp;
	(*client).allowedActionToken = token;
	ret true;
}
CHANGECLIENTALLOWEDACTIONS(){
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	if(!(*client).allowedAction){
		xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, atom._NET_WM_ALLOWED_ACTIONS));
	}else{
		xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_WM_ALLOWED_ACTIONS, XCB_ATOM_ATOM, bitsof(xcb_atom_t), (*client).allowedActionSize, (*client).allowedActionStart));
	}
	ret true;
}
SETCLIENTORDERTYPE(){
	uint option;
	uint windowType;
	uint state;
	uint8 orderType;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	option = (*client).option;
	windowType = (*client).windowType;
	state = (*client).state;
	if(option & OVERRIDE_REDIRECT_CLIENT_OPTION){
		orderType = NONE_ORDER_TYPE;
	}elif(windowType & DESKTOP_WINDOW_TYPE){
		orderType = DESKTOP_ORDER_TYPE;
	}elif(state & BELOW_STATE){
		orderType = BELOW_ORDER_TYPE;
	}elif(windowType & DOCK_WINDOW_TYPE){
		orderType = DOCK_ORDER_TYPE;
	}elif(state & ABOVE_STATE){
		orderType = ABOVE_ORDER_TYPE;
	}elif(state & FULLSCREEN_STATE){
		orderType = FULLSCREEN_ORDER_TYPE;
	}else{
		orderType = NORMAL_ORDER_TYPE;
	}
	if(orderType == (*client).orderType){
		ret false;
	}
	(*client).orderType = orderType;
	ret true;
}
MOVERESIZECLIENT(){
	int windowWidth;
	int windowHeight;
	int containerWidth;
	int containerHeight;
	int candidateContainerX;
	int candidateContainerY;
	int candidateContainerWidth;
	int candidateContainerHeight;
	int candidateWindowX;
	int candidateWindowY;
	int candidateWindowWidth;
	int candidateWindowHeight;
	bool configure;
	if(!clientSystem or !isValidClient(clientSystem, client) or (*client).option & (OVERRIDE_REDIRECT_CLIENT_OPTION | TEMPORARILY_UNMAPPED_CLIENT_OPTION) or windowGravity > CENTER_POINT_WINDOW_GRAVITY){
		ret false;
	}
	if(treatAsNormal){
		if(width == (int)((*client).containerWidth + 2 * (*client).containerBorder) and height == (int)((*client).containerHeight + 2 * (*client).containerBorder)){
			if(!((*client).allowedAction & MOVE_ALLOWED_ACTION)){
				ret false;
			}
		}else{
			if(!((*client).allowedAction & RESIZE_ALLOWED_ACTION)){
				ret false;
			}
		}
	}
	candidateContainerX = (*client).containerX;
	candidateContainerY = (*client).containerY;
	candidateContainerWidth = (*client).containerWidth;
	candidateContainerHeight = (*client).containerHeight;
	candidateWindowX = (*client).windowX;
	candidateWindowY = (*client).windowY;
	candidateWindowWidth = (*client).windowWidth;
	candidateWindowHeight = (*client).windowHeight;
	windowWidth = width - 2 * (*client).windowBorder - (*client).frameExtentsLeft - (*client).frameExtentsRight - 2 * (*client).containerBorder;
	windowHeight = height - 2 * (*client).windowBorder - (*client).frameExtentsTop - (*client).frameExtentsBottom - 2 * (*client).containerBorder;
	if(repositionAfterwards){
		if(windowWidth < 1){
			windowWidth = 1;
		}
		if(windowHeight < 1){
			windowHeight = 1;
		}
		containerWidth = windowWidth + 2 * (*client).windowBorder + (*client).frameExtentsLeft + (*client).frameExtentsRight;
		containerHeight = windowHeight + 2 * (*client).windowBorder + (*client).frameExtentsTop + (*client).frameExtentsBottom;
		candidateContainerX = x;
		candidateContainerY = y;
		candidateContainerWidth = containerWidth;
		candidateContainerHeight = containerHeight;
		candidateWindowX = 0;
		candidateWindowY = 0;
		candidateWindowWidth = windowWidth;
		candidateWindowHeight = windowHeight;
	}
	if(useMinimumHints and (*client).normalHintsFlags & PROGRAM_MINIMUM_SIZE_NORMAL_HINT){
		if(windowWidth < (*client).normalHintsMinWidth){
			if(windowGravity and windowGravity != NORTH_SIDE_WINDOW_GRAVITY and windowGravity != SOUTH_SIDE_WINDOW_GRAVITY){
				windowWidth = (*client).normalHintsMinWidth;
			}
		}
		if(windowHeight < (*client).normalHintsMinHeight){
			if(windowGravity and windowGravity != WEST_SIDE_WINDOW_GRAVITY and windowGravity != EAST_SIDE_WINDOW_GRAVITY){
				windowHeight = (*client).normalHintsMinHeight;
			}
		}
	}
	if(useMaximumHints and (*client).normalHintsFlags & PROGRAM_MAXIMUM_SIZE_NORMAL_HINT){
		if(windowWidth > (*client).normalHintsMaxWidth){
			if(windowGravity and windowGravity != NORTH_SIDE_WINDOW_GRAVITY and windowGravity != SOUTH_SIDE_WINDOW_GRAVITY){
				windowWidth = (*client).normalHintsMaxWidth;
			}
		}
		if(windowHeight > (*client).normalHintsMaxHeight){
			if(windowGravity and windowGravity != WEST_SIDE_WINDOW_GRAVITY and windowGravity != EAST_SIDE_WINDOW_GRAVITY){
				windowHeight = (*client).normalHintsMaxHeight;
			}
		}
	}
	if(windowWidth < 1){
		windowWidth = 1;
	}
	if(windowHeight < 1){
		windowHeight = 1;
	}
	containerWidth = windowWidth + 2 * (*client).windowBorder + (*client).frameExtentsLeft + (*client).frameExtentsRight;
	containerHeight = windowHeight + 2 * (*client).windowBorder + (*client).frameExtentsTop + (*client).frameExtentsBottom;
	if(containerWidth != candidateContainerWidth or containerHeight != candidateContainerWidth){
		const int offsetX = candidateContainerWidth - containerWidth;
		const int offsetY = candidateContainerHeight - containerHeight;
		switch windowGravity over
			to NONE_WINDOW_GRAVITY: /*-------------*/ /*-------------*/ /*-------------*/ brk;
			to NORTH_POINT_WINDOW_GRAVITY: /*------*/ x += offsetX / 2; /*-------------*/ brk;
			to NORTH_SIDE_WINDOW_GRAVITY: /*-------*/ /*-------------*/ /*-------------*/ brk;
			to SOUTH_POINT_WINDOW_GRAVITY: /*------*/ x += offsetX / 2; y += offsetY / 1; brk;
			to SOUTH_SIDE_WINDOW_GRAVITY: /*-------*/ /*-------------*/ y += offsetY / 1; brk;
			to WEST_POINT_WINDOW_GRAVITY: /*-------*/ /*-------------*/ y += offsetY / 2; brk;
			to WEST_SIDE_WINDOW_GRAVITY: /*--------*/ /*-------------*/ /*-------------*/ brk;
			to EAST_POINT_WINDOW_GRAVITY: /*-------*/ x += offsetX / 1; y += offsetY / 2; brk;
			to EAST_SIDE_WINDOW_GRAVITY: /*--------*/ x += offsetX / 1; /*-------------*/ brk;
			to NORTH_WEST_POINT_WINDOW_GRAVITY: /*-*/ /*-------------*/ /*-------------*/ brk;
			to NORTH_EAST_POINT_WINDOW_GRAVITY: /*-*/ x += offsetX / 1; /*-------------*/ brk;
			to SOUTH_WEST_POINT_WINDOW_GRAVITY: /*-*/ /*-------------*/ y += offsetY / 1; brk;
			to SOUTH_EAST_POINT_WINDOW_GRAVITY: /*-*/ x += offsetX / 1; y += offsetY / 1; brk;
			to CENTER_POINT_WINDOW_GRAVITY: /*-----*/ x += offsetX / 2; y += offsetY / 2; brk;
			off: /*--------------------------------*/ /*-------------*/ /*-------------*/ brk;
		end
	}
	configure = windowWidth != (int)(*client).windowWidth or windowHeight != (int)(*client).windowHeight;
	(*client).containerX = x;
	(*client).containerY = y;
	(*client).containerWidth = containerWidth;
	(*client).containerHeight = containerHeight;
	(*client).windowX = 0;
	(*client).windowY = 0;
	(*client).windowWidth = windowWidth;
	(*client).windowHeight = windowHeight;
	if(!configure and !force){
		sendClientConfigureEvent(clientSystem, client);
	}else{
		xcb_discard_reply(connection, xcb_configure_window_checked(connection, (*client).window, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &(*client).windowX));
		if(force){
			xcb_configure_window(connection, (*client).container, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &(*client).containerX);
		}
	}
	(*client).option &= ~(HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
	(*client).workareaPosition = NONE_WORKAREA_POSITION;
	ret true;
}
SENDCLIENTCONFIGUREEVENT(){
	xcb_configure_notify_event_t message;
	Client *siblingClient;
	if(!clientSystem or !isValidClient(clientSystem, client) or (*client).option & (OVERRIDE_REDIRECT_CLIENT_OPTION | TEMPORARILY_UNMAPPED_CLIENT_OPTION)){
		ret false;
	}
	message.response_type = XCB_CONFIGURE_NOTIFY;
	message.event = (*client).window;
	message.window = (*client).window;
	message.above_sibling = XCB_NONE;
	if((siblingClient = findBelowClient(clientSystem, client))){
		message.above_sibling = (*siblingClient).window;
	}
	message.x = (*client).containerX + (*client).containerBorder + (*client).frameExtentsLeft;
	message.y = (*client).containerY + (*client).containerBorder + (*client).frameExtentsTop;
	message.width = (*client).windowWidth;
	message.height = (*client).windowHeight;
	message.border_width = (*client).windowBorder;
	message.override_redirect = false;
	xcb_discard_reply(connection, xcb_send_event_checked(connection, false, message.window, XCB_EVENT_MASK_STRUCTURE_NOTIFY, &message));
	ret true;
}
RESTACKCLIENT(){
	uint *start;
	uint *current;
	uint *wall;
	uint *top;
	uint *bottom;
	int copy0X;
	int copy0Y;
	uint copy0Width;
	uint copy0Height;
	int copy1X;
	int copy1Y;
	uint copy1Width;
	uint copy1Height;
	uint copy;
	Client *clientStart;
	if(!clientSystem or !(*clientSystem).orderedClientOffsetStart){
		ret false;
	}
	start = (*clientSystem).orderedClientOffsetStart;
	wall = start + (*clientSystem).orderedClientOffsetAllocated;
	clientStart = (*clientSystem).clientStart;
	switch stackMode over
		to XCB_STACK_MODE_ABOVE: /*-----*/ jmp stackModeAbove;
		to XCB_STACK_MODE_BELOW: /*-----*/ jmp stackModeBelow;
		to XCB_STACK_MODE_TOP_IF: /*----*/ jmp stackModeTopIf;
		to XCB_STACK_MODE_BOTTOM_IF: /*-*/ jmp stackModeBottomIf;
		to XCB_STACK_MODE_OPPOSITE: /*--*/ jmp stackModeOpposite;
		off: /*-------------------------*/ ret false;
	end
	stackModeAbove:{
		uint *siblingClient = wall - 1;
		if(!(current = findOrderedClientOffset(clientSystem, client))){
			ret false;
		}
		copy = *current;
		if(sibling and !(siblingClient = findOrderedClientOffset(clientSystem, findClientWindow(clientSystem, sibling)))){
			jmp correctPosition;
		}
		if(current == siblingClient or current == siblingClient + 1){
			jmp correctPosition;
		}
		if(current < siblingClient){
			top = siblingClient;
			jmp moveUpLoop;
		}
		bottom = siblingClient + 1;
		jmp moveDownLoop;
	}
	stackModeBelow:{
		uint *siblingClient = start;
		if(!(current = findOrderedClientOffset(clientSystem, client))){
			ret false;
		}
		copy = *current;
		if(sibling and !(siblingClient = findOrderedClientOffset(clientSystem, findClientWindow(clientSystem, sibling)))){
			jmp correctPosition;
		}
		if(current == siblingClient or current == siblingClient - 1){
			jmp correctPosition;
		}
		if(current < siblingClient){
			top = siblingClient - 1;
			jmp moveUpLoop;
		}
		bottom = siblingClient;
		jmp moveDownLoop;
	}
	stackModeTopIf:{
		uint *siblingCurrent;
		uint *siblingWall = wall;
		Client *c;
		if(!(current = findOrderedClientOffset(clientSystem, client))){
			ret false;
		}
		copy = *current;
		if(current == wall - 1){
			jmp correctPosition;
		}
		siblingCurrent = current + 1;
		if(sibling){
			if(!(siblingCurrent = findOrderedClientOffset(clientSystem, findClientWindow(clientSystem, sibling))) or siblingCurrent <= current){
				jmp correctPosition;
			}
			siblingWall = siblingCurrent + 1;
		}
		c = clientStart + *current;
		if((*c).container){
			const uint border = 2 * (*c).containerBorder;
			copy0X = (*c).containerX;
			copy0Y = (*c).containerY;
			copy0Width = (*c).containerWidth + border;
			copy0Height = (*c).containerHeight + border;
		}else{
			const uint border = 2 * (*c).windowBorder;
			copy0X = (*c).windowX;
			copy0Y = (*c).windowY;
			copy0Width = (*c).windowWidth + border;
			copy0Height = (*c).windowHeight + border;
		}
		jmp topIfLoop;
		topIfLoop:{
			if(siblingCurrent < siblingWall){
				c = clientStart + *siblingCurrent;
				if((*c).container){
					const uint border = 2 * (*c).containerBorder;
					copy1X = (*c).containerX;
					copy1Y = (*c).containerY;
					copy1Width = (*c).containerWidth + border;
					copy1Height = (*c).containerHeight + border;
				}else{
					const uint border = 2 * (*c).windowBorder;
					copy1X = (*c).windowX;
					copy1Y = (*c).windowY;
					copy1Width = (*c).windowWidth + border;
					copy1Height = (*c).windowHeight + border;
				}
				if(intersects(copy0X, copy0Y, copy0Width, copy0Height, copy1X, copy1Y, copy1Width, copy1Height)){
					top = siblingCurrent;
					jmp moveUpLoop;
				}
				inc siblingCurrent;
				jmp topIfLoop;
			}
			jmp correctPosition;
		}
	}
	stackModeBottomIf:{
		uint *siblingStart = start - 1;
		uint *siblingCurrent;
		Client *c;
		if(!(current = findOrderedClientOffset(clientSystem, client))){
			ret false;
		}
		copy = *current;
		if(current == start){
			jmp correctPosition;
		}
		siblingCurrent = current - 1;
		if(sibling){
			if(!(siblingCurrent = findOrderedClientOffset(clientSystem, findClientWindow(clientSystem, sibling))) or siblingCurrent >= current){
				jmp correctPosition;
			}
			siblingStart = siblingCurrent - 1;
		}
		c = clientStart + *current;
		if((*c).container){
			const uint border = 2 * (*c).containerBorder;
			copy0X = (*c).containerX;
			copy0Y = (*c).containerY;
			copy0Width = (*c).containerWidth + border;
			copy0Height = (*c).containerHeight + border;
		}else{
			const uint border = 2 * (*c).windowBorder;
			copy0X = (*c).windowX;
			copy0Y = (*c).windowY;
			copy0Width = (*c).windowWidth + border;
			copy0Height = (*c).windowHeight + border;
		}
		jmp bottomIfLoop;
		bottomIfLoop:{
			if(siblingCurrent > siblingStart){
				c = clientStart + *siblingCurrent;
				if((*c).container){
					const uint border = 2 * (*c).containerBorder;
					copy1X = (*c).containerX;
					copy1Y = (*c).containerY;
					copy1Width = (*c).containerWidth + border;
					copy1Height = (*c).containerHeight + border;
				}else{
					const uint border = 2 * (*c).windowBorder;
					copy1X = (*c).windowX;
					copy1Y = (*c).windowY;
					copy1Width = (*c).windowWidth + border;
					copy1Height = (*c).windowHeight + border;
				}
				if(intersects(copy0X, copy0Y, copy0Width, copy0Height, copy1X, copy1Y, copy1Width, copy1Height)){
					top = siblingCurrent;
					jmp moveUpLoop;
				}
				dec siblingCurrent;
				jmp bottomIfLoop;
			}
			jmp correctPosition;
		}
	}
	stackModeOpposite:{
		uint *siblingStart = start - 1;
		uint *siblingCurrent;
		uint *siblingWall = wall;
		Client *c;
		if(!(current = findOrderedClientOffset(clientSystem, client))){
			ret false;
		}
		copy = *current;
		if(sibling){
			if(!(siblingCurrent = findOrderedClientOffset(clientSystem, findClientWindow(clientSystem, sibling))) or siblingCurrent == current){
				jmp correctPosition;
			}
			siblingStart = siblingCurrent - 1;
			siblingWall = siblingCurrent + 1;
		}
		c = clientStart + *current;
		if((*c).container){
			const uint border = 2 * (*c).containerBorder;
			copy0X = (*c).containerX;
			copy0Y = (*c).containerY;
			copy0Width = (*c).containerWidth + border;
			copy0Height = (*c).containerHeight + border;
		}else{
			const uint border = 2 * (*c).windowBorder;
			copy0X = (*c).windowX;
			copy0Y = (*c).windowY;
			copy0Width = (*c).windowWidth + border;
			copy0Height = (*c).windowHeight + border;
		}
		siblingCurrent = current + 1;
		jmp stackModeOppositeUpLoop;
		stackModeOppositeUpLoop:{
			if(siblingCurrent < siblingWall){
				c = clientStart + *siblingCurrent;
				if((*c).container){
					const uint border = 2 * (*c).containerBorder;
					copy1X = (*c).containerX;
					copy1Y = (*c).containerY;
					copy1Width = (*c).containerWidth + border;
					copy1Height = (*c).containerHeight + border;
				}else{
					const uint border = 2 * (*c).windowBorder;
					copy1X = (*c).windowX;
					copy1Y = (*c).windowY;
					copy1Width = (*c).windowWidth + border;
					copy1Height = (*c).windowHeight + border;
				}
				if(intersects(copy0X, copy0Y, copy0Width, copy0Height, copy1X, copy1Y, copy1Width, copy1Height)){
					top = wall - 1;
					jmp moveUpLoop;
				}
				inc siblingCurrent;
				jmp stackModeOppositeUpLoop;
			}
			siblingCurrent = current - 1;
			jmp stackModeOppositeDownLoop;
		}
		stackModeOppositeDownLoop:{
			if(siblingCurrent > siblingStart){
				c = clientStart + *siblingCurrent;
				if((*c).container){
					const uint border = 2 * (*c).containerBorder;
					copy1X = (*c).containerX;
					copy1Y = (*c).containerY;
					copy1Width = (*c).containerWidth + border;
					copy1Height = (*c).containerHeight + border;
				}else{
					const uint border = 2 * (*c).windowBorder;
					copy1X = (*c).windowX;
					copy1Y = (*c).windowY;
					copy1Width = (*c).windowWidth + border;
					copy1Height = (*c).windowHeight + border;
				}
				if(intersects(copy0X, copy0Y, copy0Width, copy0Height, copy1X, copy1Y, copy1Width, copy1Height)){
					bottom = start;
					jmp moveDownLoop;
				}
				dec siblingCurrent;
				jmp stackModeOppositeDownLoop;
			}
			jmp correctPosition;
		}
	}
	moveUpLoop:{
		if(current < top and (*(clientStart + copy)).orderType <= (*(clientStart + *(current + 1))).orderType){
			if(true){
				*current = *(current + 1);
				inc current;
				jmp moveUpLoop;
			}
		}
		jmp correctPosition;
	}
	moveDownLoop:{
		if(current > bottom and (*(clientStart + copy)).orderType >= (*(clientStart + *(current - 1))).orderType){
			if(true){
				*current = *(current - 1);
				dec current;
				jmp moveDownLoop;
			}
		}
		jmp correctPosition;
	}
	correctPosition:{
		uint *top = wall - 1;
		uint *bottom = start;
		jmp correctPositionDownLoop;
		correctPositionDownLoop:{
			if(current > bottom and (*(clientStart + copy)).orderType > (*(clientStart + *(current - 1))).orderType){
				if(true){
					*current = *(current - 1);
					dec current;
					jmp correctPositionDownLoop;
				}
			}
			jmp correctPositionUpLoop;
		}
		correctPositionUpLoop:{
			if(current < top and (*(clientStart + copy)).orderType < (*(clientStart + *(current + 1))).orderType){
				if(true){
					*current = *(current + 1);
					inc current;
					jmp correctPositionUpLoop;
				}
			}
			if(*current == copy){
				ret false;
			}
			*current = copy;
			ret true;
		}
	}
}
CONFIGURECLIENT(){
	Client *siblingClient;
	uint8 stackMode;
	uint32 valueMask;
	uint32 valueList[2];
	if(!clientSystem or !isValidClient(clientSystem, client) or ((*client).desktop != NONE_DESKTOP and (*client).desktop != 0xFFFFFFFF and !((*client).state & FULLSCREEN_STATE))){
		ret false;
	}
	if((siblingClient = findBelowDesktopClient(clientSystem, client))){
		stackMode = XCB_STACK_MODE_ABOVE;
		valueMask = XCB_CONFIG_WINDOW_SIBLING | XCB_CONFIG_WINDOW_STACK_MODE;
		*(valueList + 0) = (*siblingClient).container;
		*(valueList + 1) = stackMode;
	}elif((siblingClient = findAboveDesktopClient(clientSystem, client))){
		stackMode = XCB_STACK_MODE_BELOW;
		valueMask = XCB_CONFIG_WINDOW_SIBLING | XCB_CONFIG_WINDOW_STACK_MODE;
		*(valueList + 0) = (*siblingClient).container;
		*(valueList + 1) = stackMode;
	}else{
		stackMode = XCB_STACK_MODE_ABOVE;
		valueMask = XCB_CONFIG_WINDOW_STACK_MODE;
		*(valueList + 0) = stackMode;
	}
	xcb_configure_window(connection, (*client).container, valueMask, valueList);
	ret true;
}
ASSIGNCLIENTSTRUT(){
	Monitor *monitor;
	int x;
	int y;
	int width;
	int height;
	if(!clientSystem or !monitorSystem or !(*monitorSystem).size or !isValidClient(clientSystem, client)){
		ret false;
	}
	if((*client).strutTop){
		x = (*client).strutTopStartX;
		y = 0;
		width = (*client).strutTopEndX - (*client).strutTopStartX;
		height = (*client).strutTop;
		(*client).strut = TOP_STRUT;
	}elif((*client).strutBottom){
		x = (*client).strutBottomStartX;
		y = screenHeightInPixels - (*client).strutBottom;
		width = (*client).strutBottomEndX - (*client).strutBottomStartX;
		height = (*client).strutBottom;
		(*client).strut = BOTTOM_STRUT;
	}elif((*client).strutLeft){
		x = 0;
		y = (*client).strutLeftStartY;
		width = (*client).strutLeft;
		height = (*client).strutLeftEndY - (*client).strutLeftStartY;
		(*client).strut = LEFT_STRUT;
	}elif((*client).strutRight){
		x = screenWidthInPixels - (*client).strutRight;
		y = (*client).strutRightStartY;
		width = (*client).strutRight;
		height = (*client).strutRightEndY - (*client).strutRightStartY;
		(*client).strut = RIGHT_STRUT;
	}else{
		(*client).strut = NONE_STRUT;
		ret false;
	}
	if(width < 0 or height < 0){
		(*client).strut = NONE_STRUT;
		ret false;
	}
	if(x + width >= (int)screenWidthInPixels){
		x = (int)screenWidthInPixels - width;
	}
	if(y + height >= (int)screenHeightInPixels){
		y = (int)screenHeightInPixels - height;
	}
	x *= (x > 0);
	y *= (y > 0);
	if(!(monitor = findRectangleMonitor(monitorSystem, x, y, width, height))){
		ret false;
	}
	getIntersection((*monitor).leftX, (*monitor).topY, (*monitor).width, (*monitor).height, x, y, width, height, &x, &y, &width, &height);
	if(width < 1){
		width = 1;
	}
	if(height < 1){
		height = 1;
	}
	(*client).strutX = x;
	(*client).strutY = y;
	(*client).strutWidth = width;
	(*client).strutHeight = height;
	ret true;
}
GETFOCUSEDCLIENT(){
	if(!clientSystem or !(*clientSystem).focusedClientOffset){
		ret NULL;
	}
	ret (*clientSystem).clientStart + (*clientSystem).focusedClientOffset;
}
SETFOCUSEDCLIENT(){
	if(!clientSystem or !isValidClient(clientSystem, client) or client == getFocusedClient(clientSystem) or (*client).stateState != NORMAL_STATE){
		ret false;
	}
	if(!(*client).hintsInput and !((*client).protocol & TAKE_FOCUS_CLIENT_PROTOCOL) and !((*client).windowType & (TOOLBAR_WINDOW_TYPE | UTILITY_WINDOW_TYPE | DIALOG_WINDOW_TYPE | NORMAL_WINDOW_TYPE))){
		ret false;
	}
	if(findModalTransientForClient(clientSystem, client)){
		ret false;
	}
	if((*client).desktop != NONE_DESKTOP and (*client).desktop != 0xFFFFFFFF and (*client).desktop != currentDesktop){
		if(!(*client).hintsInput and !((*client).windowType & (TOOLBAR_WINDOW_TYPE | UTILITY_WINDOW_TYPE | DIALOG_WINDOW_TYPE | NORMAL_WINDOW_TYPE))){
			ret false;
		}
		if(updateClientState(clientSystem, client, _NET_WM_STATE_ADD, DEMANDS_ATTENTION_STATE)){
			changeClientState(clientSystem, client);
		}
		ret true;
	}
	if((*client).protocol & TAKE_FOCUS_CLIENT_PROTOCOL and !(*client).hintsInput){
		offerClientFocus(clientSystem, client);
		ret true;
	}
	xcb_discard_reply(connection, xcb_set_input_focus_checked(connection, XCB_INPUT_FOCUS_POINTER_ROOT, (*client).window, getTimestamp()));
	ret true;
}
OFFERCLIENTFOCUS(){
	xcb_client_message_event_t message;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	message.response_type = XCB_CLIENT_MESSAGE;
	message.format = 32;
	message.window = (*client).window;
	message.type = atom.WM_PROTOCOLS;
	*(message.data.data32 + 0) = atom.WM_TAKE_FOCUS;
	*(message.data.data32 + 1) = getTimestamp();
	*(message.data.data32 + 2) = 0;
	*(message.data.data32 + 3) = 0;
	*(message.data.data32 + 4) = 0;
	xcb_discard_reply(connection, xcb_send_event_checked(connection, false, message.window, XCB_NONE, &message));
	ret true;
}
FOCUSCLIENT(){
	if(!clientSystem or !isValidClient(clientSystem, client) or client == getFocusedClient(clientSystem) or (*client).stateState != NORMAL_STATE or (*client).option & TEMPORARILY_UNMAPPED_CLIENT_OPTION){
		ret false;
	}
	if(focusOnClick){
		Client *const oldFocusedClient = getFocusedClient(clientSystem);
		if(oldFocusedClient){



/*!
			if((*oldFocusedClient).container){
				const uint32 valueList = CONTAINER_EVENT_MASK;
				xcb_change_window_attributes(connection, (*oldFocusedClient).container, XCB_CW_EVENT_MASK, &valueList);
			}
			{
				const uint32 valueList = WINDOW_EVENT_MASK;
				xcb_discard_reply(connection, xcb_change_window_attributes_checked(connection, (*oldFocusedClient).window, XCB_CW_EVENT_MASK, &valueList));
			}
*/



			if((*oldFocusedClient).container){
				xcb_grab_button(connection, true, (*oldFocusedClient).container, XCB_EVENT_MASK_BUTTON_PRESS, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, XCB_BUTTON_INDEX_1, XCB_NONE);
			}
			xcb_discard_reply(connection, xcb_grab_button_checked(connection, true, (*oldFocusedClient).window, XCB_EVENT_MASK_BUTTON_PRESS, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, XCB_BUTTON_INDEX_1, XCB_NONE));



		}



/*!
		if((*client).container){
			const uint32 valueList = CONTAINER_EVENT_MASK | XCB_EVENT_MASK_BUTTON_PRESS;
			xcb_change_window_attributes(connection, (*client).container, XCB_CW_EVENT_MASK, &valueList);
		}
		{
			const uint32 valueList = WINDOW_EVENT_MASK | XCB_EVENT_MASK_BUTTON_PRESS;
			xcb_discard_reply(connection, xcb_change_window_attributes_checked(connection, (*client).window, XCB_CW_EVENT_MASK, &valueList));
		}
*/



		if((*client).container){
			xcb_ungrab_button(connection, XCB_BUTTON_INDEX_1, (*client).container, XCB_NONE);
		}
		xcb_discard_reply(connection, xcb_ungrab_button_checked(connection, XCB_BUTTON_INDEX_1, (*client).window, XCB_NONE));



	}
	(*clientSystem).focusedClientOffset = client - (*clientSystem).clientStart;
	(*client).hintsUrgency = false;
	if(updateClientState(clientSystem, client, _NET_WM_STATE_REMOVE, DEMANDS_ATTENTION_STATE)){
		changeClientState(clientSystem, client);
	}
	ret true;
}
CHANGEACTIVEWINDOW(){
	Client *client;
	xcb_window_t activeWindow;
	if(!clientSystem){
		ret false;
	}
	activeWindow = XCB_NONE;
	if((client = getFocusedClient(clientSystem))){
		activeWindow = (*client).window;
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_ACTIVE_WINDOW, XCB_ATOM_WINDOW, bitsof(xcb_window_t), 1, &activeWindow);
	ret true;
}
SETMOTIONCLIENT(){
	struct{
		uint32 /*-*/ stackMode;
	} valueList;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	if(!intersects(x, y, 1, 1, (*client).containerX, (*client).containerY, (*client).containerWidth + 2 * (*client).containerBorder, (*client).containerHeight + 2 * (*client).containerBorder)){
		ret false;
	}
	valueList.stackMode = XCB_STACK_MODE_ABOVE;
	xcb_configure_window(connection, glassWindow, XCB_CONFIG_WINDOW_STACK_MODE, &valueList);
	xcb_map_window(connection, glassWindow);
	(*clientSystem).motionAction = motionAction;
	(*clientSystem).motionGravity = motionGravity;
	(*clientSystem).motionStartingX = x;
	(*clientSystem).motionStartingY = y;
	(*clientSystem).motionX = (*client).containerX;
	(*clientSystem).motionY = (*client).containerY;
	(*clientSystem).motionWidth = (*client).containerWidth + 2 * (*client).containerBorder;
	(*clientSystem).motionHeight = (*client).containerHeight + 2 * (*client).containerBorder;
	(*clientSystem).motionClientOffset = client - (*clientSystem).clientStart;
	ret true;
}
UNSETMOTIONCLIENT(){
	if(!clientSystem or !(*clientSystem).motionAction){
		ret false;
	}
	xcb_unmap_window(connection, glassWindow);
	(*clientSystem).motionAction = NONE_MOTION_ACTION;
	(*clientSystem).motionClientOffset = 0;
	ret true;
}
CLOSECLIENT(){
	#define KILL_SUCCESS /*-*/ (0)
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	switch command over
		to NONE_CLOSE_CLIENT_COMMAND:{
			ret false;
		}
		to CLOSE_CLOSE_CLIENT_COMMAND:{
			xcb_client_message_event_t message;
			uint32 *const data = message.data.data32;
			if(!((*client).protocol & DELETE_WINDOW_CLIENT_PROTOCOL) or !((*client).allowedAction & CLOSE_ALLOWED_ACTION)){
				ret false;
			}
			message.response_type = XCB_CLIENT_MESSAGE;
			message.format = 32;
			message.window = (*client).window;
			message.type = atom.WM_PROTOCOLS;
			*(data + 0) = atom.WM_DELETE_WINDOW;
			*(data + 1) = getTimestamp();
			*(data + 2) = 0;
			*(data + 3) = 0;
			*(data + 4) = 0;
			xcb_discard_reply(connection, xcb_send_event_checked(connection, false, message.window, XCB_NONE, &message));
			ret true;
		}
		to KILL_CLOSE_CLIENT_COMMAND:{
			if(!(*client).pid or kill((*client).pid, SIGTERM) != KILL_SUCCESS){
				xcb_discard_reply(connection, xcb_kill_client_checked(connection, (*client).window));
			}
			ret true;
		}
		off:{
			ret false;
		}
	end
	#undef  KILL_SUCCESS
}
LOSEFOCUS(){
	if(!clientSystem or !getFocusedClient(clientSystem)){
		ret false;
	}
	unfocusClient(clientSystem);
	xcb_set_input_focus(connection, XCB_INPUT_FOCUS_POINTER_ROOT, defaultFocusWindow, getTimestamp());
	ret true;
}
UNFOCUSCLIENT(){
	Client *focusedClient;
	if(!clientSystem){
		ret false;
	}
	focusedClient = getFocusedClient(clientSystem);
	if(!focusedClient){
		ret false;
	}
	if(focusOnClick){
		if(focusedClient){



/*!
			if((*focusedClient).container){
				const uint32 valueList = CONTAINER_EVENT_MASK;
				xcb_change_window_attributes(connection, (*focusedClient).container, XCB_CW_EVENT_MASK, &valueList);
			}
			{
				const uint32 valueList = WINDOW_EVENT_MASK;
				xcb_discard_reply(connection, xcb_change_window_attributes_checked(connection, (*focusedClient).window, XCB_CW_EVENT_MASK, &valueList));
			}
*/



			xcb_grab_button(connection, true, (*focusedClient).container, XCB_EVENT_MASK_BUTTON_PRESS, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, XCB_BUTTON_INDEX_1, XCB_NONE);
			xcb_discard_reply(connection, xcb_grab_button_checked(connection, true, (*focusedClient).window, XCB_EVENT_MASK_BUTTON_PRESS, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, XCB_BUTTON_INDEX_1, XCB_NONE));



		}
	}
	(*clientSystem).focusedClientOffset = 0;
	ret true;
}
UNMAPCLIENT(){
	if(!clientSystem or !isValidClient(clientSystem, client) or (state != WITHDRAWN_STATE and state != ICONIC_STATE) or (*client).stateState == state){
		ret false;
	}
	if((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION){
		(*client).stateState = WITHDRAWN_STATE;
	}else{
		xcb_unmap_window(connection, (*client).container);
		xcb_discard_reply(connection, xcb_unmap_window_checked(connection, (*client).window));
		if(state == WITHDRAWN_STATE){
			xcb_discard_reply(connection, xcb_reparent_window_checked(connection, (*client).window, (*screen).root, 0, 0));
			if(updateClientState(clientSystem, client, _NET_WM_STATE_REMOVE, ~NONE_STATE)){
				changeClientState(clientSystem, client);
			}
		}else{
			if(updateClientState(clientSystem, client, _NET_WM_STATE_ADD, HIDDEN_STATE)){
				changeClientState(clientSystem, client);
			}
		}
		(*client).stateState = state;
		xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom.WM_STATE, atom.WM_STATE, bitsof(uint32), 2, &(*client).stateState));
		(*client).option &= ~TEMPORARILY_UNMAPPED_CLIENT_OPTION;
	}
	unsetMotionClient(clientSystem);
	if(client == getFocusedClient(clientSystem)){
		loseFocus(clientSystem);
	}
	ret true;
}
DESTROYCLIENT(){
	uint *current;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	unmapClient(clientSystem, client, WITHDRAWN_STATE);
	if((current = findOrderedClientOffset(clientSystem, client))){
		shiftMemory(current + 1, ((*clientSystem).orderedClientOffsetStart + (*clientSystem).orderedClientOffsetAllocated - current - 1) * sizeof(uint), -(int)sizeof(uint));
		dec (*clientSystem).orderedClientOffsetAllocated;
	}
	free((*client).iconStart);
	popPointer((*client).iconToken);
	free((*client).allowedActionStart);
	popPointer((*client).allowedActionToken);
	free((*client).stateStart);
	popPointer((*client).stateToken);
	free((*client).windowTypeStart);
	popPointer((*client).windowTypeToken);
	free((*client).visibleIconNameStart);
	popPointer((*client).visibleIconNameToken);
	free((*client).visibleNameStart);
	popPointer((*client).visibleNameToken);
	free((*client).windowRoleStart);
	popPointer((*client).windowRoleToken);
	free((*client).clientIDStart);
	popPointer((*client).clientIDToken);
	free((*client).clientMachineStart);
	popPointer((*client).clientMachineToken);
	free((*client).colormapWindowStart);
	popPointer((*client).colormapWindowToken);
	free((*client).protocolStart);
	popPointer((*client).protocolToken);
	free((*client).classStart);
	popPointer((*client).classToken);
	free((*client).iconNameStart);
	popPointer((*client).iconNameToken);
	free((*client).nameStart);
	popPointer((*client).nameToken);
	if((*client).gc){
		xcb_free_gc(connection, (*client).gc);
	}
	if((*client).pixmap){
		xcb_free_pixmap(connection, (*client).pixmap);
	}
	if((*client).container){
		xcb_destroy_window(connection, (*client).container);
	}
	(*client).inUse = false;
	if(client == (*clientSystem).clientStart + (*clientSystem).clientAllocated - 1){
		if(dec (*clientSystem).clientAllocated < (*clientSystem).clientNotInUseOffset){
			dec (*clientSystem).clientNotInUseOffset;
		}
	}elif(client - (*clientSystem).clientStart < (*clientSystem).clientNotInUseOffset){
		(*clientSystem).clientNotInUseOffset = client - (*clientSystem).clientStart;
	}
	ret true;
}
ISVALIDCLIENT(){
	ret clientSystem and (*clientSystem).clientAllocated > 1 and client and client > (*clientSystem).clientStart and client < (*clientSystem).clientStart + (*clientSystem).clientAllocated and (*client).inUse;
}
FINDCLIENTWINDOW(){
	Client *current;
	Client *wall;
	if(!clientSystem or !(*clientSystem).clientAllocated or !window){
		ret NULL;
	}
	current = (*clientSystem).clientStart;
	wall = current + (*clientSystem).clientAllocated;
	jmp findClientWindowLoop;
	findClientWindowLoop:{
		if(current < wall){
			if((*current).window == window){
				if(!(*current).inUse){
					ret NULL;
				}
				ret current;
			}
			inc current;
			jmp findClientWindowLoop;
		}
		ret NULL;
	}
}
FINDCLIENTCONTAINER(){
	Client *current;
	Client *wall;
	if(!clientSystem or !(*clientSystem).clientAllocated or !window){
		ret NULL;
	}
	current = (*clientSystem).clientStart;
	wall = current + (*clientSystem).clientAllocated;
	jmp findClientContainerLoop;
	findClientContainerLoop:{
		if(current < wall){
			if((*current).container == window){
				if(!(*current).inUse){
					ret NULL;
				}
				ret current;
			}
			inc current;
			jmp findClientContainerLoop;
		}
		ret NULL;
	}
}
FINDCONFIGUREDCLIENTWINDOW(){
	Client *current;
	Client *wall;
	if(!clientSystem or !(*clientSystem).clientAllocated or !window){
		ret NULL;
	}
	if((*clientSystem).recentlyConfiguredClientOffset){
		current = (*clientSystem).clientStart + (*clientSystem).recentlyConfiguredClientOffset;
		if(isValidClient(clientSystem, current) and (*current).window == window){
			ret current;
		}
		(*clientSystem).recentlyConfiguredClientOffset = 0;
	}
	current = (*clientSystem).clientStart;
	wall = current + (*clientSystem).clientAllocated;
	jmp findConfiguredClientWindowLoop;
	findConfiguredClientWindowLoop:{
		if(current < wall){
			if((*current).window == window){
				if(!(*current).inUse){
					ret NULL;
				}
				(*clientSystem).recentlyConfiguredClientOffset = current - (*clientSystem).clientStart;
				ret current;
			}
			inc current;
			jmp findConfiguredClientWindowLoop;
		}
		ret NULL;
	}
}
FINDORDEREDCLIENTOFFSET(){
	uint *current;
	uint *wall;
	Client *clientStart;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret NULL;
	}
	current = (*clientSystem).orderedClientOffsetStart;
	wall = current + (*clientSystem).orderedClientOffsetAllocated;
	clientStart = (*clientSystem).clientStart;
	jmp findOrderedClientOffsetLoop;
	findOrderedClientOffsetLoop:{
		if(current < wall){
			if(clientStart + *current == client){
				ret current;
			}
			inc current;
			jmp findOrderedClientOffsetLoop;
		}
		ret NULL;
	}
}
FINDBELOWCLIENT(){
	uint *clientOffset;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret NULL;
	}
	if(!(clientOffset = findOrderedClientOffset(clientSystem, client)) or clientOffset == (*clientSystem).orderedClientOffsetStart){
		ret NULL;
	}
	ret (*clientSystem).clientStart + *(clientOffset - 1);
}
FINDABOVEDESKTOPCLIENT(){
	uint *current;
	uint *wall;
	Client *clientStart;
	bool flag;
	if(!clientSystem or !(*clientSystem).orderedClientOffsetAllocated or !isValidClient(clientSystem, client) or (*client).desktop == NONE_DESKTOP){
		ret NULL;
	}
	current = (*clientSystem).orderedClientOffsetStart;
	wall = current + (*clientSystem).orderedClientOffsetAllocated;
	clientStart = (*clientSystem).clientStart;
	flag = false;
	jmp findAboveDesktopClientLoop;
	findAboveDesktopClientLoop:{
		if(current < wall){
			Client *const c = clientStart + *current;
			if(flag and (*c).desktop == (*client).desktop){
				ret c;
			}
			if(c == client){
				flag = true;
			}
			inc current;
			jmp findAboveDesktopClientLoop;
		}
		ret NULL;
	}
}
FINDBELOWDESKTOPCLIENT(){
	uint *start;
	uint *current;
	Client *clientStart;
	bool flag;
	if(!(*clientSystem).orderedClientOffsetAllocated or !isValidClient(clientSystem, client) or (*client).desktop == NONE_DESKTOP){
		ret NULL;
	}
	start = (*clientSystem).orderedClientOffsetStart;
	current = start + (*clientSystem).orderedClientOffsetAllocated - 1;
	clientStart = (*clientSystem).clientStart;
	flag = false;
	jmp findBelowDesktopClientLoop;
	findBelowDesktopClientLoop:{
		if(current >= start){
			Client *const c = clientStart + *current;
			if(flag and (*c).desktop == (*client).desktop){
				ret c;
			}
			if(c == client){
				flag = true;
			}
			dec current;
			jmp findBelowDesktopClientLoop;
		}
		ret NULL;
	}
}
FINDMODALTRANSIENTFORCLIENT(){
	Client *current;
	Client *wall;
	xcb_window_t window;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret NULL;
	}
	current = (*clientSystem).clientStart;
	wall = current + (*clientSystem).clientAllocated;
	window = (*client).window;
	jmp findModalTransientForClientLoop;
	findModalTransientForClientLoop:{
		if(current < wall){
			if((*current).transientFor == window and (*current).state & MODAL_STATE){
				if(!(*current).inUse){
					ret NULL;
				}
				ret current;
			}
			inc current;
			jmp findModalTransientForClientLoop;
		}
		ret NULL;
	}
}
FINDBELOWMANAGEDCLIENT(){
	uint *start;
	uint *current;
	Client *clientStart;
	bool flag;
	if(!clientSystem or !(*clientSystem).orderedClientOffsetAllocated or !isValidClient(clientSystem, client) or (*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION){
		ret NULL;
	}
	start = (*clientSystem).orderedClientOffsetStart;
	current = start + (*clientSystem).orderedClientOffsetAllocated - 1;
	clientStart = (*clientSystem).clientStart;
	flag = false;
	jmp findBelowManagedClientLoop;
	findBelowManagedClientLoop:{
		if(current >= start){
			Client *const c = clientStart + *current;
			if(flag and !((*c).option & OVERRIDE_REDIRECT_CLIENT_OPTION)){
				ret c;
			}
			if(c == client){
				flag = true;
			}
			dec current;
			jmp findBelowManagedClientLoop;
		}
		ret NULL;
	}
}
FINICLIENTSYSTEM(){
	if(!clientSystem){
		ret false;
	}
	if((*clientSystem).clientAllocated){
		Client *current = (*clientSystem).clientStart;
		Client *const wall = current + (*clientSystem).clientAllocated;
		jmp destroyClientLoop;
		destroyClientLoop:{
			if(current < wall){
				if((*current).inUse){
					xcb_discard_reply(connection, xcb_reparent_window_checked(connection, (*current).window, (*screen).root, 0, 0));
					free((*current).iconStart);
					popPointer((*current).iconToken);
					(*current).iconSize = 0;
					(*current).iconStart = NULL;
					(*current).iconToken = 0;
					free((*current).allowedActionStart);
					popPointer((*current).allowedActionToken);
					(*current).allowedActionSize = 0;
					(*current).allowedActionStart = NULL;
					(*current).allowedActionToken = 0;
					free((*current).stateStart);
					popPointer((*current).stateToken);
					(*current).stateSize = 0;
					(*current).stateStart = NULL;
					(*current).stateToken = 0;
					free((*current).windowTypeStart);
					popPointer((*current).windowTypeToken);
					(*current).windowTypeSize = 0;
					(*current).windowTypeStart = NULL;
					(*current).windowTypeToken = 0;
					free((*current).visibleIconNameStart);
					popPointer((*current).visibleIconNameToken);
					(*current).visibleIconNameSize = 0;
					(*current).visibleIconNameStart = NULL;
					(*current).visibleIconNameToken = 0;
					free((*current).visibleNameStart);
					popPointer((*current).visibleNameToken);
					(*current).visibleNameSize = 0;
					(*current).visibleNameStart = NULL;
					(*current).visibleNameToken = 0;
					free((*current).windowRoleStart);
					popPointer((*current).windowRoleToken);
					(*current).windowRoleSize = 0;
					(*current).windowRoleStart = NULL;
					(*current).windowRoleToken = 0;
					free((*current).clientIDStart);
					popPointer((*current).clientIDToken);
					(*current).clientIDSize = 0;
					(*current).clientIDStart = NULL;
					(*current).clientIDToken = 0;
					free((*current).clientMachineStart);
					popPointer((*current).clientMachineToken);
					(*current).clientMachineSize = 0;
					(*current).clientMachineStart = NULL;
					(*current).clientMachineToken = 0;
					free((*current).colormapWindowStart);
					popPointer((*current).colormapWindowToken);
					(*current).colormapWindowSize = 0;
					(*current).colormapWindowStart = NULL;
					(*current).colormapWindowToken = 0;
					free((*current).protocolStart);
					popPointer((*current).protocolToken);
					(*current).protocolSize = 0;
					(*current).protocolStart = NULL;
					(*current).protocolToken = 0;
					free((*current).classStart);
					popPointer((*current).classToken);
					(*current).classSize = 0;
					(*current).classStart = NULL;
					(*current).classToken = 0;
					free((*current).iconNameStart);
					popPointer((*current).iconNameToken);
					(*current).iconNameSize = 0;
					(*current).iconNameStart = NULL;
					(*current).iconNameToken = 0;
					free((*current).nameStart);
					popPointer((*current).nameToken);
					(*current).nameSize = 0;
					(*current).nameStart = NULL;
					(*current).nameToken = 0;
					if((*current).gc){
						xcb_free_gc(connection, (*current).gc);
						(*current).gc = XCB_NONE;
					}
					if((*current).pixmap){
						xcb_free_pixmap(connection, (*current).pixmap);
						(*current).pixmap = XCB_NONE;
					}
					if((*current).container){
						xcb_destroy_window(connection, (*current).container);
						(*current).container = XCB_NONE;
					}
				}
				inc current;
				jmp destroyClientLoop;
			}
		}
	}
	(*clientSystem).motionAction = NONE_MOTION_ACTION;
	(*clientSystem).recentlyConfiguredClientOffset = 0;
	(*clientSystem).motionClientOffset = 0;
	(*clientSystem).focusedClientOffset = 0;
	free((*clientSystem).orderedClientOffsetStart);
	popPointer((*clientSystem).orderedClientOffsetToken);
	(*clientSystem).orderedClientOffsetSize = 0;
	(*clientSystem).orderedClientOffsetAllocated = 0;
	(*clientSystem).orderedClientOffsetStart = NULL;
	(*clientSystem).orderedClientOffsetToken = 0;
	free((*clientSystem).clientStart);
	popPointer((*clientSystem).clientToken);
	(*clientSystem).clientSize = 0;
	(*clientSystem).clientAllocated = 0;
	(*clientSystem).clientNotInUseOffset = 0;
	(*clientSystem).clientStart = NULL;
	(*clientSystem).clientToken = 0;
	ret true;
}
INITVIRTUALROOTSYSTEM(){
	if(!virtualRootSystem){
		ret false;
	}
	(*virtualRootSystem).virtualRootSize = 0;
	(*virtualRootSystem).virtualRootAllocated = 0;
	(*virtualRootSystem).virtualRootStart = NULL;
	(*virtualRootSystem).virtualRootToken = 0;
	(*virtualRootSystem).workareaEdgeOffsetSize = 0;
	(*virtualRootSystem).workareaEdgeOffsetStart = NULL;
	(*virtualRootSystem).workareaEdgeOffsetToken = 0;
	(*virtualRootSystem).windowSize = 0;
	(*virtualRootSystem).windowStart = NULL;
	(*virtualRootSystem).windowToken = 0;
	(*virtualRootSystem).viewportSize = 0;
	(*virtualRootSystem).viewportStart = NULL;
	(*virtualRootSystem).viewportToken = 0;
	(*virtualRootSystem).desktopNamesSize = 0;
	(*virtualRootSystem).desktopNamesStart = NULL;
	(*virtualRootSystem).desktopNamesToken = 0;
	(*virtualRootSystem).workareaSize = 0;
	(*virtualRootSystem).workareaStart = NULL;
	(*virtualRootSystem).workareaToken = 0;
	(*virtualRootSystem).width = 1;
	(*virtualRootSystem).height = 1;
	(*virtualRootSystem).currentDesktop = NONE_DESKTOP;
	(*virtualRootSystem).showingDesktop = false;
	(*virtualRootSystem).desktopLayoutColumns = 0;
	(*virtualRootSystem).desktopLayoutRows = 0;
	(*virtualRootSystem).desktopLayoutOrientation = _NET_WM_ORIENTATION_HORZ;
	(*virtualRootSystem).desktopLayoutStartingCorner = _NET_WM_TOPLEFT;
	(*virtualRootSystem).mapped = false;
	ret true;
}
SETVIRTUALROOTAMOUNT(){
	int addedSize;
	if(!virtualRootSystem or !monitorSystem or !(*monitorSystem).size or !clientSystem or !size){
		ret false;
	}
	addedSize = (int)size - (int)(*virtualRootSystem).virtualRootAllocated;
	if(!addedSize){
		ret false;
	}
	if((*virtualRootSystem).virtualRootAllocated + addedSize >= (*virtualRootSystem).virtualRootSize){
		void *temp;
		(*virtualRootSystem).virtualRootSize += addedSize;
		temp = realloc((*virtualRootSystem).virtualRootStart, (*virtualRootSystem).virtualRootSize * sizeof(VirtualRoot));
		if(!(*virtualRootSystem).virtualRootToken){
			(*virtualRootSystem).virtualRootToken = pushPointer(temp, "virtual root pointer", iFree);
		}else{
			updatePointer((*virtualRootSystem).virtualRootToken, temp);
		}
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for virtual roots");
			(*virtualRootSystem).virtualRootSize -= addedSize;
			ret false;
		}
		(*virtualRootSystem).virtualRootStart = temp;
	}
	if((*virtualRootSystem).virtualRootAllocated + addedSize >= (*virtualRootSystem).windowSize){
		void *temp;
		(*virtualRootSystem).windowSize += addedSize;
		temp = realloc((*virtualRootSystem).windowStart, (*virtualRootSystem).windowSize * sizeof(xcb_window_t));
		if(!(*virtualRootSystem).windowToken){
			(*virtualRootSystem).windowToken = pushPointer(temp, "virtual root window pointer", iFree);
		}else{
			updatePointer((*virtualRootSystem).windowToken, temp);
		}
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for virtual root windows");
			(*virtualRootSystem).windowSize -= addedSize;
			ret false;
		}
		(*virtualRootSystem).windowStart = temp;
	}
	if((*virtualRootSystem).virtualRootAllocated + addedSize >= (*virtualRootSystem).viewportSize){
		void *temp;
		(*virtualRootSystem).viewportSize += addedSize;
		temp = realloc((*virtualRootSystem).viewportStart, (*virtualRootSystem).viewportSize * sizeof(Viewport));
		if(!(*virtualRootSystem).viewportToken){
			(*virtualRootSystem).viewportToken = pushPointer(temp, "virtual root viewport pointer", iFree);
		}else{
			updatePointer((*virtualRootSystem).viewportToken, temp);
		}
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for virtual root viewports");
			(*virtualRootSystem).viewportSize -= addedSize;
			ret false;
		}
		(*virtualRootSystem).viewportStart = temp;
	}
	if((*virtualRootSystem).virtualRootAllocated + addedSize >= (*virtualRootSystem).workareaSize){
		void *temp;
		(*virtualRootSystem).workareaSize += addedSize;
		temp = realloc((*virtualRootSystem).workareaStart, (*virtualRootSystem).workareaSize * sizeof(Workarea));
		if(!(*virtualRootSystem).workareaToken){
			(*virtualRootSystem).workareaToken = pushPointer(temp, "virtual root workarea pointer", iFree);
		}else{
			updatePointer((*virtualRootSystem).workareaToken, temp);
		}
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for virtual root workareas");
			(*virtualRootSystem).workareaSize -= addedSize;
			ret false;
		}
		(*virtualRootSystem).workareaStart = temp;
	}
	(*virtualRootSystem).virtualRootAllocated += addedSize;
	if(addedSize > 0){
		VirtualRoot *current = (*virtualRootSystem).virtualRootStart + (*virtualRootSystem).virtualRootAllocated - addedSize;
		VirtualRoot *const wall = (*virtualRootSystem).virtualRootStart + (*virtualRootSystem).virtualRootAllocated;
		xcb_window_t *windowCurrent = (*virtualRootSystem).windowStart + (*virtualRootSystem).virtualRootAllocated - addedSize;
		Viewport *viewportCurrent = (*virtualRootSystem).viewportStart + (*virtualRootSystem).virtualRootAllocated - addedSize;
		uint32 valueMask = XCB_CW_BACK_PIXEL | XCB_CW_BORDER_PIXEL | XCB_CW_EVENT_MASK | XCB_CW_COLORMAP;
		struct{
			uint32 /*---------*/ backgroundColor;
			uint32 /*---------*/ borderColor;
			uint32 /*---------*/ eventMask;
			xcb_colormap_t /*-*/ colormap;
			xcb_cursor_t /*---*/ cursor;
		} valueList;
		struct{
			uint32 /*---------*/ stackMode;
		} windowValueList;
		struct{
			uint32 /*---------*/ generateExpose;
		} gcValueList;
		valueList.backgroundColor = 0x00000000;
		valueList.borderColor = 0x00000000;
		valueList.eventMask = XCB_EVENT_MASK_NO_EVENT;
		valueList.colormap = (*screen).default_colormap;
		if(cursorSystem and (*cursorSystem).cursor){
			valueMask |= XCB_CW_CURSOR;
			valueList.cursor = (*cursorSystem).cursor;
		}
		windowValueList.stackMode = XCB_STACK_MODE_BELOW;
		gcValueList.generateExpose = false;
		jmp createVirtualRootLoop;
		createVirtualRootLoop:{
			if(current < wall){
				(*current).window = xcb_generate_id(connection);
				(*current).pixmap = xcb_generate_id(connection);
				(*current).gc = xcb_generate_id(connection);
				(*current).orderedClientOffsetSize = 0;
				(*current).orderedClientOffsetAllocated = 0;
				(*current).orderedClientOffsetStart = NULL;
				(*current).orderedClientOffsetToken = 0;
				(*current).nameSize = 0;
				(*current).nameStart = NULL;
				(*current).nameToken = 0;
				(*current).workareaEdgeOffsetSize = (*monitorSystem).size;
				(*current).workareaEdgeOffsetStart = malloc((*current).workareaEdgeOffsetSize * sizeof(EdgeOffset));
				(*current).workareaEdgeOffsetToken = pushPointer((*current).workareaEdgeOffsetStart, "virtual root monitor workarea pointer", iFree);
				if(!(*current).workareaEdgeOffsetStart){
					printTitledError("memory allocation error", "could not allocate memory for virtual root monitor workareas");
					(*current).workareaEdgeOffsetSize = 0;
				}else{
					EdgeOffset *edgeOffsetCurrent = (*current).workareaEdgeOffsetStart;
					EdgeOffset *const edgeOffsetWall = edgeOffsetCurrent + (*current).workareaEdgeOffsetSize;
					jmp setEdgeOffsetLoop;
					setEdgeOffsetLoop:{
						if(edgeOffsetCurrent < edgeOffsetWall){
							(*edgeOffsetCurrent).top = 0;
							(*edgeOffsetCurrent).bottom = 0;
							(*edgeOffsetCurrent).left = 0;
							(*edgeOffsetCurrent).right = 0;
							inc edgeOffsetCurrent;
							jmp setEdgeOffsetLoop;
						}
					}
				}
				*windowCurrent = (*current).window;
				(*viewportCurrent).x = 0;
				(*viewportCurrent).y = 0;
				xcb_create_window(connection, (*screen).root_depth, (*current).window, (*screen).root, 0, 0, (*virtualRootSystem).width, (*virtualRootSystem).height, 0, XCB_WINDOW_CLASS_INPUT_OUTPUT, (*screen).root_visual, valueMask, &valueList);
				xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_STACK_MODE, &windowValueList);
				xcb_create_pixmap(connection, (*screen).root_depth, (*current).pixmap, (*screen).root, (*virtualRootSystem).width, (*virtualRootSystem).height);
				xcb_create_gc(connection, (*current).gc, (*current).pixmap, XCB_GC_GRAPHICS_EXPOSURES, &gcValueList);
				xcb_change_window_attributes(connection, (*current).window, XCB_CW_BACK_PIXMAP, &(*current).pixmap);
				fillDrawable((*current).pixmap, (*current).gc, 0, 0, (*virtualRootSystem).width, (*virtualRootSystem).height, 0x00000000);
				inc windowCurrent;
				inc viewportCurrent;
				inc current;
				jmp createVirtualRootLoop;
			}
			if(!(*virtualRootSystem).mapped){
				jmp emergencyExit;
			}
			current = (*virtualRootSystem).virtualRootStart + (*virtualRootSystem).virtualRootAllocated - addedSize;
			jmp mapVirtualRootLoop;
		}
		mapVirtualRootLoop:{
			if(current < wall){
				xcb_map_window(connection, (*current).window);
				inc current;
				jmp mapVirtualRootLoop;
			}
			jmp emergencyExit;
		}
	}
	if(addedSize < 0){
		const uint lastVirtualRoot = (*virtualRootSystem).virtualRootAllocated - 1;
		VirtualRoot *current = (*virtualRootSystem).virtualRootStart + (*virtualRootSystem).virtualRootAllocated;
		VirtualRoot *const wall = current - addedSize;
		if((*virtualRootSystem).currentDesktop != NONE_DESKTOP and (*virtualRootSystem).currentDesktop >= (*virtualRootSystem).virtualRootAllocated){
			gotoVirtualRoot(virtualRootSystem, clientSystem, lastVirtualRoot, true);
		}
		jmp destroyVirtualRootLoop;
		destroyVirtualRootLoop:{
			if(current < wall){
				if((*current).orderedClientOffsetStart){
					uint *clientCurrent = (*current).orderedClientOffsetStart;
					uint *const clientWall = clientCurrent + (*current).orderedClientOffsetAllocated;
					Client *const clientStart = (*clientSystem).clientStart;
					jmp changeClientVirtualRootLoop;
					changeClientVirtualRootLoop:{
						if(clientCurrent < clientWall){
							moveClientToVirtualRoot(virtualRootSystem, monitorSystem, clientSystem, clientStart + *clientCurrent, lastVirtualRoot, true);
							inc clientCurrent;
							jmp changeClientVirtualRootLoop;
						}
					}
				}
				destroyVirtualRoot(virtualRootSystem, current);
				inc current;
				jmp destroyVirtualRootLoop;
			}
			jmp emergencyExit;
		}
	}
	emergencyExit:{
		if((*virtualRootSystem).currentDesktop == NONE_DESKTOP){
			gotoVirtualRoot(virtualRootSystem, clientSystem, 0, true);
		}
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_NUMBER_OF_DESKTOPS, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &(*virtualRootSystem).virtualRootAllocated);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_DESKTOP_GEOMETRY, XCB_ATOM_CARDINAL, bitsof(uint32), 2, &(*virtualRootSystem).width);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_DESKTOP_VIEWPORT, XCB_ATOM_CARDINAL, bitsof(int32), (*virtualRootSystem).virtualRootAllocated * 2, (*virtualRootSystem).viewportStart);
		if(setVirtualRootNames(virtualRootSystem)){
			xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_DESKTOP_NAMES, atom.UTF8_STRING, bitsof(uint8), (*virtualRootSystem).desktopNamesSize, (*virtualRootSystem).desktopNamesStart);
		}
		if(setVirtualRootWorkarea(virtualRootSystem, monitorSystem)){
			changeVirtualRootWorkarea(virtualRootSystem);
		}
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_VIRTUAL_ROOTS, XCB_ATOM_WINDOW, bitsof(xcb_window_t), (*virtualRootSystem).virtualRootAllocated, (*virtualRootSystem).windowStart);
		ret true;
	}
}
SETVIRTUALROOTWORKAREA(){
	int virtualRootWidth;
	int virtualRootHeight;
	VirtualRoot *current;
	VirtualRoot *wall;
	int outerOffsetTop;
	int outerOffsetBottom;
	int outerOffsetLeft;
	int outerOffsetRight;
	Workarea *workareaCurrent;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size){
		ret false;
	}
	virtualRootWidth = (*virtualRootSystem).width;
	virtualRootHeight = (*virtualRootSystem).height;
	jmp calculateOuterOffsets;
	calculateOuterOffsets:{
		outerOffsetTop = 0;
		outerOffsetBottom = 0;
		outerOffsetLeft = 0;
		outerOffsetRight = 0;
		if((*virtualRootSystem).workareaEdgeOffsetStart){
			const EdgeOffset *edgeCurrent = (*virtualRootSystem).workareaEdgeOffsetStart;
			const EdgeOffset *const edgeWall = edgeCurrent + (*virtualRootSystem).workareaEdgeOffsetSize;
			Monitor *monitorCurrent = (*monitorSystem).start;
			jmp calculateOuterOffsetsLoop;
			calculateOuterOffsetsLoop:{
				if(edgeCurrent < edgeWall){
					if(!(*monitorCurrent).leftX) /*-----------------------*/ outerOffsetLeft += (*edgeCurrent).left;
					if((*monitorCurrent).rightX == virtualRootWidth) /*---*/ outerOffsetRight += (*edgeCurrent).right;
					if(!(*monitorCurrent).topY) /*------------------------*/ outerOffsetTop += (*edgeCurrent).top;
					if((*monitorCurrent).bottomY == virtualRootHeight) /*-*/ outerOffsetBottom += (*edgeCurrent).bottom;
					inc monitorCurrent;
					inc edgeCurrent;
					jmp calculateOuterOffsetsLoop;
				}
			}
		}
		current = (*virtualRootSystem).virtualRootStart;
		wall = current + (*virtualRootSystem).virtualRootAllocated;
		workareaCurrent = (*virtualRootSystem).workareaStart;
		jmp setVirtualRootWorkareaLoop;
	}
	setVirtualRootWorkareaLoop:{
		if(current < wall){
			int innerOffsetTop = 0;
			int innerOffsetBottom = 0;
			int innerOffsetLeft = 0;
			int innerOffsetRight = 0;
			int width;
			int height;
			if((*current).workareaEdgeOffsetStart){
				const EdgeOffset *edgeCurrent = (*current).workareaEdgeOffsetStart;
				const EdgeOffset *const edgeWall = edgeCurrent + (*current).workareaEdgeOffsetSize;
				Monitor *monitorCurrent = (*monitorSystem).start;
				jmp calculateInnerOffsetsLoop;
				calculateInnerOffsetsLoop:{
					if(edgeCurrent < edgeWall){
						if(!(*monitorCurrent).leftX) /*-----------------------*/ innerOffsetLeft += (*edgeCurrent).left;
						if((*monitorCurrent).rightX == virtualRootWidth) /*---*/ innerOffsetRight += (*edgeCurrent).right;
						if(!(*monitorCurrent).topY) /*------------------------*/ innerOffsetTop += (*edgeCurrent).top;
						if((*monitorCurrent).bottomY == virtualRootHeight) /*-*/ innerOffsetBottom += (*edgeCurrent).bottom;
						inc monitorCurrent;
						inc edgeCurrent;
						jmp calculateInnerOffsetsLoop;
					}
				}
			}
			width = virtualRootWidth - outerOffsetLeft - innerOffsetLeft - outerOffsetRight - innerOffsetRight;
			height = virtualRootHeight - outerOffsetTop - innerOffsetTop - outerOffsetBottom - innerOffsetBottom;
			if(width < 0){
				width = 0;
			}
			if(height < 0){
				height = 0;
			}
			(*workareaCurrent).x = outerOffsetLeft + innerOffsetLeft;
			(*workareaCurrent).y = outerOffsetTop + innerOffsetTop;
			(*workareaCurrent).width = width;
			(*workareaCurrent).height = height;
			inc workareaCurrent;
			inc current;
			jmp setVirtualRootWorkareaLoop;
		}
		ret true;
	}
}
CHANGEVIRTUALROOTWORKAREA(){
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated){
		ret false;
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_WORKAREA, XCB_ATOM_CARDINAL, bitsof(uint32), (*virtualRootSystem).virtualRootAllocated * 4, (*virtualRootSystem).workareaStart);
	ret true;
}
SETVIRTUALROOTNAMES(){
	VirtualRoot *start;
	VirtualRoot *current;
	VirtualRoot *wall;
	uint8 *desktopNamesCurrent;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated){
		ret false;
	}
	start = (*virtualRootSystem).virtualRootStart;
	current = start;
	wall = current + (*virtualRootSystem).virtualRootAllocated;
	(*virtualRootSystem).desktopNamesSize = 0;
	desktopNamesCurrent = (*virtualRootSystem).desktopNamesStart;
	jmp appendDesktopNameLoop;
	appendDesktopNameLoop:{
		if(current < wall){
			if(!(*current).nameStart){
				const uint32 which = current - start;
				setVirtualRootNumberName(virtualRootSystem, which, which + 1);
			}
			if((*current).nameStart){
				const uint offset = desktopNamesCurrent - (*virtualRootSystem).desktopNamesStart;
				uint size = (*virtualRootSystem).desktopNamesSize + (*current).nameSize;
				void *const temp = realloc((*virtualRootSystem).desktopNamesStart, size * sizeof(uint8));
				if(!(*virtualRootSystem).desktopNamesToken){
					(*virtualRootSystem).desktopNamesToken = pushPointer(temp, "virtual root desktop name pointer", iFree);
				}else{
					updatePointer((*virtualRootSystem).desktopNamesToken, temp);
				}
				if(!temp){
					printTitledError("memory allocation error", "could not allocate memory for virtual root desktop names");
					ret false;
				}
				(*virtualRootSystem).desktopNamesStart = temp;
				(*virtualRootSystem).desktopNamesSize = size;
				desktopNamesCurrent = (*virtualRootSystem).desktopNamesStart + offset;
				copyMemory((*current).nameStart, desktopNamesCurrent, (*current).nameSize);
				desktopNamesCurrent += (*current).nameSize;
			}
			inc current;
			jmp appendDesktopNameLoop;
		}
		ret true;
	}
}
SETVIRTUALROOTNAME(){
	void *nameStart;
	uint32 nameToken;
	VirtualRoot *virtualRoot;
	if(!virtualRootSystem or which >= (*virtualRootSystem).virtualRootAllocated){
		ret false;
	}
	nameStart = malloc((length + 1) * sizeof(uint8));
	nameToken = pushPointer(nameStart, "virtual root name pointer", iFree);
	if(!nameStart){
		printTitledError("memory allocation error", "could not allocate memory for virtual root desktop name");
		ret false;
	}
	copyMemory(name, nameStart, length * sizeof(uint8));
	*((uint8 *)nameStart + length) = '\0';
	virtualRoot = (*virtualRootSystem).virtualRootStart + which;
	free((*virtualRoot).nameStart);
	popPointer((*virtualRoot).nameToken);
	(*virtualRoot).nameSize = length + 1;
	(*virtualRoot).nameStart = nameStart;
	(*virtualRoot).nameToken = nameToken;
	ret true;
}
SETVIRTUALROOTNUMBERNAME(){
	uint length;
	void *nameStart;
	uint32 nameToken;
	if(!virtualRootSystem or which >= (*virtualRootSystem).virtualRootAllocated){
		ret false;
	}
	jmp getNumberLength;
	getNumberLength:{
		uint n = number;
		length = 0;
		jmp getNumberLengthLoop;
		getNumberLengthLoop:{
			if(n){
				n /= 10;
				inc length;
				jmp getNumberLengthLoop;
			}
		}
		if(!length){
			length = 1;
		}
		jmp allocateName;
	}
	allocateName:{
		nameStart = malloc((length + 1) * sizeof(uint8));
		nameToken = pushPointer(nameStart, "virtual root name pointer", iFree);
		if(!nameStart){
			printTitledError("memory allocation error", "could not allocate memory for virtual root desktop number name");
			ret false;
		}
		jmp storeNumber;
	}
	storeNumber:{
		uint8 *nameCurrent = (uint8 *)nameStart + length;
		*nameCurrent = '\0';
		dec nameCurrent;
		jmp storeNumberLoop;
		storeNumberLoop:{
			if(number){
				*nameCurrent = number % 10 + 48;
				dec nameCurrent;
				number /= 10;
				jmp storeNumberLoop;
			}
			jmp storeName;
		}
	}
	storeName:{
		VirtualRoot *const virtualRoot = (*virtualRootSystem).virtualRootStart + which;
		free((*virtualRoot).nameStart);
		popPointer((*virtualRoot).nameToken);
		(*virtualRoot).nameSize = length + 1;
		(*virtualRoot).nameStart = nameStart;
		(*virtualRoot).nameToken = nameToken;
		ret true;
	}
}
GOTOVIRTUALROOT(){
	if(!virtualRootSystem or !clientSystem or which >= (*virtualRootSystem).virtualRootAllocated or which == NONE_DESKTOP or which == (*virtualRootSystem).currentDesktop){
		ret false;
	}
	if(loseClientFocus){
		loseFocus(clientSystem);
	}
	if((*virtualRootSystem).currentDesktop == NONE_DESKTOP){
		(*virtualRootSystem).currentDesktop = 0;
	}
	configureFullscreenVirtualRootClients(virtualRootSystem, clientSystem, which);
	if((*virtualRootSystem).virtualRootAllocated > 1 and which != (*virtualRootSystem).currentDesktop){
		struct{
			xcb_window_t /*-*/ sibling;
			uint32 /*-------*/ stackMode;
		} valueList;
		valueList.sibling = (*((*virtualRootSystem).virtualRootStart + (*virtualRootSystem).currentDesktop)).window;
		valueList.stackMode = XCB_STACK_MODE_ABOVE;
		xcb_configure_window(connection, (*((*virtualRootSystem).virtualRootStart + which)).window, XCB_CONFIG_WINDOW_SIBLING | XCB_CONFIG_WINDOW_STACK_MODE, &valueList);
	}
	showVirtualRootDesktop(virtualRootSystem, clientSystem, (*virtualRootSystem).currentDesktop, false);
	(*virtualRootSystem).currentDesktop = which;
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_CURRENT_DESKTOP, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &(*virtualRootSystem).currentDesktop);
	ret true;
}
CONFIGUREFULLSCREENVIRTUALROOTCLIENTS(){
	uint *start;
	uint *current;
	uint *wall;
	Client *clientStart;
	struct{
		xcb_window_t /*-*/ sibling;
		uint32 /*-------*/ stackMode;
	} valueList;
	if(!virtualRootSystem or (*virtualRootSystem).currentDesktop == NONE_DESKTOP or !clientSystem or !(*clientSystem).orderedClientOffsetStart or which >= (*virtualRootSystem).virtualRootAllocated or which == NONE_DESKTOP){
		ret false;
	}
	start = (*clientSystem).orderedClientOffsetStart;
	wall = start + (*clientSystem).orderedClientOffsetAllocated;
	current = wall - 1;
	clientStart = (*clientSystem).clientStart;
	valueList.sibling = (*((*virtualRootSystem).virtualRootStart + (*virtualRootSystem).currentDesktop)).window;
	valueList.stackMode = XCB_STACK_MODE_ABOVE;
	jmp findTopOwnedWindowLoop;
	findTopOwnedWindowLoop:{
		if(current >= start){
			Client *const client = clientStart + *current;
			if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION) and ((*client).desktop == 0xFFFFFFFF or ((*client).state & FULLSCREEN_STATE and (*client).desktop == (*virtualRootSystem).currentDesktop))){
				valueList.sibling = (*client).container;
			}else{
				dec current;
				jmp findTopOwnedWindowLoop;
			}
		}
		current = wall - 1;
		jmp configureFullscreenClientAboveLoop;
	}
	configureFullscreenClientAboveLoop:{
		if(current >= start){
			Client *const client = clientStart + *current;
			if((*client).state & FULLSCREEN_STATE and (*client).desktop == which){
				xcb_window_t window = (*client).container;
				if(!window){
					window = (*client).window;
				}
				xcb_discard_reply(connection, xcb_configure_window_checked(connection, window, XCB_CONFIG_WINDOW_SIBLING | XCB_CONFIG_WINDOW_STACK_MODE, &valueList));
			}
			dec current;
			jmp configureFullscreenClientAboveLoop;
		}
		current = start;
		jmp configureFullscreenClientBelowLoop;
	}
	configureFullscreenClientBelowLoop:{
		if(current < wall){
			Client *const client = clientStart + *current;
			if((*client).state & FULLSCREEN_STATE and (*client).desktop == (*virtualRootSystem).currentDesktop){
				xcb_window_t window = (*client).container;
				struct{
					uint32 /*-*/ stackMode;
				} valueList;
				if(!window){
					window = (*client).window;
				}
				valueList.stackMode = XCB_STACK_MODE_BELOW;
				xcb_discard_reply(connection, xcb_configure_window_checked(connection, window, XCB_CONFIG_WINDOW_STACK_MODE, &valueList));
			}
			inc current;
			jmp configureFullscreenClientBelowLoop;
		}
		ret true;
	}
}
RESIZEVIRTUALROOT(){
	VirtualRoot *current;
	VirtualRoot *wall;
	struct{
		uint32 /*-*/ width;
		uint32 /*-*/ height;
	} windowValueList;
	struct{
		uint32 /*-*/ generateExpose;
	} gcValueList;
	if(!virtualRootSystem or !monitorSystem or !(*monitorSystem).size or !wallpaperSystem or !(*wallpaperSystem).pixmap or !clientSystem or !width or !height){
		ret false;
	}
	(*virtualRootSystem).width = width;
	(*virtualRootSystem).height = height;
	if((*virtualRootSystem).workareaEdgeOffsetSize != (*monitorSystem).size){



		/*! add support for normal windows. */



		Client *current = (*clientSystem).clientStart;
		Client *const wall = current + (*clientSystem).clientAllocated;
		jmp removeVirtualRootClientWorkareaLoop;
		removeVirtualRootClientWorkareaLoop:{
			if(current < wall){
				if((*current).inUse){
					removeVirtualRootClientWorkarea(virtualRootSystem, monitorSystem, clientSystem, current);
				}
				inc current;
				jmp removeVirtualRootClientWorkareaLoop;
			}
			setVirtualRootGlobalEdgeOffset(virtualRootSystem, monitorSystem);
			current = (*clientSystem).clientStart;
			jmp addVirtualRootClientWorkareaLoop;
		}
		addVirtualRootClientWorkareaLoop:{
			if(current < wall){
				if((*current).inUse){
					if(addVirtualRootClientWorkarea(virtualRootSystem, monitorSystem, clientSystem, current)){
						updateVirtualRootStrutedClients(virtualRootSystem, monitorSystem, clientSystem, current, ADD_UPDATE_WORKAREA_ACTION);
					}
				}
				inc current;
				jmp addVirtualRootClientWorkareaLoop;
			}
			updateVirtualRootWorkareaClients(virtualRootSystem, monitorSystem, clientSystem);
		}
	}
	current = (*virtualRootSystem).virtualRootStart;
	wall = current + (*virtualRootSystem).virtualRootAllocated;
	windowValueList.width = (*virtualRootSystem).width;
	windowValueList.height = (*virtualRootSystem).height;
	gcValueList.generateExpose = false;
	jmp configureVirtualRootLoop;
	configureVirtualRootLoop:{
		if(current < wall){
			if((*current).gc){
				xcb_free_gc(connection, (*current).gc);
			}
			if((*current).pixmap){
				xcb_free_pixmap(connection, (*current).pixmap);
			}
			(*current).pixmap = xcb_generate_id(connection);
			(*current).gc = xcb_generate_id(connection);
			xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &windowValueList);
			xcb_create_pixmap(connection, (*screen).root_depth, (*current).pixmap, (*screen).root, (*virtualRootSystem).width, (*virtualRootSystem).height);
			xcb_create_gc(connection, (*current).gc, (*current).pixmap, XCB_GC_GRAPHICS_EXPOSURES, &gcValueList);
			xcb_change_window_attributes(connection, (*current).window, XCB_CW_BACK_PIXMAP, &(*current).pixmap);
			inc current;
			jmp configureVirtualRootLoop;
		}
		jmp applyProperties;
	}
	applyProperties:{
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_DESKTOP_GEOMETRY, XCB_ATOM_CARDINAL, bitsof(uint32), 2, &(*virtualRootSystem).width);
		if(setVirtualRootWorkarea(virtualRootSystem, monitorSystem)){
			changeVirtualRootWorkarea(virtualRootSystem);
		}
		ret true;
	}
}
SETVIRTUALROOTGLOBALEDGEOFFSET(){
	uint32 size;
	EdgeOffset *start;
	uint32 token;
	EdgeOffset *current;
	EdgeOffset *wall;
	if(!virtualRootSystem or !monitorSystem or !(*monitorSystem).size){
		ret false;
	}
	size = (*monitorSystem).size;
	start = malloc(size * sizeof(EdgeOffset));
	token = pushPointer(start, "virtual root monitor workarea pointer", iFree);
	if(start){
		free((*virtualRootSystem).workareaEdgeOffsetStart);
		popPointer((*virtualRootSystem).workareaEdgeOffsetToken);
		(*virtualRootSystem).workareaEdgeOffsetSize = size;
		(*virtualRootSystem).workareaEdgeOffsetStart = start;
		(*virtualRootSystem).workareaEdgeOffsetToken = token;
	}
	current = (*virtualRootSystem).workareaEdgeOffsetStart;
	wall = current + (*virtualRootSystem).workareaEdgeOffsetSize;
	jmp setOuterEdgeOffsetLoop;
	setOuterEdgeOffsetLoop:{
		if(current < wall){
			(*current).top = 0;
			(*current).bottom = 0;
			(*current).left = 0;
			(*current).right = 0;
			inc current;
			jmp setOuterEdgeOffsetLoop;
		}
		jmp setInnerEdgeOffset;
	}
	setInnerEdgeOffset:{
		VirtualRoot *virtualRootCurrent = (*virtualRootSystem).virtualRootStart;
		VirtualRoot *const virtualRootWall = virtualRootCurrent + (*virtualRootSystem).virtualRootAllocated;
		jmp setInnerEdgeOffsetLoop0;
		setInnerEdgeOffsetLoop0:{
			if(virtualRootCurrent < virtualRootWall){
				size = (*monitorSystem).size;
				start = malloc(size * sizeof(EdgeOffset));
				token = pushPointer(start, "virtual root monitor workarea pointer", iFree);
				if(start){
					free((*virtualRootCurrent).workareaEdgeOffsetStart);
					popPointer((*virtualRootCurrent).workareaEdgeOffsetToken);
					(*virtualRootCurrent).workareaEdgeOffsetSize = size;
					(*virtualRootCurrent).workareaEdgeOffsetStart = start;
					(*virtualRootCurrent).workareaEdgeOffsetToken = token;
				}
				current = (*virtualRootCurrent).workareaEdgeOffsetStart;
				wall = current + (*virtualRootCurrent).workareaEdgeOffsetSize;
				jmp setInnerEdgeOffsetLoop1;
				setInnerEdgeOffsetLoop1:{
					if(current < wall){
						(*current).top = 0;
						(*current).bottom = 0;
						(*current).left = 0;
						(*current).right = 0;
						inc current;
						jmp setInnerEdgeOffsetLoop1;
					}
					inc virtualRootCurrent;
					jmp setInnerEdgeOffsetLoop0;
				}
			}
			ret true;
		}
	}
}
SETVIRTUALROOTWALLPAPER(){
	VirtualRoot *current;
	VirtualRoot *wall;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !wallpaperSystem){
		ret false;
	}
	current = (*virtualRootSystem).virtualRootStart;
	wall = current + (*virtualRootSystem).virtualRootAllocated;
	jmp applyWallpaperLoop;
	applyWallpaperLoop:{
		if(current < wall){
			fillDrawable((*current).pixmap, (*current).gc, 0, 0, (*virtualRootSystem).width, (*virtualRootSystem).height, (*wallpaperSystem).color);
			if((*wallpaperSystem).pixmap){
				xcb_copy_area(connection, (*wallpaperSystem).pixmap, (*current).pixmap, (*current).gc, 0, 0, 0, 0, (*wallpaperSystem).width, (*wallpaperSystem).height);
			}
			inc current;
			jmp applyWallpaperLoop;
		}
		if(!(*virtualRootSystem).mapped){
			ret true;
		}
		current = (*virtualRootSystem).virtualRootStart;
		jmp clearAreaLoop;
	}
	clearAreaLoop:{
		if(current < wall){
			xcb_clear_area(connection, false, (*current).window, 0, 0, 0, 0);
			inc current;
			jmp clearAreaLoop;
		}
		ret true;
	}
}
RESTACKVIRTUALROOTBELOW(){
	VirtualRoot *start;
	VirtualRoot *current;
	VirtualRoot *wall;
	uint currentDesktop;
	struct{
		uint32 /*-*/ stackMode;
	} valueList;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or (*virtualRootSystem).currentDesktop == NONE_DESKTOP){
		ret false;
	}
	start = (*virtualRootSystem).virtualRootStart;
	current = start;
	wall = current + (*virtualRootSystem).virtualRootAllocated;
	valueList.stackMode = XCB_STACK_MODE_BELOW;
	currentDesktop = (*virtualRootSystem).currentDesktop;
	jmp restackVirtualRootBelowLoop;
	restackVirtualRootBelowLoop:{
		if(current < wall){
			if(current - start != currentDesktop){
				xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_STACK_MODE, &valueList);
			}
			inc current;
			jmp restackVirtualRootBelowLoop;
		}
		jmp restackCurrentVirtualRootAbove;
	}
	restackCurrentVirtualRootAbove:{
		if((*virtualRootSystem).virtualRootAllocated == 1){
			xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_STACK_MODE, &valueList);
		}else{
			struct{
				xcb_window_t /*-*/ sibling;
				uint32 /*-------*/ stackMode;
			} valueList;
			valueList.sibling = (*start).window;
			valueList.stackMode = XCB_STACK_MODE_ABOVE;
			xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_SIBLING | XCB_CONFIG_WINDOW_STACK_MODE, &valueList);
		}
		ret true;
	}
}
MAPVIRTUALROOTS(){
	VirtualRoot *current;
	VirtualRoot *wall;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated){
		ret false;
	}
	current = (*virtualRootSystem).virtualRootStart;
	wall = current + (*virtualRootSystem).virtualRootAllocated;
	jmp mapWindowLoop;
	mapWindowLoop:{
		if(current < wall){
			xcb_map_window(connection, (*current).window);
			inc current;
			jmp mapWindowLoop;
		}
		(*virtualRootSystem).mapped = true;
		ret true;
	}
}
SETCLIENTVIRTUALROOT(){
	uint *clientOffset;
	VirtualRoot *oldVirtualRoot;
	VirtualRoot *newVirtualRoot;
	xcb_window_t newParent;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !clientSystem or !isValidClient(clientSystem, client) or (*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION or ((*client).stateState != WITHDRAWN_STATE and !((*client).allowedAction & CHANGE_DESKTOP_ALLOWED_ACTION)) or (which != NONE_DESKTOP and which != 0xFFFFFFFF and which >= (*virtualRootSystem).virtualRootAllocated) or which == (*client).desktop){
		ret false;
	}
	oldVirtualRoot = NULL;
	newVirtualRoot = NULL;
	newParent = XCB_NONE;
	if((*client).desktop == NONE_DESKTOP or (*client).desktop == 0xFFFFFFFF){
		if(which != NONE_DESKTOP and which != 0xFFFFFFFF){
			newVirtualRoot = (*virtualRootSystem).virtualRootStart + which;
			newParent = (*newVirtualRoot).window;
		}
	}elif(which == NONE_DESKTOP or which == 0xFFFFFFFF){
		oldVirtualRoot = (*virtualRootSystem).virtualRootStart + (*client).desktop;
		newParent = (*screen).root;
	}else{
		oldVirtualRoot = (*virtualRootSystem).virtualRootStart + (*client).desktop;
		newVirtualRoot = (*virtualRootSystem).virtualRootStart + which;
		newParent = (*newVirtualRoot).window;
	}
	if(oldVirtualRoot){
		if(!(clientOffset = findOrderedVirtualRootClientOffset(virtualRootSystem, oldVirtualRoot, clientSystem, (*client).window))){
			ret false;
		}
	}
	if(newVirtualRoot){
		if((*newVirtualRoot).orderedClientOffsetAllocated == (*newVirtualRoot).orderedClientOffsetSize){
			void *temp;
			(*newVirtualRoot).orderedClientOffsetSize += CLIENT_BLOCK_SIZE;
			temp = realloc((*newVirtualRoot).orderedClientOffsetStart, (*newVirtualRoot).orderedClientOffsetSize * sizeof(uint));
			if(!(*newVirtualRoot).orderedClientOffsetToken){
				(*newVirtualRoot).orderedClientOffsetToken = pushPointer(temp, "virtual root ordered client offset pointer", iFree);
			}else{
				updatePointer((*newVirtualRoot).orderedClientOffsetToken, temp);
			}
			if(!temp){
				printTitledError("memory allocation error", "could not allocate memory for virtual root ordered client offsets");
				(*newVirtualRoot).orderedClientOffsetSize -= CLIENT_BLOCK_SIZE;
				ret false;
			}
			(*newVirtualRoot).orderedClientOffsetStart = temp;
		}
	}
	if(oldVirtualRoot){
		shiftMemory(clientOffset + 1, ((*oldVirtualRoot).orderedClientOffsetStart + (*oldVirtualRoot).orderedClientOffsetAllocated - clientOffset - 1) * sizeof(uint), -(int)sizeof(uint));
		dec (*oldVirtualRoot).orderedClientOffsetAllocated;
	}
	if(newParent and !((*client).state & FULLSCREEN_STATE)){
		xcb_reparent_window(connection, (*client).container, newParent, (*client).containerX, (*client).containerY);
	}
	(*client).desktop = which;
	if(newVirtualRoot){
		*((*newVirtualRoot).orderedClientOffsetStart + (*newVirtualRoot).orderedClientOffsetAllocated) = client - (*clientSystem).clientStart;
		inc (*newVirtualRoot).orderedClientOffsetAllocated;
	}
	ret true;
}
CHANGEVIRTUALROOTCLIENTDESKTOP(){
	if(!virtualRootSystem or !clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	if((*client).desktop == NONE_DESKTOP){
		xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, atom._NET_WM_DESKTOP));
	}else{
		xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_WM_DESKTOP, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &(*client).desktop));
	}
	ret true;
}
MOVECLIENTTOVIRTUALROOT(){
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or !clientSystem or !isValidClient(clientSystem, client) or (*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION or ((*client).stateState != WITHDRAWN_STATE and !((*client).allowedAction & CHANGE_DESKTOP_ALLOWED_ACTION)) or (which != NONE_DESKTOP and which != 0xFFFFFFFF and which >= (*virtualRootSystem).virtualRootAllocated) or which == (*client).desktop){
		ret false;
	}
	if(loseClientFocus and client == getFocusedClient(clientSystem)){
		loseFocus(clientSystem);
	}
	if(removeVirtualRootClientWorkarea(virtualRootSystem, monitorSystem, clientSystem, client)){
		updateVirtualRootStrutedClients(virtualRootSystem, monitorSystem, clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
		updateVirtualRootWorkareaClients(virtualRootSystem, monitorSystem, clientSystem);
	}
	if(setClientVirtualRoot(virtualRootSystem, clientSystem, client, which)){
		configureVirtualRootClient(virtualRootSystem, clientSystem, client);
		if((*client).strut){
			updateVirtualRootWorkareaClients(virtualRootSystem, monitorSystem, clientSystem);
		}else{
			updateVirtualRootWorkareaClient(virtualRootSystem, monitorSystem, clientSystem, client);
		}
		changeVirtualRootClientDesktop(virtualRootSystem, clientSystem, client);
	}
	if(addVirtualRootClientWorkarea(virtualRootSystem, monitorSystem, clientSystem, client)){
		updateVirtualRootStrutedClients(virtualRootSystem, monitorSystem, clientSystem, client, ADD_UPDATE_WORKAREA_ACTION);
		updateVirtualRootWorkareaClients(virtualRootSystem, monitorSystem, clientSystem);
	}
	if((*client).strut){
		if(setVirtualRootWorkarea(virtualRootSystem, monitorSystem)){
			changeVirtualRootWorkarea(virtualRootSystem);
		}
	}
	ret true;
}
CONFIGUREVIRTUALROOTCLIENT(){
	Client *siblingClient;
	uint8 stackMode;
	xcb_window_t sibling;
	uint32 valueMask;
	uint32 valueList[2];
	if(!virtualRootSystem or !clientSystem or !isValidClient(clientSystem, client) or (*client).desktop == NONE_DESKTOP or (*client).desktop == 0xFFFFFFFF or (*client).state & FULLSCREEN_STATE){
		ret false;
	}
	if((siblingClient = findBelowDesktopClient(clientSystem, client))){
		stackMode = XCB_STACK_MODE_ABOVE;
		sibling = (*siblingClient).window;
		valueMask = XCB_CONFIG_WINDOW_SIBLING | XCB_CONFIG_WINDOW_STACK_MODE;
		*(valueList + 0) = (*siblingClient).container;
		*(valueList + 1) = XCB_STACK_MODE_ABOVE;
	}else{
		stackMode = XCB_STACK_MODE_BELOW;
		sibling = XCB_NONE;
		valueMask = XCB_CONFIG_WINDOW_STACK_MODE;
		*(valueList + 0) = XCB_STACK_MODE_BELOW;
	}
	if(!restackVirtualRootClient(virtualRootSystem, clientSystem, client, stackMode, sibling)){
		ret false;
	}
	xcb_configure_window(connection, (*client).container, valueMask, valueList);
	ret true;
}
RESTACKVIRTUALROOTCLIENT(){
	VirtualRoot *virtualRoot;
	uint *start;
	uint *current;
	uint *wall;
	uint copy;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !clientSystem or !isValidClient(clientSystem, client) or (*client).desktop == NONE_DESKTOP or (*client).desktop == 0xFFFFFFFF){
		ret false;
	}
	virtualRoot = (*virtualRootSystem).virtualRootStart + (*client).desktop;
	if(!(*virtualRoot).orderedClientOffsetStart){
		ret false;
	}
	start = (*virtualRoot).orderedClientOffsetStart;
	wall = start + (*virtualRoot).orderedClientOffsetAllocated;
	switch stackMode over
		to XCB_STACK_MODE_ABOVE: /*-*/ jmp stackModeAbove;
		to XCB_STACK_MODE_BELOW: /*-*/ jmp stackModeBelow;
		off: /*---------------------*/ ret false;
	end
	stackModeAbove:{
		uint *siblingClient = wall - 1;
		if(sibling and !(siblingClient = findOrderedVirtualRootClientOffset(virtualRootSystem, virtualRoot, clientSystem, sibling))){
			ret false;
		}
		if(!(current = findOrderedVirtualRootClientOffset(virtualRootSystem, virtualRoot, clientSystem, (*client).window)) or current == siblingClient or current == siblingClient + 1){
			ret false;
		}
		copy = *current;
		if(current < siblingClient){
			shiftMemory(current + 1, (siblingClient - current) * sizeof(uint), -(int)sizeof(uint));
			*siblingClient = copy;
			ret true;
		}
		shiftMemory(siblingClient + 1, (current - siblingClient - 1) * sizeof(uint), sizeof(uint));
		*(siblingClient + 1) = copy;
		ret true;
	}
	stackModeBelow:{
		uint *siblingClient = start;
		if(sibling and !(siblingClient = findOrderedVirtualRootClientOffset(virtualRootSystem, virtualRoot, clientSystem, sibling))){
			ret false;
		}
		if(!(current = findOrderedVirtualRootClientOffset(virtualRootSystem, virtualRoot, clientSystem, (*client).window)) or current == siblingClient or current == siblingClient - 1){
			ret false;
		}
		copy = *current;
		if(current < siblingClient){
			shiftMemory(current + 1, (siblingClient - current - 1) * sizeof(uint), -(int)sizeof(uint));
			*(siblingClient - 1) = copy;
			ret true;
		}
		shiftMemory(siblingClient, (current - siblingClient) * sizeof(uint), sizeof(uint));
		*siblingClient = copy;
		ret true;
	}
}
ADDVIRTUALROOTCLIENTWORKAREA(){
	uint monitorOffset;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or (*monitorSystem).size != (*virtualRootSystem).workareaEdgeOffsetSize or !clientSystem or !isValidClient(clientSystem, client) or (*client).stateState != NORMAL_STATE or !(*client).strut){
		ret false;
	}
	jmp findMonitorOffset;
	findMonitorOffset:{
		Monitor *monitor;
		if(!(monitor = findRectangleMonitor(monitorSystem, (*client).strutX, (*client).strutY, (*client).strutWidth, (*client).strutHeight))){
			ret false;
		}
		monitorOffset = monitor - (*monitorSystem).start;
		jmp calculateWorkarea;
	}
	calculateWorkarea:{
		EdgeOffset *edgeOffset = (*virtualRootSystem).workareaEdgeOffsetStart + monitorOffset;
		int x = 0;
		int y = 0;
		if((*client).desktop == NONE_DESKTOP or (*client).desktop == 0xFFFFFFFF){
			switch (*client).strut over
				to TOP_STRUT: /*----*/ y = 0; /*---------------------------------------------------*/ brk;
				to BOTTOM_STRUT: /*-*/ y = (*virtualRootSystem).height - (*client).strutHeight; /*-*/ brk;
				to LEFT_STRUT: /*---*/ x = 0; /*---------------------------------------------------*/ brk;
				to RIGHT_STRUT: /*--*/ x = (*virtualRootSystem).width - (*client).strutWidth; /*---*/ brk;
				off: /*-------------*/ /*----------------------------------------------------------*/ brk;
			end
		}else{
			if(!(*virtualRootSystem).virtualRootAllocated){
				ret false;
			}
			switch (*client).strut over
				to TOP_STRUT: /*----*/ y = (*edgeOffset).top; /*----------------------------------------------------------*/ brk;
				to BOTTOM_STRUT: /*-*/ y = (*virtualRootSystem).height - (*edgeOffset).bottom - (*client).strutHeight; /*-*/ brk;
				to LEFT_STRUT: /*---*/ x = (*edgeOffset).left; /*---------------------------------------------------------*/ brk;
				to RIGHT_STRUT: /*--*/ x = (*virtualRootSystem).width - (*edgeOffset).right - (*client).strutWidth; /*----*/ brk;
				off: /*-------------*/ /*---------------------------------------------------------------------------------*/ brk;
			end
			edgeOffset = (*((*virtualRootSystem).virtualRootStart + (*client).desktop)).workareaEdgeOffsetStart + monitorOffset;
		}
		switch (*client).strut over
			to TOP_STRUT: /*----*/ (*client).strutY = y; (*edgeOffset).top += (*client).strutHeight; /*----*/ brk;
			to BOTTOM_STRUT: /*-*/ (*client).strutY = y; (*edgeOffset).bottom += (*client).strutHeight; /*-*/ brk;
			to LEFT_STRUT: /*---*/ (*client).strutX = x; (*edgeOffset).left += (*client).strutWidth; /*----*/ brk;
			to RIGHT_STRUT: /*--*/ (*client).strutX = x; (*edgeOffset).right += (*client).strutWidth; /*---*/ brk;
			off: /*-------------*/ /*-----------------*/ /*------------------------------------------------*/ brk;
		end
		ret true;
	}
}
UPDATEVIRTUALROOTSTRUTEDCLIENTS(){
	Client *current;
	Client *wall;
	uint clientMonitorOffset;
	int multiplier;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or !clientSystem or !isValidClient(clientSystem, client) or !action or action > REMOVE_UPDATE_WORKAREA_ACTION){
		ret false;
	}
	jmp findMonitorOffset;
	findMonitorOffset:{
		Monitor *monitor;
		if(!(monitor = findRectangleMonitor(monitorSystem, (*client).strutX, (*client).strutY, (*client).strutWidth, (*client).strutHeight))){
			ret false;
		}
		current = (*clientSystem).clientStart;
		wall = current + (*clientSystem).clientAllocated;
		clientMonitorOffset = monitor - (*monitorSystem).start;
		multiplier = 1 - (action == REMOVE_UPDATE_WORKAREA_ACTION) * 2;
		jmp updateVirtualRootStrutedClientsLoop;
	}
	updateVirtualRootStrutedClientsLoop:{
		if(current < wall){
			if(current != client and (*current).strut == (*client).strut and (*current).stateState == NORMAL_STATE){
				if((*client).desktop == NONE_DESKTOP or (*client).desktop == 0xFFFFFFFF or ((*current).desktop != NONE_DESKTOP and (*current).desktop != 0xFFFFFFFF)){
					Monitor *monitor;
					uint monitorOffset;
					if(!(monitor = findRectangleMonitor(monitorSystem, (*current).strutX, (*current).strutY, (*current).strutWidth, (*current).strutHeight))){
						ret false;
					}
					monitorOffset = monitor - (*monitorSystem).start;
					if(monitorOffset == clientMonitorOffset){
						const int width = (*client).strutWidth;
						const int height = (*client).strutHeight;
						switch (*current).strut over
							to TOP_STRUT: /*----*/ (*client).strutY -= multiplier * height; /*-*/ brk;
							to BOTTOM_STRUT: /*-*/ (*client).strutY += multiplier * height; /*-*/ brk;
							to LEFT_STRUT: /*---*/ (*client).strutX -= multiplier * width; /*--*/ brk;
							to RIGHT_STRUT: /*--*/ (*client).strutX += multiplier * width; /*--*/ brk;
							off: /*-------------*/ /*------------------------------------------*/ brk;
						end
						moveResizeClient(clientSystem, client, (*client).strutX, (*client).strutY, (*client).strutWidth, (*client).strutHeight, false, false, false, false, false, NONE_WINDOW_GRAVITY);
					}
				}
			}
			inc current;
			jmp updateVirtualRootStrutedClientsLoop;
		}
		ret true;
	}
}
REMOVEVIRTUALROOTCLIENTWORKAREA(){
	uint monitorOffset;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootStart or !monitorSystem or !(*monitorSystem).size or (*monitorSystem).size != (*virtualRootSystem).workareaEdgeOffsetSize or !clientSystem or !isValidClient(clientSystem, client) or (*client).stateState != NORMAL_STATE or !(*client).strut or (*client).desktop == NONE_DESKTOP){
		ret false;
	}
	jmp findMonitorOffset;
	findMonitorOffset:{
		Monitor *monitor;
		if(!(monitor = findRectangleMonitor(monitorSystem, (*client).strutX, (*client).strutY, (*client).strutWidth, (*client).strutHeight))){
			ret false;
		}
		monitorOffset = monitor - (*monitorSystem).start;
		jmp calculateWorkarea;
	}
	calculateWorkarea:{
		EdgeOffset *edgeOffset;
		if((*client).desktop == 0xFFFFFFFF){
			edgeOffset = (*virtualRootSystem).workareaEdgeOffsetStart + monitorOffset;
		}else{
			edgeOffset = (*((*virtualRootSystem).virtualRootStart + (*client).desktop)).workareaEdgeOffsetStart + monitorOffset;
		}
		switch (*client).strut over
			to TOP_STRUT: /*----*/ (*edgeOffset).top -= (*client).strutHeight; /*----*/ brk;
			to BOTTOM_STRUT: /*-*/ (*edgeOffset).bottom -= (*client).strutHeight; /*-*/ brk;
			to LEFT_STRUT: /*---*/ (*edgeOffset).left -= (*client).strutWidth; /*----*/ brk;
			to RIGHT_STRUT: /*--*/ (*edgeOffset).right -= (*client).strutWidth; /*---*/ brk;
			off: /*-------------*/ /*------------------------------------------------*/ brk;
		end
		ret true;
	}
}
MAXIMIZECLIENT(){
	Monitor *monitor;
	int x;
	int y;
	uint width;
	uint height;
	uint8 option;
	uint8 workareaPosition;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or (*monitorSystem).size != (*virtualRootSystem).workareaEdgeOffsetSize or !clientSystem or !isValidClient(clientSystem, client) or (*client).option & (OVERRIDE_REDIRECT_CLIENT_OPTION | TEMPORARILY_UNMAPPED_CLIENT_OPTION) or ((*client).allowedAction & (MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION)) != (MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION) or ((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) == (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE) or !whichMonitor or whichMonitor >= ALL_WHICH_MONITOR){
		ret false;
	}
	if(!(monitor = getWhichMonitor(monitorSystem, whichMonitor))){
		ret false;
	}
	if(!updateClientState(clientSystem, client, _NET_WM_STATE_ADD, MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
		ret false;
	}
	option = (*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
	workareaPosition = (*client).workareaPosition;
	if(!((*client).state & FULLSCREEN_STATE)){
		(*client).oldContainerX = (*client).containerX;
		(*client).oldContainerY = (*client).containerY;
		(*client).oldContainerWidth = (*client).containerWidth;
		(*client).oldContainerHeight = (*client).containerHeight;
		(*client).oldContainerBorder = (*client).containerBorder;
	}elif((*client).desktop != NONE_DESKTOP and (*client).desktop != 0xFFFFFFFF){
		xcb_reparent_window(connection, (*client).container, (*((*virtualRootSystem).virtualRootStart + (*client).desktop)).window, (*client).containerX, (*client).containerY);
	}
	updateClientState(clientSystem, client, _NET_WM_STATE_REMOVE, FULLSCREEN_STATE);
	{
		const uint monitorOffset = monitor - (*monitorSystem).start;
		const EdgeOffset *const outerEdgeOffset = (*virtualRootSystem).workareaEdgeOffsetStart + monitorOffset;
		const EdgeOffset *const innerEdgeOffset = (*((*virtualRootSystem).virtualRootStart + (*client).desktop)).workareaEdgeOffsetStart + monitorOffset;
		x = (*monitor).leftX + (*outerEdgeOffset).left + (*innerEdgeOffset).left;
		y = (*monitor).topY + (*outerEdgeOffset).top + (*innerEdgeOffset).top;
		width = (*monitor).width - (*outerEdgeOffset).left - (*innerEdgeOffset).left - (*innerEdgeOffset).right - (*outerEdgeOffset).right;
		height = (*monitor).height - (*outerEdgeOffset).top - (*innerEdgeOffset).top - (*innerEdgeOffset).bottom - (*outerEdgeOffset).bottom;
	}
	moveResizeClient(clientSystem, client, x, y, width, height, false, false, false, false, false, NONE_WINDOW_GRAVITY);
	(*client).option |= option;
	(*client).workareaPosition = workareaPosition;
	if(setClientAllowedActions(clientSystem, client)){
		changeClientAllowedActions(clientSystem, client);
	}
	changeClientState(clientSystem, client);
	ret true;
}
UNMAXIMIZECLIENT(){
	uint8 option;
	uint8 workareaPosition;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or (*monitorSystem).size != (*virtualRootSystem).workareaEdgeOffsetSize or !clientSystem or !isValidClient(clientSystem, client) or (*client).option & (OVERRIDE_REDIRECT_CLIENT_OPTION | TEMPORARILY_UNMAPPED_CLIENT_OPTION) or ((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) != (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
		ret false;
	}
	if(!updateClientState(clientSystem, client, _NET_WM_STATE_REMOVE, MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
		ret false;
	}
	option = (*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
	workareaPosition = (*client).workareaPosition;
	(*client).containerX = (*client).oldContainerX;
	(*client).containerY = (*client).oldContainerY;
	(*client).containerWidth = (*client).oldContainerWidth;
	(*client).containerHeight = (*client).oldContainerHeight;
	(*client).containerBorder = (*client).oldContainerBorder;
	if((*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION)){
		(*client).allowedAction |= MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION;
		updateVirtualRootWorkareaClient(virtualRootSystem, monitorSystem, clientSystem, client);
	}else{
		moveResizeClient(clientSystem, client, (*client).containerX, (*client).containerY, (*client).containerWidth + 2 * (*client).containerBorder, (*client).containerHeight + 2 * (*client).containerBorder, false, false, false, false, false, NONE_WINDOW_GRAVITY);
		(*client).option |= option;
		(*client).workareaPosition = workareaPosition;
	}
	if(setClientAllowedActions(clientSystem, client)){
		changeClientAllowedActions(clientSystem, client);
	}
	changeClientState(clientSystem, client);
	ret true;
}
FULLSCREENCLIENT(){
	Monitor *monitor;
	uint8 option;
	uint8 workareaPosition;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or (*monitorSystem).size != (*virtualRootSystem).workareaEdgeOffsetSize or !clientSystem or !isValidClient(clientSystem, client) or (*client).option & (OVERRIDE_REDIRECT_CLIENT_OPTION | TEMPORARILY_UNMAPPED_CLIENT_OPTION) or !((*client).allowedAction & FULLSCREEN_ALLOWED_ACTION) or (*client).state & FULLSCREEN_STATE or (*client).desktop == NONE_DESKTOP or (*client).desktop == 0xFFFFFFFF or !whichMonitor or whichMonitor >= ALL_WHICH_MONITOR){
		ret false;
	}
	if(!(monitor = getWhichMonitor(monitorSystem, whichMonitor))){
		ret false;
	}
	if(!updateClientState(clientSystem, client, _NET_WM_STATE_ADD, FULLSCREEN_STATE)){
		ret false;
	}
	option = (*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
	workareaPosition = (*client).workareaPosition;
	if(((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) != (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
		(*client).oldContainerX = (*client).containerX;
		(*client).oldContainerY = (*client).containerY;
		(*client).oldContainerWidth = (*client).containerWidth;
		(*client).oldContainerHeight = (*client).containerHeight;
		(*client).oldContainerBorder = (*client).containerBorder;
	}
	if((*client).desktop != NONE_DESKTOP and (*client).desktop != 0xFFFFFFFF){
		xcb_reparent_window(connection, (*client).container, (*screen).root, (*client).containerX, (*client).containerY);
	}
	updateClientState(clientSystem, client, _NET_WM_STATE_REMOVE, MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE);
	moveResizeClient(clientSystem, client, (*monitor).leftX, (*monitor).topY, (*monitor).width, (*monitor).height, false, false, false, false, false, NONE_WINDOW_GRAVITY);
	(*client).option |= option;
	(*client).workareaPosition = workareaPosition;
	if(setClientAllowedActions(clientSystem, client)){
		changeClientAllowedActions(clientSystem, client);
	}
	changeClientState(clientSystem, client);
	ret true;
}
UNFULLSCREENCLIENT(){
	uint8 option;
	uint8 workareaPosition;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or !clientSystem or !isValidClient(clientSystem, client) or (*client).option & (OVERRIDE_REDIRECT_CLIENT_OPTION | TEMPORARILY_UNMAPPED_CLIENT_OPTION) or !((*client).state & FULLSCREEN_STATE)){
		ret false;
	}
	if(!updateClientState(clientSystem, client, _NET_WM_STATE_REMOVE, FULLSCREEN_STATE)){
		ret false;
	}
	option = (*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
	workareaPosition = (*client).workareaPosition;
	if((*client).desktop != NONE_DESKTOP and (*client).desktop != 0xFFFFFFFF){
		xcb_reparent_window(connection, (*client).container, (*((*virtualRootSystem).virtualRootStart + (*client).desktop)).window, (*client).containerX, (*client).containerY);
	}
	(*client).containerX = (*client).oldContainerX;
	(*client).containerY = (*client).oldContainerY;
	(*client).containerWidth = (*client).oldContainerWidth;
	(*client).containerHeight = (*client).oldContainerHeight;
	(*client).containerBorder = (*client).oldContainerBorder;
	if((*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION)){
		(*client).allowedAction |= MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION;
		updateVirtualRootWorkareaClient(virtualRootSystem, monitorSystem, clientSystem, client);
	}else{
		moveResizeClient(clientSystem, client, (*client).containerX, (*client).containerY, (*client).containerWidth + 2 * (*client).containerBorder, (*client).containerHeight + 2 * (*client).containerBorder, false, false, false, false, false, NONE_WINDOW_GRAVITY);
		(*client).option |= option;
		(*client).workareaPosition = workareaPosition;
	}
	if(setClientAllowedActions(clientSystem, client)){
		changeClientAllowedActions(clientSystem, client);
	}
	changeClientState(clientSystem, client);
	ret true;
}
MOVERESIZEWORKAREACLIENT(){
	Monitor *monitor;
	int workareaX;
	int workareaY;
	int workareaWidth;
	int workareaHeight;
	int x;
	int y;
	int width;
	int height;
	uint8 windowGravity;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or (*virtualRootSystem).workareaEdgeOffsetSize != (*monitorSystem).size or !isValidClient(clientSystem, client) or (*client).desktop == NONE_DESKTOP or (*client).desktop == 0xFFFFFFFF or (*client).desktop >= (*virtualRootSystem).virtualRootAllocated or (*client).state & FULLSCREEN_STATE or (*client).option & (OVERRIDE_REDIRECT_CLIENT_OPTION | TEMPORARILY_UNMAPPED_CLIENT_OPTION)){
		ret false;
	}
	if(!(monitor = getWhichMonitor(monitorSystem, whichMonitor))){
		if(whichMonitor != SELF_WHICH_MONITOR){
			ret false;
		}
		if(!(monitor = findRectangleMonitor(monitorSystem, (*client).containerX, (*client).containerY, (*client).containerWidth + 2 * (*client).containerBorder, (*client).containerHeight + 2 * (*client).containerBorder))){
			ret false;
		}
	}
	{
		const uint monitorOffset = monitor - (*monitorSystem).start;
		const EdgeOffset *const outerEdgeOffset = (*virtualRootSystem).workareaEdgeOffsetStart + monitorOffset;
		const EdgeOffset *const innerEdgeOffset = (*((*virtualRootSystem).virtualRootStart + (*client).desktop)).workareaEdgeOffsetStart + monitorOffset;
		workareaX = (*monitor).leftX + (*outerEdgeOffset).left + (*innerEdgeOffset).left;
		workareaY = (*monitor).topY + (*outerEdgeOffset).top + (*innerEdgeOffset).top;
		workareaWidth = (*monitor).width - (*outerEdgeOffset).left - (*innerEdgeOffset).left - (*innerEdgeOffset).right - (*outerEdgeOffset).right;
		workareaHeight = (*monitor).height - (*outerEdgeOffset).top - (*innerEdgeOffset).top - (*innerEdgeOffset).bottom - (*outerEdgeOffset).bottom;
	}
	switch workareaPosition over
		to NONE_WORKAREA_POSITION: /*---------*/ /*--------------------------------*/ /*----------------------------------*/ /*----------------------------------------------*/ /*------------------------------------------------*/ /*--------------------------------------------------*/ ret false;
		to TOP_WORKAREA_POSITION: /*----------*/ width = workareaWidth / 1; /*-----*/ height = workareaHeight / 2; /*-----*/ x = workareaX; /*-------------------------------*/ y = workareaY; /*---------------------------------*/ windowGravity = NORTH_SIDE_WINDOW_GRAVITY; /*-------*/ brk;
		to BOTTOM_WORKAREA_POSITION: /*-------*/ width = workareaWidth / 1; /*-----*/ height = workareaHeight / 2; /*-----*/ x = workareaX; /*-------------------------------*/ y = workareaY + workareaHeight - height; /*-------*/ windowGravity = SOUTH_SIDE_WINDOW_GRAVITY; /*-------*/ brk;
		to LEFT_WORKAREA_POSITION: /*---------*/ width = workareaWidth / 2; /*-----*/ height = workareaHeight / 1; /*-----*/ x = workareaX; /*-------------------------------*/ y = workareaY; /*---------------------------------*/ windowGravity = WEST_SIDE_WINDOW_GRAVITY; /*--------*/ brk;
		to RIGHT_WORKAREA_POSITION: /*--------*/ width = workareaWidth / 2; /*-----*/ height = workareaHeight / 1; /*-----*/ x = workareaX + workareaWidth - width; /*-------*/ y = workareaY; /*---------------------------------*/ windowGravity = EAST_SIDE_WINDOW_GRAVITY; /*--------*/ brk;
		to TOP_LEFT_WORKAREA_POSITION: /*-----*/ width = workareaWidth / 2; /*-----*/ height = workareaHeight / 2; /*-----*/ x = workareaX; /*-------------------------------*/ y = workareaY; /*---------------------------------*/ windowGravity = NORTH_WEST_POINT_WINDOW_GRAVITY; /*-*/ brk;
		to TOP_RIGHT_WORKAREA_POSITION: /*----*/ width = workareaWidth / 2; /*-----*/ height = workareaHeight / 2; /*-----*/ x = workareaX + workareaWidth - width; /*-------*/ y = workareaY; /*---------------------------------*/ windowGravity = NORTH_EAST_POINT_WINDOW_GRAVITY; /*-*/ brk;
		to BOTTOM_LEFT_WORKAREA_POSITION: /*--*/ width = workareaWidth / 2; /*-----*/ height = workareaHeight / 2; /*-----*/ x = workareaX; /*-------------------------------*/ y = workareaY + workareaHeight - height; /*-------*/ windowGravity = SOUTH_WEST_POINT_WINDOW_GRAVITY; /*-*/ brk;
		to BOTTOM_RIGHT_WORKAREA_POSITION: /*-*/ width = workareaWidth / 2; /*-----*/ height = workareaHeight / 2; /*-----*/ x = workareaX + workareaWidth - width; /*-------*/ y = workareaY + workareaHeight - height; /*-------*/ windowGravity = SOUTH_EAST_POINT_WINDOW_GRAVITY; /*-*/ brk;
		to CENTER_WORKAREA_POSITION: /*-------*/ width = workareaWidth * 3 / 4; /*-*/ height = workareaHeight * 3 / 4; /*-*/ x = workareaX + (workareaWidth - width) / 2; /*-*/ y = workareaY + (workareaHeight - height) / 2; /*-*/ windowGravity = CENTER_POINT_WINDOW_GRAVITY; /*-----*/ brk;
		to FULL_WORKAREA_POSITION: /*---------*/ width = workareaWidth / 1; /*-----*/ height = workareaHeight / 1; /*-----*/ x = workareaX; /*-------------------------------*/ y = workareaY; /*---------------------------------*/ windowGravity = NONE_WINDOW_GRAVITY; /*-------------*/ brk;
		off: /*-------------------------------*/ /*--------------------------------*/ /*----------------------------------*/ /*----------------------------------------------*/ /*------------------------------------------------*/ /*--------------------------------------------------*/ ret false;
	end
	if(!moveResizeClient(clientSystem, client, x, y, width, height, false, true, false, false, true, windowGravity)){
		ret false;
	}
	(*client).workareaPosition = workareaPosition;
	switch workareaPosition over
		to NONE_WORKAREA_POSITION: /*---------*/ /*------------------------------------------------------------------------------------------------*/ ret false;
		to TOP_WORKAREA_POSITION: /*----------*/ (*client).option |= HORIZONTALLY_MAXIMIZED_CLIENT_OPTION; /*--------------------------------------*/ brk;
		to BOTTOM_WORKAREA_POSITION: /*-------*/ (*client).option |= HORIZONTALLY_MAXIMIZED_CLIENT_OPTION; /*--------------------------------------*/ brk;
		to LEFT_WORKAREA_POSITION: /*---------*/ (*client).option |= VERTICALLY_MAXIMIZED_CLIENT_OPTION; /*----------------------------------------*/ brk;
		to RIGHT_WORKAREA_POSITION: /*--------*/ (*client).option |= VERTICALLY_MAXIMIZED_CLIENT_OPTION; /*----------------------------------------*/ brk;
		to TOP_LEFT_WORKAREA_POSITION: /*-----*/ /*------------------------------------------------------------------------------------------------*/ brk;
		to TOP_RIGHT_WORKAREA_POSITION: /*----*/ /*------------------------------------------------------------------------------------------------*/ brk;
		to BOTTOM_LEFT_WORKAREA_POSITION: /*--*/ /*------------------------------------------------------------------------------------------------*/ brk;
		to BOTTOM_RIGHT_WORKAREA_POSITION: /*-*/ /*------------------------------------------------------------------------------------------------*/ brk;
		to CENTER_WORKAREA_POSITION: /*-------*/ /*------------------------------------------------------------------------------------------------*/ brk;
		to FULL_WORKAREA_POSITION: /*---------*/ (*client).option |= HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION; /*-*/ brk;
		off: /*-------------------------------*/ /*------------------------------------------------------------------------------------------------*/ ret false;
	end
	ret true;
}
UPDATEVIRTUALROOTWORKAREACLIENT(){
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or !clientSystem or !isValidClient(clientSystem, client) or (*client).strut or (*client).stateState != NORMAL_STATE or (((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) != (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE) and !((*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION)))){
		ret false;
	}
	moveResizeWorkareaClient(virtualRootSystem, monitorSystem, clientSystem, client, SELF_WHICH_MONITOR, (*client).workareaPosition);
	ret true;
}
UPDATEVIRTUALROOTWORKAREACLIENTS(){
	VirtualRoot *current;
	VirtualRoot *wall;
	Client *clientStart;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !(*virtualRootSystem).workareaEdgeOffsetSize or !monitorSystem or !(*monitorSystem).size or (*monitorSystem).size != (*virtualRootSystem).workareaEdgeOffsetSize or !clientSystem or !(*clientSystem).clientAllocated){
		ret false;
	}
	current = (*virtualRootSystem).virtualRootStart;
	wall = current + (*virtualRootSystem).virtualRootAllocated;
	clientStart = (*clientSystem).clientStart;
	jmp updateVirtualRootLoop;
	updateVirtualRootLoop:{
		if(current < wall){
			if((*current).orderedClientOffsetAllocated){
				uint *ordedredClientOffsetCurrent = (*current).orderedClientOffsetStart;
				uint *const ordedredClientOffsetWall = ordedredClientOffsetCurrent + (*current).orderedClientOffsetAllocated;
				jmp updateClientLoop;
				updateClientLoop:{
					if(ordedredClientOffsetCurrent < ordedredClientOffsetWall){
						Client *const client = clientStart + *ordedredClientOffsetCurrent;
						if(!(*client).strut and (*client).stateState == NORMAL_STATE and (((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) == (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE) or (*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION))){
							const EdgeOffset *outerEdgeOffset;
							const EdgeOffset *innerEdgeOffset;
							const uint8 option = (*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
							const uint8 workareaPosition = (*client).workareaPosition;
							Monitor *monitor;
							uint monitorOffset;
							int workareaX;
							int workareaY;
							int workareaWidth;
							int workareaHeight;
							if(!(monitor = findRectangleMonitor(monitorSystem, (*client).containerX, (*client).containerY, (*client).containerWidth + 2 * (*client).containerBorder, (*client).containerHeight + 2 * (*client).containerBorder))){
								ret false;
							}
							monitorOffset = monitor - (*monitorSystem).start;
							outerEdgeOffset = (*virtualRootSystem).workareaEdgeOffsetStart + monitorOffset;
							innerEdgeOffset = (*current).workareaEdgeOffsetStart + monitorOffset;
							workareaX = (*monitor).leftX + (*outerEdgeOffset).left + (*innerEdgeOffset).left;
							workareaY = (*monitor).topY + (*outerEdgeOffset).top + (*innerEdgeOffset).top;
							workareaWidth = (*monitor).width - (*outerEdgeOffset).left - (*innerEdgeOffset).left - (*innerEdgeOffset).right - (*outerEdgeOffset).right;
							workareaHeight = (*monitor).height - (*outerEdgeOffset).top - (*innerEdgeOffset).top - (*innerEdgeOffset).bottom - (*outerEdgeOffset).bottom;
							if(((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) == (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE) or ((*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION)) == (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION)){
								moveResizeClient(clientSystem, client, workareaX, workareaY, workareaWidth, workareaHeight, false, false, true, false, true, NONE_WINDOW_GRAVITY);
							}elif((*client).option & HORIZONTALLY_MAXIMIZED_CLIENT_OPTION){
								moveResizeClient(clientSystem, client, workareaX, (*client).containerY, workareaWidth, (*client).containerHeight + 2 * (*client).containerBorder, false, false, true, false, true, NONE_WINDOW_GRAVITY);
							}else{
								moveResizeClient(clientSystem, client, (*client).containerX, workareaY, (*client).containerWidth + 2 * (*client).containerBorder, workareaHeight, false, false, true, false, true, NONE_WINDOW_GRAVITY);
							}
							(*client).option |= option;
							(*client).workareaPosition = workareaPosition;
						}
						inc ordedredClientOffsetCurrent;
						jmp updateClientLoop;
					}
				}
			}
			inc current;
			jmp updateVirtualRootLoop;
		}
		ret true;
	}
}
SHOWVIRTUALROOTDESKTOP(){
	VirtualRoot *virtualRoot;
	uint *current;
	uint *wall;
	if(!virtualRootSystem or !clientSystem or !(*clientSystem).clientAllocated or showDesktop == (*virtualRootSystem).showingDesktop or which >= (*virtualRootSystem).virtualRootAllocated or which == NONE_DESKTOP){
		ret false;
	}
	virtualRoot = (*virtualRootSystem).virtualRootStart + which;
	current = (*virtualRoot).orderedClientOffsetStart;
	wall = current + (*virtualRoot).orderedClientOffsetAllocated;
	jmp showDesktopLoop;
	showDesktopLoop:{
		if(current < wall){
			Client *const client = (*clientSystem).clientStart + *current;
			if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION) and !((*client).windowType & (DESKTOP_WINDOW_TYPE | DOCK_WINDOW_TYPE))){
				if(showDesktop){
					if((*client).stateState & NORMAL_STATE){
						xcb_unmap_window(connection, (*client).container);
						(*client).option |= TEMPORARILY_UNMAPPED_CLIENT_OPTION;
					}
				}else{
					if((*client).option & TEMPORARILY_UNMAPPED_CLIENT_OPTION){
						xcb_map_window(connection, (*client).container);
						(*client).option &= ~TEMPORARILY_UNMAPPED_CLIENT_OPTION;
					}
				}
			}
			inc current;
			jmp showDesktopLoop;
		}
		(*virtualRootSystem).showingDesktop = showDesktop;
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_SHOWING_DESKTOP, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &(*virtualRootSystem).showingDesktop);
		ret true;
	}
}
DESTROYVIRTUALROOT(){
	if(!virtualRootSystem or !isValidVirtualRoot(virtualRootSystem, virtualRoot)){
		ret false;
	}
	if((*virtualRoot).gc){
		xcb_free_gc(connection, (*virtualRoot).gc);
		(*virtualRoot).gc = XCB_NONE;
	}
	if((*virtualRoot).pixmap){
		xcb_free_pixmap(connection, (*virtualRoot).pixmap);
		(*virtualRoot).pixmap = XCB_NONE;
	}
	if((*virtualRoot).window){
		xcb_destroy_window(connection, (*virtualRoot).window);
		(*virtualRoot).window = XCB_NONE;
	}
	free((*virtualRoot).workareaEdgeOffsetStart);
	popPointer((*virtualRoot).workareaEdgeOffsetToken);
	(*virtualRoot).workareaEdgeOffsetSize = 0;
	(*virtualRoot).workareaEdgeOffsetStart = NULL;
	(*virtualRoot).workareaEdgeOffsetToken = 0;
	free((*virtualRoot).nameStart);
	popPointer((*virtualRoot).nameToken);
	(*virtualRoot).nameSize = 0;
	(*virtualRoot).nameStart = NULL;
	(*virtualRoot).nameToken = 0;
	free((*virtualRoot).orderedClientOffsetStart);
	popPointer((*virtualRoot).orderedClientOffsetToken);
	(*virtualRoot).orderedClientOffsetSize = 0;
	(*virtualRoot).orderedClientOffsetAllocated = 0;
	(*virtualRoot).orderedClientOffsetStart = NULL;
	(*virtualRoot).orderedClientOffsetToken = 0;
	ret true;
}
ISVALIDVIRTUALROOT(){
	ret virtualRootSystem and virtualRoot and virtualRoot >= (*virtualRootSystem).virtualRootStart and virtualRoot < (*virtualRootSystem).virtualRootStart + (*virtualRootSystem).virtualRootAllocated;
}
FINDVIRTUALROOT(){
	VirtualRoot *current;
	VirtualRoot *wall;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !window){
		ret NULL;
	}
	current = (*virtualRootSystem).virtualRootStart;
	wall = current + (*virtualRootSystem).virtualRootAllocated;
	jmp findVirtualRootLoop;
	findVirtualRootLoop:{
		if(current < wall){
			if((*current).window == window){
				ret current;
			}
			inc current;
			jmp findVirtualRootLoop;
		}
		ret NULL;
	}
}
FINDORDEREDVIRTUALROOTCLIENTOFFSET(){
	uint *current;
	uint *wall;
	Client *clientStart;
	if(!virtualRootSystem or !isValidVirtualRoot(virtualRootSystem, virtualRoot) or !(*virtualRoot).orderedClientOffsetAllocated or !clientSystem or !(*clientSystem).clientAllocated or !window){
		ret NULL;
	}
	current = (*virtualRoot).orderedClientOffsetStart;
	wall = current + (*virtualRoot).orderedClientOffsetAllocated;
	clientStart = (*clientSystem).clientStart;
	jmp findOrderedVirtualRootClientOffsetLoop;
	findOrderedVirtualRootClientOffsetLoop:{
		if(current < wall){
			if((*(clientStart + *current)).window == window){
				ret current;
			}
			inc current;
			jmp findOrderedVirtualRootClientOffsetLoop;
		}
		ret NULL;
	}
}
FINDPOSITIONEDORDEREDVIRTUALROOTCLIENT(){
	VirtualRoot *virtualRoot;
	uint *start;
	uint *current;
	Client *clientStart;
	if(!virtualRootSystem or !clientSystem or !(*clientSystem).clientAllocated or which >= (*virtualRootSystem).virtualRootAllocated or which == NONE_DESKTOP or which == 0xFFFFFFFF){
		ret NULL;
	}
	virtualRoot = (*virtualRootSystem).virtualRootStart + which;
	if(!isValidVirtualRoot(virtualRootSystem, virtualRoot) or !(*virtualRoot).orderedClientOffsetStart){
		ret NULL;
	}
	start = (*virtualRoot).orderedClientOffsetStart;
	current = start + (*virtualRoot).orderedClientOffsetAllocated - 1;
	clientStart = (*clientSystem).clientStart;
	jmp findPositionedOrderedVirtualRootClientLoop;
	findPositionedOrderedVirtualRootClientLoop:{
		if(current >= start){
			Client *const client = clientStart + *current;
			if((*client).inUse and (*client).containerX <= x and (*client).containerX + (int)((*client).containerWidth + 2 * (*client).containerBorder) > x and (*client).containerY <= y and (*client).containerY + (int)((*client).containerHeight + 2 * (*client).containerBorder) > y){
				ret client;
			}
			dec current;
			jmp findPositionedOrderedVirtualRootClientLoop;
		}
		ret NULL;
	}
}
FINIVIRTUALROOTSYSTEM(){
	VirtualRoot *current;
	VirtualRoot *wall;
	if(!virtualRootSystem){
		ret false;
	}
	if((*virtualRootSystem).virtualRootAllocated){
		current = (*virtualRootSystem).virtualRootStart;
		wall = current + (*virtualRootSystem).virtualRootAllocated;
		jmp destroyVirtualRootLoop;
		destroyVirtualRootLoop:{
			if(current < wall){
				destroyVirtualRoot(virtualRootSystem, current);
				inc current;
				jmp destroyVirtualRootLoop;
			}
		}
	}
	(*virtualRootSystem).width = 0;
	(*virtualRootSystem).height = 0;
	(*virtualRootSystem).currentDesktop = NONE_DESKTOP;
	(*virtualRootSystem).showingDesktop = false;
	(*virtualRootSystem).desktopLayoutColumns = 0;
	(*virtualRootSystem).desktopLayoutRows = 0;
	(*virtualRootSystem).desktopLayoutOrientation = _NET_WM_ORIENTATION_HORZ;
	(*virtualRootSystem).desktopLayoutStartingCorner = _NET_WM_TOPLEFT;
	(*virtualRootSystem).mapped = false;
	free((*virtualRootSystem).workareaStart);
	popPointer((*virtualRootSystem).workareaToken);
	(*virtualRootSystem).workareaSize = 0;
	(*virtualRootSystem).workareaStart = NULL;
	(*virtualRootSystem).workareaToken = 0;
	free((*virtualRootSystem).desktopNamesStart);
	popPointer((*virtualRootSystem).desktopNamesToken);
	(*virtualRootSystem).desktopNamesSize = 0;
	(*virtualRootSystem).desktopNamesStart = NULL;
	(*virtualRootSystem).desktopNamesToken = 0;
	free((*virtualRootSystem).viewportStart);
	popPointer((*virtualRootSystem).viewportToken);
	(*virtualRootSystem).viewportSize = 0;
	(*virtualRootSystem).viewportStart = NULL;
	(*virtualRootSystem).viewportToken = 0;
	free((*virtualRootSystem).windowStart);
	popPointer((*virtualRootSystem).windowToken);
	(*virtualRootSystem).windowSize = 0;
	(*virtualRootSystem).windowStart = NULL;
	(*virtualRootSystem).windowToken = 0;
	free((*virtualRootSystem).workareaEdgeOffsetStart);
	popPointer((*virtualRootSystem).workareaEdgeOffsetToken);
	(*virtualRootSystem).workareaEdgeOffsetSize = 0;
	(*virtualRootSystem).workareaEdgeOffsetStart = NULL;
	(*virtualRootSystem).workareaEdgeOffsetToken = 0;
	free((*virtualRootSystem).virtualRootStart);
	popPointer((*virtualRootSystem).virtualRootToken);
	(*virtualRootSystem).virtualRootSize = 0;
	(*virtualRootSystem).virtualRootAllocated = 0;
	(*virtualRootSystem).virtualRootStart = NULL;
	(*virtualRootSystem).virtualRootToken = 0;
	ret true;
}
INITCLIENTLISTSYSTEM(){
	#define CLIENT_LIST_BLOCK_SIZE /*-*/ (16)
	if(!clientListSystem){
		ret false;
	}
	(*clientListSystem).clientSize = 0;
	(*clientListSystem).clientAllocated = 0;
	(*clientListSystem).clientStart = NULL;
	(*clientListSystem).clientToken = 0;
	(*clientListSystem).property = XCB_NONE;
	ret true;
}
SETCLIENTLISTPROPERTY(){
	if(!clientListSystem or !property){
		ret false;
	}
	(*clientListSystem).property = property;
	ret true;
}
ADDCLIENTLISTWINDOW(){
	if(!clientListSystem){
		ret false;
	}
	if((*clientListSystem).clientAllocated == (*clientListSystem).clientSize){
		void *temp;
		(*clientListSystem).clientSize += CLIENT_LIST_BLOCK_SIZE;
		temp = realloc((*clientListSystem).clientStart, (*clientListSystem).clientSize * sizeof(xcb_window_t));
		if(!(*clientListSystem).clientToken){
			(*clientListSystem).clientToken = pushPointer(temp, "client list window pointer", iFree);
		}else{
			updatePointer((*clientListSystem).clientToken, temp);
		}
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for client list");
			(*clientListSystem).clientSize -= CLIENT_LIST_BLOCK_SIZE;
			ret false;
		}
		(*clientListSystem).clientStart = temp;
	}
	*((*clientListSystem).clientStart + (*clientListSystem).clientAllocated) = window;
	inc (*clientListSystem).clientAllocated;
	ret true;
}
CONFIGURECLIENTLISTCLIENT(){
	Client *siblingClient;
	uint8 stackMode;
	xcb_window_t sibling;
	if(!clientListSystem or !clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	if((siblingClient = findBelowManagedClient(clientSystem, client))){
		stackMode = XCB_STACK_MODE_ABOVE;
		sibling = (*siblingClient).window;
	}else{
		stackMode = XCB_STACK_MODE_BELOW;
		sibling = XCB_NONE;
	}
	if(!restackClientListWindow(clientListSystem, (*client).window, stackMode, sibling)){
		ret false;
	}
	ret true;
}
RESTACKCLIENTLISTWINDOW(){
	xcb_window_t *start;
	xcb_window_t *current;
	xcb_window_t *wall;
	xcb_window_t copy;
	if(!clientListSystem or !(*clientListSystem).clientAllocated){
		ret false;
	}
	start = (*clientListSystem).clientStart;
	wall = start + (*clientListSystem).clientAllocated;
	switch stackMode over
		to XCB_STACK_MODE_ABOVE: /*-*/ jmp stackModeAbove;
		to XCB_STACK_MODE_BELOW: /*-*/ jmp stackModeBelow;
		off: /*---------------------*/ ret false;
	end
	stackModeAbove:{
		xcb_window_t *siblingWindow = wall - 1;
		if(!(current = findClientListWindow(clientListSystem, window))){
			ret false;
		}
		if(sibling and !(siblingWindow = findClientListWindow(clientListSystem, sibling))){
			ret false;
		}
		if(current == siblingWindow or current == siblingWindow + 1){
			ret false;
		}
		copy = *current;
		if(current < siblingWindow){
			shiftMemory(current + 1, (siblingWindow - current) * sizeof(xcb_window_t), -(int)sizeof(xcb_window_t));
			*siblingWindow = copy;
			ret true;
		}
		shiftMemory(siblingWindow + 1, (current - siblingWindow - 1) * sizeof(xcb_window_t), sizeof(xcb_window_t));
		*(siblingWindow + 1) = copy;
		ret true;
	}
	stackModeBelow:{
		xcb_window_t *siblingWindow = start;
		if(!(current = findClientListWindow(clientListSystem, window))){
			ret false;
		}
		if(sibling and !(siblingWindow = findClientListWindow(clientListSystem, sibling))){
			ret false;
		}
		if(current == siblingWindow or current == siblingWindow - 1){
			ret false;
		}
		copy = *current;
		if(current < siblingWindow){
			shiftMemory(current + 1, (siblingWindow - current - 1) * sizeof(xcb_window_t), -(int)sizeof(xcb_window_t));
			*(siblingWindow - 1) = copy;
			ret true;
		}
		shiftMemory(siblingWindow, (current - siblingWindow) * sizeof(xcb_window_t), sizeof(xcb_window_t));
		*siblingWindow = copy;
		ret true;
	}
}
CHANGECLIENTLISTPROPERTY(){
	if(!clientListSystem or !(*clientListSystem).property){
		ret false;
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, (*clientListSystem).property, XCB_ATOM_WINDOW, bitsof(xcb_window_t), (*clientListSystem).clientAllocated, (*clientListSystem).clientStart);
	ret true;
}
REMOVECLIENTLISTWINDOW(){
	xcb_window_t *current;
	if(!(current = findClientListWindow(clientListSystem, window))){
		ret false;
	}
	shiftMemory(current + 1, ((*clientListSystem).clientStart + (*clientListSystem).clientAllocated - current - 1) * sizeof(xcb_window_t), -(int)sizeof(xcb_window_t));
	dec (*clientListSystem).clientAllocated;
	ret true;
}
FINDCLIENTLISTWINDOW(){
	xcb_window_t *current;
	xcb_window_t *wall;
	if(!clientListSystem or !(*clientListSystem).clientStart or !window){
		ret NULL;
	}
	current = (*clientListSystem).clientStart;
	wall = current + (*clientListSystem).clientAllocated;
	jmp findClientListWindowLoop;
	findClientListWindowLoop:{
		if(current < wall){
			if(*current == window){
				ret current;
			}
			inc current;
			jmp findClientListWindowLoop;
		}
		ret NULL;
	}
}
FINICLIENTLISTSYSTEM(){
	if(!clientListSystem){
		ret false;
	}
	free((*clientListSystem).clientStart);
	popPointer((*clientListSystem).clientToken);
	(*clientListSystem).clientSize = 0;
	(*clientListSystem).clientAllocated = 0;
	(*clientListSystem).clientStart = NULL;
	(*clientListSystem).clientToken = 0;
	(*clientListSystem).property = XCB_NONE;
	ret true;
	#undef  CLIENT_LIST_BLOCK_SIZE
}
INITWINDOWMANAGERSYSTEM(){
	jmp updateSelection;
	updateSelection:{
		previousWMSelectionWindow = XCB_NONE;
		wmSelectionTimestamp = getTimestamp();
		jmp selectInput;
	}
	initSystems:{
		uint32 valueMask;
		struct{
			uint32 /*-------*/ eventMask;
			xcb_cursor_t /*-*/ cursor;
		} valueList;
		setCursor(&cursorSystem, LEFT_POINTER_CURSOR_GLYPH, 0x00171717, 0x00E8E8E8);
		setWallpaperColor(&wallpaperSystem, &monitorSystem, 0xFF171717);
		setWallpaperPixmap(&wallpaperSystem, &monitorSystem, atom._XROOTPMAP_ID);
		createWallpaper(&wallpaperSystem, &monitorSystem, screenWidthInPixels, screenHeightInPixels);
		resizeVirtualRoot(&virtualRootSystem, &monitorSystem, &wallpaperSystem, &clientSystem, screenWidthInPixels, screenHeightInPixels);
		setVirtualRootAmount(&virtualRootSystem, &monitorSystem, &clientSystem, &cursorSystem, 10);
		setVirtualRootWallpaper(&virtualRootSystem, &wallpaperSystem);
		mapVirtualRoots(&virtualRootSystem);
		valueMask = XCB_CW_EVENT_MASK;
		if(cursorSystem.cursor){
			valueMask |= XCB_CW_CURSOR;
			valueList.cursor = cursorSystem.cursor;
		}
		wmCheckWindow = xcb_generate_id(connection);
		defaultFocusWindow = xcb_generate_id(connection);
		glassWindow = xcb_generate_id(connection);
		xcb_create_window(connection, XCB_COPY_FROM_PARENT, wmCheckWindow, (*screen).root, -1, -1, 1, 1, 0, XCB_WINDOW_CLASS_INPUT_ONLY, (*screen).root_visual, XCB_NONE, NULL);
		valueList.eventMask = XCB_EVENT_MASK_FOCUS_CHANGE;
		xcb_create_window(connection, XCB_COPY_FROM_PARENT, defaultFocusWindow, (*screen).root, -1, -1, 1, 1, 0, XCB_WINDOW_CLASS_INPUT_ONLY, (*screen).root_visual, XCB_CW_EVENT_MASK, &valueList);
		valueList.eventMask = XCB_EVENT_MASK_KEY_RELEASE | XCB_EVENT_MASK_BUTTON_RELEASE | XCB_EVENT_MASK_POINTER_MOTION;
		xcb_create_window(connection, XCB_COPY_FROM_PARENT, glassWindow, (*screen).root, 0, 0, screenWidthInPixels, screenHeightInPixels, 0, XCB_WINDOW_CLASS_INPUT_ONLY, (*screen).root_visual, valueMask, &valueList);
		xcb_map_window(connection, defaultFocusWindow);
		xcb_set_input_focus(connection, XCB_INPUT_FOCUS_POINTER_ROOT, defaultFocusWindow, getTimestamp());
		/*! set desktop layout here if not set already */
		setClientListProperty(&clientListSystem, atom._NET_CLIENT_LIST);
		setClientListProperty(&clientListStackingSystem, atom._NET_CLIENT_LIST_STACKING);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, wmCheckWindow, atom._NET_WM_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, wmCheckWindow, atom._NET_SUPPORTING_WM_CHECK, XCB_ATOM_WINDOW, bitsof(xcb_window_t), 1, &wmCheckWindow);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, defaultFocusWindow, atom.WM_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, defaultFocusWindow, atom._NET_WM_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_SUPPORTING_WM_CHECK, XCB_ATOM_WINDOW, bitsof(xcb_window_t), 1, &wmCheckWindow);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_WM_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
		setNetSupported();
		changeActiveWindow(&clientSystem);
		jmp announce;
	}
	announce:{
		xcb_client_message_event_t message;
		uint32 *const data = message.data.data32;
		message.response_type = XCB_CLIENT_MESSAGE;
		message.format = 32;
		message.window = (*screen).root;
		message.type = atom.MANAGER;
		*(data + 0) = getTimestamp();
		*(data + 1) = atom.WM_Sn;
		*(data + 2) = wmSelectionWindow;
		*(data + 3) = 0;
		*(data + 4) = 0;
		xcb_send_event(connection, false, message.window, XCB_EVENT_MASK_STRUCTURE_NOTIFY, &message);
		ret true;
	}
}
SETNETSUPPORTED(){
	#define UNSUPPORTED(a) /*--*/ EMPTY_MACRO
	#define INITIALIZE(a) /*---*/ XCB_NONE,
	#define APPEND(a) /*-------*/ *current = atom.a; inc current;
	#define ATOM(SUPPORTED) /*-*/ { \
		  SUPPORTED(_NET_SUPPORTED) \
		  SUPPORTED(_NET_CLIENT_LIST) \
		  SUPPORTED(_NET_CLIENT_LIST_STACKING) \
		  SUPPORTED(_NET_NUMBER_OF_DESKTOPS) \
		  SUPPORTED(_NET_DESKTOP_GEOMETRY) \
		  SUPPORTED(_NET_DESKTOP_VIEWPORT) \
		  SUPPORTED(_NET_CURRENT_DESKTOP) \
		  SUPPORTED(_NET_DESKTOP_NAMES) \
		  SUPPORTED(_NET_ACTIVE_WINDOW) \
		  SUPPORTED(_NET_WORKAREA) \
		  SUPPORTED(_NET_SUPPORTING_WM_CHECK) \
		  SUPPORTED(_NET_VIRTUAL_ROOTS) \
		UNSUPPORTED(_NET_DESKTOP_LAYOUT) \
		  SUPPORTED(_NET_SHOWING_DESKTOP) \
		  SUPPORTED(_NET_CLOSE_WINDOW) \
		UNSUPPORTED(_NET_MOVERESIZE_WINDOW) \
		UNSUPPORTED(_NET_WM_MOVERESIZE) \
		  SUPPORTED(_NET_RESTACK_WINDOW) \
		  SUPPORTED(_NET_REQUEST_FRAME_EXTENTS) \
		  SUPPORTED(_NET_WM_NAME) \
		  SUPPORTED(_NET_WM_VISIBLE_NAME) \
		UNSUPPORTED(_NET_WM_ICON_NAME) \
		UNSUPPORTED(_NET_WM_VISIBLE_ICON_NAME) \
		  SUPPORTED(_NET_WM_DESKTOP) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_DESKTOP) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_DOCK) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_TOOLBAR) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_MENU) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_UTILITY) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_SPLASH) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_DIALOG) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_NORMAL) \
		  SUPPORTED(_NET_WM_STATE) \
		  SUPPORTED(_NET_WM_STATE_MODAL) \
		UNSUPPORTED(_NET_WM_STATE_STICKY) \
		  SUPPORTED(_NET_WM_STATE_MAXIMIZED_HORZ) \
		  SUPPORTED(_NET_WM_STATE_MAXIMIZED_VERT) \
		UNSUPPORTED(_NET_WM_STATE_SHADED) \
		  SUPPORTED(_NET_WM_STATE_SKIP_TASKBAR) \
		  SUPPORTED(_NET_WM_STATE_SKIP_PAGER) \
		  SUPPORTED(_NET_WM_STATE_HIDDEN) \
		  SUPPORTED(_NET_WM_STATE_FULLSCREEN) \
		  SUPPORTED(_NET_WM_STATE_ABOVE) \
		  SUPPORTED(_NET_WM_STATE_BELOW) \
		  SUPPORTED(_NET_WM_STATE_DEMANDS_ATTENTION) \
		  SUPPORTED(_NET_WM_ALLOWED_ACTIONS) \
		  SUPPORTED(_NET_WM_ACTION_MOVE) \
		  SUPPORTED(_NET_WM_ACTION_RESIZE) \
		  SUPPORTED(_NET_WM_ACTION_MINIMIZE) \
		UNSUPPORTED(_NET_WM_ACTION_SHADE) \
		UNSUPPORTED(_NET_WM_ACTION_STICK) \
		  SUPPORTED(_NET_WM_ACTION_MAXIMIZE_HORZ) \
		  SUPPORTED(_NET_WM_ACTION_MAXIMIZE_VERT) \
		  SUPPORTED(_NET_WM_ACTION_FULLSCREEN) \
		  SUPPORTED(_NET_WM_ACTION_CHANGE_DESKTOP) \
		  SUPPORTED(_NET_WM_ACTION_CLOSE) \
		  SUPPORTED(_NET_WM_STRUT) \
		  SUPPORTED(_NET_WM_STRUT_PARTIAL) \
		UNSUPPORTED(_NET_WM_ICON_GEOMETRY) \
		UNSUPPORTED(_NET_WM_ICON) \
		  SUPPORTED(_NET_WM_PID) \
		  SUPPORTED(_NET_WM_HANDLED_ICONS) \
		  SUPPORTED(_NET_WM_USER_TIME) \
		  SUPPORTED(_NET_FRAME_EXTENTS) \
		UNSUPPORTED(_NET_WM_PING) \
		UNSUPPORTED(_NET_WM_SYNC_REQUEST) \
		UNSUPPORTED(_NET_WM_SYNC_REQUEST_COUNTER) \
	}
	xcb_atom_t valueList[] = ATOM(INITIALIZE);
	xcb_atom_t *current = valueList;
	ATOM(APPEND);
	resetProperty((*screen).root, atom._NET_SUPPORTED, XCB_ATOM_ATOM, sizeof(xcb_atom_t), countof(valueList), valueList);
	ret true;
	#undef  ATOM
	#undef  APPEND
	#undef  INITIALIZE
	#undef  UNSUPPORTED
}
STORECLIENTPROPERTIES(){
	xcb_window_t container;
	xcb_window_t window;
	xcb_list_properties_reply_t *reply;
	uint32 token;
	if(!client){
		ret false;
	}
	container = (*client).container;
	window = (*client).window;
	reply = xcb_wait_for_reply(connection, xcb_list_properties(connection, window), NULL);
	token = pushPointer(reply, "storeClientProperties() list properties reply", iFree);
	if(reply){
		const uint length = xcb_list_properties_atoms_length(reply);
		if(length){
			const xcb_atom_t *current = xcb_list_properties_atoms(reply);
			const xcb_atom_t *const wall = current + length;
			jmp copyPropertyLoop;
			copyPropertyLoop:{
				xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property(connection, false, window, *current, XCB_GET_PROPERTY_TYPE_ANY, 0, 0xFFFFFFFF), NULL);
				uint32 token = pushPointer(reply, "storeClientProperties() get property reply", iFree);
				if(reply){
					const void *const value = xcb_get_property_value(reply);
					if(container){
						const uint size = (*reply).format / 8;
						uint length = xcb_get_property_value_length(reply);
						if(size){
							length /= size;
						}
						xcb_change_property(connection, XCB_PROP_MODE_REPLACE, container, *current, (*reply).type, (*reply).format, length, value);
					}
					storeClientProperty(client, *current, xcb_get_property_value_length(reply), value);
					free(reply);
					popPointer(token);
				}
				if(inc current < wall){
					jmp copyPropertyLoop;
				}
			}
		}
		free(reply);
		popPointer(token);
	}
	ret true;
}
STORECLIENTPROPERTY(){
	if(!client or !property){
		ret false;
	}
	if(property == atom.WM_NAME){
		if((*client).propertyPreference & NAME_PROPERTY_PREFERENCE or !length or !value){
			ret false;
		}
		if(!*((uint8 *)value + length / sizeof(uint8) - 1)){
			dec length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client WM_NAME pointer", &(*client).nameSize, &(*client).nameStart, &(*client).nameToken)){
			ret false;
		}
		if(reallocateProperty(sizeof(uint8), length, value, "client _NET_WM_VISIBLE_NAME pointer", &(*client).visibleNameSize, &(*client).visibleNameStart, &(*client).visibleNameToken)){
			xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_WM_VISIBLE_NAME, atom.UTF8_STRING, bitsof(uint8), (*client).visibleNameSize, (*client).visibleNameStart));
		}
		ret true;
	}
	if(property == atom.WM_ICON_NAME){
		if((*client).propertyPreference & ICON_NAME_PROPERTY_PREFERENCE or !length or !value){
			ret false;
		}
		if(!*((uint8 *)value + length / sizeof(uint8) - 1)){
			dec length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client WM_ICON_NAME pointer", &(*client).iconNameSize, &(*client).iconNameStart, &(*client).iconNameToken)){
			ret false;
		}
		if(reallocateProperty(sizeof(uint8), length, value, "client _NET_WM_VISIBLE_ICON_NAME pointer", &(*client).visibleIconNameSize, &(*client).visibleIconNameStart, &(*client).visibleIconNameToken)){
			xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_WM_VISIBLE_ICON_NAME, atom.UTF8_STRING, bitsof(uint8), (*client).visibleIconNameSize, (*client).visibleIconNameStart));
		}
		ret true;
	}
	if(property == atom.WM_NORMAL_HINTS){
		uint32 flags;
		if(!length or !value){
			ret false;
		}
		flags = *(uint32 *)value;
		(*client).normalHintsFlags |= flags;
		value = (uint32 *)value + 1;
		length -= 1 * sizeof(uint32);
		if(flags & (USER_POSITION_NORMAL_HINT | PROGRAM_POSITION_NORMAL_HINT) and length >= 2){
			(*client).normalHintsX = *((int32 *)value + 0);
			(*client).normalHintsY = *((int32 *)value + 1);
			value = (int32 *)value + 2;
			length -= 2 * sizeof(int32);
		}
		if(flags & (USER_SIZE_NORMAL_HINT | PROGRAM_SIZE_NORMAL_HINT) and length >= 2){
			(*client).normalHintsWidth = *((int32 *)value + 0);
			(*client).normalHintsHeight = *((int32 *)value + 1);
			value = (int32 *)value + 2;
			length -= 2 * sizeof(int32);
		}
		if(flags & PROGRAM_MINIMUM_SIZE_NORMAL_HINT and length >= 2){
			(*client).normalHintsMinWidth = *((int32 *)value + 0);
			(*client).normalHintsMinHeight = *((int32 *)value + 1);
			value = (int32 *)value + 2;
			length -= 2 * sizeof(int32);
		}
		if(flags & PROGRAM_MAXIMUM_SIZE_NORMAL_HINT and length >= 2){
			(*client).normalHintsMaxWidth = *((int32 *)value + 0);
			(*client).normalHintsMaxHeight = *((int32 *)value + 1);
			value = (int32 *)value + 2;
			length -= 2 * sizeof(int32);
		}
		if(flags & PROGRAM_RESIZE_INCREMENT_NORMAL_HINT and length >= 2){
			(*client).normalHintsWidthInc = *((int32 *)value + 0);
			(*client).normalHintsHeightInc = *((int32 *)value + 1);
			value = (int32 *)value + 2;
			length -= 2 * sizeof(int32);
		}
		if(flags & PROGRAM_ASPECT_NORMAL_HINT and length >= 4){
			(*client).normalHintsMinAspectNumerator = *((int32 *)value + 0);
			(*client).normalHintsMinAspectDenominator = *((int32 *)value + 1);
			(*client).normalHintsMaxAspectNumerator = *((int32 *)value + 2);
			(*client).normalHintsMaxAspectDenominator = *((int32 *)value + 3);
			value = (int32 *)value + 4;
			length -= 4 * sizeof(int32);
		}
		if(flags & PROGRAM_BASE_SIZE_NORMAL_HINT and length >= 2){
			(*client).normalHintsBaseWidth = *((int32 *)value + 0);
			(*client).normalHintsBaseHeight = *((int32 *)value + 1);
			value = (int32 *)value + 2;
			length -= 2 * sizeof(int32);
		}
		if(flags & PROGRAM_WINDOW_GRAVITY_NORMAL_HINT and length >= 1){
			(*client).normalHintsWindowGravity = *((int32 *)value + 0);
			if((*client).normalHintsWindowGravity == XCB_GRAVITY_WIN_UNMAP){
				(*client).normalHintsWindowGravity = XCB_GRAVITY_NORTH_WEST;
			}
		}
		if(!(*client).normalHintsMinWidth){
			(*client).normalHintsMinWidth = (*client).normalHintsBaseWidth;
			(*client).normalHintsMinHeight = (*client).normalHintsBaseHeight;
		}
		if(!(*client).normalHintsBaseWidth){
			(*client).normalHintsBaseWidth = (*client).normalHintsMinWidth;
			(*client).normalHintsBaseHeight = (*client).normalHintsMinHeight;
		}
		ret true;
	}
	if(property == atom.WM_HINTS){
		uint32 flags;
		if(!length or !value){
			ret false;
		}
		flags = *(uint32 *)value;
		value = (uint32 *)value + 1;
		length -= 1 * sizeof(uint32);
		if(flags & INPUT_HINT and length >= 1){
			(*client).hintsInput = !!*((uint32 *)value + 0);
			value = (uint32 *)value + 1;
			length -= 1 * sizeof(uint32);
		}
		if(flags & STATE_HINT and length >= 1){
			(*client).hintsInitialState = *((uint32 *)value + 0);
			if((*client).hintsInitialState != NORMAL_STATE and (*client).hintsInitialState != ICONIC_STATE){
				(*client).hintsInitialState = NORMAL_STATE;
			}
			value = (uint32 *)value + 1;
			length -= 1 * sizeof(uint32);
		}
		if(flags & ICON_PIXMAP_HINT and length >= 1){
			(*client).hintsIconPixmap = *((xcb_pixmap_t *)value + 0);
			value = (xcb_pixmap_t *)value + 1;
			length -= 1 * sizeof(xcb_pixmap_t);
		}
		if(flags & ICON_WINDOW_HINT and length >= 1){
			(*client).hintsIconWindow = *((xcb_window_t *)value + 0);
			value = (xcb_window_t *)value + 1;
			length -= 1 * sizeof(xcb_window_t);
		}
		if(flags & ICON_POSITION_HINT and length >= 2){
			(*client).hintsIconX = *((int32 *)value + 0);
			(*client).hintsIconY = *((int32 *)value + 1);
			value = (int32 *)value + 2;
			length -= 2 * sizeof(int32);
		}
		if(flags & ICON_MASK_HINT and length >= 1){
			(*client).hintsIconMask = *((xcb_pixmap_t *)value + 0);
			value = (xcb_pixmap_t *)value + 1;
			length -= 1 * sizeof(xcb_pixmap_t);
		}
		if(flags & WINDOW_GROUP_HINT and length >= 1){
			(*client).hintsWindowGroup = *((xcb_window_t *)value + 0);
		}
		if(flags & URGENCY_HINT){
			(*client).hintsUrgency = true;
		}
		ret true;
	}
	if(property == atom.WM_CLASS){
		if((*client).stateState != WITHDRAWN_STATE or !length or !value){
			ret false;
		}
		if(*((uint8 *)value + length / sizeof(uint8) - 1)){
			inc length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client WM_CLASS pointer", &(*client).classSize, &(*client).classStart, &(*client).classToken)){
			ret false;
		}
		*((*client).classStart + length / sizeof(uint8) - 1) = '\0';
		ret true;
	}
	if(property == atom.WM_TRANSIENT_FOR){
		if(length != sizeof(xcb_window_t) or !value){
			ret false;
		}
		(*client).transientFor = *(xcb_window_t *)value;
		/*! update stacking to keep the transient above its parent. */
		ret true;
	}
	if(property == atom.WM_PROTOCOLS){
		xcb_window_t *current;
		xcb_window_t *wall;
		if(!length or !value){
			ret false;
		}
		if(!reallocateProperty(sizeof(xcb_atom_t), length, value, "client WM_PROTOCOLS pointer", &(*client).protocolSize, (uint8 **)&(*client).protocolStart, &(*client).protocolToken)){
			ret false;
		}
		current = (*client).protocolStart;
		wall = current + (*client).protocolSize;
		(*client).protocol = NONE_CLIENT_PROTOCOL;
		jmp storeProtocolLoop;
		storeProtocolLoop:{
			const xcb_atom_t a = *current;
			if(a == atom.WM_TAKE_FOCUS){
				(*client).protocol |= TAKE_FOCUS_CLIENT_PROTOCOL;
			}elif(a == atom.WM_DELETE_WINDOW){
				(*client).protocol |= DELETE_WINDOW_CLIENT_PROTOCOL;
			}elif(a == atom._NET_WM_PING){
				(*client).protocol |= PING_CLIENT_PROTOCOL;
			}elif(a == atom._NET_WM_SYNC_REQUEST){
				(*client).protocol |= SYNC_CLIENT_PROTOCOL;
			}
			if(inc current < wall){
				jmp storeProtocolLoop;
			}
			ret true;
		}
	}
	if(property == atom.WM_COLORMAP_WINDOWS){
		const xcb_window_t *current;
		const xcb_window_t *wall;
		struct{
			uint32 /*-*/ eventMask;
		} valueList;
		if(!length or !value){
			ret false;
		}
		if(!reallocateProperty(sizeof(xcb_window_t), length, value, "client WM_COLORMAP_WINDOWS pointer", &(*client).colormapWindowSize, (uint8 **)&(*client).colormapWindowStart, &(*client).colormapWindowToken)){
			ret false;
		}
		current = (*client).colormapWindowStart;
		wall = current + (*client).colormapWindowSize;
		valueList.eventMask = XCB_EVENT_MASK_COLOR_MAP_CHANGE;
		jmp selectInputColormapLoop;
		selectInputColormapLoop:{
			if(!findClientWindow(&clientSystem, *current)){
				xcb_discard_reply(connection, xcb_change_window_attributes_checked(connection, *current, XCB_CW_EVENT_MASK, &valueList));
			}
			if(inc current < wall){
				jmp selectInputColormapLoop;
			}
			ret true;
		}
	}
	if(property == atom.WM_CLIENT_MACHINE){
		if(!length or !value){
			ret false;
		}
		if(!*((uint8 *)value + length / sizeof(uint8) - 1)){
			dec length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client WM_CLIENT_MACHINE pointer", &(*client).clientMachineSize, &(*client).clientMachineStart, &(*client).clientMachineToken)){
			ret false;
		}
		ret true;
	}
	if(property == atom.SM_CLIENT_ID){
		if(!length or !value){
			ret false;
		}
		if(!*((uint8 *)value + length / sizeof(uint8) - 1)){
			dec length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client SM_CLIENT_ID pointer", &(*client).clientIDSize, &(*client).clientIDStart, &(*client).clientIDToken)){
			ret false;
		}
		ret true;
	}
	if(property == atom.WM_CLIENT_LEADER){
		if(length != sizeof(xcb_window_t) or !value){
			ret false;
		}
		(*client).clientLeader = *(xcb_window_t *)value;
		ret true;
	}
	if(property == atom.WM_WINDOW_ROLE){
		if(!length or !value){
			ret false;
		}
		if(!*((uint8 *)value + length / sizeof(uint8) - 1)){
			dec length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client WM_WINDOW_ROLE pointer", &(*client).windowRoleSize, &(*client).windowRoleStart, &(*client).windowRoleToken)){
			ret false;
		}
		ret true;
	}
	if(property == atom.WM_STATE){
		resetProperty((*client).window, property, property, sizeof(uint32), 2, &(*client).stateState);
		ret true;
	}
	if(property == atom._NET_WM_NAME){
		if(!length or !value){
			ret false;
		}
		if(!*((uint8 *)value + length / sizeof(uint8) - 1)){
			dec length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client _NET_WM_NAME pointer", &(*client).nameSize, &(*client).nameStart, &(*client).nameToken)){
			ret false;
		}
		(*client).propertyPreference |= NAME_PROPERTY_PREFERENCE;
		if(reallocateProperty(sizeof(uint8), length, value, "client _NET_WM_VISIBLE_NAME pointer", &(*client).visibleNameSize, &(*client).visibleNameStart, &(*client).visibleNameToken)){
			xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_WM_VISIBLE_NAME, atom.UTF8_STRING, bitsof(uint8), (*client).visibleNameSize, (*client).visibleNameStart));
		}
		ret true;
	}
	if(property == atom._NET_WM_VISIBLE_NAME){
		if(!(*client).visibleNameStart){
			xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, property));
			ret true;
		}
		resetProperty((*client).window, property, atom.UTF8_STRING, sizeof(uint8), (*client).visibleNameSize, (*client).visibleNameStart);
		ret true;
	}
	if(property == atom._NET_WM_ICON_NAME){
		if(!length or !value){
			ret false;
		}
		if(!*((uint8 *)value + length / sizeof(uint8) - 1)){
			dec length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client _NET_WM_ICON_NAME pointer", &(*client).iconNameSize, &(*client).iconNameStart, &(*client).iconNameToken)){
			ret false;
		}
		(*client).propertyPreference |= ICON_NAME_PROPERTY_PREFERENCE;
		if(reallocateProperty(sizeof(uint8), length, value, "client _NET_WM_VISIBLE_ICON_NAME pointer", &(*client).visibleIconNameSize, &(*client).visibleIconNameStart, &(*client).visibleIconNameToken)){
			xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_WM_VISIBLE_ICON_NAME, atom.UTF8_STRING, bitsof(uint8), (*client).visibleIconNameSize, (*client).visibleIconNameStart));
		}
		ret true;
	}
	if(property == atom._NET_WM_VISIBLE_ICON_NAME){
		if(!(*client).visibleIconNameStart){
			xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, property));
			ret true;
		}
		resetProperty((*client).window, property, atom.UTF8_STRING, sizeof(uint8), (*client).visibleIconNameSize, (*client).visibleIconNameStart);
		ret true;
	}
	if(property == atom._NET_WM_DESKTOP){
		if((*client).stateState != WITHDRAWN_STATE or length != sizeof(uint32) or !value){
			ret false;
		}
		moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, *(uint32 *)value, true);
		ret true;
	}
	if(property == atom._NET_WM_WINDOW_TYPE){
		const xcb_atom_t *current;
		const xcb_atom_t *wall;
		xcb_atom_t desktop;
		xcb_atom_t dock;
		xcb_atom_t toolbar;
		xcb_atom_t menu;
		xcb_atom_t utility;
		xcb_atom_t splash;
		xcb_atom_t dialog;
		xcb_atom_t normal;
		uint8 windowType;
		if((*client).stateState != WITHDRAWN_STATE or !length or !value){
			ret false;
		}
		current = value;
		wall = current + length / sizeof(xcb_atom_t);
		desktop = atom._NET_WM_WINDOW_TYPE_DESKTOP;
		dock = atom._NET_WM_WINDOW_TYPE_DOCK;
		toolbar = atom._NET_WM_WINDOW_TYPE_TOOLBAR;
		menu = atom._NET_WM_WINDOW_TYPE_MENU;
		utility = atom._NET_WM_WINDOW_TYPE_UTILITY;
		splash = atom._NET_WM_WINDOW_TYPE_SPLASH;
		dialog = atom._NET_WM_WINDOW_TYPE_DIALOG;
		normal = atom._NET_WM_WINDOW_TYPE_NORMAL;
		windowType = NONE_WINDOW_TYPE;
		jmp createWindowTypeLoop;
		createWindowTypeLoop:{
			if(current < wall){
				const xcb_atom_t a = *current;
				windowType |= (a == desktop) * DESKTOP_WINDOW_TYPE + (a == dock) * DOCK_WINDOW_TYPE + (a == toolbar) * TOOLBAR_WINDOW_TYPE + (a == menu) * MENU_WINDOW_TYPE + (a == utility) * UTILITY_WINDOW_TYPE + (a == splash) * SPLASH_WINDOW_TYPE + (a == dialog) * DIALOG_WINDOW_TYPE + (a == normal) * NORMAL_WINDOW_TYPE;
				inc current;
				jmp createWindowTypeLoop;
			}
		}
		if(windowType == (*client).windowType){
			ret false;
		}
		if(!reallocateProperty(sizeof(xcb_atom_t), length, value, "client _NET_WM_WINDOW_TYPE pointer", &(*client).windowTypeSize, (uint8 **)&(*client).windowTypeStart, &(*client).windowTypeToken)){
			ret false;
		}
		(*client).windowType = windowType;
		setDefaultClientWindowType(&clientSystem, client);
		if(setClientAllowedActions(&clientSystem, client)){
			changeClientAllowedActions(&clientSystem, client);
		}
		if(setClientOrderType(&clientSystem, client)){
			if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
				configureClient(&clientSystem, client);
				configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
				if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
					changeClientListProperty(&clientListStackingSystem);
				}
			}
		}
		ret true;
	}
	if(property == atom._NET_WM_STATE){
		const xcb_atom_t *current;
		const xcb_atom_t *wall;
		xcb_atom_t modal;
		xcb_atom_t sticky;
		xcb_atom_t maximizedVert;
		xcb_atom_t maximizedHorz;
		xcb_atom_t shaded;
		xcb_atom_t skipTaskbar;
		xcb_atom_t skipPager;
		xcb_atom_t hidden;
		xcb_atom_t fullscreen;
		xcb_atom_t above;
		xcb_atom_t below;
		xcb_atom_t demandsAttention;
		uint16 state;
		if((*client).stateState != WITHDRAWN_STATE or !length or !value){
			ret false;
		}
		current = value;
		wall = current + length / sizeof(xcb_atom_t);
		modal = atom._NET_WM_STATE_MODAL;
		sticky = atom._NET_WM_STATE_STICKY;
		maximizedHorz = atom._NET_WM_STATE_MAXIMIZED_HORZ;
		maximizedVert = atom._NET_WM_STATE_MAXIMIZED_VERT;
		shaded = atom._NET_WM_STATE_SHADED;
		skipTaskbar = atom._NET_WM_STATE_SKIP_TASKBAR;
		skipPager = atom._NET_WM_STATE_SKIP_PAGER;
		hidden = atom._NET_WM_STATE_HIDDEN;
		fullscreen = atom._NET_WM_STATE_FULLSCREEN;
		above = atom._NET_WM_STATE_ABOVE;
		below = atom._NET_WM_STATE_BELOW;
		demandsAttention = atom._NET_WM_STATE_DEMANDS_ATTENTION;
		state = NONE_STATE;
		jmp createaStateLoop;
		createaStateLoop:{
			if(current < wall){
				const xcb_atom_t a = *current;
				state |= (a == modal) * MODAL_STATE + (a == sticky) * STICKY_STATE + (a == maximizedHorz) * MAXIMIZED_HORZ_STATE + (a == maximizedVert) * MAXIMIZED_VERT_STATE + (a == shaded) * SHADED_STATE + (a == skipTaskbar) * SKIP_TASKBAR_STATE + (a == skipPager) * SKIP_PAGER_STATE + (a == hidden) * HIDDEN_STATE + (a == fullscreen) * FULLSCREEN_STATE + (a == above) * ABOVE_STATE + (a == below) * BELOW_STATE + (a == demandsAttention) * DEMANDS_ATTENTION_STATE;
				inc current;
				jmp createaStateLoop;
			}
		}
		if(state == (*client).state){
			ret false;
		}
		if(!reallocateProperty(sizeof(xcb_atom_t), length, value, "client _NET_WM_STATE pointer", &(*client).stateSize, (uint8 **)&(*client).stateStart, &(*client).stateToken)){
			ret false;
		}
		(*client).state = state;
		if(setClientAllowedActions(&clientSystem, client)){
			changeClientAllowedActions(&clientSystem, client);
		}
		if(setClientOrderType(&clientSystem, client)){
			if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
				configureClient(&clientSystem, client);
				configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
				if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
					changeClientListProperty(&clientListStackingSystem);
				}
			}
		}
		ret true;
	}
	if(property == atom._NET_WM_ALLOWED_ACTIONS){
		resetProperty((*client).window, property, XCB_ATOM_ATOM, sizeof(xcb_atom_t), (*client).allowedActionSize, (*client).allowedActionStart);
		ret true;
	}
	if(property == atom._NET_WM_STRUT){
		bool flag;
		if((*client).propertyPreference & STRUT_PROPERTY_PREFERENCE or length != 4 * sizeof(uint32) or !value){
			ret false;
		}
		(*client).strutLeft = *((uint32 *)value + 0);
		(*client).strutRight = *((uint32 *)value + 1);
		(*client).strutTop = *((uint32 *)value + 2);
		(*client).strutBottom = *((uint32 *)value + 3);
		(*client).strutLeftStartY = 0;
		(*client).strutLeftEndY = 0;
		(*client).strutRightStartY = 0;
		(*client).strutRightEndY = 0;
		(*client).strutTopStartX = 0;
		(*client).strutTopEndX = 0;
		(*client).strutBottomStartX = 0;
		(*client).strutBottomEndX = 0;
		flag = false;
		if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
			updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
			updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
			flag = true;
		}
		if(assignClientStrut(&clientSystem, &monitorSystem, client)){
			if(addVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
				updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, ADD_UPDATE_WORKAREA_ACTION);
				updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
				flag = true;
			}
		}
		if(flag){
			if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
				changeVirtualRootWorkarea(&virtualRootSystem);
			}
		}
		ret true;
	}
	if(property == atom._NET_WM_STRUT_PARTIAL){
		bool flag;
		if(length != 12 * sizeof(uint32) or !value){
			ret false;
		}
		(*client).strutLeft = *((uint32 *)value + 0);
		(*client).strutRight = *((uint32 *)value + 1);
		(*client).strutTop = *((uint32 *)value + 2);
		(*client).strutBottom = *((uint32 *)value + 3);
		(*client).strutLeftStartY = *((uint32 *)value + 4);
		(*client).strutLeftEndY = *((uint32 *)value + 5);
		(*client).strutRightStartY = *((uint32 *)value + 6);
		(*client).strutRightEndY = *((uint32 *)value + 7);
		(*client).strutTopStartX = *((uint32 *)value + 8);
		(*client).strutTopEndX = *((uint32 *)value + 9);
		(*client).strutBottomStartX = *((uint32 *)value + 10);
		(*client).strutBottomEndX = *((uint32 *)value + 11);
		(*client).propertyPreference |= STRUT_PROPERTY_PREFERENCE;
		flag = false;
		if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
			updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
			updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
			flag = true;
		}
		if(assignClientStrut(&clientSystem, &monitorSystem, client)){
			if(addVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
				updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, ADD_UPDATE_WORKAREA_ACTION);
				updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
				flag = true;
			}
		}
		if(flag){
			if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
				changeVirtualRootWorkarea(&virtualRootSystem);
			}
		}
		ret true;
	}
	if(property == atom._NET_WM_ICON_GEOMETRY){
		if(length != 4 * sizeof(uint32) or !value){
			ret false;
		}
		(*client).iconGeometryX = *((uint32 *)value + 0);
		(*client).iconGeometryY = *((uint32 *)value + 1);
		(*client).iconGeometryWidth = *((uint32 *)value + 2);
		(*client).iconGeometryHeight = *((uint32 *)value + 3);
		ret true;
	}
	if(property == atom._NET_WM_ICON){
		if(!length or !value){
			ret false;
		}
		if(!reallocateProperty(sizeof(uint32), length, value, "client _NET_WM_ICON pointer", &(*client).iconSize, (uint8 **)&(*client).iconStart, &(*client).iconToken)){
			ret false;
		}
		ret true;
	}
	if(property == atom._NET_WM_PID){
		if(length != sizeof(uint32) or !value){
			ret false;
		}
		(*client).pid = *(uint32 *)value;
		ret true;
	}
	if(property == atom._NET_WM_HANDLED_ICONS){
		(*client).handledIcons = true;
		ret true;
	}
	if(property == atom._NET_WM_USER_TIME){
		if(length != sizeof(uint32) or !value){
			ret false;
		}
		(*client).userTime = *(uint32 *)value;
		ret true;
	}
	if(property == atom._NET_FRAME_EXTENTS){
		resetProperty((*client).window, property, XCB_ATOM_CARDINAL, sizeof(uint32), 4, &(*client).frameExtentsLeft);
		ret true;
	}
	ret false;
}
REALLOCATEPROPERTY(){
	void *temp;
	uint32 tempToken;
	if(!length or !value or !sizeReturn or !startReturn or !tokenReturn){
		ret false;
	}
	temp = malloc(length * sizeof(uint8));
	tempToken = pushPointer(temp, label, iFree);
	if(!temp){
		ret false;
	}
	copyMemory(value, temp, length * sizeof(uint8));
	free(*startReturn);
	popPointer(*tokenReturn);
	*sizeReturn = length / itemSize;
	*startReturn = temp;
	*tokenReturn = tempToken;
	ret true;
}
UNSTORECLIENTPROPERTY(){
	if(!client or !property){
		ret false;
	}
	if(property == atom.WM_NAME){
		if((*client).propertyPreference & NAME_PROPERTY_PREFERENCE){
			ret false;
		}
		free((*client).nameStart);
		popPointer((*client).nameToken);
		(*client).nameStart = NULL;
		(*client).nameToken = 0;
		free((*client).visibleNameStart);
		popPointer((*client).visibleNameToken);
		(*client).visibleNameStart = NULL;
		(*client).visibleNameToken = 0;
		xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, atom._NET_WM_VISIBLE_NAME));
		ret true;
	}
	if(property == atom.WM_ICON_NAME){
		if((*client).propertyPreference & ICON_NAME_PROPERTY_PREFERENCE){
			ret false;
		}
		free((*client).iconNameStart);
		popPointer((*client).iconNameToken);
		(*client).iconNameStart = NULL;
		(*client).iconNameToken = 0;
		free((*client).visibleIconNameStart);
		popPointer((*client).visibleIconNameToken);
		(*client).visibleIconNameStart = NULL;
		(*client).visibleIconNameToken = 0;
		xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, atom._NET_WM_VISIBLE_ICON_NAME));
		ret true;
	}
	if(property == atom.WM_NORMAL_HINTS){
		(*client).normalHintsFlags = NONE_NORMAL_HINT;
		ret true;
	}
	if(property == atom.WM_HINTS){
		(*client).hintsInput = false;
		(*client).hintsInitialState = NORMAL_STATE;
		(*client).hintsIconPixmap = XCB_NONE;
		(*client).hintsIconWindow = XCB_NONE;
		(*client).hintsIconX = 0;
		(*client).hintsIconY = 0;
		(*client).hintsIconMask = XCB_NONE;
		(*client).hintsWindowGroup = XCB_NONE;
		(*client).hintsUrgency = false;
		ret true;
	}
	if(property == atom.WM_CLASS){
		free((*client).classStart);
		popPointer((*client).classToken);
		(*client).classStart = NULL;
		(*client).classToken = 0;
		ret true;
	}
	if(property == atom.WM_TRANSIENT_FOR){
		(*client).transientFor = XCB_NONE;
		if(((*client).windowType & (DIALOG_WINDOW_TYPE | NORMAL_WINDOW_TYPE)) == DIALOG_WINDOW_TYPE){
			/*! update window type. */
		}
		ret true;
	}
	if(property == atom.WM_PROTOCOLS){
		free((*client).protocolStart);
		popPointer((*client).protocolToken);
		(*client).protocol = NONE_CLIENT_PROTOCOL;
		(*client).protocolStart = NULL;
		(*client).protocolToken = 0;
		ret true;
	}
	if(property == atom.WM_COLORMAP_WINDOWS){
		free((*client).colormapWindowStart);
		popPointer((*client).colormapWindowToken);
		(*client).colormapWindowStart = NULL;
		(*client).colormapWindowToken = 0;
		ret true;
	}
	if(property == atom.WM_CLIENT_MACHINE){
		free((*client).clientMachineStart);
		popPointer((*client).clientMachineToken);
		(*client).clientMachineStart = NULL;
		(*client).clientMachineToken = 0;
		ret true;
	}
	if(property == atom.SM_CLIENT_ID){
		free((*client).clientIDStart);
		popPointer((*client).clientIDToken);
		(*client).clientIDStart = NULL;
		(*client).clientIDToken = 0;
		ret true;
	}
	if(property == atom.WM_CLIENT_LEADER){
		(*client).clientLeader = XCB_NONE;
		ret true;
	}
	if(property == atom.WM_WINDOW_ROLE){
		free((*client).windowRoleStart);
		popPointer((*client).windowRoleToken);
		(*client).windowRoleStart = NULL;
		(*client).windowRoleToken = 0;
		ret true;
	}
	if(property == atom.WM_STATE){
		if((*client).stateState != WITHDRAWN_STATE){
			resetProperty((*client).window, property, property, sizeof(uint32), 2, &(*client).stateState);
			ret false;
		}
		ret true;
	}
	if(property == atom._NET_WM_NAME){
		if(!((*client).propertyPreference & NAME_PROPERTY_PREFERENCE)){
			ret false;
		}
		free((*client).nameStart);
		popPointer((*client).nameToken);
		(*client).nameStart = NULL;
		(*client).nameToken = 0;
		free((*client).visibleNameStart);
		popPointer((*client).visibleNameToken);
		(*client).visibleNameStart = NULL;
		(*client).visibleNameToken = 0;
		xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, atom._NET_WM_VISIBLE_NAME));
		ret true;
	}
	if(property == atom._NET_WM_VISIBLE_NAME){
		if((*client).visibleNameStart){
			resetProperty((*client).window, property, atom.UTF8_STRING, sizeof(uint8), (*client).visibleNameSize, (*client).visibleNameStart);
			ret false;
		}
		ret true;
	}
	if(property == atom._NET_WM_ICON_NAME){
		if(!((*client).propertyPreference & ICON_NAME_PROPERTY_PREFERENCE)){
			ret false;
		}
		free((*client).iconNameStart);
		popPointer((*client).iconNameToken);
		(*client).iconNameStart = NULL;
		(*client).iconNameToken = 0;
		free((*client).visibleIconNameStart);
		popPointer((*client).visibleIconNameToken);
		(*client).visibleIconNameStart = NULL;
		(*client).visibleIconNameToken = 0;
		xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, atom._NET_WM_VISIBLE_ICON_NAME));
		ret true;
	}
	if(property == atom._NET_WM_VISIBLE_ICON_NAME){
		if((*client).visibleIconNameStart){
			resetProperty((*client).window, property, atom.UTF8_STRING, sizeof(uint8), (*client).visibleIconNameSize, (*client).visibleIconNameStart);
			ret false;
		}
		ret true;
	}
	if(property == atom._NET_WM_DESKTOP){
		if((*client).stateState != WITHDRAWN_STATE){
			resetProperty((*client).window, property, XCB_ATOM_CARDINAL, sizeof(uint32), 1, &(*client).desktop);
			ret false;
		}
		moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, NONE_DESKTOP, true);
		ret true;
	}
	if(property == atom._NET_WM_WINDOW_TYPE){
		free((*client).windowTypeStart);
		popPointer((*client).windowTypeToken);
		(*client).windowType = NONE_WINDOW_TYPE;
		(*client).windowTypeStart = NULL;
		(*client).windowTypeToken = 0;
		if((*client).stateState != WITHDRAWN_STATE){
			setDefaultClientWindowType(&clientSystem, client);
			if(setClientAllowedActions(&clientSystem, client)){
				changeClientAllowedActions(&clientSystem, client);
			}
			if(setClientOrderType(&clientSystem, client)){
				if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
					configureClient(&clientSystem, client);
					configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
					if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}
			}
		}
		ret true;
	}
	if(property == atom._NET_WM_STATE){
		if((*client).stateState != WITHDRAWN_STATE){
			resetProperty((*client).window, property, XCB_ATOM_ATOM, bitsof(xcb_atom_t), (*client).stateSize, (*client).stateStart);
			ret false;
		}
		free((*client).stateStart);
		popPointer((*client).stateToken);
		(*client).state = NONE_STATE;
		(*client).stateStart = NULL;
		(*client).stateToken = 0;
		ret true;
	}
	if(property == atom._NET_WM_ALLOWED_ACTIONS){
		if((*client).stateState != WITHDRAWN_STATE){
			resetProperty((*client).window, property, XCB_ATOM_ATOM, sizeof(xcb_atom_t), (*client).allowedActionSize, (*client).allowedActionStart);
			ret false;
		}
		free((*client).allowedActionStart);
		popPointer((*client).allowedActionToken);
		(*client).allowedAction = NONE_ALLOWED_ACTION;
		(*client).allowedActionStart = NULL;
		(*client).allowedActionToken = 0;
		ret true;
	}
	if(property == atom._NET_WM_STRUT){
		if(!((*client).propertyPreference & STRUT_PROPERTY_PREFERENCE)){
			if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
				updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
				updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
				if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
					xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_WORKAREA, XCB_ATOM_CARDINAL, bitsof(uint32), virtualRootSystem.virtualRootAllocated * 4, virtualRootSystem.workareaStart);
				}
			}
			(*client).strut = NONE_STRUT;
		}
		ret true;
	}
	if(property == atom._NET_WM_STRUT_PARTIAL){
		if((*client).propertyPreference & STRUT_PROPERTY_PREFERENCE){
			if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
				updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
				updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
				if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
					xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_WORKAREA, XCB_ATOM_CARDINAL, bitsof(uint32), virtualRootSystem.virtualRootAllocated * 4, virtualRootSystem.workareaStart);
				}
			}
			(*client).strut = NONE_STRUT;
		}
		ret true;
	}
	if(property == atom._NET_WM_ICON_GEOMETRY){
		(*client).iconGeometryX = 0;
		(*client).iconGeometryY = 0;
		(*client).iconGeometryWidth = 0;
		(*client).iconGeometryHeight = 0;
		ret true;
	}
	if(property == atom._NET_WM_ICON){
		free((*client).iconStart);
		popPointer((*client).iconToken);
		(*client).iconStart = NULL;
		(*client).iconToken = 0;
		ret true;
	}
	if(property == atom._NET_WM_PID){
		(*client).pid = 0;
		ret true;
	}
	if(property == atom._NET_WM_HANDLED_ICONS){
		(*client).handledIcons = false;
		ret true;
	}
	if(property == atom._NET_WM_USER_TIME){
		(*client).userTime = NONE_USER_TIME;
		ret true;
	}
	if(property == atom._NET_FRAME_EXTENTS){
		if((*client).stateState != WITHDRAWN_STATE){
			resetProperty((*client).window, property, XCB_ATOM_CARDINAL, sizeof(uint32), 4, &(*client).frameExtentsLeft);
			ret false;
		}
		(*client).frameExtentsLeft = 0;
		(*client).frameExtentsRight = 0;
		(*client).frameExtentsTop = 0;
		(*client).frameExtentsBottom = 0;
		ret true;
	}
	ret false;
}
FINDOWNEDWINDOW(){
	ret window == wmSelectionWindow or window == wmCheckWindow or window == defaultFocusWindow or window == glassWindow;
}
FINIWINDOWMANAGERSYSTEM(){
	ret true;
}
SETCONFIGVARIABLES(){
	focusOnClick = false;
	focusOnHover = false;
	focusOnClick = true;
	ret;
}
READCONFIG(){
	#define STATEMENT_BLOCK_SIZE /*-*/ (256)
	#define DEFAULT_CONFIG_PATH /*--*/ ("/etc/" PROGRAM_NAME "/" PROGRAM_NAME ".conf")
	const Instruction *const *currentScopeInstruction = globalScopeInstruction;
	const char *const *currentScopeInstructionList = globalInstructionList;
	const Instruction *instructionStart;
	const Instruction *instructionStartCopy;
	const Instruction *instructionCurrent;
	const Instruction *name0Instruction;
	const Instruction *name1Instruction;
	const Instruction *name2Instruction;
	const Instruction *name3Instruction;
	const Instruction *name4Instruction;
	const Instruction *nameList0Instruction;
	const Instruction *nameList1Instruction;
	const Instruction *nameList2Instruction;
	const Instruction *nameList3Instruction;
	const Instruction *nameList4Instruction;
	const Instruction *integer0Instruction;
	const Instruction *integer1Instruction;
	const Instruction *integer2Instruction;
	const Instruction *integer3Instruction;
	const Instruction *integer4Instruction;
	const Instruction *string0Instruction;
	const Instruction *string1Instruction;
	const Instruction *string2Instruction;
	const Instruction *string3Instruction;
	const Instruction *string4Instruction;
	const Instruction *image0Instruction;
	const Instruction *image1Instruction;
	const Instruction *image2Instruction;
	const Instruction *image3Instruction;
	const Instruction *image4Instruction;
	const char *imageErrorMessage;
	FILE *configFile = NULL;
	uint32 configFileToken;
	void *system = NULL;
	uint statementSize = STATEMENT_BLOCK_SIZE;
	char *statementStart = NULL;
	uint32 statementToken = 0;
	char *statementCurrent;
	char *statementWall = NULL;
	char *statementConcreteWall;
	uint8 name0Return;
	uint8 name1Return;
	uint8 name2Return;
	uint8 name3Return;
	uint8 name4Return;
	uint8 nameList0Return;
	uint8 nameList1Return;
	uint8 nameList2Return;
	uint8 nameList3Return;
	uint8 nameList4Return;
	int64 integer0Return;
	int64 integer1Return;
	int64 integer2Return;
	int64 integer3Return;
	int64 integer4Return;
	char *string0Return = NULL;
	uint32 string0Token = 0;
	char *string1Return = NULL;
	uint32 string1Token = 0;
	char *string2Return = NULL;
	uint32 string2Token = 0;
	char *string3Return = NULL;
	uint32 string3Token = 0;
	char *string4Return = NULL;
	uint32 string4Token = 0;
	Image image0Return;
	Image image1Return;
	Image image2Return;
	Image image3Return;
	Image image4Return;
	JmpPoint jmpPoint;
	uint fileLine = 1;
	uint statementLine = 0;
	char fileChar;
	uint itemAmount;
	char quote = '\0';
	uint currentScopeInstructionListSize = countof(globalInstructionList) - 1;
	StringTreeSystem *const *const *currentScopeInstructionData = globalScopeInstructionData;
	StringTreeSystem *const *instructionDataStart;
	StringTreeSystem *const *instructionDataStartCopy;
	StringTreeSystem *const *instructionDataCurrent;
	StringTreeSystem *currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
	image0Return.dataStart = NULL;
	image0Return.dataToken = 0;
	image1Return.dataStart = NULL;
	image1Return.dataToken = 0;
	image2Return.dataStart = NULL;
	image2Return.dataToken = 0;
	image3Return.dataStart = NULL;
	image3Return.dataToken = 0;
	image4Return.dataStart = NULL;
	image4Return.dataToken = 0;
	jmp setupPointers;
	setupPointers:{
		if(getNextConfigChar == &ifgetc){
			if(!createConfigFile){
				DIR *const dir = opendir(configPath);
				uint32 token = pushPointer(dir, "config directory argument", closedir);
				if(dir){
					closedir(dir);
					popPointer(token);
					printConfigError("config error", "config file is directory", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
			}
			configFile = fopen(configPath, "r");
			configFileToken = pushPointer(configFile, "config file", fclose);
			if(!configFile){
				#define BUFFER_SIZE /*-*/ (4096)
				FILE *defaultConfigFile;
				uint32 defaultConfigFileToken;
				if(!createConfigFile){
					printConfigError("config error", "could not open config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				configFile = fopen(configPath, "w");
				configFileToken = pushPointer(configFile, "config file", fclose);
				if(!configFile){
					printConfigError("config error", "could not create config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				defaultConfigFile = fopen(DEFAULT_CONFIG_PATH, "r");
				defaultConfigFileToken = pushPointer(defaultConfigFile, "default config file", fclose);
				if(!defaultConfigFile){
					remove(configPath);
					printTitledNamedError("config file error", "could not copy default configuration file from", DEFAULT_CONFIG_PATH);
					jmp configEmergencyExit;
				}
				copyConfigFileLoop:{
					char buffer[BUFFER_SIZE];
					size_t bytesRead;
					if((bytesRead = fread(buffer, sizeof(*buffer), sizeof(buffer), defaultConfigFile))){
						if(fwrite(buffer, sizeof(*buffer), bytesRead, configFile) != bytesRead){
							fclose(defaultConfigFile);
							popPointer(defaultConfigFileToken);
							remove(configPath);
							printTitledError("config copying error", "could not copy default config file correctly");
							jmp configEmergencyExit;
						}
						jmp copyConfigFileLoop;
					}
				}
				fclose(defaultConfigFile);
				popPointer(defaultConfigFileToken);
				fclose(configFile);
				popPointer(configFileToken);
				if(!(configFile = fopen(configPath, "r"))){
					printTitledError("config error", "could not open newly written file");
					jmp configEmergencyExit;
				}
				#undef  BUFFER_SIZE
			}
		}
		statementStart = malloc(statementSize * sizeof(char));
		statementToken = pushPointer(statementStart, "statement pointer", iFree);
		if(!statementStart){
			printTitledError("config error", "could not store user data");
			jmp configEmergencyExit;
		}
		if(getNextConfigChar == &ifgetc){
			system = configFile;
		}elif(getNextConfigChar == &getNextSTDINCharacter){
			system = &stdinSystem;
		}elif(getNextConfigChar == &getNextSharedMemoryCharacter){
			system = &sharedMemorySystem;
		}
		jmp getStatementStart;
	}
	getStatementStart:{
		#define EOF_N1 /*----------------------------*/ (EOF)
		#define ZER_00 /*----------------------------*/ ('\0')
		#define EOT_04 /*----------------------------*/ (0x04)
		#define ALR_07 /*----------------------------*/ ('\a')
		#define BSP_08 /*----------------------------*/ ('\b')
		#define TAB_09 /*----------------------------*/ ('\t')
		#define NLN_10 /*----------------------------*/ ('\n')
		#define VTB_11 /*----------------------------*/ ('\v')
		#define FFD_12 /*----------------------------*/ ('\f')
		#define CRE_13 /*----------------------------*/ ('\r')
		#define ESC_27 /*----------------------------*/ ('\e')
		#define SPC_32 /*----------------------------*/ (' ')
		#define DQT_34 /*----------------------------*/ ('\"')
		#define SQT_39 /*----------------------------*/ ('\'')
		#define AST_42 /*----------------------------*/ ('*')
		#define FSL_47 /*----------------------------*/ ('/')
		#define ZER_48 /*----------------------------*/ ('0')
		#define SCL_59 /*----------------------------*/ (';')
		#define QMK_63 /*----------------------------*/ ('?')
		#define BSL_92 /*----------------------------*/ ('\\')
		#define LOA_97 /*----------------------------*/ ('a')
		#define LOB_98 /*----------------------------*/ ('b')
		#define LOF_102 /*---------------------------*/ ('f')
		#define LON_110 /*---------------------------*/ ('n')
		#define LOR_114 /*---------------------------*/ ('r')
		#define LOT_116 /*---------------------------*/ ('t')
		#define LOV_118 /*---------------------------*/ ('v')
		#define OCB_123 /*---------------------------*/ ('{')
		#define BAR_124 /*---------------------------*/ ('|')
		#define CCB_125 /*---------------------------*/ ('}')
		#define GET_STATEMENT_JMP_POINT /*-----------*/ (0)
		#define STORE_WHITESPACE_JMP_POINT /*--------*/ (1)
		#define CHECK_COMMENT_JMP_POINT /*-----------*/ (2)
		#define STORE_BAR_JMP_POINT /*---------------*/ (3)
		#define GET_DOUBLE_QUOTATION_JMP_POINT /*----*/ (4)
		#define GET_SINGLE_QUOTATION_JMP_POINT /*----*/ (5)
		#define HANDLE_ESCAPE_CHARACTER_JMP_POINT /*-*/ (6)
		#define ENTER_SCOPE_JMP_POINT /*-------------*/ (7)
		#define GET_STATEMENT_END_JMP_POINT /*-------*/ (8)
		statementCurrent = statementStart;
		statementConcreteWall = statementStart + statementSize * sizeof(char);
		statementLine = 0;
		itemAmount = 0;
		free(string0Return);
		popPointer(string0Token);
		free(string1Return);
		popPointer(string1Token);
		free(string2Return);
		popPointer(string2Token);
		free(string3Return);
		popPointer(string3Token);
		free(string4Return);
		popPointer(string4Token);
		free(image0Return.dataStart);
		popPointer(image0Return.dataToken);
		free(image1Return.dataStart);
		popPointer(image1Return.dataToken);
		free(image2Return.dataStart);
		popPointer(image2Return.dataToken);
		free(image3Return.dataStart);
		popPointer(image3Return.dataToken);
		free(image4Return.dataStart);
		popPointer(image4Return.dataToken);
		name0Instruction = NULL;
		name1Instruction = NULL;
		name2Instruction = NULL;
		name3Instruction = NULL;
		name4Instruction = NULL;
		nameList0Instruction = NULL;
		nameList1Instruction = NULL;
		nameList2Instruction = NULL;
		nameList3Instruction = NULL;
		nameList4Instruction = NULL;
		integer0Instruction = NULL;
		integer1Instruction = NULL;
		integer2Instruction = NULL;
		integer3Instruction = NULL;
		integer4Instruction = NULL;
		string0Instruction = NULL;
		string1Instruction = NULL;
		string2Instruction = NULL;
		string3Instruction = NULL;
		string4Instruction = NULL;
		image0Instruction = NULL;
		image1Instruction = NULL;
		image2Instruction = NULL;
		image3Instruction = NULL;
		image4Instruction = NULL;
		string0Return = NULL;
		string0Token = 0;
		string1Return = NULL;
		string1Token = 0;
		string2Return = NULL;
		string2Token = 0;
		string3Return = NULL;
		string3Token = 0;
		string4Return = NULL;
		string4Token = 0;
		image0Return.dataStart = NULL;
		image0Return.dataToken = 0;
		image1Return.dataStart = NULL;
		image1Return.dataToken = 0;
		image2Return.dataStart = NULL;
		image2Return.dataToken = 0;
		image3Return.dataStart = NULL;
		image3Return.dataToken = 0;
		image4Return.dataStart = NULL;
		image4Return.dataToken = 0;
		jmp getStatement;
	}
	getStatement: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp checkCommentStoreCharacter;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	getDoubleQuotation: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getDoubleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getDoubleQuotationStoreCharacter;
		to DQT_34: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getDoubleQuotationStoreCharacter;
	end
	getSingleQuotation: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getSingleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getSingleQuotationStoreCharacter;
		to SQT_39: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getSingleQuotationStoreCharacter;
	end
	handleEscapeCharacter: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to DQT_34: /*--*/ fileChar = '\"'; /*-----------------*/ jmp storeEscapedCharacter;
		to SQT_39: /*--*/ fileChar = '\''; /*-----------------*/ jmp storeEscapedCharacter;
		to ZER_48: /*--*/ fileChar = '\0'; /*-----------------*/ jmp storeEscapedCharacter;
		to QMK_63: /*--*/ fileChar = '\?'; /*-----------------*/ jmp storeEscapedCharacter;
		to BSL_92: /*--*/ fileChar = '\\'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOA_97: /*--*/ fileChar = '\a'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOB_98: /*--*/ fileChar = '\b'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOF_102: /*-*/ fileChar = '\f'; /*-----------------*/ jmp storeEscapedCharacter;
		to LON_110: /*-*/ fileChar = '\n'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOR_114: /*-*/ fileChar = '\r'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOT_116: /*-*/ fileChar = '\t'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOV_118: /*-*/ fileChar = '\v'; /*-----------------*/ jmp storeEscapedCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	checkComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to AST_42: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreSingleLineComment;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	ignoreMultipleLineComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to AST_42: /*--*/ /*----------------------------------*/ jmp checkMultipleLineCommentEnd;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	end
	checkMultipleLineCommentEnd: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	end
	ignoreSingleLineComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreSingleLineComment;
	end
	endOfFile:{
		if(statementCurrent == statementStart){
			jmp successfulConfig;
		}
		if(getPreviousConfigChar){
			getPreviousConfigChar(system);
		}
		jmp completeStatement;
	}
	storeWhitespace:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp getStatement;
		}
		inc itemAmount;
		fileChar = '\0';
		jmp getStatementStoreCharacter;
	}
	completeStatement:{
		if(statementCurrent <= statementStart){
			jmp getStatement;
		}
		if(!*(statementCurrent - 1)){
			jmp getStatementEnd;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = GET_STATEMENT_END_JMP_POINT;
		jmp storeCharacter;
	}
	handleOpeningBracket:{
		if(statementCurrent <= statementStart){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray opening bracket error", "could not enter nameless scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(*(statementCurrent - 1)){
			inc itemAmount;
			fileChar = '\0';
			jmpPoint = ENTER_SCOPE_JMP_POINT;
			jmp storeCharacter;
		}
		jmp enterScope;
	}
	enterScope:{
		StringTreeSystem *stringTreeSystem;
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(currentScopeInstruction == globalScopeInstruction){
			stringTreeSystem = &globalScopesInstructionStringTreeSystem;
		}else{
			printConfigError("invalid scope error", "no scopes inside current scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(!findStringTreeString(stringTreeSystem, &statementCurrent)){
			printConfigError("invalid scope error", "invalid scope name", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(itemAmount > 1){
			/*! missing space between final argument and scope imminent */
			printConfigError("scope argument error", "too many arguments", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, (void *)1, (void *)1, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		currentScopeInstruction = scope1ScopeInstruction;
		currentScopeInstructionData = scope1ScopeInstructionData;
		currentScopeInstructionList = scope1ScopeInstructionList;
		currentScopeInstructionStringTreeSystem = &scope1ScopeInstructionStringTreeSystem;
		currentScopeInstructionListSize = countof(scope1ScopeInstructionList) - 1;
		jmp getStatementStart;
	}
	attemptStoreBar:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp storeBar;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = STORE_BAR_JMP_POINT;
		jmp storeCharacter;
	}
	storeBar:{
		fileChar = '|';
		jmpPoint = STORE_WHITESPACE_JMP_POINT;
		jmp storeCharacter;
	}
	handleClosingBracket:{
		if(statementCurrent > statementStart){
			if(getNextConfigChar != &ifgetc){
				getPreviousConfigChar(system);
				jmp completeStatement;
			}
			fseek(configFile, -1, SEEK_CUR);
			jmp completeStatement;
		}
		if(currentScopeInstruction == globalScopeInstruction){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray closing bracket error", "could not drop to previous config scope", '}', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(currentScopeInstruction == scope1ScopeInstruction){
			currentScopeInstruction = globalScopeInstruction;
			currentScopeInstructionData = globalScopeInstructionData;
			currentScopeInstructionList = globalInstructionList;
			currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
			currentScopeInstructionListSize = countof(globalInstructionList) - 1;
		}
		jmp getStatementStart;
	}
	storeEscapedCharacter:{
		*(statementCurrent - 1) = fileChar;
		if(quote == '\"'){
			jmp getDoubleQuotation;
		}
		jmp getSingleQuotation;
	}
	getStatementStoreCharacter:{
		jmpPoint = GET_STATEMENT_JMP_POINT;
		jmp storeCharacter;
	}
	getDoubleQuotationStoreCharacter:{
		jmpPoint = GET_DOUBLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	getSingleQuotationStoreCharacter:{
		jmpPoint = GET_SINGLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	handleEscapeCharacterStoreCharacter:{
		jmpPoint = HANDLE_ESCAPE_CHARACTER_JMP_POINT;
		jmp storeCharacter;
	}
	checkCommentStoreCharacter:{
		jmpPoint = CHECK_COMMENT_JMP_POINT;
		jmp storeCharacter;
	}
	storeCharacter:{
		if(statementCurrent >= statementConcreteWall){
			const uint offset = statementCurrent - statementStart;
			void *temp;
			statementSize += STATEMENT_BLOCK_SIZE;
			temp = realloc(statementStart, statementSize * sizeof(char));
			updatePointer(statementToken, temp);
			if(!temp){
				printConfigError("memory allocation error", "could not allocate memory for config statement", ';', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				statementSize -= STATEMENT_BLOCK_SIZE;
				jmp getStatementStart;
			}
			statementStart = temp;
			statementCurrent = statementStart + offset;
			statementConcreteWall = statementStart + statementSize * sizeof(char);
		}
		if(jmpPoint != CHECK_COMMENT_JMP_POINT and !statementLine){
			statementLine = fileLine;
		}
		*statementCurrent = fileChar;
		inc statementCurrent;
		switch jmpPoint over
			to GET_STATEMENT_JMP_POINT: /*-----------*/ jmp getStatement;
			to STORE_WHITESPACE_JMP_POINT: /*--------*/ jmp storeWhitespace;
			to CHECK_COMMENT_JMP_POINT: /*-----------*/ jmp checkComment;
			to STORE_BAR_JMP_POINT: /*---------------*/ jmp storeBar;
			to GET_DOUBLE_QUOTATION_JMP_POINT: /*----*/ jmp getDoubleQuotation;
			to GET_SINGLE_QUOTATION_JMP_POINT: /*----*/ jmp getSingleQuotation;
			to HANDLE_ESCAPE_CHARACTER_JMP_POINT: /*-*/ jmp handleEscapeCharacter;
			to ENTER_SCOPE_JMP_POINT: /*-------------*/ jmp enterScope;
			off: /*----------------------------------*/ jmp getStatementEnd;
		end
	}
	getStatementEnd:{
		if(statementCurrent > statementStart) /*-*/ jmp findStatement;
		if(!feof(configFile)) /*-----------------*/ jmp getStatementStart;
		/*---------------------------------------*/ jmp successfulConfig;
		#undef  GET_STATEMENT_END_JMP_POINT
		#undef  ENTER_SCOPE_JMP_POINT
		#undef  HANDLE_ESCAPE_CHARACTER_JMP_POINT
		#undef  GET_SINGLE_QUOTATION_JMP_POINT
		#undef  GET_DOUBLE_QUOTATION_JMPPOINT
		#undef  STORE_BAR_JMP_POINT
		#undef  CHECK_COMMENT_JMP_POINT
		#undef  STORE_WHITESPACE_JMP_POINT
		#undef  GET_STATEMENT_JMP_POINT
		#undef  CCB_125
		#undef  BAR_124
		#undef  OCB_123
		#undef  LOV_118
		#undef  LOT_116
		#undef  LOR_114
		#undef  LON_110
		#undef  LOF_102
		#undef  LOB_98
		#undef  LOA_97
		#undef  BSL_92
		#undef  QMK_63
		#undef  SCL_59
		#undef  ZER_48
		#undef  FSL_47
		#undef  AST_42
		#undef  SQT_39
		#undef  DQT_34
		#undef  SPC_32
		#undef  ESC_27
		#undef  CRE_13
		#undef  FFD_12
		#undef  VTB_11
		#undef  NLN_10
		#undef  TAB_09
		#undef  BSP_08
		#undef  ALR_07
		#undef  EOT_04
		#undef  ZER_00
		#undef  EOF_N1
	}
	findStatement:{
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(!findStringTreeString(currentScopeInstructionStringTreeSystem, &statementCurrent)){
			printConfigError("config error", "unrecognized instruction", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp printAllInstructionPatterns;
		}
		instructionStart = *(currentScopeInstruction + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionStartCopy = instructionStart;
		instructionCurrent = instructionStart;
		instructionDataStart = *(currentScopeInstructionData + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionDataStartCopy = instructionDataStart;
		instructionDataCurrent = instructionDataStart;
		if(*instructionCurrent == NONE_INSTRUCTION_TYPE){
			jmp unimplementedInstruction;
		}
		if(statementCurrent >= statementWall and *instructionCurrent != END_INSTRUCTION_TYPE){
			printConfigError("config error", "missing instruction body", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		inc statementCurrent;
		jmp switchInstructionLoop;
	}
	switchInstructionLoop: switch *instructionCurrent over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp unimplementedInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp matchName;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp matchNameList;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp matchInteger;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp matchString;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp matchImageString;
		off: /*---------------------------*/ jmp endOfInstruction;
	end
	unimplementedInstruction:{
		printConfigError("implementation error", "using unimplemented instruction", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchName:{
		char *s;
		uint8 *namePointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!name0Instruction){
			namePointer = &name0Return;
			name0Instruction = instructionCurrent;
		}elif(!name1Instruction){
			namePointer = &name1Return;
			name1Instruction = instructionCurrent;
		}elif(!name2Instruction){
			namePointer = &name2Return;
			name2Instruction = instructionCurrent;
		}elif(!name3Instruction){
			namePointer = &name3Return;
			name3Instruction = instructionCurrent;
		}else{
			namePointer = &name4Return;
			name4Instruction = instructionCurrent;
		}
		s = statementCurrent;
		if(!findStringTreeString(*instructionDataCurrent, &s)){
			printConfigError("match string error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		statementCurrent = s;
		inc statementCurrent;
		*namePointer = (**instructionDataCurrent).returnedCounter;
		jmp advanceDataInstruction;
	}
	matchNameList:{
		uint8 *nameListPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!nameList0Instruction){
			nameListPointer = &nameList0Return;
			nameList0Instruction = instructionCurrent;
		}elif(!nameList1Instruction){
			nameListPointer = &nameList1Return;
			nameList1Instruction = instructionCurrent;
		}elif(!nameList2Instruction){
			nameListPointer = &nameList2Return;
			nameList2Instruction = instructionCurrent;
		}elif(!nameList3Instruction){
			nameListPointer = &nameList3Return;
			nameList3Instruction = instructionCurrent;
		}else{
			nameListPointer = &nameList4Return;
			nameList4Instruction = instructionCurrent;
		}
		switch matchNameList(*instructionDataCurrent, statementWall, &statementCurrent, nameListPointer) over
			to INVALID_NAME_NAME_LIST: /*--*/ jmp invalidNameNameList;
			to PREMATURE_END_NAME_LIST: /*-*/ jmp prematureEndNameList;
			off: /*------------------------*/ jmp advanceDataInstruction;
		end
	}
	invalidNameNameList:{
		printConfigError("bar list error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	prematureEndNameList:{
		printConfigError("bar list error", "missing final name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchInteger:{
		int64 *integerPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!integer0Instruction){
			integerPointer = &integer0Return;
			integer0Instruction = instructionCurrent;
		}elif(!integer1Instruction){
			integerPointer = &integer1Return;
			integer1Instruction = instructionCurrent;
		}elif(!integer2Instruction){
			integerPointer = &integer2Return;
			integer2Instruction = instructionCurrent;
		}elif(!integer3Instruction){
			integerPointer = &integer3Return;
			integer3Instruction = instructionCurrent;
		}else{
			integerPointer = &integer4Return;
			integer4Instruction = instructionCurrent;
		}
		switch matchInteger(&statementCurrent, statementWall, integerPointer) over
			to NON_NUMBER_NUMBER: /*-------*/ jmp printNonNumberError;
			to OVERFLOWN_NUMBER_NUMBER: /*-*/ jmp printOverflownNumberError;
			to DIVIDED_BY_ZERO_NUMBER: /*--*/ jmp printDividedByZeroNumberError;
			off: /*------------------------*/ jmp advanceInstruction;
		end
	}
	printNonNumberError:{
		printConfigError("match integer error", "not a number", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printOverflownNumberError:{
		printConfigError("match integer error", "integer overflow", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printDividedByZeroNumberError:{
		printConfigError("match integer error", "integer divided by zero", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchString:{
		char **stringPointer;
		uint32 *stringTokenPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!string0Instruction){
			stringPointer = &string0Return;
			stringTokenPointer = &string0Token;
			string0Instruction = instructionCurrent;
		}elif(!string1Instruction){
			stringPointer = &string1Return;
			stringTokenPointer = &string1Token;
			string1Instruction = instructionCurrent;
		}elif(!string2Instruction){
			stringPointer = &string2Return;
			stringTokenPointer = &string2Token;
			string2Instruction = instructionCurrent;
		}elif(!string3Instruction){
			stringPointer = &string3Return;
			stringTokenPointer = &string3Token;
			string3Instruction = instructionCurrent;
		}else{
			stringPointer = &string4Return;
			stringTokenPointer = &string4Token;
			string4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, stringPointer, stringTokenPointer)){
			printConfigError("match string error", "could not allocate string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		jmp advanceInstruction;
	}
	matchImageString:{
		char *string = NULL;
		uint32 token = 0;
		Image *imagePointer;
		uint8 matchImageReturn;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!image0Instruction){
			imagePointer = &image0Return;
			image0Instruction = instructionCurrent;
		}elif(!image1Instruction){
			imagePointer = &image1Return;
			image1Instruction = instructionCurrent;
		}elif(!image2Instruction){
			imagePointer = &image2Return;
			image2Instruction = instructionCurrent;
		}elif(!image3Instruction){
			imagePointer = &image3Return;
			image3Instruction = instructionCurrent;
		}else{
			imagePointer = &image4Return;
			image4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, &string, &token)){
			printConfigError("match image error", "could not allocate image string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		matchImageReturn = matchImage(string, &imageErrorMessage, &image0Return);
		free(string);
		popPointer(token);
		switch matchImageReturn over
			to CANNOT_OPEN_MATCH_IMAGE: /*--------*/ jmp printCannotOpenReadConfig;
			to CANNOT_READ_MATCH_IMAGE: /*--------*/ jmp printCannotReadReadConfig;
			to UNSUPPORTED_FORMAT_MATCH_IMAGE: /*-*/ jmp printUnsupportedFormatReadConfig;
			to BAD_HEADER_MATCH_IMAGE: /*---------*/ jmp printBadHeaderReadConfig;
			to BAD_DEPTH_MATCH_IMAGE: /*----------*/ jmp printBadDepthReadConfig;
			to BAD_COMPRESSION_MATCH_IMAGE: /*----*/ jmp printBadCompressionReadConfig;
			to UNSUPPORTED_HEIGHT_MATCH_IMAGE: /*-*/ jmp printUnsupportedHeightReadConfig;
			to BAD_SIZE_MATCH_IMAGE: /*-----------*/ jmp printBadSizeReadConfig;
			to FAILED_MATCH_IMAGE: /*-------------*/ jmp printFailedReadConfig;
			to BAD_PIXELS_MATCH_IMAGE: /*---------*/ jmp printBadPixelsReadConfig;
			to BAD_IMAGE_MATCH_IMAGE: /*----------*/ jmp printBadImageReadConfig;
			off: /*-------------------------------*/ jmp advanceInstruction;
		end
	}
	printCannotOpenReadConfig:{
		printConfigError("match image error", "could not open image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printCannotReadReadConfig:{
		printConfigError("match image error", "could not read image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedFormatReadConfig:{
		printConfigError("match image error", "image file not bmp", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadHeaderReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadDepthReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadCompressionReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedHeightReadConfig:{
		printConfigError("match image error", "negative height is not supported", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadSizeReadConfig:{
		printConfigError("match image error", "could not traverse image past the header", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printFailedReadConfig:{
		printConfigError("match image error", "could not allocate pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadPixelsReadConfig:{
		printConfigError("match image error", "could not read pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadImageReadConfig:{
		printConfigError("match image error", "image is broken", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	endOfInstruction:{
		if(instructionStart == setInstruction){
			#define applySubinstruction(s, i) /*-*/ instructionStart = s##i##Subinstruction; instructionDataStart = s##i##SubinstructionData
			switch name0Return over
				off: /*-*/ brk;
			end
		}
		if(instructionStart == doInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*---------------------*/ applySubinstruction(execute, Do); /*-----------------*/ jmp assessSubinstruction;
				to PLACE_TOP_COMMAND: /*-------------------*/ applySubinstruction(placeTop, Do); /*----------------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_COMMAND: /*----------------*/ applySubinstruction(placeBottom, Do); /*-------------*/ jmp assessSubinstruction;
				to PLACE_LEFT_COMMAND: /*------------------*/ applySubinstruction(placeLeft, Do); /*---------------*/ jmp assessSubinstruction;
				to PLACE_RIGHT_COMMAND: /*-----------------*/ applySubinstruction(placeRight, Do); /*--------------*/ jmp assessSubinstruction;
				to PLACE_TOP_LEFT_COMMAND: /*--------------*/ applySubinstruction(placeTopLeft, Do); /*------------*/ jmp assessSubinstruction;
				to PLACE_TOP_RIGHT_COMMAND: /*-------------*/ applySubinstruction(placeTopRight, Do); /*-----------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_LEFT_COMMAND: /*-----------*/ applySubinstruction(placeBottomLeft, Do); /*---------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_RIGHT_COMMAND: /*----------*/ applySubinstruction(placeBottomRight, Do); /*--------*/ jmp assessSubinstruction;
				to PLACE_CENTER_COMMAND: /*----------------*/ applySubinstruction(placeCenter, Do); /*-------------*/ jmp assessSubinstruction;
				to PLACE_FULL_COMMAND: /*------------------*/ applySubinstruction(placeFull, Do); /*---------------*/ jmp assessSubinstruction;
				to MOVE_COMMAND: /*------------------------*/ applySubinstruction(move, Do); /*--------------------*/ jmp assessSubinstruction;
				to RESIZE_COMMAND: /*----------------------*/ applySubinstruction(resize, Do); /*------------------*/ jmp assessSubinstruction;
				to ENTER_MAXIMIZED_COMMAND: /*-------------*/ applySubinstruction(enterMaximized, Do); /*----------*/ jmp assessSubinstruction;
				to TOGGLE_MAXIMIZED_COMMAND: /*------------*/ applySubinstruction(toggleMaximized, Do); /*---------*/ jmp assessSubinstruction;
				to ENTER_FULLSCREEN_COMMAND: /*------------*/ applySubinstruction(enterFullscreen, Do); /*---------*/ jmp assessSubinstruction;
				to TOGGLE_FULLSCREEN_COMMAND: /*-----------*/ applySubinstruction(toggleFullscreen, Do); /*--------*/ jmp assessSubinstruction;
				to GO_TO_WORKSPACE_COMMAND: /*-------------*/ applySubinstruction(goToWorkspace, Do); /*-----------*/ jmp assessSubinstruction;
				to MOVE_WINDOW_TO_WORKSPACE_COMMAND: /*----*/ applySubinstruction(moveWindowToWorkspace, Do); /*---*/ jmp assessSubinstruction;
				to GO_TO_WORKSPACE_WITH_WINDOW_COMMAND: /*-*/ applySubinstruction(goToWorkspaceWithWindow, Do); /*-*/ jmp assessSubinstruction;
				off: /*------------------------------------*/ /*---------------------------------------------------*/ brk;
			end
		}
		if(instructionStart == grabKeycodeInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*---------------------*/ applySubinstruction(execute, GrabKeycode); /*-----------------*/ jmp assessSubinstruction;
				to PLACE_TOP_COMMAND: /*-------------------*/ applySubinstruction(placeTop, GrabKeycode); /*----------------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_COMMAND: /*----------------*/ applySubinstruction(placeBottom, GrabKeycode); /*-------------*/ jmp assessSubinstruction;
				to PLACE_LEFT_COMMAND: /*------------------*/ applySubinstruction(placeLeft, GrabKeycode); /*---------------*/ jmp assessSubinstruction;
				to PLACE_RIGHT_COMMAND: /*-----------------*/ applySubinstruction(placeRight, GrabKeycode); /*--------------*/ jmp assessSubinstruction;
				to PLACE_TOP_LEFT_COMMAND: /*--------------*/ applySubinstruction(placeTopLeft, GrabKeycode); /*------------*/ jmp assessSubinstruction;
				to PLACE_TOP_RIGHT_COMMAND: /*-------------*/ applySubinstruction(placeTopRight, GrabKeycode); /*-----------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_LEFT_COMMAND: /*-----------*/ applySubinstruction(placeBottomLeft, GrabKeycode); /*---------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_RIGHT_COMMAND: /*----------*/ applySubinstruction(placeBottomRight, GrabKeycode); /*--------*/ jmp assessSubinstruction;
				to PLACE_CENTER_COMMAND: /*----------------*/ applySubinstruction(placeCenter, GrabKeycode); /*-------------*/ jmp assessSubinstruction;
				to PLACE_FULL_COMMAND: /*------------------*/ applySubinstruction(placeFull, GrabKeycode); /*---------------*/ jmp assessSubinstruction;
				to MOVE_COMMAND: /*------------------------*/ applySubinstruction(move, GrabKeycode); /*--------------------*/ jmp assessSubinstruction;
				to RESIZE_COMMAND: /*----------------------*/ applySubinstruction(resize, GrabKeycode); /*------------------*/ jmp assessSubinstruction;
				to ENTER_MAXIMIZED_COMMAND: /*-------------*/ applySubinstruction(enterMaximized, GrabKeycode); /*----------*/ jmp assessSubinstruction;
				to TOGGLE_MAXIMIZED_COMMAND: /*------------*/ applySubinstruction(toggleMaximized, GrabKeycode); /*---------*/ jmp assessSubinstruction;
				to ENTER_FULLSCREEN_COMMAND: /*------------*/ applySubinstruction(enterFullscreen, GrabKeycode); /*---------*/ jmp assessSubinstruction;
				to TOGGLE_FULLSCREEN_COMMAND: /*-----------*/ applySubinstruction(toggleFullscreen, GrabKeycode); /*--------*/ jmp assessSubinstruction;
				to GO_TO_WORKSPACE_COMMAND: /*-------------*/ applySubinstruction(goToWorkspace, GrabKeycode); /*-----------*/ jmp assessSubinstruction;
				to MOVE_WINDOW_TO_WORKSPACE_COMMAND: /*----*/ applySubinstruction(moveWindowToWorkspace, GrabKeycode); /*---*/ jmp assessSubinstruction;
				to GO_TO_WORKSPACE_WITH_WINDOW_COMMAND: /*-*/ applySubinstruction(goToWorkspaceWithWindow, GrabKeycode); /*-*/ jmp assessSubinstruction;
				off: /*------------------------------------*/ /*------------------------------------------------------------*/ brk;
			end
		}
		if(instructionStart == grabButtonInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*---------------------*/ applySubinstruction(execute, GrabButton); /*-----------------*/ jmp assessSubinstruction;
				to PLACE_TOP_COMMAND: /*-------------------*/ applySubinstruction(placeTop, GrabButton); /*----------------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_COMMAND: /*----------------*/ applySubinstruction(placeBottom, GrabButton); /*-------------*/ jmp assessSubinstruction;
				to PLACE_LEFT_COMMAND: /*------------------*/ applySubinstruction(placeLeft, GrabButton); /*---------------*/ jmp assessSubinstruction;
				to PLACE_RIGHT_COMMAND: /*-----------------*/ applySubinstruction(placeRight, GrabButton); /*--------------*/ jmp assessSubinstruction;
				to PLACE_TOP_LEFT_COMMAND: /*--------------*/ applySubinstruction(placeTopLeft, GrabButton); /*------------*/ jmp assessSubinstruction;
				to PLACE_TOP_RIGHT_COMMAND: /*-------------*/ applySubinstruction(placeTopRight, GrabButton); /*-----------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_LEFT_COMMAND: /*-----------*/ applySubinstruction(placeBottomLeft, GrabButton); /*---------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_RIGHT_COMMAND: /*----------*/ applySubinstruction(placeBottomRight, GrabButton); /*--------*/ jmp assessSubinstruction;
				to PLACE_CENTER_COMMAND: /*----------------*/ applySubinstruction(placeCenter, GrabButton); /*-------------*/ jmp assessSubinstruction;
				to PLACE_FULL_COMMAND: /*------------------*/ applySubinstruction(placeFull, GrabButton); /*---------------*/ jmp assessSubinstruction;
				to MOVE_COMMAND: /*------------------------*/ applySubinstruction(move, GrabButton); /*--------------------*/ jmp assessSubinstruction;
				to RESIZE_COMMAND: /*----------------------*/ applySubinstruction(resize, GrabButton); /*------------------*/ jmp assessSubinstruction;
				to ENTER_MAXIMIZED_COMMAND: /*-------------*/ applySubinstruction(enterMaximized, GrabButton); /*----------*/ jmp assessSubinstruction;
				to TOGGLE_MAXIMIZED_COMMAND: /*------------*/ applySubinstruction(toggleMaximized, GrabButton); /*---------*/ jmp assessSubinstruction;
				to ENTER_FULLSCREEN_COMMAND: /*------------*/ applySubinstruction(enterFullscreen, GrabButton); /*---------*/ jmp assessSubinstruction;
				to TOGGLE_FULLSCREEN_COMMAND: /*-----------*/ applySubinstruction(toggleFullscreen, GrabButton); /*--------*/ jmp assessSubinstruction;
				to GO_TO_WORKSPACE_COMMAND: /*-------------*/ applySubinstruction(goToWorkspace, GrabButton); /*-----------*/ jmp assessSubinstruction;
				to MOVE_WINDOW_TO_WORKSPACE_COMMAND: /*----*/ applySubinstruction(moveWindowToWorkspace, GrabButton); /*---*/ jmp assessSubinstruction;
				to GO_TO_WORKSPACE_WITH_WINDOW_COMMAND: /*-*/ applySubinstruction(goToWorkspaceWithWindow, GrabButton); /*-*/ jmp assessSubinstruction;
				off: /*------------------------------------*/ /*-----------------------------------------------------------*/ brk;
			end
			#undef  applySubinstruction
		}
		if(statementCurrent < statementWall){
			printConfigError("config error", "extra parameters error", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(instructionStartCopy == helpInstruction){
			printError("%s%s: %s: line %u: %s%s:%s %s:\n", colorStart, programName, configPath, statementLine, colorError, "config help menu", colorEnd, displaySimpleConfigErrors? "contracted" : "expanded");
			jmp printAllInstructionPatterns;
		}
		if(instructionStartCopy == expandInstruction){
			displaySimpleConfigErrors = false;
			jmp getStatementStart;
		}
		if(instructionStartCopy == contractInstruction){
			displaySimpleConfigErrors = true;
			jmp getStatementStart;
		}
		if(instructionStartCopy == readConfigInstruction){
			readConfig(false, string0Return, &ifgetc, NULL);
			jmp getStatementStart;
		}
		if(instructionStartCopy == useTerminalInstruction){
			switch name0Return over
				to TRUE_BOOLEAN:{
					if(!connectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == useMessengerInstruction){
			switch name0Return over
				to TRUE_BOOLEAN:{
					if(!connectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == setInstruction){
			switch name0Return over
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == doInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*---------------------*/ /*---------------------------*/ /*--------------------*/ brk;
				to PLACE_TOP_COMMAND: /*-------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_COMMAND: /*----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_LEFT_COMMAND: /*------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_RIGHT_COMMAND: /*-----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_TOP_LEFT_COMMAND: /*--------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_TOP_RIGHT_COMMAND: /*-------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_LEFT_COMMAND: /*-----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_RIGHT_COMMAND: /*----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_CENTER_COMMAND: /*----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_FULL_COMMAND: /*------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to MOVE_COMMAND: /*------------------------*/ field0 = nameList0Return; /*-*/ field1 = integer0Return; brk;
				to RESIZE_COMMAND: /*----------------------*/ field0 = nameList0Return; /*-*/ field1 = integer0Return; brk;
				to ENTER_MAXIMIZED_COMMAND: /*-------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to TOGGLE_MAXIMIZED_COMMAND: /*------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to ENTER_FULLSCREEN_COMMAND: /*------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to TOGGLE_FULLSCREEN_COMMAND: /*-----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to GO_TO_WORKSPACE_COMMAND: /*-------------*/ field0 = integer0Return; /*--*/ /*--------------------*/ brk;
				to MOVE_WINDOW_TO_WORKSPACE_COMMAND: /*----*/ field0 = integer0Return; /*--*/ /*--------------------*/ brk;
				to GO_TO_WORKSPACE_WITH_WINDOW_COMMAND: /*-*/ field0 = integer0Return; /*--*/ /*--------------------*/ brk;
				off: /*------------------------------------*/ /*---------------------------*/ /*--------------------*/ brk;
			end
			switch matchCommand(name0Return, string0Return, getNextConfigChar == &ifgetc? CONFIG_MATCH_COMMAND_ORIGIN : getNextConfigChar == &getNextSTDINCharacter? STDIN_MATCH_COMMAND_ORIGIN : TRANSMITTER_MATCH_COMMAND_ORIGIN, field0, field1, field2, field3, field4) over
				to TYPICAL_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to RESTART_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to EXIT_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				off:{
					printConfigError("config error", "do subinstruction not implemented yet", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionStart, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == grabKeycodeInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*---------------------*/ /*---------------------------*/ /*--------------------*/ brk;
				to PLACE_TOP_COMMAND: /*-------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_COMMAND: /*----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_LEFT_COMMAND: /*------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_RIGHT_COMMAND: /*-----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_TOP_LEFT_COMMAND: /*--------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_TOP_RIGHT_COMMAND: /*-------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_LEFT_COMMAND: /*-----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_RIGHT_COMMAND: /*----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_CENTER_COMMAND: /*----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_FULL_COMMAND: /*------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to MOVE_COMMAND: /*------------------------*/ field0 = nameList2Return; /*-*/ field1 = integer1Return; brk;
				to RESIZE_COMMAND: /*----------------------*/ field0 = nameList2Return; /*-*/ field1 = integer1Return; brk;
				to ENTER_MAXIMIZED_COMMAND: /*-------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to TOGGLE_MAXIMIZED_COMMAND: /*------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to ENTER_FULLSCREEN_COMMAND: /*------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to TOGGLE_FULLSCREEN_COMMAND: /*-----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to GO_TO_WORKSPACE_COMMAND: /*-------------*/ field0 = integer1Return; /*--*/ /*--------------------*/ brk;
				to MOVE_WINDOW_TO_WORKSPACE_COMMAND: /*----*/ field0 = integer1Return; /*--*/ /*--------------------*/ brk;
				to GO_TO_WORKSPACE_WITH_WINDOW_COMMAND: /*-*/ field0 = integer1Return; /*--*/ /*--------------------*/ brk;
				off: /*------------------------------------*/ /*---------------------------*/ /*--------------------*/ brk;
			end
			if(!insertShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_key_checked(connection, true, (*screen).root, nameList0Return, integer0Return, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab key on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == grabButtonInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*---------------------*/ /*---------------------------*/ /*--------------------*/ brk;
				to PLACE_TOP_COMMAND: /*-------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_COMMAND: /*----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_LEFT_COMMAND: /*------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_RIGHT_COMMAND: /*-----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_TOP_LEFT_COMMAND: /*--------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_TOP_RIGHT_COMMAND: /*-------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_LEFT_COMMAND: /*-----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_RIGHT_COMMAND: /*----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_CENTER_COMMAND: /*----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_FULL_COMMAND: /*------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to MOVE_COMMAND: /*------------------------*/ field0 = nameList2Return; /*-*/ field1 = integer1Return; brk;
				to RESIZE_COMMAND: /*----------------------*/ field0 = nameList2Return; /*-*/ field1 = integer1Return; brk;
				to ENTER_MAXIMIZED_COMMAND: /*-------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to TOGGLE_MAXIMIZED_COMMAND: /*------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to ENTER_FULLSCREEN_COMMAND: /*------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to TOGGLE_FULLSCREEN_COMMAND: /*-----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to GO_TO_WORKSPACE_COMMAND: /*-------------*/ field0 = integer1Return; /*--*/ /*--------------------*/ brk;
				to MOVE_WINDOW_TO_WORKSPACE_COMMAND: /*----*/ field0 = integer1Return; /*--*/ /*--------------------*/ brk;
				to GO_TO_WORKSPACE_WITH_WINDOW_COMMAND: /*-*/ field0 = integer1Return; /*--*/ /*--------------------*/ brk;
				off: /*------------------------------------*/ /*---------------------------*/ /*--------------------*/ brk;
			end
			if(!insertShortcut(&buttonShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_button_checked(connection, true, (*screen).root, XCB_EVENT_MASK_NO_EVENT, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, integer0Return, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab button on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabKeycodeInstruction){
			if(!removeShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find key to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_key_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab key from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabButtonInstruction){
			if(!removeShortcut(&buttonShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find button to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_button_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab button from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == stopInstruction){
			jmp successfulConfig;
		}
		jmp getStatementStart;
	}
	advanceInstruction:{
		inc instructionCurrent;
		jmp switchInstructionLoop;
	}
	advanceDataInstruction:{
		inc instructionCurrent;
		inc instructionDataCurrent;
		jmp switchInstructionLoop;
	}
	assessSubinstruction:{
		instructionCurrent = instructionStart + (instructionCurrent - instructionStartCopy);
		instructionDataCurrent = instructionDataStart + (instructionDataCurrent - instructionDataStartCopy);
		if(statementCurrent < statementWall){
			jmp switchInstructionLoop;
		}
		jmp printMissingArgumentError;
	}
	printMissingArgumentError:{
		printConfigError("config error", "missing argument error", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printAllInstructionPatterns:{
		const char *const *const wall = currentScopeInstructionList + currentScopeInstructionListSize;
		const char *const *current = currentScopeInstructionList;
		const Instruction *const *in = currentScopeInstruction;
		StringTreeSystem *const *const *da = currentScopeInstructionData;
		jmp printExpandedHelpInstructions;
		printExpandedHelpInstructions:{
			const Instruction *n = *in - 1;
			StringTreeSystem *const *d = *da;
			printError("\tpattern | %s", *current);
			jmp printHelpInstructionParametersLoop;
			printHelpInstructionParametersLoop: switch *(inc n) over
				to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
				to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
				to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
				to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
				to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
				to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
				off: /*---------------------------*/ jmp printHelpInstructionParametersLoopExit;
			end
			noneInstruction:{
				printError(" <unimplemented>");
				jmp printHelpInstructionParametersLoopExit;
			}
			nameInstruction:{
				if(displaySimpleConfigErrors){
					printError(" name");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" (%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
					printNameLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameLoop;
						}
						printError(")");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			nameListInstruction:{
				if(displaySimpleConfigErrors){
					printError(" list");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" ((%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
					printNameListOnceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListOnceLoop;
						}
						stringArray = (**d).stringArray;
						printError(")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
						inc stringArray;
						jmp printNameListTwiceLoop;
					}
					printNameListTwiceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListTwiceLoop;
						}
						printError("))*(?![\\s]*[|]))");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			numberInstruction:{
				if(displaySimpleConfigErrors){
					printError(" number");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
				jmp printHelpInstructionParametersLoop;
			}
			stringInstruction:{
				if(displaySimpleConfigErrors){
					printError(" string");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
			imageInstruction:{
				if(displaySimpleConfigErrors){
					printError(" image");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
		}
		printHelpInstructionParametersLoopExit:{
			inc in;
			inc da;
			if(displaySimpleConfigErrors){
				printError("\n");
			}else{
				printError(" $\n");
			}
			if(inc current < wall){
				jmp printExpandedHelpInstructions;
			}
			printError("\n");
			jmp getStatementStart;
		}
	}
	successfulConfig:{
		if(currentScopeInstruction != globalScopeInstruction){
			*statementCurrent = '\0';
			statementWall = statementCurrent;
			statementLine = fileLine;
			if(fileLine != 1){
				dec statementLine;
			}
			printConfigError("config error", "missing closing scope bracket", '\0', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		jmp configEmergencyExit;
	}
	configEmergencyExit:{
		if(configFile and fileLine == 1 and !statementLine){
			printConfigError("config warning", "empty config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		free(statementStart);
		popPointer(statementToken);
		if(configFile){
			fclose(configFile);
			popPointer(configFileToken);
		}
		jmp postReadConfig;
	}
	postReadConfig:{
		xcb_flush(connection);
		ret;
	}
	#undef  DEFAULT_CONFIG_PATH
	#undef  STATEMENT_BLOCK_SIZE
}
MATCHCOMMAND(){
	uint8 commandReturned = TYPICAL_MATCH_COMMAND_TYPE;
	(void)field0;
	(void)field1;
	(void)field2;
	(void)field3;
	(void)field4;
	switch origin over
		to PRESS_MATCH_COMMAND_ORIGIN:{
			printCommand("press", command);
			if(!((*eventModifierNode).onState & PRESS_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to RELEASE_MATCH_COMMAND_ORIGIN:{
			printCommand("release", command);
			if(!((*eventModifierNode).onState & RELEASE_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to CONFIG_MATCH_COMMAND_ORIGIN:{
			printCommand("config", command);
			jmp matchCommand;
		}
		to STDIN_MATCH_COMMAND_ORIGIN:{
			printCommand("stdin", command);
			jmp matchCommand;
		}
		to TRANSMITTER_MATCH_COMMAND_ORIGIN:{
			printCommand("transmitter", command);
			jmp matchCommand;
		}
		off:{
			jmp emergencyExit;
		}
	end
	matchCommand: switch command over
		to NONE_COMMAND: /*---------------------------------*/ jmp noneCommand;
		to EXECUTE_COMMAND: /*------------------------------*/ jmp executeCommand;
		to FOCUS_COMMAND: /*--------------------------------*/ jmp focusCommand;
		to MOTION_MOVE_COMMAND: /*--------------------------*/ jmp motionMoveCommand;
		to MOTION_RESIZE_COMMAND: /*------------------------*/ jmp motionResizeCommand;
		to PLACE_TOP_COMMAND: /*----------------------------*/ jmp placeTopCommand;
		to PLACE_BOTTOM_COMMAND: /*-------------------------*/ jmp placeBottomCommand;
		to PLACE_LEFT_COMMAND: /*---------------------------*/ jmp placeLeftCommand;
		to PLACE_RIGHT_COMMAND: /*--------------------------*/ jmp placeRightCommand;
		to PLACE_TOP_LEFT_COMMAND: /*-----------------------*/ jmp placeTopLeftCommand;
		to PLACE_TOP_RIGHT_COMMAND: /*----------------------*/ jmp placeTopRightCommand;
		to PLACE_BOTTOM_LEFT_COMMAND: /*--------------------*/ jmp placeBottomLeftCommand;
		to PLACE_BOTTOM_RIGHT_COMMAND: /*-------------------*/ jmp placeBottomRightCommand;
		to PLACE_CENTER_COMMAND: /*-------------------------*/ jmp placeCenterCommand;
		to PLACE_FULL_COMMAND: /*---------------------------*/ jmp placeFullCommand;
		to MOVE_COMMAND: /*---------------------------------*/ jmp moveCommand;
		to RESIZE_COMMAND: /*-------------------------------*/ jmp resizeCommand;
		to ENTER_MAXIMIZED_COMMAND: /*----------------------*/ jmp enterMaximizedCommand;
		to LEAVE_MAXIMIZED_COMMAND: /*----------------------*/ jmp leaveMaximizedCommand;
		to TOGGLE_MAXIMIZED_COMMAND: /*---------------------*/ jmp toggleMaximizedCommand;
		to ENTER_FULLSCREEN_COMMAND: /*---------------------*/ jmp enterFullscreenCommand;
		to LEAVE_FULLSCREEN_COMMAND: /*---------------------*/ jmp leaveFullscreenCommand;
		to TOGGLE_FULLSCREEN_COMMAND: /*--------------------*/ jmp toggleFullscreenCommand;
		to SHOW_DESKTOP_COMMAND: /*-------------------------*/ jmp showDesktopCommand;
		to HIDE_DESKTOP_COMMAND: /*-------------------------*/ jmp hideDesktopCommand;
		to TOGGLE_DESKTOP_COMMAND: /*-----------------------*/ jmp toggleDesktopCommand;
		to GO_TO_WORKSPACE_COMMAND: /*----------------------*/ jmp goToWorkspaceCommand;
		to GO_TO_NEXT_WORKSPACE_COMMAND: /*-----------------*/ jmp goToNextWorkspaceCommand;
		to GO_TO_PREVIOUS_WORKSPACE_COMMAND: /*-------------*/ jmp goToPreviousWorkspaceCommand;
		to MOVE_WINDOW_TO_WORKSPACE_COMMAND: /*-------------*/ jmp moveWindowToWorkspaceCommand;
		to MOVE_WINDOW_TO_NEXT_WORKSPACE_COMMAND: /*--------*/ jmp moveWindowToNextWorkspaceCommand;
		to MOVE_WINDOW_TO_PREVIOUS_WORKSPACE_COMMAND: /*----*/ jmp moveWindowToPreviousWorkspaceCommand;
		to GO_TO_WORKSPACE_WITH_WINDOW_COMMAND: /*----------*/ jmp goToWorkspaceWithWindowCommand;
		to GO_TO_NEXT_WORKSPACE_WITH_WINDOW_COMMAND: /*-----*/ jmp goToNextWorkspaceWithWindowCommand;
		to GO_TO_PREVIOUS_WORKSPACE_WITH_WINDOW_COMMAND: /*-*/ jmp goToPreviousWorkspaceWithWindowCommand;
		to CLOSE_COMMAND: /*--------------------------------*/ jmp closeCommand;
		to KILL_COMMAND: /*---------------------------------*/ jmp killCommand;
		to RESTART_COMMAND: /*------------------------------*/ jmp restartCommand;
		to EXIT_COMMAND: /*---------------------------------*/ jmp exitCommand;
		off: /*---------------------------------------------*/ jmp unrecognizedCommand;
	end
	noneCommand:{
		jmp emergencyExit;
	}
	executeCommand:{
		spawnProcess(execute);
		jmp emergencyExit;
	}
	focusCommand:{
		Client *client;
		setPointer(&pointerSystem);
		if((client = findPositionedOrderedVirtualRootClient(&virtualRootSystem, &clientSystem, virtualRootSystem.currentDesktop, pointerSystem.x, pointerSystem.y))){
			setFocusedClient(&clientSystem, client, virtualRootSystem.currentDesktop);
		}
		jmp emergencyExit;
	}
	motionMoveCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		int x = 0;
		int y = 0;
		if(!client or !((*client).allowedAction & MOVE_ALLOWED_ACTION)){
			jmp emergencyExit;
		}
		setPointer(&pointerSystem);
		x = pointerSystem.x;
		y = pointerSystem.y;
		setMotionClient(&clientSystem, client, MOVE_MOTION_ACTION, CENTER_POINT_WINDOW_GRAVITY, x, y);
		jmp emergencyExit;
	}
	motionResizeCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		int x = 0;
		int y = 0;
		uint8 direction;
		uint8 windowGravity;
		if(!client or !((*client).allowedAction & RESIZE_ALLOWED_ACTION)){
			jmp emergencyExit;
		}
		setPointer(&pointerSystem);
		x = pointerSystem.x;
		y = pointerSystem.y;
		{
			const int thresholdX = 50;
			const int thresholdY = 50;
			const int clientX = x - (*client).containerX;
			const int clientY = y - (*client).containerY;
			const int clientWidth = (*client).containerWidth + 2 * (*client).containerBorder;
			const int clientHeight = (*client).containerHeight + 2 * (*client).containerBorder;
			direction = NONE_DIRECTION;
			if(clientX < clientWidth / 2){
				if(!thresholdX or (0 <= clientX and clientX < thresholdX)){
					direction |= LEFT_DIRECTION;
				}
			}else{
				if(!thresholdX or (clientWidth - thresholdX <= clientX and clientX < clientWidth)){
					direction |= RIGHT_DIRECTION;
				}
			}
			if(clientY < clientHeight / 2){
				if(!thresholdY or (0 <= clientY and clientY < thresholdY)){
					direction |= UP_DIRECTION;
				}
			}else{
				if(!thresholdY or (clientHeight - thresholdY <= clientY and clientY < clientHeight)){
					direction |= DOWN_DIRECTION;
				}
			}
			if(!direction){
				jmp emergencyExit;
			}
		}
		{
			uint8 horizontalAxisGravityStart[2];
			uint8 verticalAxisGravityStart[2];
			uint8 *horizontalAxisGravityCurrent;
			uint8 *verticalAxisGravityCurrent;
			horizontalAxisGravityCurrent = horizontalAxisGravityStart;
			verticalAxisGravityCurrent = verticalAxisGravityStart;
			windowGravity = NONE_WINDOW_GRAVITY;
			if(direction & UP_DIRECTION){
				*verticalAxisGravityCurrent = SOUTH_SIDE_WINDOW_GRAVITY;
				inc verticalAxisGravityCurrent;
			}
			if(direction & DOWN_DIRECTION){
				*verticalAxisGravityCurrent = NORTH_SIDE_WINDOW_GRAVITY;
				inc verticalAxisGravityCurrent;
			}
			if(direction & LEFT_DIRECTION){
				*horizontalAxisGravityCurrent = EAST_SIDE_WINDOW_GRAVITY;
				inc horizontalAxisGravityCurrent;
			}
			if(direction & RIGHT_DIRECTION){
				*horizontalAxisGravityCurrent = WEST_SIDE_WINDOW_GRAVITY;
				inc horizontalAxisGravityCurrent;
			}
			if(horizontalAxisGravityCurrent == horizontalAxisGravityStart + 1){
				windowGravity = *horizontalAxisGravityStart;
			}
			if(verticalAxisGravityCurrent == verticalAxisGravityStart + 1){
				const uint8 verticalWindowGravity = *verticalAxisGravityStart;
				if(windowGravity == WEST_SIDE_WINDOW_GRAVITY){
					if(verticalWindowGravity == NORTH_SIDE_WINDOW_GRAVITY){
						windowGravity = NORTH_WEST_POINT_WINDOW_GRAVITY;
					}else{
						windowGravity = SOUTH_WEST_POINT_WINDOW_GRAVITY;
					}
				}elif(windowGravity == EAST_SIDE_WINDOW_GRAVITY){
					if(verticalWindowGravity == NORTH_SIDE_WINDOW_GRAVITY){
						windowGravity = NORTH_EAST_POINT_WINDOW_GRAVITY;
					}else{
						windowGravity = SOUTH_EAST_POINT_WINDOW_GRAVITY;
					}
				}else{
					windowGravity = *verticalAxisGravityStart;
				}
			}
		}
		setMotionClient(&clientSystem, client, RESIZE_MOTION_ACTION, windowGravity, x, y);
		jmp emergencyExit;
	}
	placeTopCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, TOP_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeBottomCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, BOTTOM_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeLeftCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, LEFT_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeRightCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, RIGHT_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeTopLeftCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, TOP_LEFT_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeTopRightCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, TOP_RIGHT_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeBottomLeftCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, BOTTOM_LEFT_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeBottomRightCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, BOTTOM_RIGHT_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeCenterCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, CENTER_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeFullCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, FULL_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	moveCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		int x;
		int y;
		if(!client){
			jmp emergencyExit;
		}
		x = (*client).containerX;
		y = (*client).containerY;
		if(field0 & UP_DIRECTION){
			y -= field1;
		}
		if(field0 & DOWN_DIRECTION){
			y += field1;
		}
		if(field0 & LEFT_DIRECTION){
			x -= field1;
		}
		if(field0 & RIGHT_DIRECTION){
			x += field1;
		}
		moveResizeClient(&clientSystem, client, x, y, (*client).containerWidth, (*client).containerHeight, false, true, false, false, false, NONE_WINDOW_GRAVITY);
		jmp emergencyExit;
	}
	resizeCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		uint8 horizontalAxisGravityStart[2];
		uint8 verticalAxisGravityStart[2];
		uint8 *horizontalAxisGravityCurrent;
		uint8 *verticalAxisGravityCurrent;
		int width;
		int height;
		uint8 windowGravity;
		if(!client){
			jmp emergencyExit;
		}
		horizontalAxisGravityCurrent = horizontalAxisGravityStart;
		verticalAxisGravityCurrent = verticalAxisGravityStart;
		width = (*client).containerWidth;
		height = (*client).containerHeight;
		windowGravity = NONE_WINDOW_GRAVITY;
		if(field0 & UP_DIRECTION){
			height += field1;
			*verticalAxisGravityCurrent = SOUTH_SIDE_WINDOW_GRAVITY;
			inc verticalAxisGravityCurrent;
		}
		if(field0 & DOWN_DIRECTION){
			height += field1;
			*verticalAxisGravityCurrent = NORTH_SIDE_WINDOW_GRAVITY;
			inc verticalAxisGravityCurrent;
		}
		if(field0 & LEFT_DIRECTION){
			width += field1;
			*horizontalAxisGravityCurrent = EAST_SIDE_WINDOW_GRAVITY;
			inc horizontalAxisGravityCurrent;
		}
		if(field0 & RIGHT_DIRECTION){
			width += field1;
			*horizontalAxisGravityCurrent = WEST_SIDE_WINDOW_GRAVITY;
			inc horizontalAxisGravityCurrent;
		}
		if(horizontalAxisGravityCurrent == horizontalAxisGravityStart + 1){
			windowGravity = *horizontalAxisGravityStart;
		}
		if(verticalAxisGravityCurrent == verticalAxisGravityStart + 1){
			const uint8 verticalWindowGravity = *verticalAxisGravityStart;
			if(windowGravity == WEST_SIDE_WINDOW_GRAVITY){
				if(verticalWindowGravity == NORTH_SIDE_WINDOW_GRAVITY){
					windowGravity = NORTH_WEST_POINT_WINDOW_GRAVITY;
				}else{
					windowGravity = SOUTH_WEST_POINT_WINDOW_GRAVITY;
				}
			}elif(windowGravity == EAST_SIDE_WINDOW_GRAVITY){
				if(verticalWindowGravity == NORTH_SIDE_WINDOW_GRAVITY){
					windowGravity = NORTH_EAST_POINT_WINDOW_GRAVITY;
				}else{
					windowGravity = SOUTH_EAST_POINT_WINDOW_GRAVITY;
				}
			}else{
				windowGravity = *verticalAxisGravityStart;
			}
		}
		if(!windowGravity){
			windowGravity = CENTER_POINT_WINDOW_GRAVITY;
		}
		moveResizeClient(&clientSystem, client, (*client).containerX, (*client).containerY, width, height, false, true, true, false, false, windowGravity);
		jmp emergencyExit;
	}
	enterMaximizedCommand:{
		maximizeClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0);
		jmp emergencyExit;
	}
	leaveMaximizedCommand:{
		unmaximizeClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem));
		jmp emergencyExit;
	}
	toggleMaximizedCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		if(!client){
			jmp emergencyExit;
		}
		if(((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) != (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
			jmp enterMaximizedCommand;
		}
		jmp leaveMaximizedCommand;
	}
	enterFullscreenCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		if(fullscreenClient(&virtualRootSystem, &monitorSystem, &clientSystem, client, field0)){
			if(setClientOrderType(&clientSystem, client)){
				if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
					configureClient(&clientSystem, client);
					configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
					if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}
			}
		}
		jmp emergencyExit;
	}
	leaveFullscreenCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		if(unfullscreenClient(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
			if(setClientOrderType(&clientSystem, client)){
				if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
					configureClient(&clientSystem, client);
					configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
					if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}
			}
		}
		jmp emergencyExit;
	}
	toggleFullscreenCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		if(!client){
			jmp emergencyExit;
		}
		if(!((*client).state & FULLSCREEN_STATE)){
			jmp enterFullscreenCommand;
		}
		jmp leaveFullscreenCommand;
	}
	showDesktopCommand:{
		showVirtualRootDesktop(&virtualRootSystem, &clientSystem, virtualRootSystem.currentDesktop, true);
		jmp emergencyExit;
	}
	hideDesktopCommand:{
		showVirtualRootDesktop(&virtualRootSystem, &clientSystem, virtualRootSystem.currentDesktop, false);
		jmp emergencyExit;
	}
	toggleDesktopCommand:{
		showVirtualRootDesktop(&virtualRootSystem, &clientSystem, virtualRootSystem.currentDesktop, !virtualRootSystem.showingDesktop);
		jmp emergencyExit;
	}
	goToWorkspaceCommand:{
		uint32 field;
		uint32 which;
		if(field0 < 0){
			jmp emergencyExit;
		}
		field = field0;
		which = field - 1;
		if(which > field){
			which = field;
		}
		gotoVirtualRoot(&virtualRootSystem, &clientSystem, which, true);
		jmp emergencyExit;
	}
	goToNextWorkspaceCommand:{
		uint32 which = virtualRootSystem.currentDesktop + 1;
		if(which < virtualRootSystem.currentDesktop){
			which = virtualRootSystem.currentDesktop;
		}
		gotoVirtualRoot(&virtualRootSystem, &clientSystem, which, true);
		jmp emergencyExit;
	}
	goToPreviousWorkspaceCommand:{
		uint32 which = virtualRootSystem.currentDesktop - 1;
		if(which > virtualRootSystem.currentDesktop){
			which = virtualRootSystem.currentDesktop;
		}
		gotoVirtualRoot(&virtualRootSystem, &clientSystem, which, true);
		jmp emergencyExit;
	}
	moveWindowToWorkspaceCommand:{
		uint32 field;
		uint32 which;
		if(field0 < 0){
			jmp emergencyExit;
		}
		field = field0;
		which = field - 1;
		if(which > field){
			which = field;
		}
		moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), which, true);
		jmp emergencyExit;
	}
	moveWindowToNextWorkspaceCommand:{
		uint32 which = virtualRootSystem.currentDesktop + 1;
		if(which < virtualRootSystem.currentDesktop){
			which = virtualRootSystem.currentDesktop;
		}
		moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), which, true);
		jmp emergencyExit;
	}
	moveWindowToPreviousWorkspaceCommand:{
		uint32 which = virtualRootSystem.currentDesktop - 1;
		if(which > virtualRootSystem.currentDesktop){
			which = virtualRootSystem.currentDesktop;
		}
		moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), which, true);
		jmp emergencyExit;
	}
	goToWorkspaceWithWindowCommand:{
		Client *client;
		uint32 field;
		uint32 which;
		if(field0 < 0){
			jmp emergencyExit;
		}
		field = field0;
		which = field - 1;
		client = getFocusedClient(&clientSystem);
		if(which > field){
			which = field;
		}
		if(client){
			moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, which, false);
		}
		gotoVirtualRoot(&virtualRootSystem, &clientSystem, which, false);
		jmp emergencyExit;
	}
	goToNextWorkspaceWithWindowCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		uint32 which = virtualRootSystem.currentDesktop + 1;
		if(which < virtualRootSystem.currentDesktop){
			which = virtualRootSystem.currentDesktop;
		}
		if(client){
			moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, which, false);
		}
		gotoVirtualRoot(&virtualRootSystem, &clientSystem, which, false);
		jmp emergencyExit;
	}
	goToPreviousWorkspaceWithWindowCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		uint32 which = virtualRootSystem.currentDesktop - 1;
		if(which > virtualRootSystem.currentDesktop){
			which = virtualRootSystem.currentDesktop;
		}
		if(client){
			moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, which, false);
		}
		gotoVirtualRoot(&virtualRootSystem, &clientSystem, which, false);
		jmp emergencyExit;
	}
	closeCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		if(!closeClient(&clientSystem, client, CLOSE_CLOSE_CLIENT_COMMAND)){
			closeClient(&clientSystem, client, KILL_CLOSE_CLIENT_COMMAND);
		}
		jmp emergencyExit;
	}
	killCommand:{
		closeClient(&clientSystem, getFocusedClient(&clientSystem), KILL_CLOSE_CLIENT_COMMAND);
		jmp emergencyExit;
	}
	restartCommand:{
		commandReturned = RESTART_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	exitCommand:{
		commandReturned = EXIT_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	unrecognizedCommand:{
		printTitledValuedError("command error", "executed unrecognized command with type", command);
		jmp emergencyExit;
	}
	emergencyExit:{
		ret commandReturned;
	}
}
CLEANUP(){
	free(event);
	popPointer(eventToken);
	event = NULL;
	eventToken = 0;
	finiSharedMemorySystem(&sharedMemorySystem);
	finiSTDINSystem(&stdinSystem);
	finiSleepThreadSystem(&sleepThreadSystem);
	cancelThreads();
	ungrabShortcuts();
	freeConfigVariables();
	finiWindowSystem(&windowSystem);
	finiWindowManagerSystem();
	finiClientListSystem(&clientListStackingSystem);
	finiClientListSystem(&clientListSystem);
	finiVirtualRootSystem(&virtualRootSystem);
	finiClientSystem(&clientSystem);
	finiWallpaperSystem(&wallpaperSystem);
	finiCursorSystem(&cursorSystem);
	finiPointerSystem(&pointerSystem);
	finiMonitorSystem(&monitorSystem);
	if(connection){
		xcb_flush(connection);
		xcb_disconnect(connection);
		popPointer(connectionToken);
		connection = NULL;
		connectionToken = 0;
	}
	finiShortcutSystem(&buttonShortcutSystem);
	finiShortcutSystem(&keycodeShortcutSystem);
	finiStringTreeSystem(&macroStringTreeSystem);
	finiStringTreeSystem(&directionStringTreeSystem);
	finiStringTreeSystem(&whichMonitorStringTreeSystem);
	finiStringTreeSystem(&cornerStringTreeSystem);
	finiStringTreeSystem(&verticalAlignmentStringTreeSystem);
	finiStringTreeSystem(&horizontalAlignmentStringTreeSystem);
	finiStringTreeSystem(&numberTypeStringTreeSystem);
	finiStringTreeSystem(&shortcutStateStringTreeSystem);
	finiStringTreeSystem(&modifierStringTreeSystem);
	finiStringTreeSystem(&commandStringTreeSystem);
	finiStringTreeSystem(&variableStringTreeSystem);
	finiStringTreeSystem(&booleanStringTreeSystem);
	finiStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
	finiStringTreeSystem(&globalInstructionStringTreeSystem);
	finiStringTreeSystem(&globalScopesInstructionStringTreeSystem);
	finiPermissionSystem(&permissionSystem);
	if(memoryManagementSystem.allocated > 1){
		printError("%s%s: %s%s:%s %s", colorStart, programName, colorError, "warning", colorEnd, "program exited with unaccounted for data pointers, namely:\n");
		printUnaccountedForPointers(memoryManagementSystem.data + 1, memoryManagementSystem.data + memoryManagementSystem.allocated);
	}
	finiMemorySystem();
	closeErrorStream();
	exit(EXIT_SUCCESS);
}
PRINTCONFIGERROR(){
	const char *statementCurrent = statementStart;
	const uint itemAmountWall = instructionCurrent - instructionStart;
	uint itemAmount = 0;
	uint spaceAmount = 0;
	StringTreeSystem *const *data;
	if(!openErrorStream()){
		ret;
	}
	flockfile(errorStream);
	fprintf(errorStream, "%s%s: %s: ", colorStart, programName, configPath);
	if(printLine){
		fprintf(errorStream, "line %u: ", statementLine);
	}
	fprintf(errorStream, "%s%s:%s %s", colorError, type, colorEnd, message);
	if(printConfig){
		fprintf(errorStream, ":\n\t config |");
	}else{
		fprintf(errorStream, "\n");
		jmp emergencyExit;
	}
	jmp printStatementItemLoop;
	printStatementItemLoop:{
		if(statementCurrent < statementWall){
			fprintf(errorStream, " %s", statementCurrent);
			jmp pushOutTermLoop;
			pushOutTermLoop:{
				if(*(inc statementCurrent)){
					jmp pushOutTermLoop;
				}
				inc statementCurrent;
			}
			if(itemAmount == itemAmountWall and instructionStart){
				spaceAmount = statementCurrent - statementStart;
			}
			inc itemAmount;
			jmp printStatementItemLoop;
		}
		if(spaceAmount == 0 and finalStatementCharacter != ';'){
			fprintf(errorStream, " ");
		}
		fprintf(errorStream, "%c\n", finalStatementCharacter);
		jmp printPattern;
	}
	printPattern:{
		if(printPointer){
			if(spaceAmount == statementCurrent - statementStart){
				dec spaceAmount;
			}
			fprintf(errorStream, "\t        |%*c^\n", inc spaceAmount, ' ');
		}
		if(!printPattern or !instructionStart){
			fprintf(errorStream, "\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, "\n\tpattern | %s", *(currentScopeInstructionList + (*currentScopeInstructionStringTreeSystem).returnedCounter));
		dec instructionStart;
		data = instructionDataStart;
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoop: switch *(inc instructionStart) over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
		off: /*---------------------------*/ jmp printInstructionParameterLoopExit;
	end
	noneInstruction:{
		fprintf(errorStream, " <unimplemented>");
		jmp printInstructionParameterLoopExit;
	}
	nameInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " name");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " (%s", *stringArray);
			inc stringArray;
			jmp printNameLoop;
			printNameLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
				}
				fprintf(errorStream, ")");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	nameListInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " list");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " ((%s", *stringArray);
			inc stringArray;
			jmp printNameListOnceLoop;
			printNameListOnceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
				}
				stringArray = (**data).stringArray;
				fprintf(errorStream, ")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
				inc stringArray;
				jmp printNameListTwiceLoop;
			}
			printNameListTwiceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListTwiceLoop;
				}
				fprintf(errorStream, "))*(?![\\s]*[|]))");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	numberInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " number");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
		jmp printInstructionParameterLoop;
	}
	stringInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " string");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	imageInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " image");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	printTilde:{
		fprintf(errorStream, " ~");
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoopExit:{
		if(displaySimpleConfigErrors){
			fprintf(errorStream, "\n\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, " $\n\n");
		jmp emergencyExit;
	}
	emergencyExit:{
		funlockfile(errorStream);
		closeErrorStream();
		ret;
	}
}

