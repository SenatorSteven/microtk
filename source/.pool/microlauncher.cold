
/*!
	future features:
		implement a default selection, probably given by a number.
		insert and match non-ascii.
		connect the copy buffer to the global text buffer.
		support getting the first n results and then the second n results and then the kth n results.
		consider different roots for each directory in path.
		support finding matches in the middle or end of a word, perhaps by using pointers to short circuit to letters.
		support utf8 in setSelectedInputCase().
		implement undo.
		implement redo.
*/



























/*!includes:{*/
	#define _DEFAULT_SOURCE
	#include <errno.h>
	#include <grp.h>
	#include <limits.h>
	#include <locale.h>
	#include <poll.h>
	#include <pthread.h>
	#include <pwd.h>
	#include <signal.h>
	#include <stdarg.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <sys/shm.h>
	#include <sys/stat.h>
	#include <sys/wait.h>
	#include <xcb/randr.h>
	#include <X11/Xlib.h>
	#include <X11/Xlib-xcb.h>
	#include <X11/Xlocale.h>
/*!}*/

/*!defines:{*/
	#define DEBUG /*-----------------------------------------*/ (false)

	#define PROGRAM_NAME /*----------------------------------*/ "microlauncher"

	#define WHICH_MONITOR_CONTENT(k, v, n, p) /*-------------*/ { \
		  v(none)           k(NONE##p) \
		, v(pointer)        k(POINTER##p) \
		, v(focused-window) k(FOCUSED_WINDOW##p) \
		, v(all)            k(ALL##p) \
		, n(NULL)           k(NULL##p) \
	}

	#define NUMBER_TYPE_CONTENT(k, v, n, p) /*---------------*/ { \
		  v(none)       k(NONE##p) \
		, v(integer)    k(INTEGER##p) \
		, v(percentage) k(PERCENTAGE##p) \
		, v(millimeter) k(MILLIMETER##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define POSITION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(bottom) k(BOTTOM##p) \
		, v(left)   k(LEFT##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define HORIZONTAL_ALIGNMENT_CONTENT(k, v, n, p) /*------*/ { \
		  v(none)   k(NONE##p) \
		, v(left)   k(LEFT##p) \
		, v(center) k(CENTER##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define VERTICAL_ALIGNMENT_CONTENT(k, v, n, p) /*--------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(center) k(CENTER##p) \
		, v(bottom) k(BOTTOM##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define CORNER_CONTENT(k, v, n, p) /*--------------------*/ { \
		  v(none)         k(NONE##p         = (b(0000))) \
		, v(top-left)     k(TOP_LEFT##p     = (b(0001))) \
		, v(top-right)    k(TOP_RIGHT##p    = (b(0010))) \
		, v(bottom-left)  k(BOTTOM_LEFT##p  = (b(0100))) \
		, v(bottom-right) k(BOTTOM_RIGHT##p = (b(1000))) \
		, n(NULL)         k(NULL##p) \
	}

	#define AXIS_CONTENT(k, v, n, p) /*----------------------*/ { \
		  v(none)       k(NONE##p) \
		, v(horizontal) k(HORIZONTAL##p) \
		, v(vertical)   k(VERTICAL##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define NONE_INPUT_MODE /*-------------------------------*/ (0)
	#define NORMAL_INPUT_MODE /*-----------------------------*/ (1)
	#define INSERT_INPUT_MODE /*-----------------------------*/ (2)

	#define NONE_DIRECTION /*--------------------------------*/ (0)
	#define UP_DIRECTION /*----------------------------------*/ (1)
	#define DOWN_DIRECTION /*--------------------------------*/ (2)
	#define LEFT_DIRECTION /*--------------------------------*/ (3)
	#define RIGHT_DIRECTION /*-------------------------------*/ (4)

	#define NONE_MATCH_LENGTH /*-----------------------------*/ (0)
	#define CHARACTER_MATCH_LENGTH /*------------------------*/ (1)
	#define WORD_MATCH_LENGTH /*-----------------------------*/ (2)

	#define NONE_CASE /*-------------------------------------*/ (0)
	#define UPPER_CASE /*------------------------------------*/ (1)
	#define LOWER_CASE /*------------------------------------*/ (2)

	#define STARTING_SELECTION_CONTENT(k, v, n, p) /*--------*/ { \
		  v(none)    k(NONE##p) \
		, v(first)   k(FIRST##p) \
		, v(last)    k(LAST##p) \
		, n(NULL)    k(NULL##p) \
	}

	#define NONE_WHICH_SELECTION /*--------------------------*/ (0)
	#define PREVIOUS_WHICH_SELECTION /*----------------------*/ (1)
	#define NEXT_WHICH_SELECTION /*--------------------------*/ (2)
	#define LEFT_WHICH_SELECTION /*--------------------------*/ (3)
	#define RIGHT_WHICH_SELECTION /*-------------------------*/ (4)
	#define ABOVE_WHICH_SELECTION /*-------------------------*/ (5)
	#define BELOW_WHICH_SELECTION /*-------------------------*/ (6)

	#define _STRING_TREE_NODE_CHILDREN_AMOUNT /*-------------*/ (14)
	#define STRING_TREE_NODE_CHILDREN_AMOUNT /*--------------*/ (_STRING_TREE_NODE_CHILDREN_AMOUNT > 28? 28 : _STRING_TREE_NODE_CHILDREN_AMOUNT)

	#define EMPTY_SHARED_STATUS /*---------------------------*/ (0)
	#define FULL_SHARED_STATUS /*----------------------------*/ (1)

	#define SHORTCUT_CODE_AMOUNT /*--------------------------*/ (256)

	#define SHORTCUT_STATE_CONTENT(k, v, n, p) /*------------*/ { \
		  v(none)    k(NONE##p    = (b(000))) \
		, v(press)   k(PRESS##p   = (b(001))) \
		, v(repeat)  k(REPEAT##p  = (b(010))) \
		, v(release) k(RELEASE##p = (b(100))) \
		, n(NULL)    k(NULL##p) \
	}

	#define NONE_INSTRUCTION_TYPE /*-------------------------*/ (b(000000))
	#define NAME_INSTRUCTION_TYPE /*-------------------------*/ (b(000001))
	#define NAME_LIST_INSTRUCTION_TYPE /*--------------------*/ (b(000010))
	#define NUMBER_INSTRUCTION_TYPE /*-----------------------*/ (b(000100))
	#define STRING_INSTRUCTION_TYPE /*-----------------------*/ (b(001000))
	#define IMAGE_INSTRUCTION_TYPE /*------------------------*/ (b(010000))
	#define END_INSTRUCTION_TYPE /*--------------------------*/ (b(100000))

	#define GLOBAL_SCOPES_INSTRUCTION_CONTENT(k, v, n, p) /*-*/ { \
		  v(scope1) k(SCOPE1##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define GLOBAL_INSTRUCTION_CONTENT(k, v, n, p) /*--------*/ { \
		  v(help)           k(HELP##p) \
		, v(expand)         k(EXPAND##p) \
		, v(contract)       k(CONTRACT##p) \
		, v(read-config)    k(READ_CONFIG##p) \
		, v(use-terminal)   k(USE_TERMINAL##p) \
		, v(use-messenger)  k(USE_MESSENGER##p) \
		, v(set)            k(SET##p) \
		, v(do)             k(DO##p) \
		, v(grab-keycode)   k(GRAB_KEYCODE##p) \
		, v(grab-button)    k(GRAB_BUTTON##p) \
		, v(ungrab-keycode) k(UNGRAB_KEYCODE##p) \
		, v(ungrab-button)  k(UNGRAB_BUTTON##p) \
		, v(stop)           k(STOP##p) \
		, n(NULL)           k(NULL##p) \
	}

	#define SCOPE1_SCOPE_INSTRUCTION_CONTENT(k, v, n, p) /*--*/ { \
		  v(help)     k(HELP##p) \
		, v(expand)   k(EXPAND##p) \
		, v(contract) k(CONTRACT##p) \
		, v(stop)     k(STOP##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define BOOLEAN_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)  k(NONE##p) \
		, v(true)  k(TRUE##p) \
		, v(false) k(FALSE##p) \
		, n(NULL)  k(NULL##p) \
	}

	#define VARIABLE_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)                                k(NONE##p) \
		, v(window-x)                            k(WINDOW_X##p) \
		, v(window-y)                            k(WINDOW_Y##p) \
		, v(window-x-offset)                     k(WINDOW_X_OFFSET##p) \
		, v(window-y-offset)                     k(WINDOW_Y_OFFSET##p) \
		, v(window-width)                        k(WINDOW_WIDTH##p) \
		, v(window-height)                       k(WINDOW_HEIGHT##p) \
		, v(window-horizontal-alignment)         k(WINDOW_HORIZONTAL_ALIGNMENT##p) \
		, v(window-vertical-alignment)           k(WINDOW_VERTICAL_ALIGNMENT##p) \
		, v(window-corner-radius)                k(WINDOW_CORNER_RADIUS##p) \
		, v(window-background)                   k(WINDOW_BACKGROUND##p) \
		, v(input-x)                             k(INPUT_X##p) \
		, v(input-y)                             k(INPUT_Y##p) \
		, v(input-x-offset)                      k(INPUT_X_OFFSET##p) \
		, v(input-y-offset)                      k(INPUT_Y_OFFSET##p) \
		, v(input-width)                         k(INPUT_WIDTH##p) \
		, v(input-height)                        k(INPUT_HEIGHT##p) \
		, v(input-horizontal-alignment)          k(INPUT_HORIZONTAL_ALIGNMENT##p) \
		, v(input-vertical-alignment)            k(INPUT_VERTICAL_ALIGNMENT##p) \
		, v(input-clip-children)                 k(INPUT_CLIP_CHILDREN##p) \
		, v(input-background)                    k(INPUT_BACKGROUND##p) \
		, v(input-text-x)                        k(INPUT_TEXT_X##p) \
		, v(input-text-y)                        k(INPUT_TEXT_Y##p) \
		, v(input-text-x-offset)                 k(INPUT_TEXT_X_OFFSET##p) \
		, v(input-text-y-offset)                 k(INPUT_TEXT_Y_OFFSET##p) \
		, v(input-text-horizontal-alignment)     k(INPUT_TEXT_HORIZONTAL_ALIGNMENT##p) \
		, v(input-text-vertical-alignment)       k(INPUT_TEXT_VERTICAL_ALIGNMENT##p) \
		, v(input-text-foreground)               k(INPUT_TEXT_FOREGROUND##p) \
		, v(input-text-background)               k(INPUT_TEXT_BACKGROUND##p) \
		, v(input-text-selected-foreground)      k(INPUT_TEXT_SELECTED_FOREGROUND##p) \
		, v(input-text-selected-background)      k(INPUT_TEXT_SELECTED_BACKGROUND##p) \
		, v(selection-x)                         k(SELECTION_X##p) \
		, v(selection-y)                         k(SELECTION_Y##p) \
		, v(selection-x-offset)                  k(SELECTION_X_OFFSET##p) \
		, v(selection-y-offset)                  k(SELECTION_Y_OFFSET##p) \
		, v(selection-width)                     k(SELECTION_WIDTH##p) \
		, v(selection-height)                    k(SELECTION_HEIGHT##p) \
		, v(selection-margin)                    k(SELECTION_MARGIN##p) \
		, v(selection-horizontal-alignment)      k(SELECTION_HORIZONTAL_ALIGNMENT##p) \
		, v(selection-vertical-alignment)        k(SELECTION_VERTICAL_ALIGNMENT##p) \
		, v(selection-clip-children)             k(SELECTION_CLIP_CHILDREN##p) \
		, v(selection-background)                k(SELECTION_BACKGROUND##p) \
		, v(selection-selected-background)       k(SELECTION_SELECTED_BACKGROUND##p) \
		, v(selection-text-x)                    k(SELECTION_TEXT_X##p) \
		, v(selection-text-y)                    k(SELECTION_TEXT_Y##p) \
		, v(selection-text-x-offset)             k(SELECTION_TEXT_X_OFFSET##p) \
		, v(selection-text-y-offset)             k(SELECTION_TEXT_Y_OFFSET##p) \
		, v(selection-text-horizontal-alignment) k(SELECTION_TEXT_HORIZONTAL_ALIGNMENT##p) \
		, v(selection-text-vertical-alignment)   k(SELECTION_TEXT_VERTICAL_ALIGNMENT##p) \
		, v(selection-text-foreground)           k(SELECTION_TEXT_FOREGROUND##p) \
		, v(selection-text-background)           k(SELECTION_TEXT_BACKGROUND##p) \
		, v(selection-text-selected-foreground)  k(SELECTION_TEXT_SELECTED_FOREGROUND##p) \
		, v(selection-text-selected-background)  k(SELECTION_TEXT_SELECTED_BACKGROUND##p) \
		, v(maximum-selection-amount)            k(MAXIMUM_SELECTION_AMOUNT##p) \
		, v(selection-axis)                      k(SELECTION_AXIS##p) \
		, v(selection-axis-amount)               k(SELECTION_AXIS_AMOUNT##p) \
		, v(starting-selection)                  k(STARTING_SELECTION##p) \
		, v(allow-circular-navigation)           k(ALLOW_CIRCULAR_NAVIGATION##p) \
		, v(which-monitor)                       k(WHICH_MONITOR##p) \
		, v(font)                                k(FONT##p) \
		, n(NULL)                                k(NULL##p) \
	}

	#define COMMAND_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)                    k(NONE##p) \
		, v(execute)                 k(EXECUTE##p) \
		, v(set-current-selection)   k(SET_CURRENT_SELECTION##p) \
		, v(show)                    k(SHOW##p) \
		, v(hide)                    k(HIDE##p) \
		, v(toggle-visibility)       k(TOGGLE_VISIBILITY##p) \
		, v(draw)                    k(DRAW##p) \
		, v(clear-input)             k(CLEAR_INPUT##p) \
		, v(to-next-letter)          k(TO_NEXT_LETTER##p) \
		, v(to-previous-letter)      k(TO_PREVIOUS_LETTER##p) \
		, v(to-next-word)            k(TO_NEXT_WORD##p) \
		, v(to-previous-word)        k(TO_PREVIOUS_WORD##p) \
		, v(to-start-of-line)        k(TO_START_OF_LINE##p) \
		, v(to-end-of-line)          k(TO_END_OF_LINE##p) \
		, v(to-next-selection)       k(TO_NEXT_SELECTION##p) \
		, v(to-previous-selection)   k(TO_PREVIOUS_SELECTION##p) \
		, v(remove-left-letter)      k(REMOVE_LEFT_LETTER##p) \
		, v(remove-right-letter)     k(REMOVE_RIGHT_LETTER##p) \
		, v(remove-left-word)        k(REMOVE_LEFT_WORD##p) \
		, v(remove-right-word)       k(REMOVE_RIGHT_WORD##p) \
		, v(select-left-letter)      k(SELECT_LEFT_LETTER##p) \
		, v(select-right-letter)     k(SELECT_RIGHT_LETTER##p) \
		, v(select-left-word)        k(SELECT_LEFT_WORD##p) \
		, v(select-right-word)       k(SELECT_RIGHT_WORD##p) \
		, v(select-to-start-of-line) k(SELECT_TO_START_OF_LINE##p) \
		, v(select-to-end-of-line)   k(SELECT_TO_END_OF_LINE##p) \
		, v(select-all)              k(SELECT_ALL##p) \
		, v(copy-selected)           k(COPY_SELECTED##p) \
		, v(cut-selected)            k(CUT_SELECTED##p) \
		, v(paste-clipboard)         k(PASTE_CLIPBOARD##p) \
		, v(uppercase-selected)      k(UPPERCASE_SELECTED##p) \
		, v(lowercase-selected)      k(LOWERCASE_SELECTED##p) \
		, v(toggle-insert-mode)      k(TOGGLE_INSERT_MODE##p) \
		, v(paste-selection)         k(PASTE_SELECTION##p) \
		, v(launch)                  k(LAUNCH##p) \
		, v(restart)                 k(RESTART##p) \
		, v(exit)                    k(EXIT##p) \
		, n(NULL)                    k(NULL##p) \
	}

	#define MODIFIER_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)     k(NONE##p) \
		, v(shift)    k(SHIFT##p) \
		, v(caps)     k(CAPS##p) \
		, v(control)  k(CONTROL##p) \
		, v(mod-1)    k(MOD_1##p) \
		, v(mod-2)    k(MOD_2##p) \
		, v(mod-3)    k(MOD_3##p) \
		, v(mod-4)    k(MOD_4##p) \
		, v(mod-5)    k(MOD_5##p) \
		, v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NAME_LIST /*--------------------------------*/ (0)
	#define SUCCESS_NAME_LIST /*-----------------------------*/ (1)
	#define INVALID_NAME_NAME_LIST /*------------------------*/ (2)
	#define PREMATURE_END_NAME_LIST /*-----------------------*/ (3)

	#define MACRO_CONTENT(k, v, n, p) /*---------------------*/ { \
		  v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NUMBER /*-----------------------------------*/ (0)
	#define VALID_NUMBER_NUMBER /*---------------------------*/ (1)
	#define NON_NUMBER_NUMBER /*-----------------------------*/ (2)
	#define OVERFLOWN_NUMBER_NUMBER /*-----------------------*/ (3)
	#define DIVIDED_BY_ZERO_NUMBER /*------------------------*/ (4)

	#define NONE_MATCH_IMAGE /*------------------------------*/ (0)
	#define CANNOT_OPEN_MATCH_IMAGE /*-----------------------*/ (1)
	#define CANNOT_READ_MATCH_IMAGE /*-----------------------*/ (2)
	#define UNSUPPORTED_FORMAT_MATCH_IMAGE /*----------------*/ (3)
	#define BAD_HEADER_MATCH_IMAGE /*------------------------*/ (4)
	#define BAD_DEPTH_MATCH_IMAGE /*-------------------------*/ (5)
	#define BAD_COMPRESSION_MATCH_IMAGE /*-------------------*/ (6)
	#define UNSUPPORTED_HEIGHT_MATCH_IMAGE /*----------------*/ (7)
	#define BAD_SIZE_MATCH_IMAGE /*--------------------------*/ (8)
	#define FAILED_MATCH_IMAGE /*----------------------------*/ (9)
	#define BAD_PIXELS_MATCH_IMAGE /*------------------------*/ (10)
	#define BAD_IMAGE_MATCH_IMAGE /*-------------------------*/ (11)
	#define SUCCESS_MATCH_IMAGE /*---------------------------*/ (12)

	#define NONE_MATCH_COMMAND_ORIGIN /*---------------------*/ (0)
	#define PRESS_MATCH_COMMAND_ORIGIN /*--------------------*/ (1)
	#define RELEASE_MATCH_COMMAND_ORIGIN /*------------------*/ (2)
	#define CONFIG_MATCH_COMMAND_ORIGIN /*-------------------*/ (3)
	#define STDIN_MATCH_COMMAND_ORIGIN /*--------------------*/ (4)
	#define TRANSMITTER_MATCH_COMMAND_ORIGIN /*--------------*/ (5)

	#define NONE_MATCH_COMMAND_TYPE /*-----------------------*/ (0)
	#define TYPICAL_MATCH_COMMAND_TYPE /*--------------------*/ (1)
	#define RESTART_MATCH_COMMAND_TYPE /*--------------------*/ (2)
	#define EXIT_MATCH_COMMAND_TYPE /*-----------------------*/ (3)

	#define ROTATION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)        k(NONE##p) \
		, v(degrees-90)  k(DEGREES_90##p)  \
		, v(degrees-180) k(DEGREES_180##p) \
		, v(degrees-270) k(DEGREES_270##p) \
		, n(NULL)        k(NULL##p) \
	}

	#define INITWINDOWSYSTEM() /*----------------------------*/ local bool                   initWindowSystem(WindowSystem *const windowSystem)
	#define CREATEWINDOWCIRCLEPIXMAP() /*--------------------*/ local bool                   createWindowCirclePixmap(WindowSystem *const windowSystem, const uint radius, const uint32 foreground, const uint32 background)
	#define CREATEWINDOWS() /*-------------------------------*/ local bool                   createWindows(WindowSystem *const windowSystem, const uint amount, const bool overrideRedirect, const uint32 eventMask)
	#define MAPWINDOWS() /*----------------------------------*/ local bool                   mapWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences, const uint8 whichMonitor)
	#define CONFIGUREWINDOWS() /*----------------------------*/ local bool                   configureWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences, const uint8 whichMonitor)
	#define DRAWWINDOWS() /*---------------------------------*/ local bool                   drawWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences)
	#define SETWINDOWPROPERTIES() /*-------------------------*/ local bool                   setWindowProperties(WindowInfo *const windowInfo, const ElementPreferences *const windowPreferences, const int x, const int y, const uint width, const uint height)
	#define DRAWWINDOW() /*----------------------------------*/ local bool                   drawWindow(WindowSystem *const windowSystem, const WindowInfo *const windowInfo, const ElementPreferences *const windowPreferences, Monitor *const monitor, ElementRectangle *windowRectangle)
	#define UNMAPWINDOWS() /*--------------------------------*/ local bool                   unmapWindows(WindowSystem *const windowSystem)
	#define DESTROYWINDOWS() /*------------------------------*/ local bool                   destroyWindows(WindowSystem *const windowSystem)
	#define GETRECTANGLE() /*--------------------------------*/ local bool                   getRectangle(Monitor *const _monitor, const ElementRectangle *const parentRectangle, const ElementPreferences *const preferences, ElementRectangle *const rectangle)
	#define GETTYPEDNUMBER() /*------------------------------*/ local int                    getTypedNumber(const int number, const uint8 type, const uint8 axis, const int size, Monitor *const monitor)
	#define FINDWINDOW() /*----------------------------------*/ local bool                   findWindow(WindowSystem *const windowSystem, const xcb_window_t window)
	#define FINIWINDOWSYSTEM() /*----------------------------*/ local bool                   finiWindowSystem(WindowSystem *const windowSystem)

	#define INITCLIPBOARDSYSTEM() /*-------------------------*/ local bool                   initClipboardSystem(ClipboardSystem *const clipboardSystem)
	#define CREATECLIPBOARDBUFFER() /*-----------------------*/ local bool                   createClipboardBuffer(ClipboardSystem *const clipboardSystem, const uint8 *const start, const uint length)
	#define DESTROYCLIPBOARDBUFFER() /*----------------------*/ local bool                   destroyClipboardBuffer(ClipboardSystem *const clipboardSystem)
	#define FINICLIPBOARDSYSTEM() /*-------------------------*/ local bool                   finiClipboardSystem(ClipboardSystem *const clipboardSystem)

	#define INITINPUTSYSTEM() /*-----------------------------*/ local bool                   initInputSystem(InputSystem *const inputSystem)
	#define INSERTINPUTCHARACTER() /*------------------------*/ local bool                   insertInputCharacter(InputSystem *const inputSystem, const xcb_key_press_event_t *const e)
	#define ALLOCATEINPUTBUFFER() /*-------------------------*/ local bool                   allocateInputBuffer(InputSystem *const inputSystem, const uint length)
	#define MOVEINPUTCURSORBY() /*---------------------------*/ local bool                   moveInputCursorBy(InputSystem *const inputSystem, const uint8 direction, const uint8 matchLength)
	#define MOVEINPUTCURSORTOSTART() /*----------------------*/ local bool                   moveInputCursorToStart(InputSystem *const inputSystem)
	#define MOVEINPUTCURSORTOEND() /*------------------------*/ local bool                   moveInputCursorToEnd(InputSystem *const inputSystem)
	#define SELECTINPUTTEXT() /*-----------------------------*/ local bool                   selectInputText(InputSystem *const inputSystem, const uint8 direction, const uint8 matchLength)
	#define SELECTINPUTUNTILSTART() /*-----------------------*/ local bool                   selectInputUntilStart(InputSystem *const inputSystem)
	#define SELECTINPUTUNTILEND() /*-------------------------*/ local bool                   selectInputUntilEnd(InputSystem *const inputSystem)
	#define SELECTALLINPUT() /*------------------------------*/ local bool                   selectAllInput(InputSystem *const inputSystem)
	#define SETSELECTEDINPUTCASE() /*------------------------*/ local bool                   setSelectedInputCase(InputSystem *const inputSystem, const uint8 newCase)
	#define REMOVEINPUTTEXT() /*-----------------------------*/ local bool                   removeInputText(InputSystem *const inputSystem, const uint8 direction, const uint8 matchLength)
	#define REMOVESELECTEDINPUT() /*-------------------------*/ local bool                   removeSelectedInput(InputSystem *const inputSystem)
	#define COPYSELECTEDINPUT() /*---------------------------*/ local bool                   copySelectedInput(InputSystem *const inputSystem, ClipboardSystem *const clipboardSystem)
	#define PASTEONINPUT() /*--------------------------------*/ local bool                   pasteOnInput(InputSystem *const inputSystem, const uint8 *const start, const uint length)
	#define CHANGEINPUTMODE() /*-----------------------------*/ local bool                   changeInputMode(InputSystem *const inputSystem)
	#define EXECUTEINPUTBUFFER() /*--------------------------*/ local bool                   executeInputBuffer(InputSystem *const inputSystem)
	#define GETINPUTCHARACTERLENGTH() /*---------------------*/ local uint                   getInputCharacterLength(InputSystem *const inputSystem, const uint8 direction, const uint8 *const p)
	#define GETINPUTWORDLENGTH() /*--------------------------*/ local uint                   getInputWordLength(InputSystem *const inputSystem, const uint8 direction, const uint8 *const p)
	#define FINIINPUTSYSTEM() /*-----------------------------*/ local bool                   finiInputSystem(InputSystem *const inputSystem)

	#define INITASCIISTRINGTREESYSTEM() /*-------------------*/ local bool                   initASCIIStringTreeSystem(ASCIIStringTreeSystem *const asciiStringTreeSystem)
	#define PATHINSERTASCIISTRING() /*-----------------------*/ local bool                   pathInsertASCIIString(ASCIIStringTreeSystem *const asciiStringTreeSystem, const char *const path)
	#define INSERTASCIISTRING() /*---------------------------*/ local bool                   insertASCIIString(ASCIIStringTreeSystem *const asciiStringTreeSystem, const uint8 *string)
	#define GETASCIISTRINGTREENODE() /*----------------------*/ local ASCIIStringTreeNode *  getASCIIStringTreeNode(ASCIIStringTreeSystem *const asciiStringTreeSystem, const uint8 **const stringReturn)
	#define ISASCIISTRING() /*-------------------------------*/ local bool                   isASCIIString(ASCIIStringTreeSystem *const asciiStringTreeSystem, const void *string)
	#define FINDASCIISTRINGTREENODES() /*--------------------*/ local bool                   findASCIIStringTreeNodes(ASCIIStringTreeSystem *const asciiStringTreeSystem, const uint amount, const uint8 *prefix)
	#define FINDFOUNDASCIISTRING() /*------------------------*/ local bool                   findFoundASCIIString(ASCIIStringTreeSystem *const asciiStringTreeSystem, const uint selectedString)
	#define FINIASCIISTRINGTREESYSTEM() /*-------------------*/ local bool                   finiASCIIStringTreeSystem(ASCIIStringTreeSystem *const asciiStringTreeSystem)

	#define INITSELECTIONSYSTEM() /*-------------------------*/ local bool                   initSelectionSystem(SelectionSystem *const selectionSystem)
	#define SETSELECTIONAXIS() /*----------------------------*/ local bool                   setSelectionAxis(SelectionSystem *const selectionSystem, const uint8 selectionAxis)
	#define SETSELECTIONAXISAMOUNT() /*----------------------*/ local bool                   setSelectionAxisAmount(SelectionSystem *const selectionSystem, const uint selectionAxisAmount)
	#define SETSELECTIONAMOUNT() /*--------------------------*/ local bool                   setSelectionAmount(SelectionSystem *const selectionSystem, const uint selectionAmount)
	#define SETSTARTINGSELECTION() /*------------------------*/ local bool                   setStartingSelection(SelectionSystem *const selectionSystem, const uint8 startingSelection)
	#define SETCURRENTSELECTION() /*-------------------------*/ local bool                   setCurrentSelection(SelectionSystem *const selectionSystem)
	#define SETSELECTIONNAVIGATION() /*----------------------*/ local bool                   setSelectionNavigation(SelectionSystem *const selectionSystem, const bool allowCircularNavigation)
	#define MOVECURRENTSELECTION() /*------------------------*/ local bool                   moveCurrentSelection(SelectionSystem *const selectionSystem, const uint8 whichSelection)
	#define FINISELECTIONSYSTEM() /*-------------------------*/ local bool                   finiSelectionSystem(SelectionSystem *const selectionSystem)

	#define SETCONFIGVARIABLES() /*--------------------------*/ local void                   setConfigVariables(void)
	#define READCONFIG() /*----------------------------------*/ local void                   readConfig(const bool createConfigFile, const char *const configPath, int (*getNextConfigChar)(void *const arg), int (*getPreviousConfigChar)(void *const arg))
	#define IFGETC() /*--------------------------------------*/ local int                    ifgetc(void *const system)
	#define MATCHNAMELIST() /*-------------------------------*/ local uint8                  matchNameList(StringTreeSystem *const stringTreeSystem, const char *const statementWall, char **statementCurrentReturn, uint8 *const valueReturn)
	#define MATCHINTEGER() /*--------------------------------*/ local uint8                  matchInteger(char **statementCurrent, const char *const statementWall, int64 *const returnValue)
	#define MATCHSTRING() /*---------------------------------*/ local bool                   matchString(char **statementCurrent, char **stringReturn, uint32 *stringToken)
	#define MATCHIMAGE() /*----------------------------------*/ local uint8                  matchImage(const char *const path, const char **errorMessage, Image *const image)
	#define MATCHCOMMAND() /*--------------------------------*/ local uint8                  matchCommand(const Command command, const char *const execute, const uint8 origin, const int32 field0, const int32 field1, const int32 field2, const int32 field3, const int32 field4)
	#define FREECONFIGVARIABLES() /*-------------------------*/ local void                   freeConfigVariables(void)

	#define CREATECIRCLE() /*--------------------------------*/ local bool                   createCircle(const int radius, const uint32 foreground, const uint32 background, Image *image)
	#define COMPOSITEIMAGES() /*-----------------------------*/ local void                   compositeImages(void (*operation)(const uint32 *const, uint32 *const), const int sourceX, const int sourceY, Image *const source, int destinationX, int destinationY, Image *const destination)
	#define COMPOSITEIMAGESOVER() /*-------------------------*/ local void                   compositeImagesOver(const uint32 *const source, uint32 *const destination)
	#define COMPOSITEIMAGESAND() /*--------------------------*/ local void                   compositeImagesAnd(const uint32 *const source, uint32 *const destination)
	#define TWOPASSBOXBLUR() /*------------------------------*/ local void                   twoPassBoxBlur(const int width, const int height, const int boxSize, uint32 *destinationData)
	#define ROTATEIMAGE() /*---------------------------------*/ local bool                   rotateImage(const uint8 rotation, Image *const image, const bool deletePreviousData)

	#define XCB_SYNC() /*------------------------------------*/ local bool                   xcb_sync(void)
	#define GETWINDOWCLASS() /*------------------------------*/ local uint8                  getWindowClass(xcb_window_t window)
	#define GETFOCUSEDWINDOW() /*----------------------------*/ local xcb_window_t           getFocusedWindow(void)

	#define RESTART() /*-------------------------------------*/ local void                   restart(const bool isInsideConfig)
	#define CLEANUP() /*-------------------------------------*/ local void                   cleanup(void)
	#define CANCELTHREADS() /*-------------------------------*/ local void                   cancelThreads(void)

	#define PRINTUNACCOUNTEDFORPOINTERS() /*-----------------*/ local void                   printUnaccountedForPointers(const Pointer *current, const Pointer *wall)
	#define PRINTERROR() /*----------------------------------*/ local void                   printError(const char *const message, ...)
	#define PRINTTITLEDERROR() /*----------------------------*/ local void                   printTitledError(const char *const title, const char *const message)
	#define PRINTTITLEDQUOTEDERROR() /*----------------------*/ local void                   printTitledQuotedError(const char *const title, const char *const argument, const char *const message)
	#define PRINTCONNECTIONERROR() /*------------------------*/ local void                   printConnectionError(void)
	#define PRINTTITLEDNAMEDERROR() /*-----------------------*/ local void                   printTitledNamedError(const char *const title, const char *const message, const char *const name)
	#define PRINTXERROR() /*---------------------------------*/ local void                   printXError(const char *const *const name)
	#define PRINTTITLEDVALUEDERROR() /*----------------------*/ local void                   printTitledValuedError(const char *const title, const char *const message, const uint value)
	#define PRINTCONFIGERROR() /*----------------------------*/ local void                   printConfigError(const char *const type, const char *const message, const char finalStatementCharacter, const bool printLine, const bool printConfig, const bool printPointer, const bool printPattern, const char *const configPath, const uint statementLine, const char *const statementStart, const char *const statementWall, const Instruction *instructionStart, const Instruction *instructionCurrent, StringTreeSystem *const *const instructionDataStart, const char *const *currentScopeInstructionList, const StringTreeSystem *const currentScopeInstructionStringTreeSystem)

	#if DEBUG
		#define printCommand(s, c) /*---*/ (fprintf(DEFAULT_OUTPUT_STREAM, "%s%s: %s" s " command:%s %s\n", colorStart, programName, colorEvent, colorEnd, *(commandList + (c >= countof(commandList)? countof(commandList) - 1 : c))))
	#else
		#define printCommand(s, c) /*---*/ EMPTY_MACRO
	#endif
/*!}*/

/*!defs:{*/
	def enum ENUM_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	def enum ENUM_CONTENT(GLOBAL_INSTRUCTION);
	def enum ENUM_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	def enum ENUM_CONTENT(BOOLEAN);
	def enum ENUM_CONTENT(VARIABLE);
	def enum ENUM_CONTENT(COMMAND);
	def enum ENUM_CONTENT(MODIFIER);
	def enum ENUM_CONTENT(SHORTCUT_STATE);
	def enum ENUM_CONTENT(NUMBER_TYPE);
	def enum ENUM_CONTENT(POSITION);
	def enum ENUM_CONTENT(HORIZONTAL_ALIGNMENT);
	def enum ENUM_CONTENT(VERTICAL_ALIGNMENT);
	def enum ENUM_CONTENT(CORNER);
	def enum ENUM_CONTENT(AXIS);
	def enum ENUM_CONTENT(STARTING_SELECTION);
	def enum ENUM_CONTENT(WHICH_MONITOR);
	def enum ENUM_CONTENT(ROTATION);
	def enum ENUM_CONTENT(MACRO);

	def struct{
		int32 /*-----------------*/ x;
		int32 /*-----------------*/ y;
		int32 /*-----------------*/ xOffset;
		int32 /*-----------------*/ yOffset;
		int32 /*-----------------*/ width;
		int32 /*-----------------*/ height;
		int32 /*-----------------*/ padding;
		int32 /*-----------------*/ margin;
		uint8 /*-----------------*/ xType;
		uint8 /*-----------------*/ yType;
		uint8 /*-----------------*/ xOffsetType;
		uint8 /*-----------------*/ yOffsetType;
		uint8 /*-----------------*/ widthType;
		uint8 /*-----------------*/ heightType;
		uint8 /*-----------------*/ paddingType;
		uint8 /*-----------------*/ marginType;
		uint8 /*-----------------*/ position;
		uint8 /*-----------------*/ horizontalAlignment;
		uint8 /*-----------------*/ verticalAlignment;
		uint8 /*-----------------*/ pad0[3];
		bool /*------------------*/ clipChildren;
		uint8 /*-----------------*/ cornerUsed;
		uint32 /*----------------*/ cornerRadius;
		uint32 /*----------------*/ foreground;
		uint32 /*----------------*/ background;
		uint32 /*----------------*/ selectedForeground;
		uint32 /*----------------*/ selectedBackground;
	} ElementPreferences;

	def struct{
		xcb_window_t /*----------*/ window;
		xcb_pixmap_t /*----------*/ bufferPixmap;
		xcb_pixmap_t /*----------*/ pixmap;
		xcb_gcontext_t /*--------*/ gc;
		int32 /*-----------------*/ x;
		int32 /*-----------------*/ y;
		uint32 /*----------------*/ width;
		uint32 /*----------------*/ height;
		bool /*------------------*/ mapped;
		uint8 /*-----------------*/ pad0[3];
	} WindowInfo;

	def struct{
		xcb_pixmap_t /*----------*/ circlePixmap;
		uint32 /*----------------*/ windowInfoSize;
		WindowInfo * /*----------*/ windowInfoStart;
		uint32 /*----------------*/ windowInfoToken;
		bool /*------------------*/ mapped;
		uint8 /*-----------------*/ pad0[3];
	} WindowSystem;

	def struct{
		Monitor * /*-------------*/ monitor;
		int32 /*-----------------*/ x;
		int32 /*-----------------*/ y;
		uint32 /*----------------*/ width;
		uint32 /*----------------*/ height;
		uint32 /*----------------*/ horizontalPadding;
		uint32 /*----------------*/ verticalPadding;
		uint32 /*----------------*/ horizontalMargin;
		uint32 /*----------------*/ verticalMargin;
	} ElementRectangle;

	def struct{
		uint8 * /*---------------*/ dataStart;
		uint32 /*----------------*/ dataToken;
		uint32 /*----------------*/ dataSize;
	} ClipboardSystem;

	def struct{
		uint32 /*----------------*/ dataSize;
		uint32 /*----------------*/ dataLength;
		uint8 * /*---------------*/ dataStart;
		uint8 * /*---------------*/ dataCurrent;
		uint32 /*----------------*/ dataToken;
		uint32 /*----------------*/ selectedDataLength;
		uint8 * /*---------------*/ selectedDataCurrent;
		uint8 /*-----------------*/ mode;
		uint8 /*-----------------*/ pad0[7];
	} InputSystem;

	def struct{
		uint8 /*-----------------*/ letter;
		uint8 /*-----------------*/ childOffsetStart;
		uint8 /*-----------------*/ childOffsetCurrent;
		uint8 /*-----------------*/ childOffsetWall;
		uint32 /*----------------*/ childOffset[128];
		uint32 /*----------------*/ parentOffset;
	} ASCIIStringTreeNode;

	def struct{
		uint32 /*----------------*/ dataSize;
		uint32 /*----------------*/ dataAllocated;
		ASCIIStringTreeNode * /*-*/ dataStart;
		uint32 /*----------------*/ dataToken;
		uint32 /*----------------*/ stringsFoundAmount;
		uint32 /*----------------*/ stringsFoundSize;
		uint32 /*----------------*/ stringsFoundAllocated;
		uint8 * /*---------------*/ stringsFoundStart;
		uint32 /*----------------*/ stringsFoundToken;
		uint32 /*----------------*/ foundStringLength;
		uint8 * /*---------------*/ foundStringStart;
	} ASCIIStringTreeSystem;

	def struct{
		uint32 /*----------------*/ selectionAmount;
		uint32 /*----------------*/ selectionAxisAmount;
		int32 /*-----------------*/ currentSelection;
		uint8 /*-----------------*/ startingSelection;
		uint8 /*-----------------*/ selectionAxis;
		bool /*------------------*/ allowCircularNavigation;
		uint8 /*-----------------*/ pad0[1];
	} SelectionSystem;

	def struct{
		bool /*----------------*/ (*risingOperation)(void *const arg);
		void * /*--------------*/ risingOperationArgument;
		bool /*----------------*/ (*fallingOperation)(void *const arg);
		void * /*--------------*/ fallingOperationArgument;
		uint32 /*--------------*/ seconds;
		uint32 /*--------------*/ nanoseconds;
		bool /*----------------*/ loopOperation;
		bool /*----------------*/ restartTimer;
		uint8 /*---------------*/ pad0[1];
		bool /*----------------*/ running;
		bool /*----------------*/ quittingThread;
		bool /*----------------*/ mutexCreated;
		bool /*----------------*/ condCreated;
		bool /*----------------*/ threadCreated;
		pthread_mutex_t /*-----*/ mutex;
		pthread_cond_t /*------*/ cond;
		pthread_t /*-----------*/ thread;
	} SleepThreadSystem;

	def struct{
		uint8 /*-----------------*/ letter;
		uint8 /*-----------------*/ childrenAmount;
		uint16 /*----------------*/ offset[STRING_TREE_NODE_CHILDREN_AMOUNT];
	} StringTreeNode;

	def struct{
		const char *const * /*---*/ stringArray;
		uint32 /*----------------*/ dataSize;
		uint32 /*----------------*/ dataAllocated;
		StringTreeNode * /*------*/ dataStart;
		uint32 /*----------------*/ dataToken;
		uint8 /*-----------------*/ counter;
		uint8 /*-----------------*/ returnedCounter;
		uint8 /*-----------------*/ pad0[2];
	} StringTreeSystem;

	def struct{
		uint32 /*----------------*/ size;
		uint32 /*----------------*/ allocated;
		char * /*----------------*/ start;
		char * /*----------------*/ current;
		uint32 /*----------------*/ token;
		uint8 /*-----------------*/ pad0[1];
		bool /*------------------*/ threadCreated;
		bool /*------------------*/ operating;
		bool /*------------------*/ quittingThread;
		pthread_t /*-------------*/ thread;
	} STDINSystem;

	def struct{
		int32 /*-----------------*/ shmID;
		uint32 /*----------------*/ shmToken;
		uint8 * /*---------------*/ start;
		uint8 * /*---------------*/ current;
		uint32 /*----------------*/ token;
		uint8 /*-----------------*/ pad0[6];
		bool /*------------------*/ mutexCreated;
		bool /*------------------*/ condCreated;
		bool /*------------------*/ threadCreated;
		bool /*------------------*/ operating;
		bool /*------------------*/ quittingFromInside;
		bool /*------------------*/ quittingThread;
		pthread_mutex_t * /*-----*/ mutex;
		pthread_cond_t * /*------*/ cond;
		pthread_t /*-------------*/ thread;
	} SharedMemorySystem;
/*!}*/

/*!globals:{*/
	local const char * /*-------------------*/ programName;
	local const char * /*-------------------*/ errorPath;
	local const char * /*-------------------*/ colorStart;
	local const char * /*-------------------*/ colorFatal;
	local const char * /*-------------------*/ colorError;
	local const char * /*-------------------*/ colorEvent;
	local const char * /*-------------------*/ colorEnd;
	local const char * /*-------------------*/ labelExamined;
	local const char * /*-------------------*/ connectionName;
	local const char * /*-------------------*/ configPath;
	local const char * /*-------------------*/ localeName;
	local const ModifierNode * /*-----------*/ eventModifierNode;
	local bool /*---------------------------*/ mustOpenErrorStream;
	local FILE * /*-------------------------*/ errorStream;
	local uint32 /*-------------------------*/ errorStreamToken;
	local volatile bool /*------------------*/ processingSignal;
	local bool /*---------------------------*/ quitting;
	local MemoryManagementSystem /*------------*/ memoryManagementSystem;
	local PermissionSystem /*---------------*/ permissionSystem;
	local bool /*---------------------------*/ globalsLockCreated;
	local pthread_rwlock_t /*---------------*/ globalsLock;
	local int /*----------------------------*/ screenNumber;
	local xcb_connection_t * /*-------------*/ connection;
	local uint32 /*-------------------------*/ connectionToken;
	local xcb_screen_t * /*-----------------*/ screen;
	local uint /*---------------------------*/ screenWidthInPixels;
	local uint /*---------------------------*/ screenHeightInPixels;
	local uint /*---------------------------*/ screenWidthInMillimeters;
	local uint /*---------------------------*/ screenHeightInMillimeters;
	local Display * /*----------------------*/ display;
	local uint32 /*-------------------------*/ displayToken;
	local uint8 /*--------------------------*/ randrMajorOpcode;
	local uint8 /*--------------------------*/ randrBaseEvent;
	local uint8 /*--------------------------*/ randrBaseError;
	local CommonAtoms /*--------------------*/ atom;
	local XIM /*----------------------------*/ im;
	local XIC /*----------------------------*/ ic;
	local xcb_visualid_t /*-----------------*/ visual;
	local uint8 /*--------------------------*/ depth;
	local xcb_colormap_t /*-----------------*/ colormap;
	local MonitorSystem /*------------------*/ monitorSystem;
	local ElementPreferences /*-------------*/ windowPreferences;
	local ElementPreferences /*-------------*/ inputPreferences;
	local ElementPreferences /*-------------*/ inputTextPreferences;
	local ElementPreferences /*-------------*/ selectionPreferences;
	local ElementPreferences /*-------------*/ selectionTextPreferences;
	local uint /*---------------------------*/ maximumSelectionAmount;
	local uint8 /*--------------------------*/ whichMonitor;
	local xcb_font_t /*---------------------*/ font;
	local WindowSystem /*-------------------*/ windowSystem;
	local ClipboardSystem /*----------------*/ clipboardSystem;
	local InputSystem /*--------------------*/ inputSystem;
	local ASCIIStringTreeSystem /*----------*/ asciiStringTreeSystem;
	local SelectionSystem /*----------------*/ selectionSystem;
	local SleepThreadSystem /*--------------*/ sleepThreadSystem;
	local StringTreeSystem /*---------------*/ globalScopesInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ globalInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ scope1ScopeInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ booleanStringTreeSystem;
	local StringTreeSystem /*---------------*/ variableStringTreeSystem;
	local StringTreeSystem /*---------------*/ commandStringTreeSystem;
	local StringTreeSystem /*---------------*/ modifierStringTreeSystem;
	local StringTreeSystem /*---------------*/ shortcutStateStringTreeSystem;
	local StringTreeSystem /*---------------*/ numberTypeStringTreeSystem;
	local StringTreeSystem /*---------------*/ horizontalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ verticalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ cornerStringTreeSystem;
	local StringTreeSystem /*---------------*/ axisStringTreeSystem;
	local StringTreeSystem /*---------------*/ startingSelectionStringTreeSystem;
	local StringTreeSystem /*---------------*/ whichMonitorStringTreeSystem;
	local StringTreeSystem /*---------------*/ macroStringTreeSystem;
	local bool /*---------------------------*/ displaySimpleConfigErrors;
	local STDINSystem /*--------------------*/ stdinSystem;
	local SharedMemorySystem /*-------------*/ sharedMemorySystem;
	local ShortcutSystem /*-----------------*/ keycodeShortcutSystem;
	local ShortcutSystem /*-----------------*/ buttonShortcutSystem;
	local xcb_generic_event_t * /*----------*/ event;
	local uint32 /*-------------------------*/ eventToken;
	local int /*----------------------------*/ keyPressNextOffset;
	local int /*----------------------------*/ keyReleaseNextOffset;
	local int /*----------------------------*/ buttonPressNextOffset;
	local int /*----------------------------*/ buttonReleaseNextOffset;
	local uint8 /*--------------------------*/ shortcutCode;
	local uint16 /*-------------------------*/ shortcutModifier;
	local bool /*---------------------------*/ expectingSecondKeyRelease;
	local uint8 /*--------------------------*/ realKeyReleaseModifier;

	local const char *const /*--------------*/ globalScopesInstructionList[] = STRING_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	local const char *const /*--------------*/ globalInstructionList[] = STRING_CONTENT(GLOBAL_INSTRUCTION);
	local const char *const /*--------------*/ scope1ScopeInstructionList[] = STRING_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	local const char *const /*--------------*/ booleanList[] = STRING_CONTENT(BOOLEAN);
	local const char *const /*--------------*/ variableList[] = STRING_CONTENT(VARIABLE);
	local const char *const /*--------------*/ commandList[] = STRING_CONTENT(COMMAND);
	local const char *const /*--------------*/ modifierList[] = STRING_CONTENT(MODIFIER);
	local const char *const /*--------------*/ shortcutStateList[] = STRING_CONTENT(SHORTCUT_STATE);
	local const char *const /*--------------*/ numberTypeList[] = STRING_CONTENT(NUMBER_TYPE);
	local const char *const /*--------------*/ horizontalAlignmentList[] = STRING_CONTENT(HORIZONTAL_ALIGNMENT);
	local const char *const /*--------------*/ verticalAlignmentList[] = STRING_CONTENT(VERTICAL_ALIGNMENT);
	local const char *const /*--------------*/ cornerList[] = STRING_CONTENT(CORNER);
	local const char *const /*--------------*/ axisList[] = STRING_CONTENT(AXIS);
	local const char *const /*--------------*/ startingSelectionList[] = STRING_CONTENT(STARTING_SELECTION);
	local const char *const /*--------------*/ whichMonitorList[] = STRING_CONTENT(WHICH_MONITOR);
	local const char *const /*--------------*/ macroList[] = STRING_CONTENT(MACRO);

	local const Instruction /*--------------*/ helpInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ expandInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ contractInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ readConfigInstruction[] = {STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useTerminalInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useMessengerInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ setInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ doInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ stopInstruction[] = {END_INSTRUCTION_TYPE};

	local const Instruction /*--------------*/ windowXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowWidthSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowHeightSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowCornerRadiusSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputWidthSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputHeightSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputClipChildrenSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputTextXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputTextYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputTextXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputTextYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputTextHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputTextVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputTextForegroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputTextBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputTextSelectedForegroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ inputTextSelectedBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionWidthSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionHeightSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionMarginSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionClipChildrenSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionSelectedBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionTextXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionTextYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionTextXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionTextYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionTextHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionTextVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionTextForegroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionTextBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionTextSelectedForegroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionTextSelectedBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ maximumSelectionAmountSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionAxisSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionAxisAmountSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ startingSelectionSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ allowCircularNavigationSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ whichMonitorSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ fontSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};

	local StringTreeSystem *const *const /*-*/ helpInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ expandInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ contractInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ readConfigInstructionData = NULL;
	local StringTreeSystem *const /*--------*/ useTerminalInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ useMessengerInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ setInstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ doInstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabKeycodeInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabButtonInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabKeycodeInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabButtonInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const *const /*-*/ stopInstructionData = NULL;

	local StringTreeSystem *const /*--------*/ windowXSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowYSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowXOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowYOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowWidthSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowHeightSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowHorizontalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &horizontalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowVerticalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &verticalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowCornerRadiusSetSubinstructionData[] = {&variableStringTreeSystem, &cornerStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputXSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputYSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputXOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputYOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputWidthSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputHeightSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputHorizontalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &horizontalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputVerticalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &verticalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputClipChildrenSetSubinstructionData[] = {&variableStringTreeSystem, &booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputTextXSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputTextYSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputTextXOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputTextYOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputTextHorizontalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &horizontalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputTextVerticalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &verticalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputTextForegroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputTextBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputTextSelectedForegroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ inputTextSelectedBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionXSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionYSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionXOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionYOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionWidthSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionHeightSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionMarginSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionHorizontalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &horizontalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionVerticalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &verticalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionClipChildrenSetSubinstructionData[] = {&variableStringTreeSystem, &booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionSelectedBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionTextXSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionTextYSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionTextXOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionTextYOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionTextHorizontalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &horizontalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionTextVerticalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &verticalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionTextForegroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionTextBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionTextSelectedForegroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionTextSelectedBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ maximumSelectionAmountSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionAxisSetSubinstructionData[] = {&variableStringTreeSystem, &axisStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionAxisAmountSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ startingSelectionSetSubinstructionData[] = {&variableStringTreeSystem, &startingSelectionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ allowCircularNavigationSetSubinstructionData[] = {&variableStringTreeSystem, &booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ whichMonitorSetSubinstructionData[] = {&variableStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ fontSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeDoSubinstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};

	#define getInstruction(i) /*-----*/ (i##Instruction)
	#define getInstructionData(i) /*-*/ (i##InstructionData)
	#define getGlobalScope(i) /*-----*/ { \
		  get##i(help) \
		, get##i(expand) \
		, get##i(contract) \
		, get##i(readConfig) \
		, get##i(useTerminal) \
		, get##i(useMessenger) \
		, get##i(set) \
		, get##i(do) \
		, get##i(grabKeycode) \
		, get##i(grabButton) \
		, get##i(ungrabKeycode) \
		, get##i(ungrabButton) \
		, get##i(stop) \
	}
/*!}*/

int main(int argumentAmount, const char *const *argument){
	setGlobals:{
		programName /*---------------*/ = *argument;
		errorPath /*-----------------*/ = NULL;
		colorStart /*----------------*/ = MESSAGE_START;
		colorFatal /*----------------*/ = MESSAGE_FATAL;
		colorError /*----------------*/ = MESSAGE_ERROR;
		colorEvent /*----------------*/ = MESSAGE_EVENT;
		colorEnd /*------------------*/ = MESSAGE_END;
		connectionName /*------------*/ = NULL;
		configPath /*----------------*/ = NULL;
		localeName /*----------------*/ = setlocale(LC_ALL, "");
		mustOpenErrorStream /*-------*/ = false;
		errorStream /*---------------*/ = DEFAULT_ERROR_STREAM;
		errorStreamToken /*----------*/ = 0;
		quitting /*------------------*/ = false;
		connection /*----------------*/ = NULL;
		connectionToken /*-----------*/ = 0;
		display /*-------------------*/ = NULL;
		displayToken /*--------------*/ = 0;
		im /*------------------------*/ = XCB_NONE;
		ic /*------------------------*/ = XCB_NONE;
		event /*---------------------*/ = NULL;
		eventToken /*----------------*/ = 0;
		keyPressNextOffset /*--------*/ = 0;
		keyReleaseNextOffset /*------*/ = 0;
		buttonPressNextOffset /*-----*/ = 0;
		buttonReleaseNextOffset /*---*/ = 0;
		shortcutCode /*--------------*/ = 0;
		shortcutModifier /*----------*/ = XCB_NONE;
		expectingSecondKeyRelease /*-*/ = false;
		initMemorySystem();
		initPermissionSystem(&permissionSystem);
		initMonitorSystem(&monitorSystem);
		initWindowSystem(&windowSystem);
		initClipboardSystem(&clipboardSystem);
		initInputSystem(&inputSystem);
		initASCIIStringTreeSystem(&asciiStringTreeSystem);
		initSelectionSystem(&selectionSystem);
		initSleepThreadSystem(&sleepThreadSystem);
		initStringTreeSystem(&globalScopesInstructionStringTreeSystem);
		initStringTreeSystem(&globalInstructionStringTreeSystem);
		initStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
		initStringTreeSystem(&booleanStringTreeSystem);
		initStringTreeSystem(&variableStringTreeSystem);
		initStringTreeSystem(&commandStringTreeSystem);
		initStringTreeSystem(&modifierStringTreeSystem);
		initStringTreeSystem(&shortcutStateStringTreeSystem);
		initStringTreeSystem(&numberTypeStringTreeSystem);
		initStringTreeSystem(&horizontalAlignmentStringTreeSystem);
		initStringTreeSystem(&verticalAlignmentStringTreeSystem);
		initStringTreeSystem(&cornerStringTreeSystem);
		initStringTreeSystem(&axisStringTreeSystem);
		initStringTreeSystem(&startingSelectionStringTreeSystem);
		initStringTreeSystem(&whichMonitorStringTreeSystem);
		initStringTreeSystem(&macroStringTreeSystem);
		initSTDINSystem(&stdinSystem);
		initSharedMemorySystem(&sharedMemorySystem);
		initShortcutSystem(&keycodeShortcutSystem);
		initShortcutSystem(&buttonShortcutSystem);
		setConfigVariables();
		setPermissions(&permissionSystem);
		lowerPermissions(&permissionSystem);
		processingSignal = false;
		jmp getProgramArguments;
	}
	selectExtraInput:{
		if(!XSupportsLocale()){
			printTitledError("locale error", "current X locale not supported");
		}
		XSetLocaleModifiers("@im=local");
		if(!(im = XOpenIM(display, NULL, NULL, NULL))){
			printTitledError("input method error", "could not open input method");
		}elif(!(ic = XCreateIC(im, XNInputStyle, XIMPreeditNothing | XIMStatusNothing, XNClientWindow, (*screen).root, NULL))){
			printTitledError("input context error", "could not open input context");
		}
		jmp setupScreenProfile;
	}
	initSystems:{
		if(createMonitors(&monitorSystem)){
			createWindows(&windowSystem, monitorSystem.size, true, XCB_EVENT_MASK_NO_EVENT);
		}
		pathInsertASCIIString(&asciiStringTreeSystem, "PATH");
		bulkInsertString(&globalScopesInstructionStringTreeSystem, globalScopesInstructionList);
		bulkInsertString(&globalInstructionStringTreeSystem, globalInstructionList);
		bulkInsertString(&scope1ScopeInstructionStringTreeSystem, scope1ScopeInstructionList);
		bulkInsertString(&booleanStringTreeSystem, booleanList);
		bulkInsertString(&variableStringTreeSystem, variableList);
		bulkInsertString(&commandStringTreeSystem, commandList);
		bulkInsertString(&modifierStringTreeSystem, modifierList);
		bulkInsertString(&shortcutStateStringTreeSystem, shortcutStateList);
		bulkInsertString(&numberTypeStringTreeSystem, numberTypeList);
		bulkInsertString(&horizontalAlignmentStringTreeSystem, horizontalAlignmentList);
		bulkInsertString(&verticalAlignmentStringTreeSystem, verticalAlignmentList);
		bulkInsertString(&cornerStringTreeSystem, cornerList);
		bulkInsertString(&axisStringTreeSystem, axisList);
		bulkInsertString(&startingSelectionStringTreeSystem, startingSelectionList);
		bulkInsertString(&whichMonitorStringTreeSystem, whichMonitorList);
		bulkInsertString(&macroStringTreeSystem, macroList);
		jmp readConfig;
	}
	switchEvent:{
		#define XCB_ONE /*-*/ (1)
		if(((*event).response_type & ~b(10000000)) > XCB_NONE and ((*event).response_type & ~b(10000000)) < XCB_GE_GENERIC){
			printXEvent(baseEventName);
		}
		switch (*event).response_type & ~b(10000000) over
			to XCB_NONE: /*--------------*/ jmp errorEvent;
			to XCB_ONE: /*---------------*/ jmp unrecognizedEvent;
			to XCB_KEY_PRESS: /*---------*/ jmp keyPressEvent;
			to XCB_KEY_RELEASE: /*-------*/ jmp keyReleaseEvent;
			to XCB_BUTTON_PRESS: /*------*/ jmp buttonPressEvent;
			to XCB_BUTTON_RELEASE: /*----*/ jmp buttonReleaseEvent;
			to XCB_MOTION_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_ENTER_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_LEAVE_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*----------*/ jmp unexpectedEvent;
			to XCB_FOCUS_OUT: /*---------*/ jmp unexpectedEvent;
			to XCB_KEYMAP_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*-*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*-------*/ jmp unexpectedEvent;
			to XCB_VISIBILITY_NOTIFY: /*-*/ jmp unexpectedEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_MAP_NOTIFY: /*--------*/ jmp unexpectedEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_SELECTION_CLEAR: /*---*/ jmp unexpectedEvent;
			to XCB_SELECTION_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_SELECTION_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_COLORMAP_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CLIENT_MESSAGE: /*----*/ jmp unexpectedEvent;
			to XCB_MAPPING_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*--------*/ jmp genericEvent;
			off: /*----------------------*/ jmp extensionEvent;
		end
		#undef  XCB_ONE
	}
	keyPressEvent:{
		#define e /*-*/ ((xcb_key_press_event_t *)event)
		if(getNextShortcut(&keycodeShortcutSystem, false, (*e).detail, (*e).state & b(11111111), &keyPressNextOffset)){
			jmp matchCommandPress;
		}
		if(insertInputCharacter(&inputSystem, e)){
			findASCIIStringTreeNodes(&asciiStringTreeSystem, maximumSelectionAmount, inputSystem.dataStart);
			setSelectionAmount(&selectionSystem, asciiStringTreeSystem.stringsFoundAmount);
			setCurrentSelection(&selectionSystem);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		shortcutCode = 0;
		shortcutModifier = XCB_NONE;
		expectingSecondKeyRelease = false;
		jmp eventLoop;
		#undef  e
	}
	keyReleaseEvent:{
		#define e /*-*/ ((xcb_key_release_event_t *)event)
		uint8 keycode = (*e).detail;
		uint16 modifier = (*e).state & b(11111111);
		if(getNextShortcut(&keycodeShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &keyReleaseNextOffset)){
			xcb_query_keymap_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_keymap_unchecked(connection), NULL);
			uint32 token = pushPointer(reply, "query keymap reply", iFree);
			if(reply){
				const bool keyIsPressed = !!(*((*reply).keys + (*e).detail / 8) & (1 << (*e).detail % 8));
				free(reply);
				popPointer(token);
				if(keyIsPressed){
					keyReleaseNextOffset = 0;
					jmp eventLoop;
				}
			}
			jmp matchCommandRelease;
		}
		if(keycode != shortcutCode and modifier == shortcutModifier){
			expectingSecondKeyRelease = true;
			realKeyReleaseModifier = shortcutModifier;
			jmp eventLoop;
		}
		if(keycode == shortcutCode and modifier != shortcutModifier){
			if(!expectingSecondKeyRelease){
				jmp eventLoop;
			}
			keycode = shortcutCode;
			modifier = realKeyReleaseModifier;
			expectingSecondKeyRelease = false;
			keyReleaseNextOffset = 0;
			if(getNextShortcut(&keycodeShortcutSystem, true, keycode, modifier, &keyReleaseNextOffset)){
				jmp matchCommandRelease;
			}
		}
		jmp eventLoop;
		#undef  e
	}
	buttonPressEvent:{
		#define e /*-*/ ((xcb_button_press_event_t *)event)
		if(getNextShortcut(&buttonShortcutSystem, false, (*e).detail, (*e).state & b(11111111), &buttonPressNextOffset)){
			jmp matchCommandPress;
		}
		if(!findWindow(&windowSystem, (*e).child)){
			jmp mainEmergencyExit;
		}
		jmp eventLoop;
		#undef  e
	}
	buttonReleaseEvent:{
		#define e /*-*/ ((xcb_button_release_event_t *)event)
		if(getNextShortcut(&buttonShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &buttonReleaseNextOffset)){
			jmp matchCommandRelease;
		}
		jmp eventLoop;
		#undef  e
	}
	{
		uint8 commandOrigin;
		matchCommandPress:{
			commandOrigin = PRESS_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommandRelease:{
			commandOrigin = RELEASE_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommand: switch matchCommand((*eventModifierNode).command, (*eventModifierNode).string, commandOrigin, (*eventModifierNode).field0, (*eventModifierNode).field1, (*eventModifierNode).field2, (*eventModifierNode).field3, (*eventModifierNode).field4) over
			to TYPICAL_MATCH_COMMAND_TYPE:{
				jmp eventLoopCheckShortcuts;
			}
			to RESTART_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp readConfig;
			}
			to EXIT_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp mainEmergencyExit;
			}
			off:{
				jmp eventLoopCheckShortcuts;
			}
		end
	}
	genericEvent:{
		#define e /*-*/ ((xcb_ge_generic_event_t *)event)
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  e
	}
	extensionEvent:{
		#define isExtensionEvent(e) /*-*/ (eventType >= e##BaseEvent and eventType < e##BaseEvent + countof(e##EventName) - 1)
		const uint8 eventType = (*event).response_type & ~b(10000000);
		if(isExtensionEvent(randr)) /*-*/ jmp switchRandrEvent;
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  isExtensionEvent
	}
	switchRandrEvent:{
		printXEvent(randrEventName);
		switch ((*event).response_type & ~b(10000000)) - randrBaseEvent over
			to XCB_RANDR_SCREEN_CHANGE_NOTIFY:
			to XCB_RANDR_NOTIFY:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
					printTitledError("pthread error", "could not lock globals write lock");
				}
				{
					int screenNumber;
					xcb_connection_t *const connection = xcb_connect_to_display_with_auth_info(connectionName, NULL, &screenNumber);
					uint32 token = pushPointer(connection, "X connection", iXCBDisconnect);
					if(connection){
						xcb_screen_t *const screen = xcb_setup_roots_iterator(xcb_get_setup(connection)).data + screenNumber;
						if(screen){
							screenWidthInPixels = (*screen).width_in_pixels;
							screenHeightInPixels = (*screen).height_in_pixels;
							screenWidthInMillimeters = (*screen).width_in_millimeters;
							screenHeightInMillimeters = (*screen).height_in_millimeters;
						}else{
							screenWidthInPixels = 0;
							screenHeightInPixels = 0;
							screenWidthInMillimeters = 0;
							screenHeightInMillimeters = 0;
						}
						xcb_disconnect(connection);
						popPointer(token);
					}
				}
				if(createMonitors(&monitorSystem)){
					const bool mapped = windowSystem.mapped;
					if(createWindows(&windowSystem, monitorSystem.size, true, XCB_EVENT_MASK_NO_EVENT)){
						if(mapped){
							mapWindows(&windowSystem, &monitorSystem, &windowPreferences, whichMonitor);
							grabDevice(KEYBOARD_GRAB_DEVICE, 100);
							grabDevice(POINTER_GRAB_DEVICE, 100);
						}
					}
				}
				jmp eventLoop;
			}
			off:{
				jmp unrecognizedEvent;
			}
		end
	}
	unrecognizedEvent:{
		printTitledValuedError("X event error", "unrecognized event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unexpectedEvent:{
		printTitledValuedError("unexpected X event", "unexpected event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unhandledEvent:{
		printTitledValuedError("X event error", "unhandled event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	mainEmergencyExit:{
		cleanup();
		ret 0;
	}
}
SETWINDOWPROPERTIES(){
	xcb_window_t window;
	uint32 desktop;
	pid_t pid;
	char hostname[256];
	xcb_atom_t type[1];
	xcb_atom_t state[4];
	struct{
		uint32 /*-*/ flags;
		int32 /*--*/ x;
		int32 /*--*/ y;
		int32 /*--*/ width;
		int32 /*--*/ height;
		int32 /*--*/ minWidth;
		int32 /*--*/ minHeight;
		int32 /*--*/ maxWidth;
		int32 /*--*/ maxHeight;
		int32 /*--*/ widthInc;
		int32 /*--*/ heightInc;
		int32 /*--*/ minAspectNumerator;
		int32 /*--*/ minAspectDenominarator;
		int32 /*--*/ maxAspectNumerator;
		int32 /*--*/ maxAspectDenominarator;
		int32 /*--*/ baseWidth;
		int32 /*--*/ baseHeight;
		int32 /*--*/ winGravity;
	} normalHints;
	struct{
		uint32 /*-*/ flags;
		uint32 /*-*/ input;
		uint32 /*-*/ initialState;
	} hints;
	struct{
		uint32 /*-*/ left;
		uint32 /*-*/ right;
		uint32 /*-*/ top;
		uint32 /*-*/ bottom;
		uint32 /*-*/ leftStartY;
		uint32 /*-*/ leftEndY;
		uint32 /*-*/ rightStartY;
		uint32 /*-*/ rightEndY;
		uint32 /*-*/ topStartX;
		uint32 /*-*/ topEndX;
		uint32 /*-*/ bottomStartX;
		uint32 /*-*/ bottomEndX;
	} strut;
	if(!windowInfo or !(*windowInfo).window){
		ret false;
	}
	window = (*windowInfo).window;
	desktop = 0xFFFFFFFF;
	pid = getpid();
	*hostname = '\0';
	if(gethostname(hostname, countof(hostname)) != GETHOSTNAME_SUCCESS){
		printTitledError("get hostname error", "could not get hostname");
	}
	*(type + 0) = atom._NET_WM_WINDOW_TYPE_UTILITY;
	*(state + 0) = atom._NET_WM_STATE_STICKY;
	*(state + 1) = atom._NET_WM_STATE_SKIP_TASKBAR;
	*(state + 2) = atom._NET_WM_STATE_SKIP_PAGER;
	*(state + 3) = atom._NET_WM_STATE_ABOVE;
	normalHints.flags = USER_POSITION_NORMAL_HINT | USER_SIZE_NORMAL_HINT | PROGRAM_MINIMUM_SIZE_NORMAL_HINT | PROGRAM_MAXIMUM_SIZE_NORMAL_HINT | PROGRAM_RESIZE_INCREMENT_NORMAL_HINT | PROGRAM_ASPECT_NORMAL_HINT | PROGRAM_BASE_SIZE_NORMAL_HINT | PROGRAM_WINDOW_GRAVITY_NORMAL_HINT;
	normalHints.x = x;
	normalHints.y = y;
	normalHints.width = width;
	normalHints.height = height;
	normalHints.minWidth = width;
	normalHints.minHeight = height;
	normalHints.maxWidth = width;
	normalHints.maxHeight = height;
	normalHints.baseWidth = width;
	normalHints.baseHeight = height;
	normalHints.widthInc = 0;
	normalHints.heightInc = 0;
	normalHints.minAspectNumerator = 1;
	normalHints.minAspectDenominarator = 1;
	normalHints.maxAspectNumerator = 1;
	normalHints.maxAspectDenominarator = 1;
	normalHints.winGravity = XCB_GRAVITY_NORTH_WEST;
	hints.flags = INPUT_HINT | STATE_HINT;
	hints.input = false;
	hints.initialState = NORMAL_STATE;
	if((*windowPreferences).position){
		strut.left = 0;
		strut.right = 0;
		strut.top = 0;
		strut.bottom = 0;
		strut.leftStartY = 0;
		strut.leftEndY = 0;
		strut.rightStartY = 0;
		strut.rightEndY = 0;
		strut.topStartX = 0;
		strut.topEndX = 0;
		strut.bottomStartX = 0;
		strut.bottomEndX = 0;
		switch (*windowPreferences).position over
			to TOP_POSITION:{
				strut.top = height;
				strut.topStartX = x;
				strut.topEndX = x + width;
				brk;
			}
			to BOTTOM_POSITION:{
				strut.bottom = height;
				strut.bottomStartX = x;
				strut.bottomEndX = x + width;
				brk;
			}
			to LEFT_POSITION:{
				strut.left = width;
				strut.leftStartY = y;
				strut.leftEndY = y + height;
				brk;
			}
			to RIGHT_POSITION:{
				strut.right = width;
				strut.rightStartY = y;
				strut.rightEndY = y + height;
				brk;
			}
			off:{
				brk;
			}
		end
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_ICON_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_NORMAL_HINTS, atom.WM_SIZE_HINTS, bitsof(uint32), sizeof(normalHints) / sizeof(uint32), &normalHints);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_HINTS, atom.WM_HINTS, bitsof(uint32), sizeof(hints) / sizeof(uint32), &hints);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_CLASS, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME "\0" PROGRAM_NAME "\0"), PROGRAM_NAME "\0" PROGRAM_NAME "\0");
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_CLIENT_MACHINE, XCB_ATOM_STRING, bitsof(uint8), findStringLength(hostname), hostname);
	if(localeName){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_LOCALE_NAME, XCB_ATOM_STRING, bitsof(uint8), findStringLength(localeName), localeName);
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_ICON_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	if(desktop == 0xFFFFFFFF){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_DESKTOP, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &desktop);
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_WINDOW_TYPE, XCB_ATOM_ATOM, bitsof(uint32), countof(type), type);
	if(*state){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STATE, XCB_ATOM_ATOM, bitsof(uint32), countof(state), state);
	}
	if((*windowPreferences).position){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STRUT, XCB_ATOM_CARDINAL, bitsof(uint32), 4, &strut);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STRUT_PARTIAL, XCB_ATOM_CARDINAL, bitsof(uint32), 12, &strut);
	}
	/*! xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_ICON, , , , ); */
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_PID, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &pid);
	ret true;
}
DRAWWINDOW(){
	ElementRectangle _windowRectangle;
	ElementRectangle inputRectangle;
	ElementRectangle selectionRectangle;
	bool hasInputRectangle;
	bool hasSelectionRectangle;
	if(!windowSystem or !windowInfo or !windowPreferences or (!monitor and !windowRectangle)){
		ret false;
	}
	jmp getRectangles;
	getRectangles:{
		if(!windowRectangle){
			windowRectangle = &_windowRectangle;
			if(!getRectangle(monitor, NULL, windowPreferences, windowRectangle) or !(*windowRectangle).width or !(*windowRectangle).height){
				ret false;
			}
		}
		hasInputRectangle = getRectangle(NULL, windowRectangle, &inputPreferences, &inputRectangle) and inputRectangle.width and inputRectangle.height;
		hasSelectionRectangle = getRectangle(NULL, windowRectangle, &selectionPreferences, &selectionRectangle) and selectionRectangle.width and selectionRectangle.height;
		jmp drawWindow;
	}
	drawWindow:{
		const xcb_pixmap_t circlePixmap = (*windowSystem).circlePixmap;
		const xcb_pixmap_t pixmap = (*windowInfo).bufferPixmap;
		const xcb_gcontext_t gc = (*windowInfo).gc;
		const uint width = (*windowRectangle).width;
		const uint height = (*windowRectangle).height;
		fillDrawable(pixmap, gc, 0, 0, width, height, (*windowPreferences).background);
		if(circlePixmap){
			const uint8 cornerUsed = (*windowPreferences).cornerUsed;
			const uint radius = (*windowPreferences).cornerRadius;
			const uint size = radius + 1;
			if(cornerUsed & TOP_LEFT_CORNER) /*-----*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, 0     , 0     , 0           , 0            , size, size);
			if(cornerUsed & TOP_RIGHT_CORNER) /*----*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, radius, 0     , width - size, 0            , size, size);
			if(cornerUsed & BOTTOM_LEFT_CORNER) /*--*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, 0     , radius, 0           , height - size, size, size);
			if(cornerUsed & BOTTOM_RIGHT_CORNER) /*-*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, radius, radius, width - size, height - size, size, size);
		}
		jmp drawWindowElements;
	}
	drawWindowElements:{
		if(hasInputRectangle){
			int clipX = 0;
			int clipY = 0;
			int clipWidth = (*windowInfo).width;
			int clipHeight = (*windowInfo).height;
			uint length;
			uint16 ucs2Start[PATH_MAX];
			ElementRectangle inputTextRectangle;
			fillDrawable((*windowInfo).bufferPixmap, (*windowInfo).gc, inputRectangle.x, inputRectangle.y, inputRectangle.width, inputRectangle.height, inputPreferences.background);
			if(inputPreferences.clipChildren){
				tightenClippingRectangle((*windowInfo).gc, inputRectangle.x, inputRectangle.y, inputRectangle.width, inputRectangle.height, &clipX, &clipY, &clipWidth, &clipHeight);
			}
			if(font){
				xcb_query_text_extents_reply_t *reply;
				uint32 token;
				uint8 *utf8Current;
				if(!inputSystem.dataLength){
					utf8Current = (void *)" ";
					*ucs2Start = ASCII_TO_UCS2(' ');
					length = 1;
				}else{
					utf8Current = inputSystem.dataStart;
					length = UTF8ToUCS2(inputSystem.dataStart, inputSystem.dataLength, ucs2Start, countof(ucs2Start));
				}
				reply = xcb_wait_for_reply(connection, xcb_query_text_extents_unchecked(connection, font, length, (void *)ucs2Start), NULL);
				token = pushPointer(reply, "drawWindow() query text extents reply", iFree);
				if(reply){
					inputTextPreferences.width = (*reply).overall_width;
					inputTextPreferences.widthType = INTEGER_NUMBER_TYPE;
					inputTextPreferences.height = (*reply).font_ascent + (*reply).font_descent;
					inputTextPreferences.heightType = INTEGER_NUMBER_TYPE;
					if(getRectangle(NULL, &inputRectangle, &inputTextPreferences, &inputTextRectangle) and inputTextRectangle.width and inputTextRectangle.height){
						uint cursorLength;
						int textSegmentLengthStart[3];
						int *textSegmentLengthCurrent = textSegmentLengthStart;
						int *textSegmentLengthWall = textSegmentLengthCurrent + countof(textSegmentLengthStart);
						uint32 *textSegmentColorsStart[3];
						uint32 **textSegmentColorCurrent = textSegmentColorsStart;
						int currentX = inputRectangle.x + inputTextRectangle.x;
						int currentY = inputRectangle.y + inputTextRectangle.y + (*reply).font_ascent;
						struct{
							uint32 /*-----*/ foreground;
							uint32 /*-----*/ background;
							xcb_font_t /*-*/ font;
						} valueList;
						if(inputSystem.dataCurrent == inputSystem.dataStart + inputSystem.dataLength){
							cursorLength = 1;
						}else{
							cursorLength = getInputCharacterLength(&inputSystem, RIGHT_DIRECTION, inputSystem.dataCurrent);
						}
						if(inputSystem.selectedDataLength){
							*(textSegmentLengthStart + 0) = inputSystem.selectedDataCurrent - inputSystem.dataStart;
							*(textSegmentLengthStart + 1) = inputSystem.selectedDataLength;
							*(textSegmentLengthStart + 2) = inputSystem.dataLength - inputSystem.selectedDataLength - (inputSystem.selectedDataCurrent - inputSystem.dataStart);
							*(textSegmentColorsStart + 0) = &inputTextPreferences.foreground;
							*(textSegmentColorsStart + 1) = &inputTextPreferences.selectedForeground;
							*(textSegmentColorsStart + 2) = &inputTextPreferences.foreground;
						}elif(inputSystem.mode == INSERT_INPUT_MODE){
							*(textSegmentLengthStart + 0) = inputSystem.dataCurrent - inputSystem.dataStart;
							*(textSegmentLengthStart + 1) = cursorLength;
							*(textSegmentLengthStart + 2) = inputSystem.dataLength - cursorLength - (inputSystem.dataCurrent - inputSystem.dataStart);
							*(textSegmentColorsStart + 0) = &inputTextPreferences.foreground;
							*(textSegmentColorsStart + 1) = &inputTextPreferences.selectedForeground;
							*(textSegmentColorsStart + 2) = &inputTextPreferences.foreground;
						}else{
							*(textSegmentLengthStart + 0) = inputSystem.dataCurrent - inputSystem.dataStart;
							*(textSegmentLengthStart + 1) = inputSystem.dataLength - (inputSystem.dataCurrent - inputSystem.dataStart);
							*(textSegmentLengthStart + 2) = 0;
							*(textSegmentColorsStart + 0) = &inputTextPreferences.foreground;
							*(textSegmentColorsStart + 1) = &inputTextPreferences.foreground;
						}
						jmp drawTextSegmentLoop;
						drawTextSegmentLoop:{
							if(textSegmentLengthCurrent < textSegmentLengthWall){
								uint8 *current = utf8Current;
								int utf8Length = *textSegmentLengthCurrent;
								if(utf8Current == inputSystem.dataStart + inputSystem.dataLength and inputSystem.mode == INSERT_INPUT_MODE){
									current = (void *)" ";
									*ucs2Start = ASCII_TO_UCS2(' ');
									utf8Length = 1;
								}
								if(utf8Length > 0){
									uint substringLength = UTF8ToUCS2(current, utf8Length, ucs2Start, countof(ucs2Start));
									xcb_query_text_extents_reply_t *const reply1 = xcb_wait_for_reply(connection, xcb_query_text_extents_unchecked(connection, font, substringLength, (void *)ucs2Start), NULL);
									uint32 token1 = pushPointer(reply1, "drawWindow() query text extents reply", iFree);
									if(reply1){
										valueList.foreground = *(*textSegmentColorCurrent + 0);
										valueList.background = *(*textSegmentColorCurrent + 1);
										valueList.font = font;
										xcb_change_gc(connection, (*windowInfo).gc, XCB_GC_FOREGROUND | XCB_GC_BACKGROUND | XCB_GC_FONT, &valueList);
										xcb_image_text_16(connection, substringLength, (*windowInfo).bufferPixmap, (*windowInfo).gc, currentX + (*reply1).overall_left, currentY, (void *)ucs2Start);
										currentX += (*reply1).overall_left + (*reply1).overall_width;
										free(reply1);
										popPointer(token1);
									}
									utf8Current += utf8Length;
								}
								if(utf8Current == inputSystem.dataCurrent or !inputSystem.dataLength){
									if(!inputSystem.selectedDataLength and inputSystem.mode != INSERT_INPUT_MODE){
										fillDrawable((*windowInfo).bufferPixmap, (*windowInfo).gc, currentX - 1, currentY - (*reply).font_ascent, 1, (*reply).font_ascent + (*reply).font_descent, inputTextPreferences.foreground);
									}
								}
								inc textSegmentColorCurrent;
								inc textSegmentLengthCurrent;
								jmp drawTextSegmentLoop;
							}
						}
					}
					free(reply);
					popPointer(token);
				}
			}
			unsetClippingRectangle((*windowInfo).gc);
		}
		if(asciiStringTreeSystem.stringsFoundAmount){
			uint currentSelection = 0;
			uint selectionAmount = asciiStringTreeSystem.stringsFoundAmount;
			uint8 *current = asciiStringTreeSystem.stringsFoundStart;
			int x = selectionRectangle.x;
			int y = selectionRectangle.y;
			int clipX = 0;
			int clipY = 0;
			int clipWidth = (*windowInfo).width;
			int clipHeight = (*windowInfo).height;
			bool clippedChildren = false;
			uint currentSelectionAxisAmount = 0;
			jmp drawSelectionLoop;
			drawSelectionLoop:{
				if(currentSelection < selectionAmount){
					if(hasSelectionRectangle){
						uint32 color;
						ElementRectangle selectionTextRectangle;
						uint16 ucs2Start[NAME_MAX + 1];
						uint length;
						if((int)currentSelection == selectionSystem.currentSelection){
							color = selectionPreferences.selectedBackground;
						}else{
							color = selectionPreferences.background;
						}
						fillDrawable((*windowInfo).bufferPixmap, (*windowInfo).gc, x, y, selectionRectangle.width, selectionRectangle.height, color);
						if(selectionPreferences.clipChildren){
							if(tightenClippingRectangle((*windowInfo).gc, x, y, selectionRectangle.width, selectionRectangle.height, &clipX, &clipY, &clipWidth, &clipHeight)){
								clippedChildren = true;
							}
						}
						if(font and (length = UTF8ToUCS2(current + 1, *current, ucs2Start, countof(ucs2Start)))){
							xcb_query_text_extents_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_text_extents_unchecked(connection, font, length, (void *)ucs2Start), NULL);
							uint32 token = pushPointer(reply, "drawWindow() query text extents reply", iFree);
							if(reply){
								selectionTextPreferences.width = (*reply).overall_width;
								selectionTextPreferences.widthType = INTEGER_NUMBER_TYPE;
								selectionTextPreferences.height = (*reply).font_ascent + (*reply).font_descent;
								selectionTextPreferences.heightType = INTEGER_NUMBER_TYPE;
								if(getRectangle(NULL, &selectionRectangle, &selectionTextPreferences, &selectionTextRectangle) and selectionTextRectangle.width and selectionTextRectangle.height){
									struct{
										uint32 /*-*/ foreground;
										uint32 /*-*/ background;
									} valueList;
									if((int)currentSelection == selectionSystem.currentSelection){
										valueList.foreground = selectionTextPreferences.selectedForeground;
										valueList.background = selectionTextPreferences.selectedBackground;
									}else{
										valueList.foreground = selectionTextPreferences.foreground;
										valueList.background = selectionTextPreferences.background;
									}
									xcb_change_gc(connection, (*windowInfo).gc, XCB_GC_FOREGROUND | XCB_GC_BACKGROUND, &valueList);
									xcb_image_text_16(connection, length, (*windowInfo).bufferPixmap, (*windowInfo).gc, x + selectionTextRectangle.x + (*reply).overall_left, y + selectionTextRectangle.y + (*reply).font_ascent, (void *)ucs2Start);
								}
								free(reply);
								popPointer(token);
							}
						}
					}
					if(clippedChildren){
						unsetClippingRectangle((*windowInfo).gc);
						clipX = 0;
						clipY = 0;
						clipWidth = (*windowInfo).width;
						clipHeight = (*windowInfo).height;
						clippedChildren = false;
					}
					if(selectionSystem.selectionAxisAmount and inc currentSelectionAxisAmount == selectionSystem.selectionAxisAmount){
						switch selectionSystem.selectionAxis over
							to NONE_AXIS: /*-------*/ /*---------------------*/ /*----------------------------------------------------------------------*/ brk;
							to HORIZONTAL_AXIS: /*-*/ x = selectionRectangle.x; y += selectionRectangle.height + selectionRectangle.verticalMargin; /*--*/ brk;
							to VERTICAL_AXIS: /*---*/ y = selectionRectangle.y; x += selectionRectangle.width + selectionRectangle.horizontalMargin; /*-*/ brk;
							off: /*----------------*/ /*---------------------*/ /*----------------------------------------------------------------------*/ brk;
						end
						currentSelectionAxisAmount = 0;
					}else{
						switch selectionSystem.selectionAxis over
							to NONE_AXIS: /*-------*/ /*----------------------------------------------------------------------*/ brk;
							to HORIZONTAL_AXIS: /*-*/ x += selectionRectangle.width + selectionRectangle.horizontalMargin; /*-*/ brk;
							to VERTICAL_AXIS: /*---*/ y += selectionRectangle.height + selectionRectangle.verticalMargin; /*--*/ brk;
							off: /*----------------*/ /*----------------------------------------------------------------------*/ brk;
						end
					}
					current += *current + 1;
					inc currentSelection;
					jmp drawSelectionLoop;
				}
			}
		}
		jmp clearArea;
	}
	clearArea:{
		xcb_copy_area(connection, (*windowInfo).bufferPixmap, (*windowInfo).pixmap, (*windowInfo).gc, 0, 0, 0, 0, (*windowInfo).width, (*windowInfo).height);
		if((*windowSystem).mapped){
			xcb_clear_area(connection, false, (*windowInfo).window, 0, 0, 0, 0);
		}
		ret true;
	}
}
INITCLIPBOARDSYSTEM(){
	if(!clipboardSystem){
		ret false;
	}
	(*clipboardSystem).dataSize = 0;
	(*clipboardSystem).dataStart = NULL;
	(*clipboardSystem).dataToken = 0;
	ret true;
}
CREATECLIPBOARDBUFFER(){
	uint dataSize;
	uint8 *dataStart;
	uint32 dataToken;
	if(!clipboardSystem or !start or !length){
		ret false;
	}
	dataSize = length;
	dataStart = malloc(dataSize * sizeof(uint8));
	dataToken = pushPointer(dataStart, "clipboard data pointer", iFree);
	if(!dataStart){
		printTitledError("memory allocation error", "could not allocate memory for clipboard data");
		ret false;
	}
	destroyClipboardBuffer(clipboardSystem);
	(*clipboardSystem).dataSize = dataSize;
	(*clipboardSystem).dataStart = dataStart;
	(*clipboardSystem).dataToken = dataToken;
	copyMemory(start, (*clipboardSystem).dataStart, length * sizeof(uint8));
	ret true;
}
DESTROYCLIPBOARDBUFFER(){
	if(!clipboardSystem){
		ret false;
	}
	free((*clipboardSystem).dataStart);
	popPointer((*clipboardSystem).dataToken);
	(*clipboardSystem).dataSize = 0;
	(*clipboardSystem).dataStart = NULL;
	(*clipboardSystem).dataToken = 0;
	ret true;
}
FINICLIPBOARDSYSTEM(){
	if(!clipboardSystem){
		ret false;
	}
	destroyClipboardBuffer(clipboardSystem);
	(*clipboardSystem).dataSize = 0;
	(*clipboardSystem).dataStart = NULL;
	(*clipboardSystem).dataToken = 0;
	ret true;
}
INITINPUTSYSTEM(){
	#define INPUT_BUFFER_BLOCK_SIZE /*-*/ (256)
	if(!inputSystem){
		ret false;
	}
	(*inputSystem).dataSize = 0;
	(*inputSystem).dataLength = 0;
	(*inputSystem).dataStart = NULL;
	(*inputSystem).dataCurrent = NULL;
	(*inputSystem).dataToken = 0;
	(*inputSystem).mode = NORMAL_INPUT_MODE;
	(*inputSystem).selectedDataLength = 0;
	(*inputSystem).selectedDataCurrent = NULL;
	ret true;
}
INSERTINPUTCHARACTER(){
	XEvent xlibEvent;
	bool usingXlib;
	uint8 buffer[4];
	uint count;
	bool returnValue;
	if(!inputSystem or !(*inputSystem).mode or !e){
		ret false;
	}
	returnValue = false;
	jmp matchInvisibleCharacter;
	matchInvisibleCharacter: switch (*e).detail over
		to 9: /*---*/ ret false;
		to 22: /*--*/ ret false;
		to 36: /*--*/ ret false;
		to 91: /*--*/ ret false;
		to 104: /*-*/ ret false;
		to 119: /*-*/ ret false;
		off: /*----*/ jmp matchCharacter;
	end
	matchCharacter:{
		xlibEvent.xkey.type = (*e).response_type & ~b(10000000);
		xlibEvent.xkey.send_event = false;
		xlibEvent.xkey.display = display;
		xlibEvent.xkey.window = (*e).event;
		xlibEvent.xkey.root = (*e).root;
		xlibEvent.xkey.subwindow = (*e).child;
		xlibEvent.xkey.time = (*e).time;
		xlibEvent.xkey.x = (*e).event_x;
		xlibEvent.xkey.y = (*e).event_y;
		xlibEvent.xkey.x_root = (*e).root_x;
		xlibEvent.xkey.y_root = (*e).root_y;
		xlibEvent.xkey.state = (*e).state;
		xlibEvent.xkey.keycode = (*e).detail;
		xlibEvent.xkey.same_screen = (*e).same_screen;
		if(!XFilterEvent(&xlibEvent, (*screen).root)){
			usingXlib = false;
			jmp lookupCharacter;
		}
		XSetEventQueueOwner(display, XlibOwnsEventQueue);
		jmp xlibEventLoop;
	}
	xlibEventLoop:{
		if(XPending(display)){
			XNextEvent(display, &xlibEvent);
			jmp switchXlibEvent;
		}
		xlibEvent.type = NoEventMask;
		jmp switchXlibEvent;
	}
	switchXlibEvent: switch xlibEvent.type over
		to KeyPress:{
			if(!XFilterEvent(&xlibEvent, (*screen).root)){
				usingXlib = true;
				jmp lookupCharacter;
			}
			jmp xlibEventLoop;
		}
		off:{
			jmp emergencyExit;
		}
	end
	lookupCharacter:{
		if(!(count = Xutf8LookupString(ic, &xlibEvent.xkey, (void *)buffer, sizeof(buffer), NULL, NULL))){
			jmp emergencyExit;
		}
		if(!allocateInputBuffer(inputSystem, count + 2)){
			jmp emergencyExit;
		}
		switch (*inputSystem).mode over
			to NORMAL_INPUT_MODE: /*-*/ jmp normalMode;
			to INSERT_INPUT_MODE: /*-*/ jmp insertMode;
			off: /*------------------*/ jmp emergencyExit;
		end
	}
	normalMode:{
		removeSelectedInput(inputSystem);
		if((*inputSystem).dataCurrent == (*inputSystem).dataStart + (*inputSystem).dataLength){
			jmp addCharacter;
		}
		shiftMemory((*inputSystem).dataCurrent, ((*inputSystem).dataStart + (*inputSystem).dataLength - (*inputSystem).dataCurrent) * sizeof(uint8), count * sizeof(uint8));
		jmp addCharacter;
	}
	insertMode:{
		uint length;
		if((*inputSystem).selectedDataCurrent){
			jmp normalMode;
		}
		if((*inputSystem).dataCurrent == (*inputSystem).dataStart + (*inputSystem).dataLength){
			jmp addCharacter;
		}
		length = getInputCharacterLength(inputSystem, RIGHT_DIRECTION, (*inputSystem).dataCurrent);
		shiftMemory((*inputSystem).dataCurrent + length, ((*inputSystem).dataStart + (*inputSystem).dataLength - (*inputSystem).dataCurrent - length) * sizeof(uint8), ((int)count - (int)length) * sizeof(uint8));
		(*inputSystem).dataLength -= length;
		jmp addCharacter;
	}
	addCharacter:{
		switch count over
			fallthrough4: to 4: *((*inputSystem).dataCurrent + 3) = *(buffer + 3); /*------*/ jmp fallthrough3;
			fallthrough3: to 3: *((*inputSystem).dataCurrent + 2) = *(buffer + 2); /*------*/ jmp fallthrough2;
			fallthrough2: to 2: *((*inputSystem).dataCurrent + 1) = *(buffer + 1); /*------*/ jmp fallthrough1;
			fallthrough1: to 1: *((*inputSystem).dataCurrent + 0) = *(buffer + 0); brk; /*-*/ jmp fallthrough4;
		end
		(*inputSystem).dataCurrent += count;
		(*inputSystem).dataLength += count;
		*((*inputSystem).dataStart + (*inputSystem).dataLength) = '\0';
		returnValue = true;
		if(usingXlib){
			jmp xlibEventLoop;
		}
		jmp emergencyExit;
	}
	emergencyExit:{
		XSetEventQueueOwner(display, XCBOwnsEventQueue);
		ret returnValue;
	}
}
ALLOCATEINPUTBUFFER(){
	if(!inputSystem or !length){
		ret false;
	}
	if((*inputSystem).dataLength + length >= (*inputSystem).dataSize){
		uint offset = 0;
		void *temp;
		if((*inputSystem).dataCurrent){
			offset = (*inputSystem).dataCurrent - (*inputSystem).dataStart;
		}
		if((*inputSystem).dataLength + length >= (*inputSystem).dataSize + INPUT_BUFFER_BLOCK_SIZE){
			(*inputSystem).dataSize = (*inputSystem).dataLength + length;
		}else{
			(*inputSystem).dataSize += INPUT_BUFFER_BLOCK_SIZE;
		}
		temp = realloc((*inputSystem).dataStart, (*inputSystem).dataSize * sizeof(uint8));
		if(!(*inputSystem).dataToken){
			(*inputSystem).dataToken = pushPointer(temp, "input buffer pointer", iFree);
		}else{
			updatePointer((*inputSystem).dataToken, temp);
		}
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for input buffer");
			(*inputSystem).dataSize -= INPUT_BUFFER_BLOCK_SIZE;
			ret false;
		}
		(*inputSystem).dataStart = temp;
		(*inputSystem).dataCurrent = (*inputSystem).dataStart + offset;
	}
	ret true;
}
MOVEINPUTCURSORBY(){
	uint8 *dataCurrent;
	int length;
	if(!inputSystem or (direction != LEFT_DIRECTION and direction != RIGHT_DIRECTION) or !matchLength or matchLength > WORD_MATCH_LENGTH){
		ret false;
	}
	if((*inputSystem).selectedDataLength){
		(*inputSystem).dataCurrent = (*inputSystem).selectedDataCurrent + (direction != LEFT_DIRECTION) * (*inputSystem).selectedDataLength;
		(*inputSystem).selectedDataLength = 0;
		(*inputSystem).selectedDataCurrent = NULL;
		ret true;
	}
	if((*inputSystem).dataCurrent == (*inputSystem).dataStart + (direction != LEFT_DIRECTION) * (*inputSystem).dataLength){
		ret false;
	}
	dataCurrent = (*inputSystem).dataCurrent - (direction == LEFT_DIRECTION) * 1;
	switch matchLength over
		to CHARACTER_MATCH_LENGTH: /*-*/ length = getInputCharacterLength(inputSystem, direction, dataCurrent); /*-*/ brk;
		to WORD_MATCH_LENGTH: /*------*/ length = getInputWordLength(inputSystem, direction, dataCurrent); /*------*/ brk;
		off: /*-----------------------*/ /*------------------------------------------------------------------------*/ ret false;
	end
	(*inputSystem).dataCurrent += (1 - (direction == LEFT_DIRECTION) * 2) * length;
	ret true;
}
MOVEINPUTCURSORTOSTART(){
	if(!inputSystem or !(*inputSystem).dataLength){
		ret false;
	}
	if((*inputSystem).selectedDataLength){
		(*inputSystem).dataCurrent = (*inputSystem).dataStart;
		(*inputSystem).selectedDataLength = 0;
		(*inputSystem).selectedDataCurrent = NULL;
		ret true;
	}
	if((*inputSystem).dataCurrent == (*inputSystem).dataStart){
		ret false;
	}
	(*inputSystem).dataCurrent = (*inputSystem).dataStart;
	(*inputSystem).selectedDataLength = 0;
	(*inputSystem).selectedDataCurrent = NULL;
	ret true;
}
MOVEINPUTCURSORTOEND(){
	if(!inputSystem or !(*inputSystem).dataLength){
		ret false;
	}
	if((*inputSystem).selectedDataLength){
		(*inputSystem).dataCurrent = (*inputSystem).dataStart + (*inputSystem).dataLength;
		(*inputSystem).selectedDataLength = 0;
		(*inputSystem).selectedDataCurrent = NULL;
		ret true;
	}
	if((*inputSystem).dataCurrent == (*inputSystem).dataStart + (*inputSystem).dataLength){
		ret false;
	}
	(*inputSystem).dataCurrent = (*inputSystem).dataStart + (*inputSystem).dataLength;
	(*inputSystem).selectedDataLength = 0;
	(*inputSystem).selectedDataCurrent = NULL;
	ret true;
}
SELECTINPUTTEXT(){
	int length;
	uint8 *dataCurrent;
	if(!inputSystem or !(*inputSystem).dataLength or (direction != LEFT_DIRECTION and direction != RIGHT_DIRECTION) or !matchLength or matchLength > WORD_MATCH_LENGTH){
		ret false;
	}
	if((*inputSystem).dataCurrent == (*inputSystem).dataStart + (direction != LEFT_DIRECTION) * (*inputSystem).dataLength){
		ret false;
	}
	dataCurrent = (*inputSystem).dataCurrent - (direction == LEFT_DIRECTION) * 1;
	switch matchLength over
		to CHARACTER_MATCH_LENGTH: /*-*/ length = getInputCharacterLength(inputSystem, direction, dataCurrent); /*-*/ brk;
		to WORD_MATCH_LENGTH: /*------*/ length = getInputWordLength(inputSystem, direction, dataCurrent); /*------*/ brk;
		off: /*-----------------------*/ /*------------------------------------------------------------------------*/ ret false;
	end
	if(!(*inputSystem).selectedDataCurrent){
		if((*inputSystem).dataCurrent == (*inputSystem).dataStart + (direction != LEFT_DIRECTION) * (*inputSystem).dataLength){
			ret false;
		}
		(*inputSystem).dataCurrent += (1 - (direction == LEFT_DIRECTION) * 2) * length;
		(*inputSystem).selectedDataLength = length;
		(*inputSystem).selectedDataCurrent = (*inputSystem).dataCurrent - (direction != LEFT_DIRECTION) * length;
		ret true;
	}
	if((direction == LEFT_DIRECTION and (*inputSystem).dataCurrent == (*inputSystem).selectedDataCurrent) or (direction == RIGHT_DIRECTION and (*inputSystem).dataCurrent > (*inputSystem).selectedDataCurrent)){
		if((*inputSystem).dataCurrent == (*inputSystem).dataStart + (direction != LEFT_DIRECTION) * (*inputSystem).dataLength){
			ret false;
		}
		(*inputSystem).dataCurrent += (1 - (direction == LEFT_DIRECTION) * 2) * length;
		(*inputSystem).selectedDataLength += length;
		(*inputSystem).selectedDataCurrent -= (direction == LEFT_DIRECTION) * length;
		ret true;
	}
	(*inputSystem).dataCurrent += (1 - (direction == LEFT_DIRECTION) * 2) * length;
	(*inputSystem).selectedDataLength -= length;
	(*inputSystem).selectedDataCurrent += (direction != LEFT_DIRECTION) * length;
	if(!(*inputSystem).selectedDataLength){
		(*inputSystem).selectedDataCurrent = NULL;
	}
	ret true;
}
SELECTINPUTUNTILSTART(){
	if(!inputSystem or !(*inputSystem).dataLength or (*inputSystem).selectedDataCurrent == (*inputSystem).dataStart){
		ret false;
	}
	(*inputSystem).selectedDataLength = (*inputSystem).dataCurrent - (*inputSystem).dataStart;
	(*inputSystem).selectedDataCurrent = (*inputSystem).dataStart;
	(*inputSystem).dataCurrent = (*inputSystem).dataStart;
	ret true;
}
SELECTINPUTUNTILEND(){
	if(!inputSystem or !(*inputSystem).dataLength or (*inputSystem).selectedDataCurrent == (*inputSystem).dataStart + (*inputSystem).dataLength){
		ret false;
	}
	(*inputSystem).selectedDataLength = (*inputSystem).dataLength - ((*inputSystem).dataCurrent - (*inputSystem).dataStart);
	(*inputSystem).selectedDataCurrent = (*inputSystem).dataCurrent;
	(*inputSystem).dataCurrent = (*inputSystem).dataStart + (*inputSystem).dataLength;
	ret true;
}
SELECTALLINPUT(){
	if(!inputSystem or !(*inputSystem).dataLength or (*inputSystem).selectedDataCurrent == (*inputSystem).dataStart){
		ret false;
	}
	(*inputSystem).selectedDataLength = (*inputSystem).dataLength;
	(*inputSystem).selectedDataCurrent = (*inputSystem).dataStart;
	(*inputSystem).dataCurrent = (*inputSystem).dataStart + (*inputSystem).dataLength;
	ret true;
}
SETSELECTEDINPUTCASE(){
	uint8 *current;
	uint8 *wall;
	uint8 c0;
	uint8 c1;
	int offset;
	if(!inputSystem or !(*inputSystem).selectedDataLength or !newCase){
		ret false;
	}
	current = (*inputSystem).selectedDataCurrent;
	wall = current + (*inputSystem).selectedDataLength;
	if(newCase == UPPER_CASE){
		c0 = 'a';
		c1 = 'z';
		offset = -32;
	}else{
		c0 = 'A';
		c1 = 'Z';
		offset = 32;
	}
	jmp setSelectedInputCaseLoop;
	setSelectedInputCaseLoop:{
		if(current < wall){
			const uint8 c = *current;
			if(c < b(10000000)){
				*current += (c >= c0 and c <= c1) * offset;
			}
			inc current;
			jmp setSelectedInputCaseLoop;
		}
		ret true;
	}
}
REMOVEINPUTTEXT(){
	uint8 *dataCurrent;
	uint length;
	if(!inputSystem or (direction != LEFT_DIRECTION and direction != RIGHT_DIRECTION) or !matchLength or matchLength > WORD_MATCH_LENGTH){
		ret false;
	}
	if(removeSelectedInput(inputSystem)){
		ret true;
	}
	if((*inputSystem).dataCurrent == (*inputSystem).dataStart + (direction != LEFT_DIRECTION) * (*inputSystem).dataLength){
		ret false;
	}
	dataCurrent = (*inputSystem).dataCurrent - (direction == LEFT_DIRECTION) * 1;
	switch matchLength over
		to CHARACTER_MATCH_LENGTH: /*-*/ length = getInputCharacterLength(inputSystem, direction, dataCurrent); /*-*/ brk;
		to WORD_MATCH_LENGTH: /*------*/ length = getInputWordLength(inputSystem, direction, dataCurrent); /*------*/ brk;
		off: /*-----------------------*/ /*------------------------------------------------------------------------*/ ret false;
	end
	(*inputSystem).dataCurrent -= (direction == LEFT_DIRECTION) * length;
	shiftMemory((*inputSystem).dataCurrent + length, ((*inputSystem).dataStart + (*inputSystem).dataLength - (*inputSystem).dataCurrent - length) * sizeof(uint8), length * -(int)sizeof(uint8));
	(*inputSystem).dataLength -= length;
	*((*inputSystem).dataStart + (*inputSystem).dataLength) = '\0';
	ret true;
}
REMOVESELECTEDINPUT(){
	if(!inputSystem or !(*inputSystem).selectedDataLength){
		ret false;
	}
	shiftMemory((*inputSystem).selectedDataCurrent + (*inputSystem).selectedDataLength, ((*inputSystem).dataStart + (*inputSystem).dataLength - (*inputSystem).selectedDataCurrent - (*inputSystem).selectedDataLength) * sizeof(uint8), (*inputSystem).selectedDataLength * -(int)sizeof(uint8));
	(*inputSystem).dataLength -= (*inputSystem).selectedDataLength;
	(*inputSystem).dataCurrent = (*inputSystem).selectedDataCurrent;
	(*inputSystem).selectedDataLength = 0;
	(*inputSystem).selectedDataCurrent = NULL;
	*((*inputSystem).dataStart + (*inputSystem).dataLength) = '\0';
	ret true;
}
COPYSELECTEDINPUT(){
	if(!inputSystem or !(*inputSystem).selectedDataLength or !clipboardSystem){
		ret false;
	}
	if(!createClipboardBuffer(clipboardSystem, (*inputSystem).selectedDataCurrent, (*inputSystem).selectedDataLength)){
		ret false;
	}
	ret true;
}
PASTEONINPUT(){
	if(!inputSystem or !start or !length){
		ret false;
	}
	if(!allocateInputBuffer(inputSystem, length + 2)){
		ret false;
	}
	removeSelectedInput(inputSystem);
	shiftMemory((*inputSystem).dataCurrent, ((*inputSystem).dataStart + (*inputSystem).dataLength - (*inputSystem).dataCurrent) * sizeof(uint8), length * sizeof(uint8));
	copyMemory(start, (*inputSystem).dataCurrent, length * sizeof(uint8));
	(*inputSystem).dataCurrent += length;
	(*inputSystem).dataLength += length;
	*((*inputSystem).dataStart + (*inputSystem).dataLength) = '\0';
	ret true;
}
CHANGEINPUTMODE(){
	if(!inputSystem){
		ret false;
	}
	switch (*inputSystem).mode over
		to NORMAL_INPUT_MODE: /*-*/ (*inputSystem).mode = INSERT_INPUT_MODE; ret true;
		to INSERT_INPUT_MODE: /*-*/ (*inputSystem).mode = NORMAL_INPUT_MODE; ret true;
		off: /*------------------*/ /*------------------------------------*/ ret false;
	end
}
EXECUTEINPUTBUFFER(){
	if(!inputSystem or !(*inputSystem).dataLength){
		ret false;
	}
	spawnProcess((*inputSystem).dataStart);
	ret true;
}
GETINPUTCHARACTERLENGTH(){
	int offset;
	int offsetOffset;
	if(!inputSystem or (direction != LEFT_DIRECTION and direction != RIGHT_DIRECTION)){
		ret 0 * sizeof(uint8);
	}
	if(*p < b(10000000)){
		ret 1 * sizeof(uint8);
	}
	offset = (direction == LEFT_DIRECTION) * -1;
	offsetOffset = offset;
	if((*(p + offset) & b(11100000)) == b(11000000) and (*(p + offset + 1) & b(11000000)) == b(10000000)){
		ret 2 * sizeof(uint8);
	}
	offset += offsetOffset;
	if((*(p + offset) & b(11110000)) == b(11100000) and (*(p + offset + 1) & b(11000000)) == b(10000000) and (*(p + offset + 2) & b(11000000)) == b(10000000)){
		ret 3 * sizeof(uint8);
	}
	offset += offsetOffset;
	if((*(p + offset) & b(11111000)) == b(11110000) and (*(p + offset + 1) & b(11000000)) == b(10000000) and (*(p + offset + 2) & b(11000000)) == b(10000000) and (*(p + offset + 3) & b(11000000)) == b(10000000)){
		ret 4 * sizeof(uint8);
	}
	ret 0 * sizeof(uint8);
}
GETINPUTWORDLENGTH(){
	const uint8 *current;
	const uint8 *wall;
	bool isSpecial;
	bool isWhitespace;
	bool isInvisible;
	int nextOffset;
	if(!inputSystem or !(*inputSystem).dataLength){
		ret 0;
	}
	jmp getCharacterTypes;
	getCharacterTypes:{
		const uint8 c = *p;
		current = p;
		isSpecial = (c >= 33 and c <= 47) or (c >= 58 and c <= 64) or (c >= 91 and c <= 94) or c == 96 or (c >= 123 and c <= 126);
		isWhitespace = (c >= 9 and c <= 13) or c == 32;
		isInvisible = (c >= 1 and c <= 8) or (c >= 14 and c <= 31) or c == 127;
		if(direction == LEFT_DIRECTION){
			nextOffset = -1;
		}else{
			nextOffset = 1;
			wall = (*inputSystem).dataStart + (*inputSystem).dataLength;
		}
		jmp getInputWordLengthLoop;
	}
	getInputWordLengthLoop:{
		bool condition;
		if(direction == LEFT_DIRECTION){
			condition = current >= (*inputSystem).dataStart;
		}else{
			condition = current < wall;
		}
		if(condition){
			const uint8 c = *current;
			if(isSpecial){
				if((c >= 33 and c <= 47) or (c >= 58 and c <= 64) or (c >= 91 and c <= 94) or c == 96 or (c >= 123 and c <= 126)){
					current += nextOffset;
					jmp getInputWordLengthLoop;
				}
			}elif(isWhitespace){
				if((c >= 9 and c <= 13) or c == 32){
					current += nextOffset;
					jmp getInputWordLengthLoop;
				}
			}elif(isInvisible){
				if((c >= 1 and c <= 8) or (c >= 14 and c <= 31) or c == 127){
					current += nextOffset;
					jmp getInputWordLengthLoop;
				}
			}else{
				if((c >= 48 and c <= 57) or (c >= 65 and c <= 90) or c == 95 or (c >= 97 and c <= 122) or c >= 128){
					current += nextOffset;
					jmp getInputWordLengthLoop;
				}
			}
		}
		if(direction == LEFT_DIRECTION){
			ret p - current;
		}
		ret current - p;
	}
}
FINIINPUTSYSTEM(){
	if(!inputSystem){
		ret false;
	}
	free((*inputSystem).dataStart);
	popPointer((*inputSystem).dataToken);
	(*inputSystem).dataSize = 0;
	(*inputSystem).dataLength = 0;
	(*inputSystem).dataStart = NULL;
	(*inputSystem).dataCurrent = NULL;
	(*inputSystem).dataToken = 0;
	(*inputSystem).selectedDataLength = 0;
	(*inputSystem).selectedDataCurrent = NULL;
	(*inputSystem).mode = NORMAL_INPUT_MODE;
	ret true;
	#undef  INPUT_BUFFER_BLOCK_SIZE
}
INITASCIISTRINGTREESYSTEM(){
	#define DATA_BLOCK_SIZE /*----------*/ (16384)
	#define FOUND_STRINGS_BLOCK_SIZE /*-*/ (512)
	if(!asciiStringTreeSystem){
		ret false;
	}
	(*asciiStringTreeSystem).dataSize = 0;
	(*asciiStringTreeSystem).dataAllocated = 0;
	(*asciiStringTreeSystem).dataStart = NULL;
	(*asciiStringTreeSystem).dataToken = 0;
	(*asciiStringTreeSystem).stringsFoundAmount = 0;
	(*asciiStringTreeSystem).stringsFoundSize = 0;
	(*asciiStringTreeSystem).stringsFoundAllocated = 0;
	(*asciiStringTreeSystem).stringsFoundStart = NULL;
	(*asciiStringTreeSystem).stringsFoundToken = 0;
	(*asciiStringTreeSystem).foundStringLength = 0;
	(*asciiStringTreeSystem).foundStringStart = NULL;
	ret true;
}
PATHINSERTASCIISTRING(){
	#define DELIMITER /*-*/ (':')
	char *pathCurrent;
	char nameStart[PATH_MAX];
	char *nameCurrent;
	if(!asciiStringTreeSystem or !path){
		ret false;
	}
	pathCurrent = getenv(path);
	if(!pathCurrent or !*pathCurrent){
		ret false;
	}
	nameCurrent = nameStart;
	jmp findNextPathLengthLoop;
	findNextPathLengthLoop:{
		const char c = *pathCurrent;
		if(c and c != DELIMITER){
			*nameCurrent = c;
			inc nameCurrent;
			inc pathCurrent;
			jmp findNextPathLengthLoop;
		}
		*nameCurrent = '\0';
		jmp getPathName;
	}
	getPathName:{
		DIR *const dir = opendir(nameStart);
		uint32 token = pushPointer(dir, "executable path pointer", closedir);
		if(dir){
			jmp storeExecutableNameLoop;
			storeExecutableNameLoop:{
				struct dirent *entry;
				if((entry = readdir(dir))){
					const uint8 *const name = (void *)(*entry).d_name;
					if((*entry).d_type != DT_LNK and (*entry).d_type != DT_REG){
						jmp storeExecutableNameLoop;
					}
					if(*name == '.' and (*(name + 1) == '\0' or (*(name + 1) == '.' and *(name + 2) == '\0'))){
						jmp storeExecutableNameLoop;
					}
					if(isASCIIString(asciiStringTreeSystem, name)){
						insertASCIIString(asciiStringTreeSystem, name);
					}
					jmp storeExecutableNameLoop;
				}
				closedir(dir);
				popPointer(token);
			}
		}
		if(*pathCurrent == DELIMITER and *(inc pathCurrent)){
			nameCurrent = nameStart;
			jmp findNextPathLengthLoop;
		}
		jmp trimMemory;
	}
	trimMemory:{
		if((*asciiStringTreeSystem).dataAllocated){
			void *temp;
			(*asciiStringTreeSystem).dataSize = (*asciiStringTreeSystem).dataAllocated;
			temp = realloc((*asciiStringTreeSystem).dataStart, (*asciiStringTreeSystem).dataSize * sizeof(ASCIIStringTreeNode));
			updatePointer((*asciiStringTreeSystem).dataToken, temp);
			if(temp){
				(*asciiStringTreeSystem).dataStart = temp;
			}
		}
		ret true;
	}
	#undef  DELIMITER
}
INSERTASCIISTRING(){
	uint size;
	uint allocated;
	ASCIIStringTreeNode *data;
	ASCIIStringTreeNode *node;
	bool returnValue;
	if(!asciiStringTreeSystem or !string){
		ret false;
	}
	size = (*asciiStringTreeSystem).dataSize;
	allocated = (*asciiStringTreeSystem).dataAllocated;
	data = (*asciiStringTreeSystem).dataStart;
	jmp findString;
	findString:{
		node = getASCIIStringTreeNode(asciiStringTreeSystem, &string);
		if(data and (!node or (*node).letter == b(10000000))){
			ret false;
		}
		jmp addLetterLoop;
	}
	addLetterLoop:{
		char c;
		uint parentOffset;
		if(allocated == size){
			const uint nodeOffset = node - data;
			void *temp;
			size += DATA_BLOCK_SIZE;
			temp = realloc(data, size * sizeof(ASCIIStringTreeNode));
			if(!(*asciiStringTreeSystem).dataToken){
				(*asciiStringTreeSystem).dataToken = pushPointer(temp, "ascii string tree pointer", iFree);
			}else{
				updatePointer((*asciiStringTreeSystem).dataToken, temp);
			}
			if(!temp){
				printTitledError("memory allocation error", "could not allocate memory for ascii string nodes");
				size -= DATA_BLOCK_SIZE;
				returnValue = false;
				jmp completeString;
			}
			data = temp;
			node = data + nodeOffset;
			setMemory(data + size - DATA_BLOCK_SIZE, 0, DATA_BLOCK_SIZE * sizeof(ASCIIStringTreeNode) / sizeof(uint64), sizeof(uint64));
			if(!allocated){
				(*node).letter = '\0';
				(*node).childOffsetStart = countof((*node).childOffset);
				(*node).childOffsetWall = 0;
				(*node).parentOffset = 0;
				inc allocated;
			}
		}
		c = *string;
		parentOffset = node - data;
		*((*node).childOffset + c) = allocated;
		if(c < (*node).childOffsetStart){
			(*node).childOffsetStart = c;
		}
		if(c + 1 > (*node).childOffsetWall){
			(*node).childOffsetWall = c + 1;
		}
		node = data + allocated;
		(*node).letter = c;
		(*node).childOffsetStart = countof((*node).childOffset);
		(*node).childOffsetWall = 0;
		(*node).parentOffset = parentOffset;
		inc allocated;
		if(c){
			inc string;
			jmp addLetterLoop;
		}
		returnValue = true;
		jmp completeString;
	}
	completeString:{
		if(node){
			(*node).letter = b(10000000);
			(*asciiStringTreeSystem).dataSize = size;
			(*asciiStringTreeSystem).dataAllocated = allocated;
			(*asciiStringTreeSystem).dataStart = data;
		}
		ret returnValue;
	}
}
GETASCIISTRINGTREENODE(){
	const uint32 *childOffsetCurrent;
	const uint32 *childOffsetWall;
	const uint8 *string;
	ASCIIStringTreeNode *data;
	ASCIIStringTreeNode *node;
	char c;
	if(!asciiStringTreeSystem or !(*asciiStringTreeSystem).dataStart or !stringReturn){
		ret NULL;
	}
	data = (*asciiStringTreeSystem).dataStart;
	node = data;
	string = *stringReturn;
	jmp findLetterLoop;
	findLetterLoop:{
		childOffsetCurrent = (*node).childOffset + (*node).childOffsetStart;
		childOffsetWall = (*node).childOffset + (*node).childOffsetWall;
		c = *string;
		jmp nextLetterLoop;
	}
	nextLetterLoop:{
		if(childOffsetCurrent < childOffsetWall){
			ASCIIStringTreeNode *child;
			if(!*childOffsetCurrent){
				inc childOffsetCurrent;
				jmp nextLetterLoop;
			}
			child = data + *childOffsetCurrent;
			if((*child).letter == c and c){
				inc string;
				node = child;
				jmp findLetterLoop;
			}
			if((*child).letter != b(10000000) or c){
				inc childOffsetCurrent;
				jmp nextLetterLoop;
			}
		}
		*stringReturn = string;
		ret node;
	}
}
ISASCIISTRING(){
	if(!asciiStringTreeSystem or !string){
		ret false;
	}
	jmp isASCIIStringLoop;
	isASCIIStringLoop:{
		if(*(uint8 *)string == b(00000000)) ret true;
		if(*(uint8 *)string >= b(10000000)) ret false;
		string = (uint8 *)string + 1;
		jmp isASCIIStringLoop;
	}
}
FINDASCIISTRINGTREENODES(){
	ASCIIStringTreeNode *data;
	ASCIIStringTreeNode *node;
	ASCIIStringTreeNode *root;
	uint8 bufferStart[NAME_MAX + 1];
	uint8 *bufferCurrent;
	uint stringsFoundAmount;
	uint stringsFoundSize;
	uint stringsFoundAllocated;
	uint8 *stringsFoundStart;
	uint8 *stringsFoundCurrent;
	uint32 stringsFoundToken;
	if(!asciiStringTreeSystem or !amount){
		ret false;
	}
	free((*asciiStringTreeSystem).stringsFoundStart);
	popPointer((*asciiStringTreeSystem).stringsFoundToken);
	(*asciiStringTreeSystem).stringsFoundAmount = 0;
	(*asciiStringTreeSystem).stringsFoundSize = 0;
	(*asciiStringTreeSystem).stringsFoundAllocated = 0;
	(*asciiStringTreeSystem).stringsFoundStart = NULL;
	(*asciiStringTreeSystem).stringsFoundToken = 0;
	(*asciiStringTreeSystem).foundStringLength = 0;
	(*asciiStringTreeSystem).foundStringStart = NULL;
	stringsFoundAmount = 0;
	stringsFoundSize = 0;
	stringsFoundAllocated = 0;
	stringsFoundStart = NULL;
	stringsFoundCurrent = stringsFoundStart;
	stringsFoundToken = 0;
	jmp getNode;
	getNode:{
		const uint8 *prefixCurrent = prefix;
		uint length;
		data = (*asciiStringTreeSystem).dataStart;
		node = data;
		if(prefix){
			node = getASCIIStringTreeNode(asciiStringTreeSystem, &prefixCurrent);
			if(*prefixCurrent){
				ret false;
			}
		}
		if(!node){
			ret false;
		}
		length = prefixCurrent - prefix;
		copyMemory(prefix, bufferStart, length * sizeof(uint8));
		bufferCurrent = bufferStart + length;
		(*(data + (*node).parentOffset)).childOffsetCurrent = countof((*node).childOffset);
		(*node).childOffsetCurrent = (*node).childOffsetStart;
		root = node;
		jmp nextLetterLoop;
	}
	nextLetterLoop:{
		if((*node).childOffset + (*node).childOffsetCurrent < (*node).childOffset + (*node).childOffsetWall){
			ASCIIStringTreeNode *child;
			if(!*((*node).childOffset + (*node).childOffsetCurrent)){
				inc (*node).childOffsetCurrent;
				jmp nextLetterLoop;
			}
			child = data + *((*node).childOffset + (*node).childOffsetCurrent);
			inc (*node).childOffsetCurrent;
			node = child;
			(*node).childOffsetCurrent = (*node).childOffsetStart;
			*bufferCurrent = (*node).letter;
			inc bufferCurrent;
			if((*node).letter == b(10000000)){
				uint length;
				node = data + (*node).parentOffset;
				dec bufferCurrent;
				length = bufferCurrent - bufferStart;
				if(stringsFoundAllocated + length + 1 >= stringsFoundSize){
					const uint offset = stringsFoundCurrent - stringsFoundStart;
					void *temp;
					stringsFoundSize += FOUND_STRINGS_BLOCK_SIZE;
					temp = realloc(stringsFoundStart, stringsFoundSize * sizeof(uint8));
					if(!stringsFoundToken){
						stringsFoundToken = pushPointer(temp, "found ascii strings pointer", iFree);
					}else{
						updatePointer(stringsFoundToken, temp);
					}
					if(!temp){
						printTitledError("memory allocation error", "could not allocate memory for found ascii strings");
						stringsFoundSize -= FOUND_STRINGS_BLOCK_SIZE;
						jmp emergencyExit;
					}
					stringsFoundStart = temp;
					stringsFoundCurrent = stringsFoundStart + offset;
				}
				stringsFoundCurrent = stringsFoundStart + stringsFoundAllocated;
				*stringsFoundCurrent = length;
				copyMemory(bufferStart, stringsFoundCurrent + 1, length * sizeof(uint8));
				stringsFoundAllocated += length + 1;
				stringsFoundCurrent += length + 1;
				if(inc stringsFoundAmount == amount){
					jmp emergencyExit;
				}
			}
			jmp nextLetterLoop;
		}
		if(node > root){
			node = data + (*node).parentOffset;
			dec bufferCurrent;
			jmp nextLetterLoop;
		}
		jmp emergencyExit;
	}
	emergencyExit:{
		stringsFoundSize = stringsFoundAllocated;
		if(stringsFoundSize){
			void *const temp = realloc(stringsFoundStart, stringsFoundSize * sizeof(uint8));
			updatePointer(stringsFoundToken, temp);
			if(temp){
				stringsFoundStart = temp;
			}
		}
		(*asciiStringTreeSystem).stringsFoundAmount = stringsFoundAmount;
		(*asciiStringTreeSystem).stringsFoundSize = stringsFoundSize;
		(*asciiStringTreeSystem).stringsFoundAllocated = stringsFoundAllocated;
		(*asciiStringTreeSystem).stringsFoundStart = stringsFoundStart;
		(*asciiStringTreeSystem).stringsFoundToken = stringsFoundToken;
		ret true;
	}
}
FINDFOUNDASCIISTRING(){
	uint currentString;
	uint8 *current;
	if(!asciiStringTreeSystem or !(*asciiStringTreeSystem).stringsFoundAmount or selectedString >= (*asciiStringTreeSystem).stringsFoundAmount){
		ret false;
	}
	currentString = 0;
	current = (*asciiStringTreeSystem).stringsFoundStart;
	jmp findFoundASCIIStringLoop;
	findFoundASCIIStringLoop:{
		if(currentString < selectedString){
			current += *current + 1;
			inc currentString;
			jmp findFoundASCIIStringLoop;
		}
		(*asciiStringTreeSystem).foundStringLength = *current;
		(*asciiStringTreeSystem).foundStringStart = current + 1;
		ret true;
	}
}
FINIASCIISTRINGTREESYSTEM(){
	if(!asciiStringTreeSystem){
		ret false;
	}
	(*asciiStringTreeSystem).foundStringLength = 0;
	(*asciiStringTreeSystem).foundStringStart = NULL;
	free((*asciiStringTreeSystem).stringsFoundStart);
	popPointer((*asciiStringTreeSystem).stringsFoundToken);
	(*asciiStringTreeSystem).stringsFoundAmount = 0;
	(*asciiStringTreeSystem).stringsFoundSize = 0;
	(*asciiStringTreeSystem).stringsFoundAllocated = 0;
	(*asciiStringTreeSystem).stringsFoundStart = NULL;
	(*asciiStringTreeSystem).stringsFoundToken = 0;
	free((*asciiStringTreeSystem).dataStart);
	popPointer((*asciiStringTreeSystem).dataToken);
	(*asciiStringTreeSystem).dataSize = 0;
	(*asciiStringTreeSystem).dataAllocated = 0;
	(*asciiStringTreeSystem).dataStart = NULL;
	(*asciiStringTreeSystem).dataToken = 0;
	ret true;
	#undef  FOUND_STRINGS_BLOCK_SIZE
	#undef  DATA_BLOCK_SIZE
}
INITSELECTIONSYSTEM(){
	if(!selectionSystem){
		ret false;
	}
	(*selectionSystem).selectionAxis = NONE_AXIS;
	(*selectionSystem).selectionAxisAmount = 0;
	(*selectionSystem).selectionAmount = 0;
	(*selectionSystem).startingSelection = NONE_STARTING_SELECTION;
	(*selectionSystem).currentSelection = -1;
	(*selectionSystem).allowCircularNavigation = false;
	ret true;
}
SETSELECTIONAXIS(){
	if(!selectionSystem or selectionAxis > VERTICAL_AXIS){
		ret false;
	}
	(*selectionSystem).selectionAxis = selectionAxis;
	ret true;
}
SETSELECTIONAXISAMOUNT(){
	if(!selectionSystem){
		ret false;
	}
	(*selectionSystem).selectionAxisAmount = selectionAxisAmount;
	ret true;
}
SETSELECTIONAMOUNT(){
	if(!selectionSystem){
		ret false;
	}
	(*selectionSystem).selectionAmount = selectionAmount;
	if((*selectionSystem).currentSelection > (int)(*selectionSystem).selectionAmount - 1){
		(*selectionSystem).currentSelection = (*selectionSystem).selectionAmount - 1;
	}
	if(!(*selectionSystem).selectionAxisAmount){
		(*selectionSystem).selectionAxisAmount = (*selectionSystem).selectionAmount;
	}
	ret true;
}
SETSTARTINGSELECTION(){
	if(!selectionSystem or startingSelection > LAST_STARTING_SELECTION){
		ret false;
	}
	(*selectionSystem).startingSelection = startingSelection;
	ret true;
}
SETCURRENTSELECTION(){
	if(!selectionSystem){
		ret false;
	}
	switch (*selectionSystem).startingSelection over
		to NONE_STARTING_SELECTION:{
			(*selectionSystem).currentSelection = -1;
			ret true;
		}
		to FIRST_STARTING_SELECTION:{
			(*selectionSystem).currentSelection = -1;
			if((*selectionSystem).selectionAmount){
				(*selectionSystem).currentSelection = 0;
			}
			ret true;
		}
		to LAST_STARTING_SELECTION:{
			(*selectionSystem).currentSelection = -1;
			if((*selectionSystem).selectionAmount){
				(*selectionSystem).currentSelection = (*selectionSystem).selectionAmount - 1;
			}
			ret true;
		}
		off:{
			ret false;
		}
	end
}
SETSELECTIONNAVIGATION(){
	if(!selectionSystem){
		ret false;
	}
	(*selectionSystem).allowCircularNavigation = allowCircularNavigation;
	ret true;
}
MOVECURRENTSELECTION(){
	if(!selectionSystem or !(*selectionSystem).selectionAxisAmount or !(*selectionSystem).selectionAmount){
		ret false;
	}
	switch whichSelection over
		to NONE_WHICH_SELECTION:{
			ret false;
		}
		to PREVIOUS_WHICH_SELECTION:{
			jmp selectPrevious;
		}
		to NEXT_WHICH_SELECTION:{
			jmp selectNext;
		}
		to LEFT_WHICH_SELECTION:{
			switch (*selectionSystem).selectionAxis over
				to NONE_AXIS: /*-------*/ ret false;
				to HORIZONTAL_AXIS: /*-*/ jmp selectLeft;
				to VERTICAL_AXIS: /*---*/ jmp selectAbove;
				off: /*----------------*/ ret false;
			end
		}
		to RIGHT_WHICH_SELECTION:{
			switch (*selectionSystem).selectionAxis over
				to NONE_AXIS: /*-------*/ ret false;
				to HORIZONTAL_AXIS: /*-*/ jmp selectRight;
				to VERTICAL_AXIS: /*---*/ jmp selectBelow;
				off: /*----------------*/ ret false;
			end
		}
		to ABOVE_WHICH_SELECTION:{
			switch (*selectionSystem).selectionAxis over
				to NONE_AXIS: /*-------*/ ret false;
				to HORIZONTAL_AXIS: /*-*/ jmp selectAbove;
				to VERTICAL_AXIS: /*---*/ jmp selectLeft;
				off: /*----------------*/ ret false;
			end
		}
		to BELOW_WHICH_SELECTION:{
			switch (*selectionSystem).selectionAxis over
				to NONE_AXIS: /*-------*/ ret false;
				to HORIZONTAL_AXIS: /*-*/ jmp selectBelow;
				to VERTICAL_AXIS: /*---*/ jmp selectRight;
				off: /*----------------*/ ret false;
			end
		}
		off:{
			ret false;
		}
	end
	selectPrevious:{
		if((*selectionSystem).currentSelection > 0){
			dec (*selectionSystem).currentSelection;
			ret true;
		}
		if((*selectionSystem).currentSelection == -1 or (*selectionSystem).allowCircularNavigation){
			(*selectionSystem).currentSelection = (*selectionSystem).selectionAmount - 1;
			ret true;
		}
		ret false;
	}
	selectNext:{
		if((*selectionSystem).currentSelection < (int)(*selectionSystem).selectionAmount - 1){
			inc (*selectionSystem).currentSelection;
			ret true;
		}
		if((*selectionSystem).currentSelection == -1 or (*selectionSystem).allowCircularNavigation){
			(*selectionSystem).currentSelection = 0;
			ret true;
		}
		ret false;
	}
	selectLeft:{
		if((*selectionSystem).currentSelection == -1){
			const uint height = (*selectionSystem).selectionAmount / (*selectionSystem).selectionAxisAmount + !!((*selectionSystem).selectionAmount % (*selectionSystem).selectionAxisAmount);
			(*selectionSystem).currentSelection = height / 2 * (*selectionSystem).selectionAxisAmount + (*selectionSystem).selectionAxisAmount - 1;
			if((*selectionSystem).currentSelection > (int)(*selectionSystem).selectionAmount - 1){
				(*selectionSystem).currentSelection = (*selectionSystem).selectionAmount - 1;
			}
			ret true;
		}
		if(!((*selectionSystem).currentSelection % (*selectionSystem).selectionAxisAmount)){
			if(!(*selectionSystem).allowCircularNavigation){
				ret false;
			}
			(*selectionSystem).currentSelection += (*selectionSystem).selectionAxisAmount - 1;
			if((*selectionSystem).currentSelection > (int)(*selectionSystem).selectionAmount - 1){
				(*selectionSystem).currentSelection = (*selectionSystem).selectionAmount - 1;
			}
			ret true;
		}
		dec (*selectionSystem).currentSelection;
		ret true;
	}
	selectRight:{
		if((*selectionSystem).currentSelection == -1){
			const uint height = (*selectionSystem).selectionAmount / (*selectionSystem).selectionAxisAmount + !!((*selectionSystem).selectionAmount % (*selectionSystem).selectionAxisAmount);
			(*selectionSystem).currentSelection = height / 2 * (*selectionSystem).selectionAxisAmount;
			ret true;
		}
		if((*selectionSystem).currentSelection == (int)(*selectionSystem).selectionAmount - 1 or !(((*selectionSystem).currentSelection + 1) % (*selectionSystem).selectionAxisAmount)){
			if(!(*selectionSystem).allowCircularNavigation){
				ret false;
			}
			(*selectionSystem).currentSelection -= (*selectionSystem).currentSelection % (*selectionSystem).selectionAxisAmount;
			ret true;
		}
		inc (*selectionSystem).currentSelection;
		ret true;
	}
	selectAbove:{
		if((*selectionSystem).currentSelection == -1){
			const uint height = (*selectionSystem).selectionAmount / (*selectionSystem).selectionAxisAmount + !!((*selectionSystem).selectionAmount % (*selectionSystem).selectionAxisAmount);
			(*selectionSystem).currentSelection = (height - 1) * (*selectionSystem).selectionAxisAmount + (*selectionSystem).selectionAxisAmount / 2;
			if((*selectionSystem).currentSelection > (int)(*selectionSystem).selectionAmount - 1){
				(*selectionSystem).currentSelection = (*selectionSystem).selectionAmount - 1;
			}
			ret true;
		}
		if((*selectionSystem).currentSelection < (int)(*selectionSystem).selectionAxisAmount){
			uint height;
			if(!(*selectionSystem).allowCircularNavigation){
				ret false;
			}
			height = (*selectionSystem).selectionAmount / (*selectionSystem).selectionAxisAmount + !!((*selectionSystem).selectionAmount % (*selectionSystem).selectionAxisAmount);
			(*selectionSystem).currentSelection += (height - 1) * (*selectionSystem).selectionAxisAmount;
			if((*selectionSystem).currentSelection > (int)(*selectionSystem).selectionAmount - 1){
				(*selectionSystem).currentSelection -= (*selectionSystem).selectionAxisAmount;
			}
			ret true;
		}
		(*selectionSystem).currentSelection -= (*selectionSystem).selectionAxisAmount;
		ret true;
	}
	selectBelow:{
		if((*selectionSystem).currentSelection == -1){
			(*selectionSystem).currentSelection = (*selectionSystem).selectionAxisAmount / 2;
			if((*selectionSystem).currentSelection > (int)(*selectionSystem).selectionAmount - 1){
				(*selectionSystem).currentSelection = (*selectionSystem).selectionAmount - 1;
			}
			ret true;
		}
		if((*selectionSystem).currentSelection > (int)((*selectionSystem).selectionAmount - (*selectionSystem).selectionAxisAmount - 1)){
			uint height;
			if(!(*selectionSystem).allowCircularNavigation){
				ret false;
			}
			height = (*selectionSystem).selectionAmount / (*selectionSystem).selectionAxisAmount + !!((*selectionSystem).selectionAmount % (*selectionSystem).selectionAxisAmount);
			(*selectionSystem).currentSelection -= (height - 1) * (*selectionSystem).selectionAxisAmount;
			if((*selectionSystem).currentSelection < 0){
				(*selectionSystem).currentSelection += (*selectionSystem).selectionAxisAmount;
			}
			ret true;
		}
		(*selectionSystem).currentSelection += (*selectionSystem).selectionAxisAmount;
		ret true;
	}
}
FINISELECTIONSYSTEM(){
	if(!selectionSystem){
		ret false;
	}
	(*selectionSystem).selectionAxis = NONE_AXIS;
	(*selectionSystem).selectionAxisAmount = 0;
	(*selectionSystem).selectionAmount = 0;
	(*selectionSystem).startingSelection = NONE_STARTING_SELECTION;
	(*selectionSystem).currentSelection = -1;
	(*selectionSystem).allowCircularNavigation = false;
	ret true;
}
SETCONFIGVARIABLES(){
	setElementPreferences(&windowPreferences);
	setElementPreferences(&inputPreferences);
	setElementPreferences(&inputTextPreferences);
	setElementPreferences(&selectionPreferences);
	setElementPreferences(&selectionTextPreferences);
	maximumSelectionAmount = 0;
	setSelectionAxis(&selectionSystem, NONE_AXIS);
	setSelectionAxisAmount(&selectionSystem, 0);
	setStartingSelection(&selectionSystem, NONE_STARTING_SELECTION);
	setSelectionNavigation(&selectionSystem, false);
	whichMonitor = NONE_WHICH_MONITOR;
	font = XCB_NONE;
	createWindowCirclePixmap(&windowSystem, 0, 0x00000000, 0x00000000);
	ret;
}
READCONFIG(){
	#define STATEMENT_BLOCK_SIZE /*-*/ (256)
	#define DEFAULT_CONFIG_PATH /*--*/ ("/etc/" PROGRAM_NAME "/" PROGRAM_NAME ".conf")
	const Instruction *const *currentScopeInstruction = globalScopeInstruction;
	const char *const *currentScopeInstructionList = globalInstructionList;
	const Instruction *instructionStart;
	const Instruction *instructionStartCopy;
	const Instruction *instructionCurrent;
	const Instruction *name0Instruction;
	const Instruction *name1Instruction;
	const Instruction *name2Instruction;
	const Instruction *name3Instruction;
	const Instruction *name4Instruction;
	const Instruction *nameList0Instruction;
	const Instruction *nameList1Instruction;
	const Instruction *nameList2Instruction;
	const Instruction *nameList3Instruction;
	const Instruction *nameList4Instruction;
	const Instruction *integer0Instruction;
	const Instruction *integer1Instruction;
	const Instruction *integer2Instruction;
	const Instruction *integer3Instruction;
	const Instruction *integer4Instruction;
	const Instruction *string0Instruction;
	const Instruction *string1Instruction;
	const Instruction *string2Instruction;
	const Instruction *string3Instruction;
	const Instruction *string4Instruction;
	const Instruction *image0Instruction;
	const Instruction *image1Instruction;
	const Instruction *image2Instruction;
	const Instruction *image3Instruction;
	const Instruction *image4Instruction;
	const char *imageErrorMessage;
	FILE *configFile = NULL;
	uint32 configFileToken;
	void *system = NULL;
	uint statementSize = STATEMENT_BLOCK_SIZE;
	char *statementStart = NULL;
	uint32 statementToken = 0;
	char *statementCurrent;
	char *statementWall = NULL;
	char *statementConcreteWall;
	uint8 name0Return;
	uint8 name1Return;
	uint8 name2Return;
	uint8 name3Return;
	uint8 name4Return;
	uint8 nameList0Return;
	uint8 nameList1Return;
	uint8 nameList2Return;
	uint8 nameList3Return;
	uint8 nameList4Return;
	int64 integer0Return;
	int64 integer1Return;
	int64 integer2Return;
	int64 integer3Return;
	int64 integer4Return;
	char *string0Return = NULL;
	uint32 string0Token = 0;
	char *string1Return = NULL;
	uint32 string1Token = 0;
	char *string2Return = NULL;
	uint32 string2Token = 0;
	char *string3Return = NULL;
	uint32 string3Token = 0;
	char *string4Return = NULL;
	uint32 string4Token = 0;
	Image image0Return;
	Image image1Return;
	Image image2Return;
	Image image3Return;
	Image image4Return;
	JmpPoint jmpPoint;
	uint fileLine = 1;
	uint statementLine = 0;
	char fileChar;
	uint itemAmount;
	char quote = '\0';
	uint currentScopeInstructionListSize = countof(globalInstructionList) - 1;
	StringTreeSystem *const *const *currentScopeInstructionData = globalScopeInstructionData;
	StringTreeSystem *const *instructionDataStart;
	StringTreeSystem *const *instructionDataStartCopy;
	StringTreeSystem *const *instructionDataCurrent;
	StringTreeSystem *currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
	image0Return.dataStart = NULL;
	image0Return.dataToken = 0;
	image1Return.dataStart = NULL;
	image1Return.dataToken = 0;
	image2Return.dataStart = NULL;
	image2Return.dataToken = 0;
	image3Return.dataStart = NULL;
	image3Return.dataToken = 0;
	image4Return.dataStart = NULL;
	image4Return.dataToken = 0;
	jmp setupPointers;
	setupPointers:{
		if(getNextConfigChar == &ifgetc){
			if(!createConfigFile){
				DIR *const dir = opendir(configPath);
				uint32 token = pushPointer(dir, "config directory argument", closedir);
				if(dir){
					closedir(dir);
					popPointer(token);
					printConfigError("config error", "config file is directory", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
			}
			configFile = fopen(configPath, "r");
			configFileToken = pushPointer(configFile, "config file", fclose);
			if(!configFile){
				#define BUFFER_SIZE /*-*/ (4096)
				FILE *defaultConfigFile;
				uint32 defaultConfigFileToken;
				if(!createConfigFile){
					printConfigError("config error", "could not open config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				configFile = fopen(configPath, "w");
				configFileToken = pushPointer(configFile, "config file", fclose);
				if(!configFile){
					printConfigError("config error", "could not create config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				defaultConfigFile = fopen(DEFAULT_CONFIG_PATH, "r");
				defaultConfigFileToken = pushPointer(defaultConfigFile, "default config file", fclose);
				if(!defaultConfigFile){
					remove(configPath);
					printTitledNamedError("config file error", "could not copy default configuration file from", DEFAULT_CONFIG_PATH);
					jmp configEmergencyExit;
				}
				copyConfigFileLoop:{
					char buffer[BUFFER_SIZE];
					size_t bytesRead;
					if((bytesRead = fread(buffer, sizeof(*buffer), sizeof(buffer), defaultConfigFile))){
						if(fwrite(buffer, sizeof(*buffer), bytesRead, configFile) != bytesRead){
							fclose(defaultConfigFile);
							popPointer(defaultConfigFileToken);
							remove(configPath);
							printTitledError("config copying error", "could not copy default config file correctly");
							jmp configEmergencyExit;
						}
						jmp copyConfigFileLoop;
					}
				}
				fclose(defaultConfigFile);
				popPointer(defaultConfigFileToken);
				fclose(configFile);
				popPointer(configFileToken);
				if(!(configFile = fopen(configPath, "r"))){
					printTitledError("config error", "could not open newly written file");
					jmp configEmergencyExit;
				}
				#undef  BUFFER_SIZE
			}
		}
		statementStart = malloc(statementSize * sizeof(char));
		statementToken = pushPointer(statementStart, "statement pointer", iFree);
		if(!statementStart){
			printTitledError("config error", "could not store user data");
			jmp configEmergencyExit;
		}
		if(getNextConfigChar == &ifgetc){
			system = configFile;
		}elif(getNextConfigChar == &getNextSTDINCharacter){
			system = &stdinSystem;
		}elif(getNextConfigChar == &getNextSharedMemoryCharacter){
			system = &sharedMemorySystem;
		}
		jmp getStatementStart;
	}
	getStatementStart:{
		#define EOF_N1 /*----------------------------*/ (EOF)
		#define ZER_00 /*----------------------------*/ ('\0')
		#define EOT_04 /*----------------------------*/ (0x04)
		#define ALR_07 /*----------------------------*/ ('\a')
		#define BSP_08 /*----------------------------*/ ('\b')
		#define TAB_09 /*----------------------------*/ ('\t')
		#define NLN_10 /*----------------------------*/ ('\n')
		#define VTB_11 /*----------------------------*/ ('\v')
		#define FFD_12 /*----------------------------*/ ('\f')
		#define CRE_13 /*----------------------------*/ ('\r')
		#define ESC_27 /*----------------------------*/ ('\e')
		#define SPC_32 /*----------------------------*/ (' ')
		#define DQT_34 /*----------------------------*/ ('\"')
		#define SQT_39 /*----------------------------*/ ('\'')
		#define AST_42 /*----------------------------*/ ('*')
		#define FSL_47 /*----------------------------*/ ('/')
		#define ZER_48 /*----------------------------*/ ('0')
		#define SCL_59 /*----------------------------*/ (';')
		#define QMK_63 /*----------------------------*/ ('?')
		#define BSL_92 /*----------------------------*/ ('\\')
		#define LOA_97 /*----------------------------*/ ('a')
		#define LOB_98 /*----------------------------*/ ('b')
		#define LOF_102 /*---------------------------*/ ('f')
		#define LON_110 /*---------------------------*/ ('n')
		#define LOR_114 /*---------------------------*/ ('r')
		#define LOT_116 /*---------------------------*/ ('t')
		#define LOV_118 /*---------------------------*/ ('v')
		#define OCB_123 /*---------------------------*/ ('{')
		#define BAR_124 /*---------------------------*/ ('|')
		#define CCB_125 /*---------------------------*/ ('}')
		#define GET_STATEMENT_JMP_POINT /*-----------*/ (0)
		#define STORE_WHITESPACE_JMP_POINT /*--------*/ (1)
		#define CHECK_COMMENT_JMP_POINT /*-----------*/ (2)
		#define STORE_BAR_JMP_POINT /*---------------*/ (3)
		#define GET_DOUBLE_QUOTATION_JMP_POINT /*----*/ (4)
		#define GET_SINGLE_QUOTATION_JMP_POINT /*----*/ (5)
		#define HANDLE_ESCAPE_CHARACTER_JMP_POINT /*-*/ (6)
		#define ENTER_SCOPE_JMP_POINT /*-------------*/ (7)
		#define GET_STATEMENT_END_JMP_POINT /*-------*/ (8)
		statementCurrent = statementStart;
		statementConcreteWall = statementStart + statementSize * sizeof(char);
		statementLine = 0;
		itemAmount = 0;
		free(string0Return);
		popPointer(string0Token);
		free(string1Return);
		popPointer(string1Token);
		free(string2Return);
		popPointer(string2Token);
		free(string3Return);
		popPointer(string3Token);
		free(string4Return);
		popPointer(string4Token);
		free(image0Return.dataStart);
		popPointer(image0Return.dataToken);
		free(image1Return.dataStart);
		popPointer(image1Return.dataToken);
		free(image2Return.dataStart);
		popPointer(image2Return.dataToken);
		free(image3Return.dataStart);
		popPointer(image3Return.dataToken);
		free(image4Return.dataStart);
		popPointer(image4Return.dataToken);
		name0Instruction = NULL;
		name1Instruction = NULL;
		name2Instruction = NULL;
		name3Instruction = NULL;
		name4Instruction = NULL;
		nameList0Instruction = NULL;
		nameList1Instruction = NULL;
		nameList2Instruction = NULL;
		nameList3Instruction = NULL;
		nameList4Instruction = NULL;
		integer0Instruction = NULL;
		integer1Instruction = NULL;
		integer2Instruction = NULL;
		integer3Instruction = NULL;
		integer4Instruction = NULL;
		string0Instruction = NULL;
		string1Instruction = NULL;
		string2Instruction = NULL;
		string3Instruction = NULL;
		string4Instruction = NULL;
		image0Instruction = NULL;
		image1Instruction = NULL;
		image2Instruction = NULL;
		image3Instruction = NULL;
		image4Instruction = NULL;
		string0Return = NULL;
		string0Token = 0;
		string1Return = NULL;
		string1Token = 0;
		string2Return = NULL;
		string2Token = 0;
		string3Return = NULL;
		string3Token = 0;
		string4Return = NULL;
		string4Token = 0;
		image0Return.dataStart = NULL;
		image0Return.dataToken = 0;
		image1Return.dataStart = NULL;
		image1Return.dataToken = 0;
		image2Return.dataStart = NULL;
		image2Return.dataToken = 0;
		image3Return.dataStart = NULL;
		image3Return.dataToken = 0;
		image4Return.dataStart = NULL;
		image4Return.dataToken = 0;
		jmp getStatement;
	}
	getStatement: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp checkCommentStoreCharacter;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	getDoubleQuotation: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getDoubleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getDoubleQuotationStoreCharacter;
		to DQT_34: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getDoubleQuotationStoreCharacter;
	end
	getSingleQuotation: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getSingleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getSingleQuotationStoreCharacter;
		to SQT_39: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getSingleQuotationStoreCharacter;
	end
	handleEscapeCharacter: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to DQT_34: /*--*/ fileChar = '\"'; /*-----------------*/ jmp storeEscapedCharacter;
		to SQT_39: /*--*/ fileChar = '\''; /*-----------------*/ jmp storeEscapedCharacter;
		to ZER_48: /*--*/ fileChar = '\0'; /*-----------------*/ jmp storeEscapedCharacter;
		to QMK_63: /*--*/ fileChar = '\?'; /*-----------------*/ jmp storeEscapedCharacter;
		to BSL_92: /*--*/ fileChar = '\\'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOA_97: /*--*/ fileChar = '\a'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOB_98: /*--*/ fileChar = '\b'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOF_102: /*-*/ fileChar = '\f'; /*-----------------*/ jmp storeEscapedCharacter;
		to LON_110: /*-*/ fileChar = '\n'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOR_114: /*-*/ fileChar = '\r'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOT_116: /*-*/ fileChar = '\t'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOV_118: /*-*/ fileChar = '\v'; /*-----------------*/ jmp storeEscapedCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	checkComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to AST_42: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreSingleLineComment;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	ignoreMultipleLineComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to AST_42: /*--*/ /*----------------------------------*/ jmp checkMultipleLineCommentEnd;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	end
	checkMultipleLineCommentEnd: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	end
	ignoreSingleLineComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreSingleLineComment;
	end
	endOfFile:{
		if(statementCurrent == statementStart){
			jmp successfulConfig;
		}
		if(getPreviousConfigChar){
			getPreviousConfigChar(system);
		}
		jmp completeStatement;
	}
	storeWhitespace:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp getStatement;
		}
		inc itemAmount;
		fileChar = '\0';
		jmp getStatementStoreCharacter;
	}
	completeStatement:{
		if(statementCurrent <= statementStart){
			jmp getStatement;
		}
		if(!*(statementCurrent - 1)){
			jmp getStatementEnd;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = GET_STATEMENT_END_JMP_POINT;
		jmp storeCharacter;
	}
	handleOpeningBracket:{
		if(statementCurrent <= statementStart){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray opening bracket error", "could not enter nameless scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(*(statementCurrent - 1)){
			inc itemAmount;
			fileChar = '\0';
			jmpPoint = ENTER_SCOPE_JMP_POINT;
			jmp storeCharacter;
		}
		jmp enterScope;
	}
	enterScope:{
		StringTreeSystem *stringTreeSystem;
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(currentScopeInstruction == globalScopeInstruction){
			stringTreeSystem = &globalScopesInstructionStringTreeSystem;
		}else{
			printConfigError("invalid scope error", "no scopes inside current scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(!findStringTreeString(stringTreeSystem, &statementCurrent)){
			printConfigError("invalid scope error", "invalid scope name", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(itemAmount > 1){
			/*! missing space between final argument and scope imminent */
			printConfigError("scope argument error", "too many arguments", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, (void *)1, (void *)1, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		currentScopeInstruction = scope1ScopeInstruction;
		currentScopeInstructionData = scope1ScopeInstructionData;
		currentScopeInstructionList = scope1ScopeInstructionList;
		currentScopeInstructionStringTreeSystem = &scope1ScopeInstructionStringTreeSystem;
		currentScopeInstructionListSize = countof(scope1ScopeInstructionList) - 1;
		jmp getStatementStart;
	}
	attemptStoreBar:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp storeBar;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = STORE_BAR_JMP_POINT;
		jmp storeCharacter;
	}
	storeBar:{
		fileChar = '|';
		jmpPoint = STORE_WHITESPACE_JMP_POINT;
		jmp storeCharacter;
	}
	handleClosingBracket:{
		if(statementCurrent > statementStart){
			if(getNextConfigChar != &ifgetc){
				getPreviousConfigChar(system);
				jmp completeStatement;
			}
			fseek(configFile, -1, SEEK_CUR);
			jmp completeStatement;
		}
		if(currentScopeInstruction == globalScopeInstruction){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray closing bracket error", "could not drop to previous config scope", '}', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(currentScopeInstruction == scope1ScopeInstruction){
			currentScopeInstruction = globalScopeInstruction;
			currentScopeInstructionData = globalScopeInstructionData;
			currentScopeInstructionList = globalInstructionList;
			currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
			currentScopeInstructionListSize = countof(globalInstructionList) - 1;
		}
		jmp getStatementStart;
	}
	storeEscapedCharacter:{
		*(statementCurrent - 1) = fileChar;
		if(quote == '\"'){
			jmp getDoubleQuotation;
		}
		jmp getSingleQuotation;
	}
	getStatementStoreCharacter:{
		jmpPoint = GET_STATEMENT_JMP_POINT;
		jmp storeCharacter;
	}
	getDoubleQuotationStoreCharacter:{
		jmpPoint = GET_DOUBLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	getSingleQuotationStoreCharacter:{
		jmpPoint = GET_SINGLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	handleEscapeCharacterStoreCharacter:{
		jmpPoint = HANDLE_ESCAPE_CHARACTER_JMP_POINT;
		jmp storeCharacter;
	}
	checkCommentStoreCharacter:{
		jmpPoint = CHECK_COMMENT_JMP_POINT;
		jmp storeCharacter;
	}
	storeCharacter:{
		if(statementCurrent >= statementConcreteWall){
			const uint offset = statementCurrent - statementStart;
			void *temp;
			statementSize += STATEMENT_BLOCK_SIZE;
			temp = realloc(statementStart, statementSize * sizeof(char));
			updatePointer(statementToken, temp);
			if(!temp){
				printConfigError("memory allocation error", "could not allocate memory for config statement", ';', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				statementSize -= STATEMENT_BLOCK_SIZE;
				jmp getStatementStart;
			}
			statementStart = temp;
			statementCurrent = statementStart + offset;
			statementConcreteWall = statementStart + statementSize * sizeof(char);
		}
		if(jmpPoint != CHECK_COMMENT_JMP_POINT and !statementLine){
			statementLine = fileLine;
		}
		*statementCurrent = fileChar;
		inc statementCurrent;
		switch jmpPoint over
			to GET_STATEMENT_JMP_POINT: /*-----------*/ jmp getStatement;
			to STORE_WHITESPACE_JMP_POINT: /*--------*/ jmp storeWhitespace;
			to CHECK_COMMENT_JMP_POINT: /*-----------*/ jmp checkComment;
			to STORE_BAR_JMP_POINT: /*---------------*/ jmp storeBar;
			to GET_DOUBLE_QUOTATION_JMP_POINT: /*----*/ jmp getDoubleQuotation;
			to GET_SINGLE_QUOTATION_JMP_POINT: /*----*/ jmp getSingleQuotation;
			to HANDLE_ESCAPE_CHARACTER_JMP_POINT: /*-*/ jmp handleEscapeCharacter;
			to ENTER_SCOPE_JMP_POINT: /*-------------*/ jmp enterScope;
			off: /*----------------------------------*/ jmp getStatementEnd;
		end
	}
	getStatementEnd:{
		if(statementCurrent > statementStart) /*-*/ jmp findStatement;
		if(!feof(configFile)) /*-----------------*/ jmp getStatementStart;
		/*---------------------------------------*/ jmp successfulConfig;
		#undef  GET_STATEMENT_END_JMP_POINT
		#undef  ENTER_SCOPE_JMP_POINT
		#undef  HANDLE_ESCAPE_CHARACTER_JMP_POINT
		#undef  GET_SINGLE_QUOTATION_JMP_POINT
		#undef  GET_DOUBLE_QUOTATION_JMPPOINT
		#undef  STORE_BAR_JMP_POINT
		#undef  CHECK_COMMENT_JMP_POINT
		#undef  STORE_WHITESPACE_JMP_POINT
		#undef  GET_STATEMENT_JMP_POINT
		#undef  CCB_125
		#undef  BAR_124
		#undef  OCB_123
		#undef  LOV_118
		#undef  LOT_116
		#undef  LOR_114
		#undef  LON_110
		#undef  LOF_102
		#undef  LOB_98
		#undef  LOA_97
		#undef  BSL_92
		#undef  QMK_63
		#undef  SCL_59
		#undef  ZER_48
		#undef  FSL_47
		#undef  AST_42
		#undef  SQT_39
		#undef  DQT_34
		#undef  SPC_32
		#undef  ESC_27
		#undef  CRE_13
		#undef  FFD_12
		#undef  VTB_11
		#undef  NLN_10
		#undef  TAB_09
		#undef  BSP_08
		#undef  ALR_07
		#undef  EOT_04
		#undef  ZER_00
		#undef  EOF_N1
	}
	findStatement:{
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(!findStringTreeString(currentScopeInstructionStringTreeSystem, &statementCurrent)){
			printConfigError("config error", "unrecognized instruction", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp printAllInstructionPatterns;
		}
		instructionStart = *(currentScopeInstruction + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionStartCopy = instructionStart;
		instructionCurrent = instructionStart;
		instructionDataStart = *(currentScopeInstructionData + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionDataStartCopy = instructionDataStart;
		instructionDataCurrent = instructionDataStart;
		if(*instructionCurrent == NONE_INSTRUCTION_TYPE){
			jmp unimplementedInstruction;
		}
		if(statementCurrent >= statementWall and *instructionCurrent != END_INSTRUCTION_TYPE){
			printConfigError("config error", "missing instruction body", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		inc statementCurrent;
		jmp switchInstructionLoop;
	}
	switchInstructionLoop: switch *instructionCurrent over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp unimplementedInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp matchName;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp matchNameList;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp matchInteger;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp matchString;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp matchImageString;
		off: /*---------------------------*/ jmp endOfInstruction;
	end
	unimplementedInstruction:{
		printConfigError("implementation error", "using unimplemented instruction", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchName:{
		char *s;
		uint8 *namePointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!name0Instruction){
			namePointer = &name0Return;
			name0Instruction = instructionCurrent;
		}elif(!name1Instruction){
			namePointer = &name1Return;
			name1Instruction = instructionCurrent;
		}elif(!name2Instruction){
			namePointer = &name2Return;
			name2Instruction = instructionCurrent;
		}elif(!name3Instruction){
			namePointer = &name3Return;
			name3Instruction = instructionCurrent;
		}else{
			namePointer = &name4Return;
			name4Instruction = instructionCurrent;
		}
		s = statementCurrent;
		if(!findStringTreeString(*instructionDataCurrent, &s)){
			printConfigError("match string error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		statementCurrent = s;
		inc statementCurrent;
		*namePointer = (**instructionDataCurrent).returnedCounter;
		jmp advanceDataInstruction;
	}
	matchNameList:{
		uint8 *nameListPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!nameList0Instruction){
			nameListPointer = &nameList0Return;
			nameList0Instruction = instructionCurrent;
		}elif(!nameList1Instruction){
			nameListPointer = &nameList1Return;
			nameList1Instruction = instructionCurrent;
		}elif(!nameList2Instruction){
			nameListPointer = &nameList2Return;
			nameList2Instruction = instructionCurrent;
		}elif(!nameList3Instruction){
			nameListPointer = &nameList3Return;
			nameList3Instruction = instructionCurrent;
		}else{
			nameListPointer = &nameList4Return;
			nameList4Instruction = instructionCurrent;
		}
		switch matchNameList(*instructionDataCurrent, statementWall, &statementCurrent, nameListPointer) over
			to INVALID_NAME_NAME_LIST: /*--*/ jmp invalidNameNameList;
			to PREMATURE_END_NAME_LIST: /*-*/ jmp prematureEndNameList;
			off: /*------------------------*/ jmp advanceDataInstruction;
		end
	}
	invalidNameNameList:{
		printConfigError("bar list error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	prematureEndNameList:{
		printConfigError("bar list error", "missing final name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchInteger:{
		int64 *integerPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!integer0Instruction){
			integerPointer = &integer0Return;
			integer0Instruction = instructionCurrent;
		}elif(!integer1Instruction){
			integerPointer = &integer1Return;
			integer1Instruction = instructionCurrent;
		}elif(!integer2Instruction){
			integerPointer = &integer2Return;
			integer2Instruction = instructionCurrent;
		}elif(!integer3Instruction){
			integerPointer = &integer3Return;
			integer3Instruction = instructionCurrent;
		}else{
			integerPointer = &integer4Return;
			integer4Instruction = instructionCurrent;
		}
		switch matchInteger(&statementCurrent, statementWall, integerPointer) over
			to NON_NUMBER_NUMBER: /*-------*/ jmp printNonNumberError;
			to OVERFLOWN_NUMBER_NUMBER: /*-*/ jmp printOverflownNumberError;
			to DIVIDED_BY_ZERO_NUMBER: /*--*/ jmp printDividedByZeroNumberError;
			off: /*------------------------*/ jmp advanceInstruction;
		end
	}
	printNonNumberError:{
		printConfigError("match integer error", "not a number", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printOverflownNumberError:{
		printConfigError("match integer error", "integer overflow", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printDividedByZeroNumberError:{
		printConfigError("match integer error", "integer divided by zero", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchString:{
		char **stringPointer;
		uint32 *stringTokenPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!string0Instruction){
			stringPointer = &string0Return;
			stringTokenPointer = &string0Token;
			string0Instruction = instructionCurrent;
		}elif(!string1Instruction){
			stringPointer = &string1Return;
			stringTokenPointer = &string1Token;
			string1Instruction = instructionCurrent;
		}elif(!string2Instruction){
			stringPointer = &string2Return;
			stringTokenPointer = &string2Token;
			string2Instruction = instructionCurrent;
		}elif(!string3Instruction){
			stringPointer = &string3Return;
			stringTokenPointer = &string3Token;
			string3Instruction = instructionCurrent;
		}else{
			stringPointer = &string4Return;
			stringTokenPointer = &string4Token;
			string4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, stringPointer, stringTokenPointer)){
			printConfigError("match string error", "could not allocate string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		jmp advanceInstruction;
	}
	matchImageString:{
		char *string = NULL;
		uint32 token = 0;
		Image *imagePointer;
		uint8 matchImageReturn;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!image0Instruction){
			imagePointer = &image0Return;
			image0Instruction = instructionCurrent;
		}elif(!image1Instruction){
			imagePointer = &image1Return;
			image1Instruction = instructionCurrent;
		}elif(!image2Instruction){
			imagePointer = &image2Return;
			image2Instruction = instructionCurrent;
		}elif(!image3Instruction){
			imagePointer = &image3Return;
			image3Instruction = instructionCurrent;
		}else{
			imagePointer = &image4Return;
			image4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, &string, &token)){
			printConfigError("match image error", "could not allocate image string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		matchImageReturn = matchImage(string, &imageErrorMessage, &image0Return);
		free(string);
		popPointer(token);
		switch matchImageReturn over
			to CANNOT_OPEN_MATCH_IMAGE: /*--------*/ jmp printCannotOpenReadConfig;
			to CANNOT_READ_MATCH_IMAGE: /*--------*/ jmp printCannotReadReadConfig;
			to UNSUPPORTED_FORMAT_MATCH_IMAGE: /*-*/ jmp printUnsupportedFormatReadConfig;
			to BAD_HEADER_MATCH_IMAGE: /*---------*/ jmp printBadHeaderReadConfig;
			to BAD_DEPTH_MATCH_IMAGE: /*----------*/ jmp printBadDepthReadConfig;
			to BAD_COMPRESSION_MATCH_IMAGE: /*----*/ jmp printBadCompressionReadConfig;
			to UNSUPPORTED_HEIGHT_MATCH_IMAGE: /*-*/ jmp printUnsupportedHeightReadConfig;
			to BAD_SIZE_MATCH_IMAGE: /*-----------*/ jmp printBadSizeReadConfig;
			to FAILED_MATCH_IMAGE: /*-------------*/ jmp printFailedReadConfig;
			to BAD_PIXELS_MATCH_IMAGE: /*---------*/ jmp printBadPixelsReadConfig;
			to BAD_IMAGE_MATCH_IMAGE: /*----------*/ jmp printBadImageReadConfig;
			off: /*-------------------------------*/ jmp advanceInstruction;
		end
	}
	printCannotOpenReadConfig:{
		printConfigError("match image error", "could not open image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printCannotReadReadConfig:{
		printConfigError("match image error", "could not read image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedFormatReadConfig:{
		printConfigError("match image error", "image file not bmp", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadHeaderReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadDepthReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadCompressionReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedHeightReadConfig:{
		printConfigError("match image error", "negative height is not supported", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadSizeReadConfig:{
		printConfigError("match image error", "could not traverse image past the header", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printFailedReadConfig:{
		printConfigError("match image error", "could not allocate pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadPixelsReadConfig:{
		printConfigError("match image error", "could not read pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadImageReadConfig:{
		printConfigError("match image error", "image is broken", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	endOfInstruction:{
		if(instructionStart == setInstruction){
			#define applySubinstruction(s, i) /*-*/ instructionStart = s##i##Subinstruction; instructionDataStart = s##i##SubinstructionData
			switch name0Return over
				to WINDOW_X_VARIABLE: /*----------------------------*/ applySubinstruction(windowX, Set); /*--------------------------*/ jmp assessSubinstruction;
				to WINDOW_Y_VARIABLE: /*----------------------------*/ applySubinstruction(windowY, Set); /*--------------------------*/ jmp assessSubinstruction;
				to WINDOW_X_OFFSET_VARIABLE: /*---------------------*/ applySubinstruction(windowXOffset, Set); /*--------------------*/ jmp assessSubinstruction;
				to WINDOW_Y_OFFSET_VARIABLE: /*---------------------*/ applySubinstruction(windowYOffset, Set); /*--------------------*/ jmp assessSubinstruction;
				to WINDOW_WIDTH_VARIABLE: /*------------------------*/ applySubinstruction(windowWidth, Set); /*----------------------*/ jmp assessSubinstruction;
				to WINDOW_HEIGHT_VARIABLE: /*-----------------------*/ applySubinstruction(windowHeight, Set); /*---------------------*/ jmp assessSubinstruction;
				to WINDOW_HORIZONTAL_ALIGNMENT_VARIABLE: /*---------*/ applySubinstruction(windowHorizontalAlignment, Set); /*--------*/ jmp assessSubinstruction;
				to WINDOW_VERTICAL_ALIGNMENT_VARIABLE: /*-----------*/ applySubinstruction(windowVerticalAlignment, Set); /*----------*/ jmp assessSubinstruction;
				to WINDOW_CORNER_RADIUS_VARIABLE: /*----------------*/ applySubinstruction(windowCornerRadius, Set); /*---------------*/ jmp assessSubinstruction;
				to WINDOW_BACKGROUND_VARIABLE: /*-------------------*/ applySubinstruction(windowBackground, Set); /*-----------------*/ jmp assessSubinstruction;
				to INPUT_X_VARIABLE: /*-----------------------------*/ applySubinstruction(inputX, Set); /*---------------------------*/ jmp assessSubinstruction;
				to INPUT_Y_VARIABLE: /*-----------------------------*/ applySubinstruction(inputY, Set); /*---------------------------*/ jmp assessSubinstruction;
				to INPUT_X_OFFSET_VARIABLE: /*----------------------*/ applySubinstruction(inputXOffset, Set); /*---------------------*/ jmp assessSubinstruction;
				to INPUT_Y_OFFSET_VARIABLE: /*----------------------*/ applySubinstruction(inputYOffset, Set); /*---------------------*/ jmp assessSubinstruction;
				to INPUT_WIDTH_VARIABLE: /*-------------------------*/ applySubinstruction(inputWidth, Set); /*-----------------------*/ jmp assessSubinstruction;
				to INPUT_HEIGHT_VARIABLE: /*------------------------*/ applySubinstruction(inputHeight, Set); /*----------------------*/ jmp assessSubinstruction;
				to INPUT_HORIZONTAL_ALIGNMENT_VARIABLE: /*----------*/ applySubinstruction(inputHorizontalAlignment, Set); /*---------*/ jmp assessSubinstruction;
				to INPUT_VERTICAL_ALIGNMENT_VARIABLE: /*------------*/ applySubinstruction(inputVerticalAlignment, Set); /*-----------*/ jmp assessSubinstruction;
				to INPUT_CLIP_CHILDREN_VARIABLE: /*-----------------*/ applySubinstruction(inputClipChildren, Set); /*----------------*/ jmp assessSubinstruction;
				to INPUT_BACKGROUND_VARIABLE: /*--------------------*/ applySubinstruction(inputBackground, Set); /*------------------*/ jmp assessSubinstruction;
				to INPUT_TEXT_X_VARIABLE: /*------------------------*/ applySubinstruction(inputTextX, Set); /*-----------------------*/ jmp assessSubinstruction;
				to INPUT_TEXT_Y_VARIABLE: /*------------------------*/ applySubinstruction(inputTextY, Set); /*-----------------------*/ jmp assessSubinstruction;
				to INPUT_TEXT_X_OFFSET_VARIABLE: /*-----------------*/ applySubinstruction(inputTextXOffset, Set); /*-----------------*/ jmp assessSubinstruction;
				to INPUT_TEXT_Y_OFFSET_VARIABLE: /*-----------------*/ applySubinstruction(inputTextYOffset, Set); /*-----------------*/ jmp assessSubinstruction;
				to INPUT_TEXT_HORIZONTAL_ALIGNMENT_VARIABLE: /*-----*/ applySubinstruction(inputTextHorizontalAlignment, Set); /*-----*/ jmp assessSubinstruction;
				to INPUT_TEXT_VERTICAL_ALIGNMENT_VARIABLE: /*-------*/ applySubinstruction(inputTextVerticalAlignment, Set); /*-------*/ jmp assessSubinstruction;
				to INPUT_TEXT_FOREGROUND_VARIABLE: /*---------------*/ applySubinstruction(inputTextForeground, Set); /*--------------*/ jmp assessSubinstruction;
				to INPUT_TEXT_BACKGROUND_VARIABLE: /*---------------*/ applySubinstruction(inputTextBackground, Set); /*--------------*/ jmp assessSubinstruction;
				to INPUT_TEXT_SELECTED_FOREGROUND_VARIABLE: /*------*/ applySubinstruction(inputTextSelectedForeground, Set); /*------*/ jmp assessSubinstruction;
				to INPUT_TEXT_SELECTED_BACKGROUND_VARIABLE: /*------*/ applySubinstruction(inputTextSelectedBackground, Set); /*------*/ jmp assessSubinstruction;
				to SELECTION_X_VARIABLE: /*-------------------------*/ applySubinstruction(selectionX, Set); /*-----------------------*/ jmp assessSubinstruction;
				to SELECTION_Y_VARIABLE: /*-------------------------*/ applySubinstruction(selectionY, Set); /*-----------------------*/ jmp assessSubinstruction;
				to SELECTION_X_OFFSET_VARIABLE: /*------------------*/ applySubinstruction(selectionXOffset, Set); /*-----------------*/ jmp assessSubinstruction;
				to SELECTION_Y_OFFSET_VARIABLE: /*------------------*/ applySubinstruction(selectionYOffset, Set); /*-----------------*/ jmp assessSubinstruction;
				to SELECTION_WIDTH_VARIABLE: /*---------------------*/ applySubinstruction(selectionWidth, Set); /*-------------------*/ jmp assessSubinstruction;
				to SELECTION_HEIGHT_VARIABLE: /*--------------------*/ applySubinstruction(selectionHeight, Set); /*------------------*/ jmp assessSubinstruction;
				to SELECTION_MARGIN_VARIABLE: /*--------------------*/ applySubinstruction(selectionMargin, Set); /*------------------*/ jmp assessSubinstruction;
				to SELECTION_HORIZONTAL_ALIGNMENT_VARIABLE: /*------*/ applySubinstruction(selectionHorizontalAlignment, Set); /*-----*/ jmp assessSubinstruction;
				to SELECTION_VERTICAL_ALIGNMENT_VARIABLE: /*--------*/ applySubinstruction(selectionVerticalAlignment, Set); /*-------*/ jmp assessSubinstruction;
				to SELECTION_CLIP_CHILDREN_VARIABLE: /*-------------*/ applySubinstruction(selectionClipChildren, Set); /*------------*/ jmp assessSubinstruction;
				to SELECTION_BACKGROUND_VARIABLE: /*----------------*/ applySubinstruction(selectionBackground, Set); /*--------------*/ jmp assessSubinstruction;
				to SELECTION_SELECTED_BACKGROUND_VARIABLE: /*-------*/ applySubinstruction(selectionSelectedBackground, Set); /*------*/ jmp assessSubinstruction;
				to SELECTION_TEXT_X_VARIABLE: /*--------------------*/ applySubinstruction(selectionTextX, Set); /*-------------------*/ jmp assessSubinstruction;
				to SELECTION_TEXT_Y_VARIABLE: /*--------------------*/ applySubinstruction(selectionTextY, Set); /*-------------------*/ jmp assessSubinstruction;
				to SELECTION_TEXT_X_OFFSET_VARIABLE: /*-------------*/ applySubinstruction(selectionTextXOffset, Set); /*-------------*/ jmp assessSubinstruction;
				to SELECTION_TEXT_Y_OFFSET_VARIABLE: /*-------------*/ applySubinstruction(selectionTextYOffset, Set); /*-------------*/ jmp assessSubinstruction;
				to SELECTION_TEXT_HORIZONTAL_ALIGNMENT_VARIABLE: /*-*/ applySubinstruction(selectionTextHorizontalAlignment, Set); /*-*/ jmp assessSubinstruction;
				to SELECTION_TEXT_VERTICAL_ALIGNMENT_VARIABLE: /*---*/ applySubinstruction(selectionTextVerticalAlignment, Set); /*---*/ jmp assessSubinstruction;
				to SELECTION_TEXT_FOREGROUND_VARIABLE: /*-----------*/ applySubinstruction(selectionTextForeground, Set); /*----------*/ jmp assessSubinstruction;
				to SELECTION_TEXT_BACKGROUND_VARIABLE: /*-----------*/ applySubinstruction(selectionTextBackground, Set); /*----------*/ jmp assessSubinstruction;
				to SELECTION_TEXT_SELECTED_FOREGROUND_VARIABLE: /*--*/ applySubinstruction(selectionTextSelectedForeground, Set); /*--*/ jmp assessSubinstruction;
				to SELECTION_TEXT_SELECTED_BACKGROUND_VARIABLE: /*--*/ applySubinstruction(selectionTextSelectedBackground, Set); /*--*/ jmp assessSubinstruction;
				to MAXIMUM_SELECTION_AMOUNT_VARIABLE: /*------------*/ applySubinstruction(maximumSelectionAmount, Set); /*-----------*/ jmp assessSubinstruction;
				to SELECTION_AXIS_VARIABLE: /*----------------------*/ applySubinstruction(selectionAxis, Set); /*--------------------*/ jmp assessSubinstruction;
				to SELECTION_AXIS_AMOUNT_VARIABLE: /*---------------*/ applySubinstruction(selectionAxisAmount, Set); /*--------------*/ jmp assessSubinstruction;
				to STARTING_SELECTION_VARIABLE: /*------------------*/ applySubinstruction(startingSelection, Set); /*----------------*/ jmp assessSubinstruction;
				to ALLOW_CIRCULAR_NAVIGATION_VARIABLE: /*-----------*/ applySubinstruction(allowCircularNavigation, Set); /*----------*/ jmp assessSubinstruction;
				to WHICH_MONITOR_VARIABLE: /*-----------------------*/ applySubinstruction(whichMonitor, Set); /*---------------------*/ jmp assessSubinstruction;
				to FONT_VARIABLE: /*--------------------------------*/ applySubinstruction(font, Set); /*-----------------------------*/ jmp assessSubinstruction;
				off: /*---------------------------------------------*/ /*-------------------------------------------------------------*/ brk;
			end
		}
		if(instructionStart == doInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, Do); jmp assessSubinstruction;
				off: /*----------------*/ /*-----------------------------*/ brk;
			end
		}
		if(instructionStart == grabKeycodeInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabKeycode); jmp assessSubinstruction;
				off: /*----------------*/ /*--------------------------------------*/ brk;
			end
		}
		if(instructionStart == grabButtonInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabButton); jmp assessSubinstruction;
				off: /*----------------*/ /*-------------------------------------*/ brk;
			end
			#undef  applySubinstruction
		}
		if(statementCurrent < statementWall){
			printConfigError("config error", "extra parameters error", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(instructionStartCopy == helpInstruction){
			printError("%s%s: %s: line %u: %s%s:%s %s:\n", colorStart, programName, configPath, statementLine, colorError, "config help menu", colorEnd, displaySimpleConfigErrors? "contracted" : "expanded");
			jmp printAllInstructionPatterns;
		}
		if(instructionStartCopy == expandInstruction){
			displaySimpleConfigErrors = false;
			jmp getStatementStart;
		}
		if(instructionStartCopy == contractInstruction){
			displaySimpleConfigErrors = true;
			jmp getStatementStart;
		}
		if(instructionStartCopy == readConfigInstruction){
			readConfig(false, string0Return, &ifgetc, NULL);
			jmp getStatementStart;
		}
		if(instructionStartCopy == useTerminalInstruction){
			switch name0Return over
				to TRUE_BOOLEAN:{
					if(!connectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == useMessengerInstruction){
			switch name0Return over
				to TRUE_BOOLEAN:{
					if(!connectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == setInstruction){
			switch name0Return over
				to WINDOW_X_VARIABLE:{
					windowPreferences.x = integer0Return;
					windowPreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_Y_VARIABLE:{
					windowPreferences.y = integer0Return;
					windowPreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_X_OFFSET_VARIABLE:{
					windowPreferences.xOffset = integer0Return;
					windowPreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_Y_OFFSET_VARIABLE:{
					windowPreferences.yOffset = integer0Return;
					windowPreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_WIDTH_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					windowPreferences.width = integer0Return;
					windowPreferences.widthType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_HEIGHT_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					windowPreferences.height = integer0Return;
					windowPreferences.heightType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_HORIZONTAL_ALIGNMENT_VARIABLE:{
					windowPreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_VERTICAL_ALIGNMENT_VARIABLE:{
					windowPreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_CORNER_RADIUS_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					if(integer0Return != windowPreferences.cornerRadius){
						if(createWindowCirclePixmap(&windowSystem, integer0Return, windowPreferences.background, 0x00000000)){
							windowPreferences.cornerRadius = integer0Return;
							windowPreferences.cornerUsed = nameList0Return;
						}
					}
					jmp getStatementStart;
				}
				to WINDOW_BACKGROUND_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					windowPreferences.background = integer0Return;
					createWindowCirclePixmap(&windowSystem, windowPreferences.cornerRadius, integer0Return, 0x00000000);
					jmp getStatementStart;
				}
				to INPUT_X_VARIABLE:{
					inputPreferences.x = integer0Return;
					inputPreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_Y_VARIABLE:{
					inputPreferences.y = integer0Return;
					inputPreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_X_OFFSET_VARIABLE:{
					inputPreferences.xOffset = integer0Return;
					inputPreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_Y_OFFSET_VARIABLE:{
					inputPreferences.yOffset = integer0Return;
					inputPreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_WIDTH_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					inputPreferences.width = integer0Return;
					inputPreferences.widthType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_HEIGHT_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					inputPreferences.height = integer0Return;
					inputPreferences.heightType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_HORIZONTAL_ALIGNMENT_VARIABLE:{
					inputPreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to INPUT_VERTICAL_ALIGNMENT_VARIABLE:{
					inputPreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to INPUT_CLIP_CHILDREN_VARIABLE:{
					switch name1Return over
						to TRUE_BOOLEAN: /*--*/ inputPreferences.clipChildren = true; /*--*/ jmp getStatementStart;
						to FALSE_BOOLEAN: /*-*/ inputPreferences.clipChildren = false; /*-*/ jmp getStatementStart;
						off: /*--------------*/ /*----------------------------------------*/ jmp getStatementStart;
					end
				}
				to INPUT_BACKGROUND_VARIABLE:{
					inputPreferences.background = integer0Return;
					jmp getStatementStart;
				}
				to INPUT_TEXT_X_VARIABLE:{
					inputTextPreferences.x = integer0Return;
					inputTextPreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_TEXT_Y_VARIABLE:{
					inputTextPreferences.y = integer0Return;
					inputTextPreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_TEXT_X_OFFSET_VARIABLE:{
					inputTextPreferences.xOffset = integer0Return;
					inputTextPreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_TEXT_Y_OFFSET_VARIABLE:{
					inputTextPreferences.yOffset = integer0Return;
					inputTextPreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to INPUT_TEXT_HORIZONTAL_ALIGNMENT_VARIABLE:{
					inputTextPreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to INPUT_TEXT_VERTICAL_ALIGNMENT_VARIABLE:{
					inputTextPreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to INPUT_TEXT_FOREGROUND_VARIABLE:{
					inputTextPreferences.foreground = integer0Return;
					jmp getStatementStart;
				}
				to INPUT_TEXT_BACKGROUND_VARIABLE:{
					inputTextPreferences.background = integer0Return;
					jmp getStatementStart;
				}
				to INPUT_TEXT_SELECTED_FOREGROUND_VARIABLE:{
					inputTextPreferences.selectedForeground = integer0Return;
					jmp getStatementStart;
				}
				to INPUT_TEXT_SELECTED_BACKGROUND_VARIABLE:{
					inputTextPreferences.selectedBackground = integer0Return;
					jmp getStatementStart;
				}
				to SELECTION_X_VARIABLE:{
					selectionPreferences.x = integer0Return;
					selectionPreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_Y_VARIABLE:{
					selectionPreferences.y = integer0Return;
					selectionPreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_X_OFFSET_VARIABLE:{
					selectionPreferences.xOffset = integer0Return;
					selectionPreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_Y_OFFSET_VARIABLE:{
					selectionPreferences.yOffset = integer0Return;
					selectionPreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_WIDTH_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					selectionPreferences.width = integer0Return;
					selectionPreferences.widthType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_HEIGHT_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					selectionPreferences.height = integer0Return;
					selectionPreferences.heightType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_MARGIN_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					selectionPreferences.margin = integer0Return;
					selectionPreferences.marginType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_HORIZONTAL_ALIGNMENT_VARIABLE:{
					selectionPreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_VERTICAL_ALIGNMENT_VARIABLE:{
					selectionPreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_CLIP_CHILDREN_VARIABLE:{
					switch name1Return over
						to TRUE_BOOLEAN: /*--*/ selectionPreferences.clipChildren = true; /*--*/ jmp getStatementStart;
						to FALSE_BOOLEAN: /*-*/ selectionPreferences.clipChildren = false; /*-*/ jmp getStatementStart;
						off: /*--------------*/ /*--------------------------------------------*/ jmp getStatementStart;
					end
				}
				to SELECTION_BACKGROUND_VARIABLE:{
					selectionPreferences.background = integer0Return;
					jmp getStatementStart;
				}
				to SELECTION_SELECTED_BACKGROUND_VARIABLE:{
					selectionPreferences.selectedBackground = integer0Return;
					jmp getStatementStart;
				}
				to SELECTION_TEXT_X_VARIABLE:{
					selectionTextPreferences.x = integer0Return;
					selectionTextPreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_TEXT_Y_VARIABLE:{
					selectionTextPreferences.y = integer0Return;
					selectionTextPreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_TEXT_X_OFFSET_VARIABLE:{
					selectionTextPreferences.xOffset = integer0Return;
					selectionTextPreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_TEXT_Y_OFFSET_VARIABLE:{
					selectionTextPreferences.yOffset = integer0Return;
					selectionTextPreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_TEXT_HORIZONTAL_ALIGNMENT_VARIABLE:{
					selectionTextPreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_TEXT_VERTICAL_ALIGNMENT_VARIABLE:{
					selectionTextPreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_TEXT_FOREGROUND_VARIABLE:{
					selectionTextPreferences.foreground = integer0Return;
					jmp getStatementStart;
				}
				to SELECTION_TEXT_BACKGROUND_VARIABLE:{
					selectionTextPreferences.background = integer0Return;
					jmp getStatementStart;
				}
				to SELECTION_TEXT_SELECTED_FOREGROUND_VARIABLE:{
					selectionTextPreferences.selectedForeground = integer0Return;
					jmp getStatementStart;
				}
				to SELECTION_TEXT_SELECTED_BACKGROUND_VARIABLE:{
					selectionTextPreferences.selectedBackground = integer0Return;
					jmp getStatementStart;
				}
				to MAXIMUM_SELECTION_AMOUNT_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					maximumSelectionAmount = integer0Return;
					jmp getStatementStart;
				}
				to SELECTION_AXIS_VARIABLE:{
					setSelectionAxis(&selectionSystem, name1Return);
					jmp getStatementStart;
				}
				to SELECTION_AXIS_AMOUNT_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					setSelectionAxisAmount(&selectionSystem, integer0Return);
					jmp getStatementStart;
				}
				to STARTING_SELECTION_VARIABLE:{
					setStartingSelection(&selectionSystem, name1Return);
					jmp getStatementStart;
				}
				to ALLOW_CIRCULAR_NAVIGATION_VARIABLE:{
					switch name1Return over
						to TRUE_BOOLEAN: /*--*/ setSelectionNavigation(&selectionSystem, true); /*--*/ jmp getStatementStart;
						to FALSE_BOOLEAN: /*-*/ setSelectionNavigation(&selectionSystem, false); /*-*/ jmp getStatementStart;
						off: /*--------------*/ /*--------------------------------------------------*/ jmp getStatementStart;
					end
				}
				to WHICH_MONITOR_VARIABLE:{
					whichMonitor = name1Return;
					jmp getStatementStart;
				}
				to FONT_VARIABLE:{
					if(font){
						xcb_close_font(connection, font);
					}
					font = xcb_generate_id(connection);
					{
						const xcb_void_cookie_t cookie = xcb_open_font_checked(connection, font, findStringLength(string0Return), string0Return);
						xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
						uint32 token = pushPointer(error, "open font error", iFree);
						if(error){
							xcb_open_font(connection, font, lengthof("fixed"), "fixed");
							printError("%s%s: %s%s:%s %s \"%s\"\n", colorStart, programName, colorError, "open font error", colorEnd, "could not open font", string0Return);
							free(error);
							popPointer(token);
						}
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == doInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			end
			switch matchCommand(name0Return, string0Return, getNextConfigChar == &ifgetc? CONFIG_MATCH_COMMAND_ORIGIN : getNextConfigChar == &getNextSTDINCharacter? STDIN_MATCH_COMMAND_ORIGIN : TRANSMITTER_MATCH_COMMAND_ORIGIN, field0, field1, field2, field3, field4) over
				to TYPICAL_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to RESTART_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to EXIT_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				off:{
					printConfigError("config error", "do subinstruction not implemented yet", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionStart, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == grabKeycodeInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			end
			if(!insertShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_key_checked(connection, true, (*screen).root, nameList0Return, integer0Return, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab key on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == grabButtonInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			end
			if(!insertShortcut(&buttonShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_button_checked(connection, true, (*screen).root, XCB_EVENT_MASK_NO_EVENT, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, integer0Return, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab button on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabKeycodeInstruction){
			if(!removeShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find key to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_key_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab key from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabButtonInstruction){
			if(!removeShortcut(&buttonShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find button to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_button_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab button from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == stopInstruction){
			jmp successfulConfig;
		}
		jmp getStatementStart;
	}
	advanceInstruction:{
		inc instructionCurrent;
		jmp switchInstructionLoop;
	}
	advanceDataInstruction:{
		inc instructionCurrent;
		inc instructionDataCurrent;
		jmp switchInstructionLoop;
	}
	assessSubinstruction:{
		instructionCurrent = instructionStart + (instructionCurrent - instructionStartCopy);
		instructionDataCurrent = instructionDataStart + (instructionDataCurrent - instructionDataStartCopy);
		if(statementCurrent < statementWall){
			jmp switchInstructionLoop;
		}
		jmp printMissingArgumentError;
	}
	printMissingArgumentError:{
		printConfigError("config error", "missing argument error", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printAllInstructionPatterns:{
		const char *const *const wall = currentScopeInstructionList + currentScopeInstructionListSize;
		const char *const *current = currentScopeInstructionList;
		const Instruction *const *in = currentScopeInstruction;
		StringTreeSystem *const *const *da = currentScopeInstructionData;
		jmp printExpandedHelpInstructions;
		printExpandedHelpInstructions:{
			const Instruction *n = *in - 1;
			StringTreeSystem *const *d = *da;
			printError("\tpattern | %s", *current);
			jmp printHelpInstructionParametersLoop;
			printHelpInstructionParametersLoop: switch *(inc n) over
				to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
				to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
				to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
				to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
				to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
				to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
				off: /*---------------------------*/ jmp printHelpInstructionParametersLoopExit;
			end
			noneInstruction:{
				printError(" <unimplemented>");
				jmp printHelpInstructionParametersLoopExit;
			}
			nameInstruction:{
				if(displaySimpleConfigErrors){
					printError(" name");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" (%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
					printNameLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameLoop;
						}
						printError(")");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			nameListInstruction:{
				if(displaySimpleConfigErrors){
					printError(" list");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" ((%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
					printNameListOnceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListOnceLoop;
						}
						stringArray = (**d).stringArray;
						printError(")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
						inc stringArray;
						jmp printNameListTwiceLoop;
					}
					printNameListTwiceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListTwiceLoop;
						}
						printError("))*(?![\\s]*[|]))");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			numberInstruction:{
				if(displaySimpleConfigErrors){
					printError(" number");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
				jmp printHelpInstructionParametersLoop;
			}
			stringInstruction:{
				if(displaySimpleConfigErrors){
					printError(" string");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
			imageInstruction:{
				if(displaySimpleConfigErrors){
					printError(" image");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
		}
		printHelpInstructionParametersLoopExit:{
			inc in;
			inc da;
			if(displaySimpleConfigErrors){
				printError("\n");
			}else{
				printError(" $\n");
			}
			if(inc current < wall){
				jmp printExpandedHelpInstructions;
			}
			printError("\n");
			jmp getStatementStart;
		}
	}
	successfulConfig:{
		if(currentScopeInstruction != globalScopeInstruction){
			*statementCurrent = '\0';
			statementWall = statementCurrent;
			statementLine = fileLine;
			if(fileLine != 1){
				dec statementLine;
			}
			printConfigError("config error", "missing closing scope bracket", '\0', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		jmp configEmergencyExit;
	}
	configEmergencyExit:{
		if(configFile and fileLine == 1 and !statementLine){
			printConfigError("config warning", "empty config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		free(statementStart);
		popPointer(statementToken);
		if(configFile){
			fclose(configFile);
			popPointer(configFileToken);
		}
		jmp postReadConfig;
	}
	postReadConfig:{
		if(!configureWindows(&windowSystem, &monitorSystem, &windowPreferences, whichMonitor)){
			if(windowSystem.mapped){
				drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
			}
		}
		xcb_flush(connection);
		ret;
	}
	#undef  DEFAULT_CONFIG_PATH
	#undef  STATEMENT_BLOCK_SIZE
}
MATCHCOMMAND(){
	uint8 commandReturned = TYPICAL_MATCH_COMMAND_TYPE;
	(void)field0;
	(void)field1;
	(void)field2;
	(void)field3;
	(void)field4;
	switch origin over
		to PRESS_MATCH_COMMAND_ORIGIN:{
			printCommand("press", command);
			if(!((*eventModifierNode).onState & PRESS_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to RELEASE_MATCH_COMMAND_ORIGIN:{
			printCommand("release", command);
			if(!((*eventModifierNode).onState & RELEASE_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to CONFIG_MATCH_COMMAND_ORIGIN:{
			printCommand("config", command);
			jmp matchCommand;
		}
		to STDIN_MATCH_COMMAND_ORIGIN:{
			printCommand("stdin", command);
			jmp matchCommand;
		}
		to TRANSMITTER_MATCH_COMMAND_ORIGIN:{
			printCommand("transmitter", command);
			jmp matchCommand;
		}
		off:{
			jmp emergencyExit;
		}
	end
	matchCommand: switch command over
		to NONE_COMMAND: /*--------------------*/ jmp noneCommand;
		to EXECUTE_COMMAND: /*-----------------*/ jmp executeCommand;
		to SET_CURRENT_SELECTION_COMMAND: /*---*/ jmp setCurrentSelectionCommand;
		to SHOW_COMMAND: /*--------------------*/ jmp showCommand;
		to HIDE_COMMAND: /*--------------------*/ jmp hideCommand;
		to TOGGLE_VISIBILITY_COMMAND: /*-------*/ jmp toggleVisibilityCommand;
		to DRAW_COMMAND: /*--------------------*/ jmp drawCommand;
		to CLEAR_INPUT_COMMAND: /*-------------*/ jmp clearInputCommand;
		to TO_NEXT_LETTER_COMMAND: /*----------*/ jmp toNextLetterCommand;
		to TO_PREVIOUS_LETTER_COMMAND: /*------*/ jmp toPreviousLetterCommand;
		to TO_NEXT_WORD_COMMAND: /*------------*/ jmp toNextWordCommand;
		to TO_PREVIOUS_WORD_COMMAND: /*--------*/ jmp toPreviousWordCommand;
		to TO_START_OF_LINE_COMMAND: /*--------*/ jmp toStartOfLineCommand;
		to TO_END_OF_LINE_COMMAND: /*----------*/ jmp toEndOfLineCommand;
		to TO_NEXT_SELECTION_COMMAND: /*-------*/ jmp toNextSelectionCommand;
		to TO_PREVIOUS_SELECTION_COMMAND: /*---*/ jmp toPreviousSelectionCommand;
		to REMOVE_LEFT_LETTER_COMMAND: /*------*/ jmp removeLeftLetterCommand;
		to REMOVE_RIGHT_LETTER_COMMAND: /*-----*/ jmp removeRightLetterCommand;
		to REMOVE_LEFT_WORD_COMMAND: /*--------*/ jmp removeLeftWordCommand;
		to REMOVE_RIGHT_WORD_COMMAND: /*-------*/ jmp removeRightWordCommand;
		to SELECT_LEFT_LETTER_COMMAND: /*------*/ jmp selectLeftLetterCommand;
		to SELECT_RIGHT_LETTER_COMMAND: /*-----*/ jmp selectRightLetterCommand;
		to SELECT_LEFT_WORD_COMMAND: /*--------*/ jmp selectLeftWordCommand;
		to SELECT_RIGHT_WORD_COMMAND: /*-------*/ jmp selectRightWordCommand;
		to SELECT_TO_START_OF_LINE_COMMAND: /*-*/ jmp selectToStartOfLineCommand;
		to SELECT_TO_END_OF_LINE_COMMAND: /*---*/ jmp selectToEndOfLineCommand;
		to SELECT_ALL_COMMAND: /*--------------*/ jmp selectAllCommand;
		to COPY_SELECTED_COMMAND: /*-----------*/ jmp copySelectedCommand;
		to CUT_SELECTED_COMMAND: /*------------*/ jmp cutSelectedCommand;
		to PASTE_CLIPBOARD_COMMAND: /*---------*/ jmp pasteClipboardCommand;
		to UPPERCASE_SELECTED_COMMAND: /*------*/ jmp uppercaseSelectedCommand;
		to LOWERCASE_SELECTED_COMMAND: /*------*/ jmp lowercaseSelectedCommand;
		to TOGGLE_INSERT_MODE_COMMAND: /*------*/ jmp toggleInsertModeCommand;
		to PASTE_SELECTION_COMMAND: /*---------*/ jmp pasteSelectionCommand;
		to LAUNCH_COMMAND: /*------------------*/ jmp launchCommand;
		to RESTART_COMMAND: /*-----------------*/ jmp restartCommand;
		to EXIT_COMMAND: /*--------------------*/ jmp exitCommand;
		off: /*--------------------------------*/ jmp unrecognizedCommand;
	end
	noneCommand:{
		jmp emergencyExit;
	}
	executeCommand:{
		spawnProcess(execute);
		jmp emergencyExit;
	}
	setCurrentSelectionCommand:{
		setCurrentSelection(&selectionSystem);
		drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		jmp emergencyExit;
	}
	showCommand:{
		findASCIIStringTreeNodes(&asciiStringTreeSystem, maximumSelectionAmount, inputSystem.dataStart);
		setSelectionAmount(&selectionSystem, asciiStringTreeSystem.stringsFoundAmount);
		setCurrentSelection(&selectionSystem);
		if(mapWindows(&windowSystem, &monitorSystem, &windowPreferences, whichMonitor)){
			grabDevice(KEYBOARD_GRAB_DEVICE, 100);
			grabDevice(POINTER_GRAB_DEVICE, 100);
		}
		jmp emergencyExit;
	}
	hideCommand:{
		if(unmapWindows(&windowSystem)){
			ungrabDevice(KEYBOARD_GRAB_DEVICE);
			ungrabDevice(POINTER_GRAB_DEVICE);
		}
		jmp emergencyExit;
	}
	toggleVisibilityCommand:{
		if(!windowSystem.mapped){
			jmp showCommand;
		}
		jmp hideCommand;
	}
	drawCommand:{
		drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		jmp emergencyExit;
	}
	clearInputCommand:{
		if(selectAllInput(&inputSystem) and removeSelectedInput(&inputSystem)){
			findASCIIStringTreeNodes(&asciiStringTreeSystem, maximumSelectionAmount, inputSystem.dataStart);
			setSelectionAmount(&selectionSystem, asciiStringTreeSystem.stringsFoundAmount);
			setCurrentSelection(&selectionSystem);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	toNextLetterCommand:{
		if(moveInputCursorBy(&inputSystem, RIGHT_DIRECTION, CHARACTER_MATCH_LENGTH)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	toPreviousLetterCommand:{
		if(moveInputCursorBy(&inputSystem, LEFT_DIRECTION, CHARACTER_MATCH_LENGTH)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	toNextWordCommand:{
		if(moveInputCursorBy(&inputSystem, RIGHT_DIRECTION, WORD_MATCH_LENGTH)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	toPreviousWordCommand:{
		if(moveInputCursorBy(&inputSystem, LEFT_DIRECTION, WORD_MATCH_LENGTH)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	toStartOfLineCommand:{
		if(moveInputCursorToStart(&inputSystem)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	toEndOfLineCommand:{
		if(moveInputCursorToEnd(&inputSystem)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	toNextSelectionCommand:{
		if(moveCurrentSelection(&selectionSystem, NEXT_WHICH_SELECTION)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	toPreviousSelectionCommand:{
		if(moveCurrentSelection(&selectionSystem, PREVIOUS_WHICH_SELECTION)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	removeLeftLetterCommand:{
		if(removeInputText(&inputSystem, LEFT_DIRECTION, CHARACTER_MATCH_LENGTH)){
			findASCIIStringTreeNodes(&asciiStringTreeSystem, maximumSelectionAmount, inputSystem.dataStart);
			setSelectionAmount(&selectionSystem, asciiStringTreeSystem.stringsFoundAmount);
			setCurrentSelection(&selectionSystem);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	removeRightLetterCommand:{
		if(removeInputText(&inputSystem, RIGHT_DIRECTION, CHARACTER_MATCH_LENGTH)){
			findASCIIStringTreeNodes(&asciiStringTreeSystem, maximumSelectionAmount, inputSystem.dataStart);
			setSelectionAmount(&selectionSystem, asciiStringTreeSystem.stringsFoundAmount);
			setCurrentSelection(&selectionSystem);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	removeLeftWordCommand:{
		if(removeInputText(&inputSystem, LEFT_DIRECTION, WORD_MATCH_LENGTH)){
			findASCIIStringTreeNodes(&asciiStringTreeSystem, maximumSelectionAmount, inputSystem.dataStart);
			setSelectionAmount(&selectionSystem, asciiStringTreeSystem.stringsFoundAmount);
			setCurrentSelection(&selectionSystem);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	removeRightWordCommand:{
		if(removeInputText(&inputSystem, RIGHT_DIRECTION, WORD_MATCH_LENGTH)){
			findASCIIStringTreeNodes(&asciiStringTreeSystem, maximumSelectionAmount, inputSystem.dataStart);
			setSelectionAmount(&selectionSystem, asciiStringTreeSystem.stringsFoundAmount);
			setCurrentSelection(&selectionSystem);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	selectLeftLetterCommand:{
		if(selectInputText(&inputSystem, LEFT_DIRECTION, CHARACTER_MATCH_LENGTH)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	selectRightLetterCommand:{
		if(selectInputText(&inputSystem, RIGHT_DIRECTION, CHARACTER_MATCH_LENGTH)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	selectLeftWordCommand:{
		if(selectInputText(&inputSystem, LEFT_DIRECTION, WORD_MATCH_LENGTH)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	selectRightWordCommand:{
		if(selectInputText(&inputSystem, RIGHT_DIRECTION, WORD_MATCH_LENGTH)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	selectToStartOfLineCommand:{
		if(selectInputUntilStart(&inputSystem)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	selectToEndOfLineCommand:{
		if(selectInputUntilEnd(&inputSystem)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	selectAllCommand:{
		if(selectAllInput(&inputSystem)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	copySelectedCommand:{
		copySelectedInput(&inputSystem, &clipboardSystem);
		jmp emergencyExit;
	}
	cutSelectedCommand:{
		if(copySelectedInput(&inputSystem, &clipboardSystem) and removeSelectedInput(&inputSystem)){
			findASCIIStringTreeNodes(&asciiStringTreeSystem, maximumSelectionAmount, inputSystem.dataStart);
			setSelectionAmount(&selectionSystem, asciiStringTreeSystem.stringsFoundAmount);
			setCurrentSelection(&selectionSystem);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	pasteClipboardCommand:{
		if(pasteOnInput(&inputSystem, clipboardSystem.dataStart, clipboardSystem.dataSize)){
			findASCIIStringTreeNodes(&asciiStringTreeSystem, maximumSelectionAmount, inputSystem.dataStart);
			setSelectionAmount(&selectionSystem, asciiStringTreeSystem.stringsFoundAmount);
			setCurrentSelection(&selectionSystem);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	uppercaseSelectedCommand:{
		if(setSelectedInputCase(&inputSystem, UPPER_CASE)){
			findASCIIStringTreeNodes(&asciiStringTreeSystem, maximumSelectionAmount, inputSystem.dataStart);
			setSelectionAmount(&selectionSystem, asciiStringTreeSystem.stringsFoundAmount);
			setCurrentSelection(&selectionSystem);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	lowercaseSelectedCommand:{
		if(setSelectedInputCase(&inputSystem, LOWER_CASE)){
			findASCIIStringTreeNodes(&asciiStringTreeSystem, maximumSelectionAmount, inputSystem.dataStart);
			setSelectionAmount(&selectionSystem, asciiStringTreeSystem.stringsFoundAmount);
			setCurrentSelection(&selectionSystem);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	toggleInsertModeCommand:{
		if(changeInputMode(&inputSystem)){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	pasteSelectionCommand:{
		if(findFoundASCIIString(&asciiStringTreeSystem, selectionSystem.currentSelection)){
			selectAllInput(&inputSystem);
			removeSelectedInput(&inputSystem);
			if(pasteOnInput(&inputSystem, asciiStringTreeSystem.foundStringStart, asciiStringTreeSystem.foundStringLength)){
				findASCIIStringTreeNodes(&asciiStringTreeSystem, maximumSelectionAmount, inputSystem.dataStart);
				setSelectionAmount(&selectionSystem, asciiStringTreeSystem.stringsFoundAmount);
				setCurrentSelection(&selectionSystem);
				drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
			}
		}
		jmp emergencyExit;
	}
	launchCommand:{
		executeInputBuffer(&inputSystem);
		jmp emergencyExit;
	}
	restartCommand:{
		commandReturned = RESTART_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	exitCommand:{
		commandReturned = EXIT_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	unrecognizedCommand:{
		printTitledValuedError("command error", "executed unrecognized command with type", command);
		jmp emergencyExit;
	}
	emergencyExit:{
		ret commandReturned;
	}
}
FREECONFIGVARIABLES(){
	if(font){
		xcb_close_font(connection, font);
		font = XCB_NONE;
	}
	ret;
}
CLEANUP(){
	free(event);
	popPointer(eventToken);
	event = NULL;
	eventToken = 0;
	finiSharedMemorySystem(&sharedMemorySystem);
	finiSTDINSystem(&stdinSystem);
	finiSleepThreadSystem(&sleepThreadSystem);
	cancelThreads();
	ungrabShortcuts();
	freeConfigVariables();
	finiSelectionSystem(&selectionSystem);
	finiASCIIStringTreeSystem(&asciiStringTreeSystem);
	finiInputSystem(&inputSystem);
	finiClipboardSystem(&clipboardSystem);
	finiWindowSystem(&windowSystem);
	finiMonitorSystem(&monitorSystem);
	if(ic){
		XDestroyIC(ic);
		ic = XCB_NONE;
	}
	if(im){
		XCloseIM(im);
		im = XCB_NONE;
	}
	if(connectionToken){
		xcb_flush(connection);
		xcb_disconnect(connection);
		popPointer(connectionToken);
		connection = NULL;
		connectionToken = 0;
	}
	if(display){
		XCloseDisplay(display);
		popPointer(displayToken);
		display = NULL;
		displayToken = 0;
	}
	finiShortcutSystem(&buttonShortcutSystem);
	finiShortcutSystem(&keycodeShortcutSystem);
	finiStringTreeSystem(&macroStringTreeSystem);
	finiStringTreeSystem(&whichMonitorStringTreeSystem);
	finiStringTreeSystem(&startingSelectionStringTreeSystem);
	finiStringTreeSystem(&axisStringTreeSystem);
	finiStringTreeSystem(&cornerStringTreeSystem);
	finiStringTreeSystem(&verticalAlignmentStringTreeSystem);
	finiStringTreeSystem(&horizontalAlignmentStringTreeSystem);
	finiStringTreeSystem(&numberTypeStringTreeSystem);
	finiStringTreeSystem(&shortcutStateStringTreeSystem);
	finiStringTreeSystem(&modifierStringTreeSystem);
	finiStringTreeSystem(&commandStringTreeSystem);
	finiStringTreeSystem(&variableStringTreeSystem);
	finiStringTreeSystem(&booleanStringTreeSystem);
	finiStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
	finiStringTreeSystem(&globalInstructionStringTreeSystem);
	finiStringTreeSystem(&globalScopesInstructionStringTreeSystem);
	finiPermissionSystem(&permissionSystem);
	if(memoryManagementSystem.allocated > 1){
		printError("%s%s: %s%s:%s %s", colorStart, programName, colorError, "warning", colorEnd, "program exited with unaccounted for data pointers, namely:\n");
		printUnaccountedForPointers(memoryManagementSystem.data + 1, memoryManagementSystem.data + memoryManagementSystem.allocated);
	}
	finiMemorySystem();
	closeErrorStream();
	exit(EXIT_SUCCESS);
}
PRINTCONFIGERROR(){
	const char *statementCurrent = statementStart;
	const uint itemAmountWall = instructionCurrent - instructionStart;
	uint itemAmount = 0;
	uint spaceAmount = 0;
	StringTreeSystem *const *data;
	if(!openErrorStream()){
		ret;
	}
	flockfile(errorStream);
	fprintf(errorStream, "%s%s: %s: ", colorStart, programName, configPath);
	if(printLine){
		fprintf(errorStream, "line %u: ", statementLine);
	}
	fprintf(errorStream, "%s%s:%s %s", colorError, type, colorEnd, message);
	if(printConfig){
		fprintf(errorStream, ":\n\t config |");
	}else{
		fprintf(errorStream, "\n");
		jmp emergencyExit;
	}
	jmp printStatementItemLoop;
	printStatementItemLoop:{
		if(statementCurrent < statementWall){
			fprintf(errorStream, " %s", statementCurrent);
			jmp pushOutTermLoop;
			pushOutTermLoop:{
				if(*(inc statementCurrent)){
					jmp pushOutTermLoop;
				}
				inc statementCurrent;
			}
			if(itemAmount == itemAmountWall and instructionStart){
				spaceAmount = statementCurrent - statementStart;
			}
			inc itemAmount;
			jmp printStatementItemLoop;
		}
		if(spaceAmount == 0 and finalStatementCharacter != ';'){
			fprintf(errorStream, " ");
		}
		fprintf(errorStream, "%c\n", finalStatementCharacter);
		jmp printPattern;
	}
	printPattern:{
		if(printPointer){
			if(spaceAmount == statementCurrent - statementStart){
				dec spaceAmount;
			}
			fprintf(errorStream, "\t        |%*c^\n", inc spaceAmount, ' ');
		}
		if(!printPattern or !instructionStart){
			fprintf(errorStream, "\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, "\n\tpattern | %s", *(currentScopeInstructionList + (*currentScopeInstructionStringTreeSystem).returnedCounter));
		dec instructionStart;
		data = instructionDataStart;
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoop: switch *(inc instructionStart) over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
		off: /*---------------------------*/ jmp printInstructionParameterLoopExit;
	end
	noneInstruction:{
		fprintf(errorStream, " <unimplemented>");
		jmp printInstructionParameterLoopExit;
	}
	nameInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " name");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " (%s", *stringArray);
			inc stringArray;
			jmp printNameLoop;
			printNameLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
				}
				fprintf(errorStream, ")");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	nameListInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " list");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " ((%s", *stringArray);
			inc stringArray;
			jmp printNameListOnceLoop;
			printNameListOnceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
				}
				stringArray = (**data).stringArray;
				fprintf(errorStream, ")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
				inc stringArray;
				jmp printNameListTwiceLoop;
			}
			printNameListTwiceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListTwiceLoop;
				}
				fprintf(errorStream, "))*(?![\\s]*[|]))");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	numberInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " number");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
		jmp printInstructionParameterLoop;
	}
	stringInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " string");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	imageInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " image");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	printTilde:{
		fprintf(errorStream, " ~");
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoopExit:{
		if(displaySimpleConfigErrors){
			fprintf(errorStream, "\n\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, " $\n\n");
		jmp emergencyExit;
	}
	emergencyExit:{
		funlockfile(errorStream);
		closeErrorStream();
		ret;
	}
}

