
/*!
	multi-server feature:
		make sure everything works properly if the user initiates two or more servers at the same time, including the currently common shared memory location in use.
*/

/*!
	starting directory idea:
		in config, use the directory the config is in as working directory. 
*/

/*!
	window system idea for virtual root-localized panels and desktops:
		add support for creating windows on each of the existing virtual roots. then add functionality for when the amount of virtual roots changes.
*/

/*!
	on the signal handler:
		the signal handler should be made smaller, to exit gracefully on specific parts of the program instead, not from the handler.
*/

/*!
	on the subinstruction redundancy:
		implement pointers to instructions and subinstructions in the config such that less subinstruction data needs be stored to .data and all errors still print properly all instructions and their data.
*/

/*!
	on the better handling of the keyboard:
		mapping notify will be received by any client upon the change on the keyboard insofar as keycode translation is concerned.
*/

/*!
	more on the signal handler:
		fix the hell out of the how and why everything is done the way it is being done.
*/

/*!
	on the thread question:
		learn how to make a thread airtight safe.
*/

/*!
	on the utf8 question:
		make sure you support it on the config, as chars are used presently.
*/

/*!
	better memory segment messages:
		use a counter in the segment or equivalent to signify how deep in the function tree we are or something to know where the crash really happens.
*/

/*!
	better input:
		come up with some standard way to handle the same key combinations to complete different operations. probably not possible on a standard level.
*/

/*!
	multiple executions of the same program issue:
		the shared memory will be accessible only by one program, the one that runs last. an error message should at least be shown on the terminal, or maybe an entire program section should be created to disallow
		copies of the same program.
*/

/*!
	native detection of custom integer types in matchInteger():
		the integer returned could be a struct instead or, since the int64 is a large type not really in use, we could store the type of the number in the upper bits.
		should the user input a value larger than can fit in a int(64-n), we can cut it off somehow. but should we choose that route, the results definitely have something to do with how integers are implemented.
		also, mind the sign.
*/

/*!
	add "none" to "macroList".
*/

/*!
	on the argument parser:
		add the option to start the stdin parser and config parser.
*/

/*!
	event system:
		work on an X event system that takes as input a set of events (bitfield) and checks when those events have happened. the first one should be about whether the current desktop is visible at all or not.
*/

/*!
	create circle feature:
		add antialiasing.
*/

/*!
	escaped characters:
		check again how they work, sending an execute with \"\" around the execute command does not read the escaped characters properly.
*/

/*!
	key and button grabbing in config:
		consider getting and storing all the cookies before waiting for their replies.
*/

/*!
	on the unidimensionality of grabbing of keys and buttons:
		there should be a way to implement grabbing such that the command is executed on each of the three time positions: on request of execution, on press and on release.
*/

/*!
	graceful exit via signal:
		there must be flags or equivalents used instead to notify threads to exit and to notify the program to exit.
*/

/*!
	gesture checking issues:
		it doesn't work. it simply does not.
		the xinput extension is simply not good enough compared to libinput.
			no idea if user is using 3 or 4 fingers, or any fingers for that matter.

		just checking for gestures will return data from whatever device just caused the event to happen. to differentiate between different devices, we should use device events instead.
*/

/*!
	on key and button grabbing:
		allow to choose between on-repeat and once-only execution.
*/

/*!
	key release issue:
		won't work properly with another key press and release between them.
		what if the user picks button-n? what do?
*/

/*!
	shared memory issues:
		create the stat() file such that it is specific to the user and running X server, to achieve multi-user support.
		implement a signal mechanism that notifies the running program that the file needed to stat() doesn't exist and should be created again.
		add thread objects to dynamic memory segment?
*/

/*!
	memory system strictness:
		the system implemented should be updated such that constructs like mutexes and flags are used to prevent the program doing anything that isn't related to storing a pointer to the segment.
*/

/*!
	an annoying feature:
		abstract colors to achieve endian independence.
*/

/*!
	future features:
		use the gpu to make a blur instead.
*/

/*!
	readConfig() features:
		dynamic hell: consider ditching recursion.
		consider a config-specified reaction to the monitor setup updating.
		use a stack to keep track of the scope and use it to go to the previous scope.
		rewrite anything scope-related, including the globals.
		create a post-read-config instruction that executes once per readConfig() completion.
		add "any" modifier to catch all possible combinations of modifiers that include the given modifier.
		add "none" to the start of every name array that makes sense to add it to, perhaps even the macro array for matchInteger(), and get rid the "+ 1" in matchName: at nameReturn.
		use dynamic buffers for the instruction values got from the config and keep counters on each type. do not reset anything after using it, only the counters and sub-buffers.
		add error printing for the image instruction.
		allow everything to be reduced to numbers. the config should be fully working even if the user inputs only integers as names, name lists and everything else excluding strings of all sorts.
		name all value fields so that when the user messes up he gets to know what the value represents (maybe introduce a "debug" config error message mode akin to "expand").
		print all available subinstructions alongside their respective intructions.
		support keysyms.
		implement a standard way for integer types, namely integer, millimeter and percentage.

		update it in general once hell is over, god knows it needs the attention.
*/

/*!
	matchInteger() features:
		consider adding parenetheses support (NOT via recursion)
*/

/*!
	config error printing:
		consider updating and validating all regex
		consider adding "unclosing string" error
		consider adding "unclosing multiline comment" error
		consider updating the opening curly bracket code such that error printing includes available subscopes in current scope
		consider adding support for bar list: which name   was wrong? the 1st? the nth? one in the middle?
		consider adding support for number  : which number was wrong? the 1st? the nth? one in the middle?
		consider updating tabs, as they mess with printing
			keep amount of spaces and tabs to print and their order

		consider proper printing of multi-line config data (add a bar per newline and print the code right of the bar)
			print line per character

		consider having better pointer precision because the user can have some funky string-related errors where the pointer will point to later instruction parameters
		consider utilizing the warning and error colors better, because currently they are the exact same color
		error printing can mess up real bad, like \" will be printed \\
*/

/*!
	eventLoop: feature:
		consider adding extension error printing support
*/

/*!
	consider adding a help instruction for each scope

	concept:
		help a
		help b
		help c

		where a, b, c are scopes. displays all instructions

		help a d
		help b e
		help c f

		where d, e, f are instructions. displays all possible arguments

	extra:
		help a d g
		help b e h
		help c f i

		where g, h, i are arguments. displays what it does/affects
*/

/*!
	other desktop program ideas:
		consider creating a session manager.
		consider creating a clipboard manager.
		consider creating a desktop.
*/

/*!
	implement a struct for rectangle preferences that produces a element:
		struct{
			v   int32 ----- x;
			v   int32 ----- y;
			v   uint32 ---- width;
			v   uint32 ---- height;
			  x uint32 ---- borderSize;
			v   uint8 ----- horizontalAlignment;
			v   uint8 ----- verticalAlignment;
			v   uint32 ---- position;
			v   uint32 ---- cornerRadius;
			v   uint32 ---- cornerUsed;
			v   uint32 ---- margin;
			  x uint32 ---- marginTop;
			  x uint32 ---- marginBottom;
			  x uint32 ---- marginLeft;
			  x uint32 ---- marginRight;
			v   uint32 ---- padding;
			  x uint32 ---- paddingTop;
			  x uint32 ---- paddingBottom;
			  x uint32 ---- paddingLeft;
			  x uint32 ---- paddingRight;
			v   uint32 ---- foreground;
			v   uint32 ---- background;
			  x uint32 ---- border;
			v   uint32 ---- selectedForeground;
			v   uint32 ---- selectedBackground;
			  x uint32 ---- selectedBorder;
		} ElementPreferences;
*/



























/*!includes:{*/
	#include <errno.h>
	#include <grp.h>
	#include <limits.h>
	#include <locale.h>
	#include <poll.h>
	#include <pthread.h>
	#include <pwd.h>
	#include <signal.h>
	#include <stdarg.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#include <unistd.h>
	#include <sys/shm.h>
	#include <sys/stat.h>
	#include <sys/wait.h>
	#include <xcb/randr.h>
	#include <xcb/xfixes.h>
	#include <xcb/xinput.h>
/*!}*/

/*!defines:{*/
	#define DEBUG /*-----------------------------------------*/ (true)

	#define PROGRAM_NAME /*----------------------------------*/ "microgeneric"

	#define MESSAGE_START /*---------------------------------*/ ("\x1b[1m")
	#define MESSAGE_FATAL /*---------------------------------*/ ("\x1b[91m")
	#define MESSAGE_ERROR /*---------------------------------*/ ("\x1b[33m")
	#define MESSAGE_EVENT /*---------------------------------*/ ("\x1b[32m")
	#define MESSAGE_END /*-----------------------------------*/ ("\x1b[m")

	#define NONE_ARGUMENT /*---------------------------------*/ (0)
	#define UNRECOGNIZED_ARGUMENT /*-------------------------*/ (1)
	#define HELP_ARGUMENT /*---------------------------------*/ (2)
	#define STDOUT_ARGUMENT /*-------------------------------*/ (3)
	#define STDERR_ARGUMENT /*-------------------------------*/ (4)
	#define CONFIG_ARGUMENT /*-------------------------------*/ (5)
	#define ERROR_ARGUMENT /*--------------------------------*/ (6)
	#define SERVER_ARGUMENT /*-------------------------------*/ (7)

	#define WHICH_MONITOR_CONTENT(k, v, n, p) /*-------------*/ { \
		  v(none)           k(NONE##p) \
		, v(pointer)        k(POINTER##p) \
		, v(focused-window) k(FOCUSED_WINDOW##p) \
		, v(all)            k(ALL##p) \
		, n(NULL)           k(NULL##p) \
	}

	#define NUMBER_TYPE_CONTENT(k, v, n, p) /*---------------*/ { \
		  v(none)       k(NONE##p) \
		, v(integer)    k(INTEGER##p) \
		, v(percentage) k(PERCENTAGE##p) \
		, v(millimeter) k(MILLIMETER##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define POSITION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(bottom) k(BOTTOM##p) \
		, v(left)   k(LEFT##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define HORIZONTAL_ALIGNMENT_CONTENT(k, v, n, p) /*------*/ { \
		  v(none)   k(NONE##p) \
		, v(left)   k(LEFT##p) \
		, v(center) k(CENTER##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define VERTICAL_ALIGNMENT_CONTENT(k, v, n, p) /*--------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(center) k(CENTER##p) \
		, v(bottom) k(BOTTOM##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define CORNER_CONTENT(k, v, n, p) /*--------------------*/ { \
		  v(none)         k(NONE##p         = (b(0000))) \
		, v(top-left)     k(TOP_LEFT##p     = (b(0001))) \
		, v(top-right)    k(TOP_RIGHT##p    = (b(0010))) \
		, v(bottom-left)  k(BOTTOM_LEFT##p  = (b(0100))) \
		, v(bottom-right) k(BOTTOM_RIGHT##p = (b(1000))) \
		, n(NULL)         k(NULL##p) \
	}

	#define AXIS_CONTENT(k, v, n, p) /*----------------------*/ { \
		  v(none)       k(NONE##p) \
		, v(horizontal) k(HORIZONTAL##p) \
		, v(vertical)   k(VERTICAL##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define _STRING_TREE_NODE_CHILDREN_AMOUNT /*-------------*/ (14)
	#define STRING_TREE_NODE_CHILDREN_AMOUNT /*--------------*/ (_STRING_TREE_NODE_CHILDREN_AMOUNT > 28? 28 : _STRING_TREE_NODE_CHILDREN_AMOUNT)

	#define EMPTY_SHARED_STATUS /*---------------------------*/ (0)
	#define FULL_SHARED_STATUS /*----------------------------*/ (1)

	#define SHORTCUT_CODE_AMOUNT /*--------------------------*/ (256)

	#define SHORTCUT_STATE_CONTENT(k, v, n, p) /*------------*/ { \
		  v(none)    k(NONE##p    = (b(000))) \
		, v(press)   k(PRESS##p   = (b(001))) \
		, v(repeat)  k(REPEAT##p  = (b(010))) \
		, v(release) k(RELEASE##p = (b(100))) \
		, n(NULL)    k(NULL##p) \
	}

	#define NONE_INSTRUCTION_TYPE /*-------------------------*/ (b(000000))
	#define NAME_INSTRUCTION_TYPE /*-------------------------*/ (b(000001))
	#define NAME_LIST_INSTRUCTION_TYPE /*--------------------*/ (b(000010))
	#define NUMBER_INSTRUCTION_TYPE /*-----------------------*/ (b(000100))
	#define STRING_INSTRUCTION_TYPE /*-----------------------*/ (b(001000))
	#define IMAGE_INSTRUCTION_TYPE /*------------------------*/ (b(010000))
	#define END_INSTRUCTION_TYPE /*--------------------------*/ (b(100000))

	#define GLOBAL_SCOPES_INSTRUCTION_CONTENT(k, v, n, p) /*-*/ { \
		  v(scope1) k(SCOPE1##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define GLOBAL_INSTRUCTION_CONTENT(k, v, n, p) /*--------*/ { \
		  v(help)           k(HELP##p) \
		, v(expand)         k(EXPAND##p) \
		, v(contract)       k(CONTRACT##p) \
		, v(read-config)    k(READ_CONFIG##p) \
		, v(use-terminal)   k(USE_TERMINAL##p) \
		, v(use-messenger)  k(USE_MESSENGER##p) \
		, v(set)            k(SET##p) \
		, v(do)             k(DO##p) \
		, v(grab-keycode)   k(GRAB_KEYCODE##p) \
		, v(grab-button)    k(GRAB_BUTTON##p) \
		, v(ungrab-keycode) k(UNGRAB_KEYCODE##p) \
		, v(ungrab-button)  k(UNGRAB_BUTTON##p) \
		, v(stop)           k(STOP##p) \
		, n(NULL)           k(NULL##p) \
	}

	#define SCOPE1_SCOPE_INSTRUCTION_CONTENT(k, v, n, p) /*--*/ { \
		  v(help)     k(HELP##p) \
		, v(expand)   k(EXPAND##p) \
		, v(contract) k(CONTRACT##p) \
		, v(stop)     k(STOP##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define BOOLEAN_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)  k(NONE##p) \
		, v(true)  k(TRUE##p) \
		, v(false) k(FALSE##p) \
		, n(NULL)  k(NULL##p) \
	}

	#define VARIABLE_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none) k(NONE##p) \
		, n(NULL) k(NULL##p) \
	}

	#define COMMAND_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)    k(NONE##p) \
		, v(execute) k(EXECUTE##p) \
		, v(restart) k(RESTART##p) \
		, v(exit)    k(EXIT##p) \
		, n(NULL)    k(NULL##p) \
	}

	#define MODIFIER_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)     k(NONE##p) \
		, v(shift)    k(SHIFT##p) \
		, v(caps)     k(CAPS##p) \
		, v(control)  k(CONTROL##p) \
		, v(mod-1)    k(MOD_1##p) \
		, v(mod-2)    k(MOD_2##p) \
		, v(mod-3)    k(MOD_3##p) \
		, v(mod-4)    k(MOD_4##p) \
		, v(mod-5)    k(MOD_5##p) \
		, v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NAME_LIST /*--------------------------------*/ (0)
	#define SUCCESS_NAME_LIST /*-----------------------------*/ (1)
	#define INVALID_NAME_NAME_LIST /*------------------------*/ (2)
	#define PREMATURE_END_NAME_LIST /*-----------------------*/ (3)

	#define MACRO_CONTENT(k, v, n, p) /*---------------------*/ { \
		  v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NUMBER /*-----------------------------------*/ (0)
	#define VALID_NUMBER_NUMBER /*---------------------------*/ (1)
	#define NON_NUMBER_NUMBER /*-----------------------------*/ (2)
	#define OVERFLOWN_NUMBER_NUMBER /*-----------------------*/ (3)
	#define DIVIDED_BY_ZERO_NUMBER /*------------------------*/ (4)

	#define NONE_MATCH_IMAGE /*------------------------------*/ (0)
	#define CANNOT_OPEN_MATCH_IMAGE /*-----------------------*/ (1)
	#define CANNOT_READ_MATCH_IMAGE /*-----------------------*/ (2)
	#define UNSUPPORTED_FORMAT_MATCH_IMAGE /*----------------*/ (3)
	#define BAD_HEADER_MATCH_IMAGE /*------------------------*/ (4)
	#define BAD_DEPTH_MATCH_IMAGE /*-------------------------*/ (5)
	#define BAD_COMPRESSION_MATCH_IMAGE /*-------------------*/ (6)
	#define UNSUPPORTED_HEIGHT_MATCH_IMAGE /*----------------*/ (7)
	#define BAD_SIZE_MATCH_IMAGE /*--------------------------*/ (8)
	#define FAILED_MATCH_IMAGE /*----------------------------*/ (9)
	#define BAD_PIXELS_MATCH_IMAGE /*------------------------*/ (10)
	#define BAD_IMAGE_MATCH_IMAGE /*-------------------------*/ (11)
	#define SUCCESS_MATCH_IMAGE /*---------------------------*/ (12)

	#define NONE_MATCH_COMMAND_ORIGIN /*---------------------*/ (0)
	#define PRESS_MATCH_COMMAND_ORIGIN /*--------------------*/ (1)
	#define RELEASE_MATCH_COMMAND_ORIGIN /*------------------*/ (2)
	#define CONFIG_MATCH_COMMAND_ORIGIN /*-------------------*/ (3)
	#define STDIN_MATCH_COMMAND_ORIGIN /*--------------------*/ (4)
	#define TRANSMITTER_MATCH_COMMAND_ORIGIN /*--------------*/ (5)

	#define NONE_MATCH_COMMAND_TYPE /*-----------------------*/ (0)
	#define TYPICAL_MATCH_COMMAND_TYPE /*--------------------*/ (1)
	#define RESTART_MATCH_COMMAND_TYPE /*--------------------*/ (2)
	#define EXIT_MATCH_COMMAND_TYPE /*-----------------------*/ (3)

	#define ROTATION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)        k(NONE##p) \
		, v(degrees-90)  k(DEGREES_90##p)  \
		, v(degrees-180) k(DEGREES_180##p) \
		, v(degrees-270) k(DEGREES_270##p) \
		, n(NULL)        k(NULL##p) \
	}

	#define QUIT() /*----------------------------------------*/ local void               quit(int signal)
	#define REAPSPAWNEDPROCESSES() /*------------------------*/ local void               reapSpawnedProcesses(const int signal)

	#define INITMEMORYSYSTEM() /*----------------------------*/ local bool               initMemorySystem(void)
	#define PUSHPOINTER() /*---------------------------------*/ local uint32            _pushPointer(const char *const file, const int line, void *const pointer, const char *const label, int (*const freeFunction)(void *))
	#define POPPOINTER() /*----------------------------------*/ local bool               popPointer(const uint32 token)
	#define UPDATEPOINTER() /*-------------------------------*/ local bool               updatePointer(const uint32 token, void *const pointer)
	#define IFREE() /*---------------------------------------*/ local int                iFree(void *const pointer)
	#define IXCBDISCONNECT() /*------------------------------*/ local int                iXCBDisconnect(void *const pointer)
	#define ISHMCTL() /*-------------------------------------*/ local int                ishmctl(void *const pointer)
	#define FINIMEMORYSYSTEM() /*----------------------------*/ local bool               finiMemorySystem(void)

	#define INITPERMISSIONSYSTEM() /*------------------------*/ local bool               initPermissionSystem(PermissionSystem *const permissionSystem)
	#define SETPERMISSIONS() /*------------------------------*/ local bool               setPermissions(PermissionSystem *const permissionSystem)
	#define LOWERPERMISSIONS() /*----------------------------*/ local bool               lowerPermissions(PermissionSystem *const permissionSystem)
	#define RAISEPERMISSIONS() /*----------------------------*/ local bool               raisePermissions(PermissionSystem *const permissionSystem)
	#define DROPPERMISSIONS() /*-----------------------------*/ local bool               dropPermissions(PermissionSystem *const permissionSystem)
	#define FINIPERMISSIONSYSTEM() /*------------------------*/ local bool               finiPermissionSystem(PermissionSystem *const permissionSystem)

	#define INSENSITIVESTRINGCOMPARE() /*--------------------*/ local bool               insensitiveStringCompare(const char *s0, const char *s1)
	#define SENSITIVESTRINGCOMPARE() /*----------------------*/ local bool               sensitiveStringCompare(const char *s0, const char *s1)

	#define INITMONITORSYSTEM() /*---------------------------*/ local bool               initMonitorSystem(MonitorSystem *const monitorSystem)
	#define CREATEMONITORS() /*------------------------------*/ local bool               createMonitors(MonitorSystem *const monitorSystem)
	#define GETWHICHMONITOR() /*-----------------------------*/ local Monitor *          getWhichMonitor(MonitorSystem *const monitorSystem, const uint8 whichMonitor)
	#define DESTROYMONITORS() /*-----------------------------*/ local bool               destroyMonitors(MonitorSystem *const monitorSystem)
	#define FINDPOINTERMONITOR() /*--------------------------*/ local Monitor *          findPointerMonitor(MonitorSystem *const monitorSystem)
	#define FINDRECTANGLEMONITOR() /*------------------------*/ local Monitor *          findRectangleMonitor(MonitorSystem *const monitorSystem, const int x, const int y, const int width, const int height)
	#define FINDWINDOWMONITOR() /*---------------------------*/ local Monitor *          findWindowMonitor(MonitorSystem *const monitorSystem, const xcb_window_t window)
	#define FINIMONITORSYSTEM() /*---------------------------*/ local bool               finiMonitorSystem(MonitorSystem *const monitorSystem)

	#define SETELEMENTPREFERENCES() /*-----------------------*/ local bool               setElementPreferences(ElementPreferences *const elementPreferences)

	#define INITWINDOWSYSTEM() /*----------------------------*/ local bool               initWindowSystem(WindowSystem *const windowSystem)
	#define CREATEWINDOWCIRCLEPIXMAP() /*--------------------*/ local bool               createWindowCirclePixmap(WindowSystem *const windowSystem, const uint radius, const uint32 foreground, const uint32 background)
	#define CREATEWINDOWS() /*-------------------------------*/ local bool               createWindows(WindowSystem *const windowSystem, const uint amount, const bool overrideRedirect, const uint32 eventMask)
	#define MAPWINDOWS() /*----------------------------------*/ local bool               mapWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences, const uint8 whichMonitor)
	#define CONFIGUREWINDOWS() /*----------------------------*/ local bool               configureWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences, const uint8 whichMonitor)
	#define DRAWWINDOWS() /*---------------------------------*/ local bool               drawWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences)
	#define SETWINDOWPROPERTIES() /*-------------------------*/ local bool               setWindowProperties(WindowInfo *const windowInfo, const ElementPreferences *const windowPreferences, const int x, const int y, const uint width, const uint height)
	#define DRAWWINDOW() /*----------------------------------*/ local bool               drawWindow(WindowSystem *const windowSystem, const WindowInfo *const windowInfo, const ElementPreferences *const windowPreferences, Monitor *const monitor, ElementRectangle *windowRectangle)
	#define UNMAPWINDOWS() /*--------------------------------*/ local bool               unmapWindows(WindowSystem *const windowSystem)
	#define DESTROYWINDOWS() /*------------------------------*/ local bool               destroyWindows(WindowSystem *const windowSystem)
	#define GETRECTANGLE() /*--------------------------------*/ local bool               getRectangle(Monitor *const _monitor, const ElementRectangle *const parentRectangle, const ElementPreferences *const preferences, ElementRectangle *const rectangle)
	#define GETTYPEDNUMBER() /*------------------------------*/ local int                getTypedNumber(const int number, const uint8 type, const uint8 axis, const int size, Monitor *const monitor)
	#define FINDWINDOW() /*----------------------------------*/ local bool               findWindow(WindowSystem *const windowSystem, const xcb_window_t window)
	#define FINIWINDOWSYSTEM() /*----------------------------*/ local bool               finiWindowSystem(WindowSystem *const windowSystem)

	#define INITSTRINGTREESYSTEM() /*------------------------*/ local bool               initStringTreeSystem(StringTreeSystem *const stringTreeSystem)
	#define BULKINSERTSTRING() /*----------------------------*/ local bool               bulkInsertString(StringTreeSystem *const stringTreeSystem, const char *const *const stringArray)
	#define INSERTSTRING() /*--------------------------------*/ local bool               insertString(StringTreeSystem *const stringTreeSystem, const char *string)
	#define GETSTRINGTREENODE() /*---------------------------*/ local StringTreeNode *   getStringTreeNode(StringTreeSystem *const stringTreeSystem, const char **const stringReturn)
	#define FINDSTRINGTREESTRING() /*------------------------*/ local bool               findStringTreeString(StringTreeSystem *const stringTreeSystem, char *const *const string)
	#define FINISTRINGTREESYSTEM() /*------------------------*/ local bool               finiStringTreeSystem(StringTreeSystem *const stringTreeSystem)

	#define INITSTDINSYSTEM() /*-----------------------------*/ local bool               initSTDINSystem(STDINSystem *const stdinSystem)
	#define CONNECTSTDIN() /*--------------------------------*/ local bool               connectSTDIN(STDINSystem *const stdinSystem)
	#define STDINMAIN() /*-----------------------------------*/ local void *             stdinMain(void *const arg)
	#define GETNEXTSTDINCHARACTER() /*-----------------------*/ local int                getNextSTDINCharacter(void *const arg)
	#define GETPREVIOUSSTDINCHARACTER() /*-------------------*/ local int                getPreviousSTDINCharacter(void *const arg)
	#define DISCONNECTSTDIN() /*-----------------------------*/ local bool               disconnectSTDIN(STDINSystem *const stdinSystem)
	#define FINISTDINSYSTEM() /*-----------------------------*/ local bool               finiSTDINSystem(STDINSystem *const stdinSystem)

	#define INITSHAREDMEMORYSYSTEM() /*----------------------*/ local bool               initSharedMemorySystem(SharedMemorySystem *const sharedMemorySystem)
	#define CONNECTSHAREDMEMORY() /*-------------------------*/ local bool               connectSharedMemory(SharedMemorySystem *const sharedMemorySystem)
	#define SHAREDMEMORYMAIN() /*----------------------------*/ local void *             sharedMemoryMain(void *const arg)
	#define GETNEXTSHAREDMEMORYCHARACTER() /*----------------*/ local int                getNextSharedMemoryCharacter(void *const arg)
	#define GETPREVIOUSSHAREDMEMORYCHARACTER() /*------------*/ local int                getPreviousSharedMemoryCharacter(void *const arg)
	#define DISCONNECTSHAREDMEMORY() /*----------------------*/ local bool               disconnectSharedMemory(SharedMemorySystem *const sharedMemorySystem)
	#define FINISHAREDMEMORYSYSTEM() /*----------------------*/ local bool               finiSharedMemorySystem(SharedMemorySystem *const sharedMemorySystem)

	#define INITSHORTCUTSYSTEM() /*--------------------------*/ local bool               initShortcutSystem(ShortcutSystem *const shortcutSystem)
	#define INSERTSHORTCUT() /*------------------------------*/ local bool               insertShortcut(ShortcutSystem *const shortcutSystem, const uint8 code, const uint16 modifier, const uint8 onState, const Command command, char *const string, const uint32 stringToken, const int32 field0, const int32 field1, const int32 field2, const int32 field3, const int32 field4)
	#define GETNEXTSHORTCUT() /*-----------------------------*/ local bool               getNextShortcut(ShortcutSystem *const shortcutSystem, const bool isRelease, uint8 code, uint16 modifier, int *const nextOffset)
	#define REMOVESHORTCUT() /*------------------------------*/ local bool               removeShortcut(ShortcutSystem *const shortcutSystem, const uint8 code, const uint16 modifier)
	#define FINISHORTCUTSYSTEM() /*--------------------------*/ local bool               finiShortcutSystem(ShortcutSystem *const shortcutSystem)

	#define SETCONFIGVARIABLES() /*--------------------------*/ local void               setConfigVariables(void)
	#define READCONFIG() /*----------------------------------*/ local void               readConfig(const bool createConfigFile, const char *const configPath, int (*getNextConfigChar)(void *const arg), int (*getPreviousConfigChar)(void *const arg))
	#define IFGETC() /*--------------------------------------*/ local int                ifgetc(void *const system)
	#define MATCHNAMELIST() /*-------------------------------*/ local uint8              matchNameList(StringTreeSystem *const stringTreeSystem, const char *const statementWall, char **statementCurrentReturn, uint8 *const valueReturn)
	#define MATCHINTEGER() /*--------------------------------*/ local uint8              matchInteger(char **statementCurrent, const char *const statementWall, int64 *const returnValue)
	#define MATCHSTRING() /*---------------------------------*/ local bool               matchString(char **statementCurrent, char **stringReturn, uint32 *stringToken)
	#define MATCHIMAGE() /*----------------------------------*/ local uint8              matchImage(const char *const path, const char **errorMessage, Image *const image)
	#define MATCHCOMMAND() /*--------------------------------*/ local uint8              matchCommand(const Command command, const char *const execute, const uint8 origin, const int32 field0, const int32 field1, const int32 field2, const int32 field3, const int32 field4)
	#define UNGRABSHORTCUTS() /*-----------------------------*/ local bool               ungrabShortcuts(void)
	#define FREECONFIGVARIABLES() /*-------------------------*/ local void               freeConfigVariables(void)

	#define FINDSTRINGLENGTH() /*----------------------------*/ local uint               findStringLength(const void *string)
	#define FINDSUBSTRING() /*-------------------------------*/ local char *             findSubstring(const char *const string, const uint stringLength, const char *const substring, const uint substringLength)
	#define GETINTERSECTION() /*-----------------------------*/ local void               getIntersection(const int x0, const int y0, const int width0, const int height0, const int x1, const int y1, const int width1, const int height1, int *const xReturn, int *const yReturn, int *const widthReturn, int *const heightReturn)
	#define LOADFILE() /*------------------------------------*/ local bool               loadFile(const char *const path, LoadedFile *const loadedFileReturn)
	#define SPAWNPROCESS() /*--------------------------------*/ local void               spawnProcess(const void *const string)

	#define CREATECIRCLE() /*--------------------------------*/ local bool               createCircle(const int radius, const uint32 foreground, const uint32 background, Image *image)
	#define COMPOSITEIMAGES() /*-----------------------------*/ local void               compositeImages(void (*operation)(const uint32 *const, uint32 *const), const int sourceX, const int sourceY, Image *const source, int destinationX, int destinationY, Image *const destination)
	#define COMPOSITEIMAGESOVER() /*-------------------------*/ local void               compositeImagesOver(const uint32 *const source, uint32 *const destination)
	#define COMPOSITEIMAGESAND() /*--------------------------*/ local void               compositeImagesAnd(const uint32 *const source, uint32 *const destination)
	#define TWOPASSBOXBLUR() /*------------------------------*/ local void               twoPassBoxBlur(const int width, const int height, const int boxSize, uint32 *destinationData)
	#define ROTATEIMAGE() /*---------------------------------*/ local bool               rotateImage(const uint8 rotation, Image *const image, const bool deletePreviousData)

	#define GETFOCUSEDWINDOW() /*----------------------------*/ local xcb_window_t       getFocusedWindow(void)
	#define GRABDEVICE() /*----------------------------------*/ local bool               grabDevice(const uint8 device, const uint attemptAmount)
	#define UNGRABDEVICE() /*--------------------------------*/ local bool               ungrabDevice(const uint8 device)
	#define TIGHTENCLIPPINGRECTANGLE() /*--------------------*/ local bool               tightenClippingRectangle(const xcb_gcontext_t gc, const int x, const int y, const int width, const int height, int *const clipXReturn, int *const clipYReturn, int *const clipWidthReturn, int *const clipHeightReturn)

	#define RESTART() /*-------------------------------------*/ local void               restart(const bool isInsideConfig)
	#define CLEANUP() /*-------------------------------------*/ local void               cleanup(void)
	#define CANCELTHREADS() /*-------------------------------*/ local void               cancelThreads(void)

	#define PRINTUNACCOUNTEDFORPOINTERS() /*-----------------*/ local void               printUnaccountedForPointers(const Pointer *current, const Pointer *wall)
	#define PRINTERROR() /*----------------------------------*/ local void               printError(const char *const message, ...)
	#define PRINTTITLEDERROR() /*----------------------------*/ local void               printTitledError(const char *const title, const char *const message)
	#define PRINTTITLEDQUOTEDERROR() /*----------------------*/ local void               printTitledQuotedError(const char *const title, const char *const argument, const char *const message)
	#define PRINTCONNECTIONERROR() /*------------------------*/ local void               printConnectionError(void)
	#define PRINTTITLEDNAMEDERROR() /*-----------------------*/ local void               printTitledNamedError(const char *const title, const char *const message, const char *const name)
	#define PRINTXERROR() /*---------------------------------*/ local void               printXError(const char *const *const name)
	#define PRINTTITLEDVALUEDERROR() /*----------------------*/ local void               printTitledValuedError(const char *const title, const char *const message, const uint value)
	#define PRINTCONFIGERROR() /*----------------------------*/ local void               printConfigError(const char *const type, const char *const message, const char finalStatementCharacter, const bool printLine, const bool printConfig, const bool printPointer, const bool printPattern, const char *const configPath, const uint statementLine, const char *const statementStart, const char *const statementWall, const Instruction *instructionStart, const Instruction *instructionCurrent, StringTreeSystem *const *const instructionDataStart, const char *const *currentScopeInstructionList, const StringTreeSystem *const currentScopeInstructionStringTreeSystem)

	#define xcb_wait_for_reply(a, b, c) /*-------------------*/ (xcb_wait_for_reply(a, (b).sequence, c))
	#define xcb_discard_reply(a, b) /*-----------------------*/ (xcb_discard_reply(a, (b).sequence))
	#define xcb_send_event(a, b, c, d, e) /*-----------------*/ (xcb_send_event(a, b, c, d, (void *)(e)))
	#define xcb_send_event_checked(a, b, c, d, e) /*---------*/ (xcb_send_event_checked(a, b, c, d, (void *)(e)))

	#define EMPTY(void) /*-----------------------------------*/ EMPTY_MACRO
	#define SELF(self) /*------------------------------------*/ self
	#define STRINGIFY(identifier) /*-------------------------*/ #identifier
	#define ENUM_CONTENT(content) /*-------------------------*/ content##_CONTENT(SELF, EMPTY, EMPTY, _##content) content##_ENUM
	#define STRING_CONTENT(content) /*-----------------------*/ content##_CONTENT(EMPTY, STRINGIFY, SELF, _##content)

	#define pushPointer(a, b, c) /*--------------------------*/ (_pushPointer(__FILE__, __LINE__, a, b, (int (*const)(void *))(c)))

	#if DEBUG
		#define useEventBase(n0, n1) /*-*/ n0 == n1##EventName? n1##BaseEvent
		#define useEventName(n0, n1) /*-*/ n0 == n1##EventName? "X " #n1 " event"
		#define printXEvent(n) /*-------*/ { \
			uint base = ((*event).response_type & ~b(10000000)) - ( \
			      n == baseEventName? 0 \
				: useEventBase(n, randr) \
				: useEventBase(n, xfixes) \
				: useEventBase(n, xinput) \
				: ((*event).response_type & ~b(10000000)) - countof(baseEventName) + 1 \
			); \
			fprintf(DEFAULT_OUTPUT_STREAM, "%s%s: %s%s:%s %s\n", colorStart, programName, colorEvent \
				, n == baseEventName? "X event" \
				: useEventName(n, randr) \
				: useEventName(n, xfixes) \
				: useEventName(n, xinput) \
				: "X unrecognized extension event" \
				, colorEnd \
				, n != baseEventName and n != randrEventName and n != xfixesEventName and n != xinputEventName? "unhandled extension event" \
				: *(n + (base >= countof(n)? countof(n) - 1 : base)) \
			); \
		}
		#define printCommand(s, c) /*---*/ (fprintf(DEFAULT_OUTPUT_STREAM, "%s%s: %s" s " command:%s %s\n", colorStart, programName, colorEvent, colorEnd, *(commandList + (c >= countof(commandList)? countof(commandList) - 1 : c))))
	#else
		#define printXEvent(n) /*-------*/ EMPTY_MACRO
		#define printCommand(s, c) /*---*/ EMPTY_MACRO
	#endif
/*!}*/

/*!defs:{*/
	def enum ENUM_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	def enum ENUM_CONTENT(GLOBAL_INSTRUCTION);
	def enum ENUM_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	def enum ENUM_CONTENT(BOOLEAN);
	def enum ENUM_CONTENT(VARIABLE);
	def enum ENUM_CONTENT(COMMAND);
	def enum ENUM_CONTENT(MODIFIER);
	def enum ENUM_CONTENT(SHORTCUT_STATE);
	def enum ENUM_CONTENT(NUMBER_TYPE);
	def enum ENUM_CONTENT(POSITION);
	def enum ENUM_CONTENT(HORIZONTAL_ALIGNMENT);
	def enum ENUM_CONTENT(VERTICAL_ALIGNMENT);
	def enum ENUM_CONTENT(CORNER);
	def enum ENUM_CONTENT(AXIS);
	def enum ENUM_CONTENT(WHICH_MONITOR);
	def enum ENUM_CONTENT(ROTATION);
	def enum ENUM_CONTENT(MACRO);

	def uint8 /*-*/ Command;
	def uint8 /*-*/ Instruction;
	def uint8 /*-*/ JmpPoint;

	def struct{
		const char * /*--------*/ label;
		uint64 * /*------------*/ data;
		uint32 /*--------------*/ token;
		uint32 /*--------------*/ line;
		const char * /*--------*/ file;
		int /*-----------------*/ (*free)(void *);
	} Pointer;

	def struct{
		uint32 /*--------------*/ size;
		uint32 /*--------------*/ allocated;
		Pointer * /*-----------*/ data;
		uint8 /*---------------*/ pad0[7];
		bool /*----------------*/ mutexCreated;
		pthread_mutex_t /*-----*/ mutex;
	} MemoryManagementSystem;

	def struct{
		uid_t /*---------------*/ normalUID;
		gid_t /*---------------*/ normalGID;
	} PermissionSystem;

	def struct{
		xcb_atom_t /*----------*/ MICRO_INIT;
		xcb_atom_t /*----------*/ MANAGER;
	} CommonAtoms;

	def struct{
		xcb_atom_t /*----------*/ name;
		int32 /*---------------*/ leftX;
		int32 /*---------------*/ rightX;
		int32 /*---------------*/ topY;
		int32 /*---------------*/ bottomY;
		int32 /*---------------*/ width;
		int32 /*---------------*/ height;
		uint32 /*--------------*/ millimeterWidth;
		uint32 /*--------------*/ millimeterHeight;
	} Monitor;

	def struct{
		Monitor * /*-----------*/ start;
		uint32 /*--------------*/ token;
		uint32 /*--------------*/ size;
	} MonitorSystem;

	def struct{
		bool /*----------------*/ (*risingOperation)(void *const arg);
		void * /*--------------*/ risingOperationArgument;
		bool /*----------------*/ (*fallingOperation)(void *const arg);
		void * /*--------------*/ fallingOperationArgument;
		uint32 /*--------------*/ seconds;
		uint32 /*--------------*/ nanoseconds;
		bool /*----------------*/ loopOperation;
		bool /*----------------*/ restartTimer;
		uint8 /*---------------*/ pad0[1];
		bool /*----------------*/ running;
		bool /*----------------*/ quittingThread;
		bool /*----------------*/ mutexCreated;
		bool /*----------------*/ condCreated;
		bool /*----------------*/ threadCreated;
		pthread_mutex_t /*-----*/ mutex;
		pthread_cond_t /*------*/ cond;
		pthread_t /*-----------*/ thread;
	} SleepThreadSystem;

	def struct{
		uint8 /*---------------*/ letter;
		uint8 /*---------------*/ childrenAmount;
		uint16 /*--------------*/ offset[STRING_TREE_NODE_CHILDREN_AMOUNT];
	} StringTreeNode;

	def struct{
		const char *const * /*-*/ stringArray;
		uint32 /*--------------*/ dataSize;
		uint32 /*--------------*/ dataAllocated;
		StringTreeNode * /*----*/ dataStart;
		uint32 /*--------------*/ dataToken;
		uint8 /*---------------*/ counter;
		uint8 /*---------------*/ returnedCounter;
		uint8 /*---------------*/ pad0[2];
	} StringTreeSystem;

	def struct{
		uint32 /*--------------*/ size;
		uint32 /*--------------*/ allocated;
		char * /*--------------*/ start;
		char * /*--------------*/ current;
		uint32 /*--------------*/ token;
		uint8 /*---------------*/ pad0[1];
		bool /*----------------*/ threadCreated;
		bool /*----------------*/ operating;
		bool /*----------------*/ quittingThread;
		pthread_t /*-----------*/ thread;
	} STDINSystem;

	def struct{
		int32 /*---------------*/ shmID;
		uint32 /*--------------*/ shmToken;
		uint8 * /*-------------*/ start;
		uint8 * /*-------------*/ current;
		uint32 /*--------------*/ token;
		uint8 /*---------------*/ pad0[6];
		bool /*----------------*/ mutexCreated;
		bool /*----------------*/ condCreated;
		bool /*----------------*/ threadCreated;
		bool /*----------------*/ operating;
		bool /*----------------*/ quittingFromInside;
		bool /*----------------*/ quittingThread;
		pthread_mutex_t * /*---*/ mutex;
		pthread_cond_t * /*----*/ cond;
		pthread_t /*-----------*/ thread;
	} SharedMemorySystem;

	def struct{
		bool /*----------------*/ inUse;
		Command /*-------------*/ command;
		uint16 /*--------------*/ modifier;
		int32 /*---------------*/ nextOffset;
		char * /*--------------*/ string;
		uint32 /*--------------*/ stringToken;
		int32 /*---------------*/ field0;
		int32 /*---------------*/ field1;
		int32 /*---------------*/ field2;
		int32 /*---------------*/ field3;
		int32 /*---------------*/ field4;
		uint8 /*---------------*/ onState;
		bool /*----------------*/ hasBeenPressed;
		uint8 /*---------------*/ pad0[6];
	} ModifierNode;

	def struct{
		ModifierNode * /*------*/ modifierStart;
		uint32 /*--------------*/ modifierToken;
		uint32 /*--------------*/ modifierSize;
		uint32 /*--------------*/ modifierAllocated;
		uint32 /*--------------*/ modifierNotInUseOffset;
		uint32 /*--------------*/ codeListStart[SHORTCUT_CODE_AMOUNT];
		uint32 /*--------------*/ codeListWall[SHORTCUT_CODE_AMOUNT];
	} ShortcutSystem;

	def struct{
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		int32 /*---------------*/ width;
		int32 /*---------------*/ height;
		void * /*--------------*/ dataStart;
		uint32 /*--------------*/ dataToken;
		uint32 /*--------------*/ dataSize;
	} Image;

	def struct{
		char * /*--------------*/ dataStart;
		uint32 /*--------------*/ dataToken;
		uint32 /*--------------*/ dataSize;
	} LoadedFile;
/*!}*/

/*!globals:{*/
	local const char * /*-------------------*/ programName;
	local const char * /*-------------------*/ errorPath;
	local const char * /*-------------------*/ colorStart;
	local const char * /*-------------------*/ colorFatal;
	local const char * /*-------------------*/ colorError;
	local const char * /*-------------------*/ colorEvent;
	local const char * /*-------------------*/ colorEnd;
	local const char * /*-------------------*/ labelExamined;
	local const char * /*-------------------*/ connectionName;
	local const char * /*-------------------*/ configPath;
	local const char * /*-------------------*/ localeName;
	local const ModifierNode * /*-----------*/ eventModifierNode;
	local bool /*---------------------------*/ mustOpenErrorStream;
	local FILE * /*-------------------------*/ errorStream;
	local uint32 /*-------------------------*/ errorStreamToken;
	local volatile bool /*------------------*/ processingSignal;
	local bool /*---------------------------*/ quitting;
	local MemoryManagementSystem /*------------*/ memoryManagementSystem;
	local PermissionSystem /*---------------*/ permissionSystem;
	local bool /*---------------------------*/ globalsLockCreated;
	local pthread_rwlock_t /*---------------*/ globalsLock;
	local int /*----------------------------*/ screenNumber;
	local xcb_connection_t * /*-------------*/ connection;
	local uint32 /*-------------------------*/ connectionToken;
	local xcb_screen_t * /*-----------------*/ screen;
	local uint /*---------------------------*/ screenWidthInPixels;
	local uint /*---------------------------*/ screenHeightInPixels;
	local uint /*---------------------------*/ screenWidthInMillimeters;
	local uint /*---------------------------*/ screenHeightInMillimeters;
	local uint8 /*--------------------------*/ randrMajorOpcode;
	local uint8 /*--------------------------*/ randrBaseEvent;
	local uint8 /*--------------------------*/ randrBaseError;
	local uint8 /*--------------------------*/ xfixesMajorOpcode;
	local uint8 /*--------------------------*/ xfixesBaseEvent;
	local uint8 /*--------------------------*/ xfixesBaseError;
	local uint8 /*--------------------------*/ xinputMajorOpcode;
	local uint8 /*--------------------------*/ xinputBaseEvent;
	local uint8 /*--------------------------*/ xinputBaseError;
	local CommonAtoms /*--------------------*/ atom;
	local xcb_visualid_t /*-----------------*/ visual;
	local uint8 /*--------------------------*/ depth;
	local xcb_colormap_t /*-----------------*/ colormap;
	local MonitorSystem /*------------------*/ monitorSystem;
	local ElementPreferences /*-------------*/ windowPreferences;
	local uint8 /*--------------------------*/ whichMonitor;
	local WindowSystem /*-------------------*/ windowSystem;
	local SleepThreadSystem /*--------------*/ sleepThreadSystem;
	local StringTreeSystem /*---------------*/ globalScopesInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ globalInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ scope1ScopeInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ booleanStringTreeSystem;
	local StringTreeSystem /*---------------*/ variableStringTreeSystem;
	local StringTreeSystem /*---------------*/ commandStringTreeSystem;
	local StringTreeSystem /*---------------*/ modifierStringTreeSystem;
	local StringTreeSystem /*---------------*/ shortcutStateStringTreeSystem;
	local StringTreeSystem /*---------------*/ numberTypeStringTreeSystem;
	local StringTreeSystem /*---------------*/ horizontalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ verticalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ cornerStringTreeSystem;
	local StringTreeSystem /*---------------*/ whichMonitorStringTreeSystem;
	local StringTreeSystem /*---------------*/ macroStringTreeSystem;
	local bool /*---------------------------*/ displaySimpleConfigErrors;
	local STDINSystem /*--------------------*/ stdinSystem;
	local SharedMemorySystem /*-------------*/ sharedMemorySystem;
	local ShortcutSystem /*-----------------*/ keycodeShortcutSystem;
	local ShortcutSystem /*-----------------*/ buttonShortcutSystem;
	local xcb_generic_event_t * /*----------*/ event;
	local uint32 /*-------------------------*/ eventToken;
	local int /*----------------------------*/ keyPressNextOffset;
	local int /*----------------------------*/ keyReleaseNextOffset;
	local int /*----------------------------*/ buttonPressNextOffset;
	local int /*----------------------------*/ buttonReleaseNextOffset;
	local uint8 /*--------------------------*/ shortcutCode;
	local uint16 /*-------------------------*/ shortcutModifier;
	local bool /*---------------------------*/ expectingSecondKeyRelease;
	local uint8 /*--------------------------*/ realKeyReleaseModifier;

	local const char *const /*--------------*/ globalScopesInstructionList[] = STRING_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	local const char *const /*--------------*/ globalInstructionList[] = STRING_CONTENT(GLOBAL_INSTRUCTION);
	local const char *const /*--------------*/ scope1ScopeInstructionList[] = STRING_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	local const char *const /*--------------*/ booleanList[] = STRING_CONTENT(BOOLEAN);
	local const char *const /*--------------*/ variableList[] = STRING_CONTENT(VARIABLE);
	local const char *const /*--------------*/ commandList[] = STRING_CONTENT(COMMAND);
	local const char *const /*--------------*/ modifierList[] = STRING_CONTENT(MODIFIER);
	local const char *const /*--------------*/ shortcutStateList[] = STRING_CONTENT(SHORTCUT_STATE);
	local const char *const /*--------------*/ numberTypeList[] = STRING_CONTENT(NUMBER_TYPE);
	local const char *const /*--------------*/ horizontalAlignmentList[] = STRING_CONTENT(HORIZONTAL_ALIGNMENT);
	local const char *const /*--------------*/ verticalAlignmentList[] = STRING_CONTENT(VERTICAL_ALIGNMENT);
	local const char *const /*--------------*/ cornerList[] = STRING_CONTENT(CORNER);
	local const char *const /*--------------*/ whichMonitorList[] = STRING_CONTENT(WHICH_MONITOR);
	local const char *const /*--------------*/ macroList[] = STRING_CONTENT(MACRO);

	local const Instruction /*--------------*/ helpInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ expandInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ contractInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ readConfigInstruction[] = {STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useTerminalInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useMessengerInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ setInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ doInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ stopInstruction[] = {END_INSTRUCTION_TYPE};

	local const Instruction /*--------------*/ executeDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};

	local StringTreeSystem *const *const /*-*/ helpInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ expandInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ contractInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ readConfigInstructionData = NULL;
	local StringTreeSystem *const /*--------*/ useTerminalInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ useMessengerInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ setInstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ doInstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabKeycodeInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabButtonInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabKeycodeInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabButtonInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const *const /*-*/ stopInstructionData = NULL;

	local StringTreeSystem *const /*--------*/ executeDoSubinstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};

	#define getInstruction(i) /*-----*/ (i##Instruction)
	#define getInstructionData(i) /*-*/ (i##InstructionData)
	#define getGlobalScope(i) /*-----*/ { \
		  get##i(help) \
		, get##i(expand) \
		, get##i(contract) \
		, get##i(readConfig) \
		, get##i(useTerminal) \
		, get##i(useMessenger) \
		, get##i(set) \
		, get##i(do) \
		, get##i(grabKeycode) \
		, get##i(grabButton) \
		, get##i(ungrabKeycode) \
		, get##i(ungrabButton) \
		, get##i(stop) \
	}
	#define getScope1Scope(i) /*-----*/ { \
		  get##i(help) \
		, get##i(expand) \
		, get##i(contract) \
		, get##i(stop) \
	}
	local const Instruction *const /*-------*/ globalScopeInstruction[] = getGlobalScope(Instruction);
	local const Instruction *const /*-------*/ scope1ScopeInstruction[] = getScope1Scope(Instruction);

	local StringTreeSystem *const *const /*-*/ globalScopeInstructionData[] = getGlobalScope(InstructionData);
	local StringTreeSystem *const *const /*-*/ scope1ScopeInstructionData[] = getScope1Scope(InstructionData);
	#undef  getScope1Scope
	#undef  getGlobalScope
	#undef  getInstructionData
	#undef  getInstruction
/*!}*/

int main(int argumentAmount, const char *const *argument){
	jmp setSignalHandler;
	setSignalHandler:{



		struct sigaction s;
		processingSignal = true;
		s.sa_handler = quit;
		s.sa_flags = 0;
		sigemptyset(&s.sa_mask);
		sigaction(SIGABRT, &s, NULL);
		sigaction(SIGBUS,  &s, NULL);
		sigaction(SIGFPE,  &s, NULL);
		sigaction(SIGILL,  &s, NULL);
		sigaction(SIGINT,  &s, NULL);
		sigaction(SIGQUIT, &s, NULL);
		sigaction(SIGSEGV, &s, NULL);
		sigaction(SIGTERM, &s, NULL);
		sigaction(SIGTRAP, &s, NULL);
		sigaction(SIGUSR1, &s, NULL);
		sigaction(SIGUSR2, &s, NULL);
		s.sa_handler = reapSpawnedProcesses;
		s.sa_flags = SA_NOCLDSTOP;
		sigaction(SIGCHLD, &s, NULL);



		jmp setGlobals;
	}
	setGlobals:{
		programName /*---------------*/ = *argument;
		errorPath /*-----------------*/ = NULL;
		colorStart /*----------------*/ = MESSAGE_START;
		colorFatal /*----------------*/ = MESSAGE_FATAL;
		colorError /*----------------*/ = MESSAGE_ERROR;
		colorEvent /*----------------*/ = MESSAGE_EVENT;
		colorEnd /*------------------*/ = MESSAGE_END;
		connectionName /*------------*/ = NULL;
		configPath /*----------------*/ = NULL;
		localeName /*----------------*/ = setlocale(LC_ALL, "");
		mustOpenErrorStream /*-------*/ = false;
		errorStream /*---------------*/ = DEFAULT_ERROR_STREAM;
		errorStreamToken /*----------*/ = 0;
		quitting /*------------------*/ = false;
		connection /*----------------*/ = NULL;
		connectionToken /*-----------*/ = 0;
		event /*---------------------*/ = NULL;
		eventToken /*----------------*/ = 0;
		keyPressNextOffset /*--------*/ = 0;
		keyReleaseNextOffset /*------*/ = 0;
		buttonPressNextOffset /*-----*/ = 0;
		buttonReleaseNextOffset /*---*/ = 0;
		shortcutCode /*--------------*/ = 0;
		shortcutModifier /*----------*/ = XCB_NONE;
		expectingSecondKeyRelease /*-*/ = false;
		initMemorySystem();
		initPermissionSystem(&permissionSystem);
		initMonitorSystem(&monitorSystem);
		initWindowSystem(&windowSystem);
		initSleepThreadSystem(&sleepThreadSystem);
		initStringTreeSystem(&globalScopesInstructionStringTreeSystem);
		initStringTreeSystem(&globalInstructionStringTreeSystem);
		initStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
		initStringTreeSystem(&booleanStringTreeSystem);
		initStringTreeSystem(&variableStringTreeSystem);
		initStringTreeSystem(&commandStringTreeSystem);
		initStringTreeSystem(&modifierStringTreeSystem);
		initStringTreeSystem(&shortcutStateStringTreeSystem);
		initStringTreeSystem(&numberTypeStringTreeSystem);
		initStringTreeSystem(&horizontalAlignmentStringTreeSystem);
		initStringTreeSystem(&verticalAlignmentStringTreeSystem);
		initStringTreeSystem(&cornerStringTreeSystem);
		initStringTreeSystem(&whichMonitorStringTreeSystem);
		initStringTreeSystem(&macroStringTreeSystem);
		initSTDINSystem(&stdinSystem);
		initSharedMemorySystem(&sharedMemorySystem);
		initShortcutSystem(&keycodeShortcutSystem);
		initShortcutSystem(&buttonShortcutSystem);
		setConfigVariables();
		{
			pthread_rwlockattr_t attributes;
			if(pthread_rwlockattr_init(&attributes) != PTHREAD_RWLOCKATTR_INIT_SUCCESS){
				printTitledError("pthread error", "could not init global lock attributes");
			}
			if(pthread_rwlockattr_setkind_np(&attributes, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP) != PTHREAD_RWLOCKATTR_SETKIND_NP_SUCCESS){
				printTitledError("pthread error", "could not set global lock attributes lock kind");
			}
			globalsLockCreated = pthread_rwlock_init(&globalsLock, &attributes) == PTHREAD_RWLOCK_INIT_SUCCESS;
			if(!globalsLockCreated){
				printTitledError("pthread error", "could not init globals lock");
			}
			if(pthread_rwlockattr_destroy(&attributes) != PTHREAD_RWLOCKATTR_DESTROY_SUCCESS){
				printTitledError("pthread error", "could not destroy global lock attributes");
			}
		}
		setPermissions(&permissionSystem);
		lowerPermissions(&permissionSystem);
		processingSignal = false;
		jmp getProgramArguments;
	}
	getProgramArguments:{
		if(argumentAmount == 1){
			printError("%s%s: %susage:%s %s [argument] [value] or %s [argument] [--help]\n\t[-h], [--help]  \tdisplay this message\n\t[-c], [--config]\tpath to config file, mandatory\n\t[-e], [--error] \tpath to error file, optional\n\t[-s], [--server]\tX server connection, optional\n", colorStart, programName, colorError, colorEnd, programName, programName);
			jmp mainEmergencyExit;
		}
		dec argumentAmount;
		jmp checkErrorRedirection;
	}
	checkErrorRedirection:{
		if(!isatty(fileno(DEFAULT_ERROR_STREAM))){
			colorStart = "";
			colorFatal = "";
			colorError = "";
			colorEvent = "";
			colorEnd = "";
		}
		jmp matchArgumentsLoop;
	}
	matchArgumentsLoop:{
		switch identifyArgument(*(inc argument)) over
			to HELP_ARGUMENT: /*---*/ jmp helpArgument;
			to CONFIG_ARGUMENT: /*-*/ jmp configArgument;
			to ERROR_ARGUMENT: /*--*/ jmp errorArgument;
			to SERVER_ARGUMENT: /*-*/ jmp serverArgument;
			off: /*----------------*/ jmp notAnArgument;
		end
	}
	helpArgument:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s [argument] [value] or %s [argument] [--help]\n\t[-h], [--help]  \tdisplay this message\n\t[-c], [--config]\tpath to config file, mandatory\n\t[-e], [--error] \tpath to error file, optional\n\t[-s], [--server]\tX server connection, optional\n", programName, programName, programName);
		jmp mainEmergencyExit;
	}
	configArgument:{
		if(configPath){
			printTitledError("argument error", "the config argument has already been specified");
			jmp mainEmergencyExit;
		}
		if(!dec argumentAmount){
			printTitledError("argument error", "no config value specified");
			jmp mainEmergencyExit;
		}
		configPath = *(inc argument);
		switch identifyArgument(configPath) over
			to UNRECOGNIZED_ARGUMENT: /*-*/ jmp openConfigFile;
			to HELP_ARGUMENT: /*---------*/ jmp displayConfigUsage;
			off: /*----------------------*/ jmp displayNoConfigValue;
		end
	}
	openConfigFile:{
		DIR *const dir = opendir(configPath);
		FILE *file;
		uint32 token = pushPointer(dir, "config directory argument", closedir);
		if(dir){
			closedir(dir);
			popPointer(token);
			printTitledQuotedError("argument error", *argument, "config value is directory");
			jmp mainEmergencyExit;
		}
		file = fopen(configPath, "r");
		token = pushPointer(file, "config file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			jmp matchArgumentLoopControl;
		}
		file = fopen(configPath, "w");
		token = pushPointer(file, "config file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			remove(configPath);
			jmp matchArgumentLoopControl;
		}
		printTitledError("argument error", "could not read or create config file");
		jmp mainEmergencyExit;
	}
	displayConfigUsage:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s --config \"/path/to/file\"\n\tif the specified file doesn't exist it will be created\n\tand it will contain the hardcoded default configuration\n", programName, programName);
		jmp mainEmergencyExit;
	}
	displayNoConfigValue:{
		printTitledError("argument error", "no config value specified");
		jmp mainEmergencyExit;
	}
	errorArgument:{
		if(errorPath){
			printTitledError("argument error", "the error argument has already been specified");
			jmp mainEmergencyExit;
		}
		if(!dec argumentAmount){
			printTitledError("argument error", "no error value specified");
			jmp mainEmergencyExit;
		}
		errorPath = *(inc argument);
		switch identifyArgument(errorPath) over
			to UNRECOGNIZED_ARGUMENT: /*-*/ jmp openErrorFile;
			to HELP_ARGUMENT: /*---------*/ jmp displayErrorUsage;
			to STDOUT_ARGUMENT: /*-------*/ jmp setErrorStreamStdout;
			to STDERR_ARGUMENT: /*-------*/ jmp setErrorStreamStderr;
			off: /*----------------------*/ jmp displayNoErrorValue;
		end
	}
	openErrorFile:{
		DIR *const dir = opendir(configPath);
		FILE *file;
		uint32 token = pushPointer(dir, "error directory argument", closedir);
		if(dir){
			closedir(dir);
			popPointer(token);
			printTitledQuotedError("argument error", *argument, "error value is directory");
			jmp mainEmergencyExit;
		}
		file = fopen(errorPath, "r");
		token = pushPointer(file, "error file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			mustOpenErrorStream = true;
			colorStart = "";
			colorFatal = "";
			colorError = "";
			colorEvent = "";
			colorEnd = "";
			jmp matchArgumentLoopControl;
		}
		file = fopen(errorPath, "w");
		token = pushPointer(file, "error file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			remove(errorPath);
			mustOpenErrorStream = true;
			colorStart = "";
			colorFatal = "";
			colorError = "";
			colorEvent = "";
			colorEnd = "";
			jmp matchArgumentLoopControl;
		}
		printTitledError("argument error", "could not create error file");
		jmp mainEmergencyExit;
	}
	displayErrorUsage:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s --error \"/path/to/file\"\n\tif the specified file doesn't exist it will be created\n", programName, programName);
		jmp mainEmergencyExit;
	}
	setErrorStreamStdout:{
		errorStream = stdout;
		jmp matchArgumentLoopControl;
	}
	setErrorStreamStderr:{
		errorStream = stderr;
		jmp matchArgumentLoopControl;
	}
	displayNoErrorValue:{
		printTitledError("argument error", "no error value specified");
		jmp mainEmergencyExit;
	}
	serverArgument:{
		if(connectionName){
			printTitledError("argument error", "the server argument has already been specified");
			jmp mainEmergencyExit;
		}
		if(!dec argumentAmount){
			printTitledError("argument error", "no server value specified");
			jmp mainEmergencyExit;
		}
		connectionName = *(inc argument);
		switch identifyArgument(connectionName) over
			to UNRECOGNIZED_ARGUMENT: /*-*/ jmp matchArgumentLoopControl;
			to HELP_ARGUMENT: /*---------*/ jmp displayServerUsage;
			off: /*----------------------*/ jmp displayNoServerValue;
		end
	}
	displayServerUsage:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s --server \"name\"\n\tthe name of the server, if running, should be something like \":0\"\n\tit can be checked with the $DISPLAY variable on a running server (no tty)\n", programName, programName);
		jmp mainEmergencyExit;
	}
	displayNoServerValue:{
		printTitledError("argument error", "no server value specified");
		jmp mainEmergencyExit;
	}
	notAnArgument:{
		printTitledQuotedError("argument error", *argument, "is not recognized as program argument, check help? [-h]");
		jmp mainEmergencyExit;
	}
	matchArgumentLoopControl:{
		if(dec argumentAmount){
			jmp matchArgumentsLoop;
		}
		jmp argumentsFinalCheck;
	}
	argumentsFinalCheck:{
		if(!configPath){
			printTitledError("argument error", "no config argument specified");
			jmp mainEmergencyExit;
		}
		if(errorPath and sensitiveStringCompare(errorPath, configPath)){
			mustOpenErrorStream = false;
			printTitledError("argument error", "config and error files are the same");
			jmp mainEmergencyExit;
		}
		jmp establishServerConnection;
	}
	setAtoms:{
		#define STRING(f) /*-*/ { \
			  f("MICRO_INIT") \
			, f("MANAGER") \
		}
	}
	initSystems:{
		createMonitors(&monitorSystem);
		bulkInsertString(&globalScopesInstructionStringTreeSystem, globalScopesInstructionList);
		bulkInsertString(&globalInstructionStringTreeSystem, globalInstructionList);
		bulkInsertString(&scope1ScopeInstructionStringTreeSystem, scope1ScopeInstructionList);
		bulkInsertString(&booleanStringTreeSystem, booleanList);
		bulkInsertString(&variableStringTreeSystem, variableList);
		bulkInsertString(&commandStringTreeSystem, commandList);
		bulkInsertString(&modifierStringTreeSystem, modifierList);
		bulkInsertString(&shortcutStateStringTreeSystem, shortcutStateList);
		bulkInsertString(&numberTypeStringTreeSystem, numberTypeList);
		bulkInsertString(&horizontalAlignmentStringTreeSystem, horizontalAlignmentList);
		bulkInsertString(&verticalAlignmentStringTreeSystem, verticalAlignmentList);
		bulkInsertString(&cornerStringTreeSystem, cornerList);
		bulkInsertString(&whichMonitorStringTreeSystem, whichMonitorList);
		bulkInsertString(&macroStringTreeSystem, macroList);
		jmp readConfig;
	}
	readConfig:{
		if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals write lock");
		}
		displaySimpleConfigErrors = true;
		restart(false);
		readConfig(true, configPath, &ifgetc, NULL);
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals write lock");
		}
		if(globalsLockCreated and pthread_rwlock_rdlock(&globalsLock) != PTHREAD_RWLOCK_RDLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals read lock");
		}
		jmp eventLoopCheckShortcuts;
	}
	eventLoopCheckShortcuts:{
		if(keyPressNextOffset) /*------*/ jmp keyPressEvent;
		if(keyReleaseNextOffset) /*----*/ jmp keyReleaseEvent;
		if(buttonPressNextOffset) /*---*/ jmp buttonPressEvent;
		if(buttonReleaseNextOffset) /*-*/ jmp buttonReleaseEvent;
		jmp eventLoop;
	}
	eventLoop:{
		xcb_flush(connection);
		free(event);
		popPointer(eventToken);
		event = NULL;
		eventToken = 0;
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals read lock");
		}
		jmp waitForEvent;
	}
	waitForEvent:{
		event = xcb_wait_for_event(connection);
		eventToken = pushPointer(event, "event pointer", iFree);
		if(event){
			if(globalsLockCreated and pthread_rwlock_rdlock(&globalsLock) != PTHREAD_RWLOCK_RDLOCK_SUCCESS){
				printTitledError("pthread error", "could not lock globals read lock");
			}
			jmp switchEvent;
		}
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp mainEmergencyExit;
		}
		jmp waitForEvent;
	}
	switchEvent:{
		#define XCB_ONE /*-*/ (1)
		if(((*event).response_type & ~b(10000000)) > XCB_NONE and ((*event).response_type & ~b(10000000)) < XCB_GE_GENERIC){
			printXEvent(baseEventName);
		}
		switch (*event).response_type & ~b(10000000) over
			to XCB_NONE: /*--------------*/ jmp errorEvent;
			to XCB_ONE: /*---------------*/ jmp unrecognizedEvent;
			to XCB_KEY_PRESS: /*---------*/ jmp keyPressEvent;
			to XCB_KEY_RELEASE: /*-------*/ jmp keyReleaseEvent;
			to XCB_BUTTON_PRESS: /*------*/ jmp buttonPressEvent;
			to XCB_BUTTON_RELEASE: /*----*/ jmp buttonReleaseEvent;
			to XCB_MOTION_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_ENTER_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_LEAVE_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*----------*/ jmp unexpectedEvent;
			to XCB_FOCUS_OUT: /*---------*/ jmp unexpectedEvent;
			to XCB_KEYMAP_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*-*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*-------*/ jmp unexpectedEvent;
			to XCB_VISIBILITY_NOTIFY: /*-*/ jmp unexpectedEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_MAP_NOTIFY: /*--------*/ jmp unexpectedEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_SELECTION_CLEAR: /*---*/ jmp unexpectedEvent;
			to XCB_SELECTION_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_SELECTION_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_COLORMAP_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CLIENT_MESSAGE: /*----*/ jmp unexpectedEvent;
			to XCB_MAPPING_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*--------*/ jmp genericEvent;
			off: /*----------------------*/ jmp extensionEvent;
		end
		#undef  XCB_ONE
	}
	keyPressEvent:{
		#define e /*-*/ ((xcb_key_press_event_t *)event)
		if(getNextShortcut(&keycodeShortcutSystem, false, (*e).detail, (*e).state & b(11111111), &keyPressNextOffset)){
			jmp matchCommandPress;
		}
		shortcutCode = 0;
		shortcutModifier = XCB_NONE;
		expectingSecondKeyRelease = false;
		jmp eventLoop;
		#undef  e
	}
	keyReleaseEvent:{
		#define e /*-*/ ((xcb_key_release_event_t *)event)
		uint8 keycode = (*e).detail;
		uint16 modifier = (*e).state & b(11111111);
		if(getNextShortcut(&keycodeShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &keyReleaseNextOffset)){
			xcb_query_keymap_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_keymap_unchecked(connection), NULL);
			uint32 token = pushPointer(reply, "query keymap reply", iFree);
			if(reply){
				const bool keyIsPressed = !!(*((*reply).keys + (*e).detail / 8) & (1 << (*e).detail % 8));
				free(reply);
				popPointer(token);
				if(keyIsPressed){
					keyReleaseNextOffset = 0;
					jmp eventLoop;
				}
			}
			jmp matchCommandRelease;
		}
		if(keycode != shortcutCode and modifier == shortcutModifier){
			expectingSecondKeyRelease = true;
			realKeyReleaseModifier = shortcutModifier;
			jmp eventLoop;
		}
		if(keycode == shortcutCode and modifier != shortcutModifier){
			if(!expectingSecondKeyRelease){
				jmp eventLoop;
			}
			keycode = shortcutCode;
			modifier = realKeyReleaseModifier;
			expectingSecondKeyRelease = false;
			keyReleaseNextOffset = 0;
			if(getNextShortcut(&keycodeShortcutSystem, true, keycode, modifier, &keyReleaseNextOffset)){
				jmp matchCommandRelease;
			}
		}
		jmp eventLoop;
		#undef  e
	}
	buttonPressEvent:{
		#define e /*-*/ ((xcb_button_press_event_t *)event)
		if(getNextShortcut(&buttonShortcutSystem, false, (*e).detail, (*e).state & b(11111111), &buttonPressNextOffset)){
			jmp matchCommandPress;
		}
		jmp eventLoop;
		#undef  e
	}
	buttonReleaseEvent:{
		#define e /*-*/ ((xcb_button_release_event_t *)event)
		if(getNextShortcut(&buttonShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &buttonReleaseNextOffset)){
			jmp matchCommandRelease;
		}
		jmp eventLoop;
		#undef  e
	}
	{
		uint8 commandOrigin;
		matchCommandPress:{
			commandOrigin = PRESS_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommandRelease:{
			commandOrigin = RELEASE_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommand: switch matchCommand((*eventModifierNode).command, (*eventModifierNode).string, commandOrigin, (*eventModifierNode).field0, (*eventModifierNode).field1, (*eventModifierNode).field2, (*eventModifierNode).field3, (*eventModifierNode).field4) over
			to TYPICAL_MATCH_COMMAND_TYPE:{
				jmp eventLoopCheckShortcuts;
			}
			to RESTART_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp readConfig;
			}
			to EXIT_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp mainEmergencyExit;
			}
			off:{
				jmp eventLoopCheckShortcuts;
			}
		end
	}
	genericEvent:{
		#define e /*-*/ ((xcb_ge_generic_event_t *)event)
		if((*e).extension == xinputMajorOpcode){
			(*e).response_type = (*e).event_type;
			jmp switchXinputEvent;
		}
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  e
	}
	extensionEvent:{
		#define isExtensionEvent(e) /*-*/ (eventType >= e##BaseEvent and eventType < e##BaseEvent + countof(e##EventName) - 1)
		const uint8 eventType = (*event).response_type & ~b(10000000);
		if(isExtensionEvent(randr)) /*--*/ jmp switchRandrEvent;
		if(isExtensionEvent(xfixes)) /*-*/ jmp switchXfixesEvent;
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  isExtensionEvent
	}
	switchRandrEvent:{
		printXEvent(randrEventName);
		switch ((*event).response_type & ~b(10000000)) - randrBaseEvent over
			to XCB_RANDR_SCREEN_CHANGE_NOTIFY:
			to XCB_RANDR_NOTIFY:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
					printTitledError("pthread error", "could not lock globals write lock");
				}
				{
					int screenNumber;
					xcb_connection_t *const connection = xcb_connect_to_display_with_auth_info(connectionName, NULL, &screenNumber);
					uint32 token = pushPointer(connection, "X connection", iXCBDisconnect);
					if(connection){
						xcb_screen_t *const screen = xcb_setup_roots_iterator(xcb_get_setup(connection)).data + screenNumber;
						if(screen){
							screenWidthInPixels = (*screen).width_in_pixels;
							screenHeightInPixels = (*screen).height_in_pixels;
							screenWidthInMillimeters = (*screen).width_in_millimeters;
							screenHeightInMillimeters = (*screen).height_in_millimeters;
						}else{
							screenWidthInPixels = 0;
							screenHeightInPixels = 0;
							screenWidthInMillimeters = 0;
							screenHeightInMillimeters = 0;
						}
						xcb_disconnect(connection);
						popPointer(token);
					}
				}
				createMonitors(&monitorSystem);
				jmp eventLoop;
			}
			off:{
				jmp unrecognizedEvent;
			}
		end
	}
	switchXfixesEvent:{
		printXEvent(xfixesEventName);
		switch ((*event).response_type & ~b(10000000)) - xfixesBaseEvent over
			to XCB_XFIXES_SELECTION_NOTIFY: /*-*/ jmp eventLoop;
			to XCB_XFIXES_CURSOR_NOTIFY: /*----*/ jmp eventLoop;
			off: /*----------------------------*/ jmp unrecognizedEvent;
		end
	}
	switchXinputEvent:{
		printXEvent(xinputEventName);
		switch (*event).response_type & ~b(10000000) over
			to XCB_NONE: /*-----------------------*/ jmp unrecognizedEvent;
			to XCB_INPUT_DEVICE_CHANGED: /*-------*/ jmp unexpectedEvent;
			to XCB_INPUT_KEY_PRESS: /*------------*/ jmp unexpectedEvent;
			to XCB_INPUT_KEY_RELEASE: /*----------*/ jmp unexpectedEvent;
			to XCB_INPUT_BUTTON_PRESS: /*---------*/ jmp unexpectedEvent;
			to XCB_INPUT_BUTTON_RELEASE: /*-------*/ jmp unexpectedEvent;
			to XCB_INPUT_MOTION: /*---------------*/ jmp unexpectedEvent;
			to XCB_INPUT_ENTER: /*----------------*/ jmp unexpectedEvent;
			to XCB_INPUT_LEAVE: /*----------------*/ jmp unexpectedEvent;
			to XCB_INPUT_FOCUS_IN: /*-------------*/ jmp unexpectedEvent;
			to XCB_INPUT_FOCUS_OUT: /*------------*/ jmp unexpectedEvent;
			to XCB_INPUT_HIERARCHY: /*------------*/ jmp xinputHierarchyEvent;
			to XCB_INPUT_PROPERTY: /*-------------*/ jmp unexpectedEvent;
			to XCB_INPUT_RAW_KEY_PRESS: /*--------*/ jmp unexpectedEvent;
			to XCB_INPUT_RAW_KEY_RELEASE: /*------*/ jmp unexpectedEvent;
			to XCB_INPUT_RAW_BUTTON_PRESS: /*-----*/ jmp unexpectedEvent;
			to XCB_INPUT_RAW_BUTTON_RELEASE: /*---*/ jmp unexpectedEvent;
			to XCB_INPUT_RAW_MOTION: /*-----------*/ jmp unexpectedEvent;
			to XCB_INPUT_TOUCH_BEGIN: /*----------*/ jmp xinputTouchBeginEvent;
			to XCB_INPUT_TOUCH_UPDATE: /*---------*/ jmp xinputTouchUpdateEvent;
			to XCB_INPUT_TOUCH_END: /*------------*/ jmp xinputTouchEndEvent;
			to XCB_INPUT_TOUCH_OWNERSHIP: /*------*/ jmp unexpectedEvent;
			to XCB_INPUT_RAW_TOUCH_BEGIN: /*------*/ jmp unexpectedEvent;
			to XCB_INPUT_RAW_TOUCH_UPDATE: /*-----*/ jmp unexpectedEvent;
			to XCB_INPUT_RAW_TOUCH_END: /*--------*/ jmp unexpectedEvent;
			to XCB_INPUT_BARRIER_HIT: /*----------*/ jmp unexpectedEvent;
			to XCB_INPUT_BARRIER_LEAVE: /*--------*/ jmp unexpectedEvent;
			to XCB_INPUT_GESTURE_PINCH_BEGIN: /*--*/ jmp unexpectedEvent;
			to XCB_INPUT_GESTURE_PINCH_UPDATE: /*-*/ jmp unexpectedEvent;
			to XCB_INPUT_GESTURE_PINCH_END: /*----*/ jmp unexpectedEvent;
			to XCB_INPUT_GESTURE_SWIPE_BEGIN: /*--*/ jmp unexpectedEvent;
			to XCB_INPUT_GESTURE_SWIPE_UPDATE: /*-*/ jmp unexpectedEvent;
			to XCB_INPUT_GESTURE_SWIPE_END: /*----*/ jmp unexpectedEvent;
			off: /*-------------------------------*/ jmp unrecognizedEvent;
		end
	}
	xinputHierarchyEvent:{
		/*!*/
		jmp eventLoop;
	}
	xinputTouchBeginEvent:{
		/*!*/
		jmp eventLoop;
	}
	xinputTouchUpdateEvent:{
		/*!*/
		jmp eventLoop;
	}
	xinputTouchEndEvent:{
		/*!*/
		jmp eventLoop;
	}
	unrecognizedEvent:{
		printTitledValuedError("X event error", "unrecognized event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unexpectedEvent:{
		printTitledValuedError("unexpected X event", "unexpected event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unhandledEvent:{
		printTitledValuedError("X event error", "unhandled event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	mainEmergencyExit:{
		cleanup();
		ret 0;
	}
}
QUIT(){
	const char *message;
	const Pointer *start;
	const Pointer *current;
	const Pointer *wall;
	jmp evaluateHandlerAvailability;
	evaluateHandlerAvailability:{
		if(quitting){
			switch signal over
				to SIGABRT: /*-*/ brk;
				to SIGBUS: /*--*/ brk;
				to SIGFPE: /*--*/ brk;
				to SIGILL: /*--*/ brk;
				to SIGSEGV: /*-*/ brk;
				to SIGTRAP: /*-*/ brk;
				off: /*--------*/ ret;
			end
			printTitledNamedError("quitting error", "could not free", labelExamined);
			jmp exit;
		}
		if(processingSignal and signal != SIGINT){
			ret;
		}
		processingSignal = true;
		jmp findSignal;
	}
	findSignal: switch signal over
		to SIGABRT: /*-*/ message = "aborted"; /*--------------*/ jmp exitWithError;
		to SIGBUS: /*--*/ message = "hardware faulted"; /*-----*/ jmp exitWithError;
		to SIGFPE: /*--*/ message = "programmer math'd up"; /*-*/ jmp exitWithError;
		to SIGILL: /*--*/ message = "executable corrupted"; /*-*/ jmp exitWithError;
		to SIGINT: /*--*/ message = "interrupted"; /*----------*/ jmp exitWithError;
		to SIGQUIT: /*-*/ message = "voluntarily quitted"; /*--*/ jmp exitWithError;
		to SIGSEGV: /*-*/ message = "segmentation faulted"; /*-*/ jmp exitWithError;
		to SIGTERM: /*-*/ message = "terminated"; /*-----------*/ jmp exitWithError;
		to SIGTRAP: /*-*/ message = "trapped"; /*--------------*/ jmp exitWithError;
		to SIGUSR1: /*-*/ /*-----------------------------------*/ jmp handleUserSignal;
		to SIGUSR2: /*-*/ /*-----------------------------------*/ jmp handleUserSignal;
		off: /*--------*/ message = "unhandled signal"; /*-----*/ jmp exitWithError;
	end
	handleUserSignal:{
		processingSignal = false;
		ret;
	}
	exitWithError:{
		quitting = true;
		finiSTDINSystem(&stdinSystem);
		finiSharedMemorySystem(&sharedMemorySystem);
		printTitledError("signal received", message);
		if(memoryManagementSystem.allocated <= 1){
			jmp exit;
		}
		start = memoryManagementSystem.data;
		current = start + 1;
		wall = start + memoryManagementSystem.allocated;
		switch signal over
			to SIGABRT:
			to SIGBUS:
			to SIGFPE:
			to SIGILL:
			to SIGSEGV:
			to SIGTRAP:{
				printError("%s%s: %spointers at time of error:%s\n", colorStart, programName, colorError, colorEnd);
				if(memoryManagementSystem.allocated > 1){
					jmp printPointedVariables;
				}
				printError("none\n");
				jmp freePointedVariablesLoop;
			}
			off:{
				jmp freePointedVariablesLoop;
			}
		end
	}
	printPointedVariables:{
		printUnaccountedForPointers(current, wall);
		current = start + 1;
		jmp freePointedVariablesLoop;
	}
	freePointedVariablesLoop:{
		if((*current).data){
			labelExamined = (*current).label;
			(*current).free((*current).data);
		}
		if(inc current < wall){
			jmp freePointedVariablesLoop;
		}
		jmp exit;
	}
	exit:{
		finiMemorySystem();
		closeErrorStream();
		exit(EXIT_SUCCESS);
	}
}
REAPSPAWNEDPROCESSES(){
	#define ANY_CHILD /*-*/ (-1)
	(void)signal;
	jmp reapSpawnedProcessLoop;
	reapSpawnedProcessLoop:{
		if(waitpid(ANY_CHILD, NULL, WNOHANG) > 0){
			jmp reapSpawnedProcessLoop;
		}
		ret;
	}
	#undef  ANY_CHILD
}
PUSHPOINTER(){
	uint32 token;
	if(!memoryManagementSystem.mutexCreated or !pointer){
		ret 0;
	}
	if(pthread_mutex_lock(&memoryManagementSystem.mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock memory system mutex");
	}
	jmp pushPointer;
	pushPointer:{
		Pointer *data;
		if(memoryManagementSystem.allocated == memoryManagementSystem.size){
			void *temp;
			memoryManagementSystem.size += DYNAMIC_DATA_SEGMENT_BLOCK_SIZE;
			if(!(temp = realloc(memoryManagementSystem.data, memoryManagementSystem.size * sizeof(Pointer)))){
				memoryManagementSystem.size -= DYNAMIC_DATA_SEGMENT_BLOCK_SIZE;
				token = 0;
				jmp emergencyExit;
			}
			memoryManagementSystem.data = temp;
			if(!memoryManagementSystem.allocated){
				(*memoryManagementSystem.data).data = (void *)1;
				inc memoryManagementSystem.allocated;
			}
		}
		token = memoryManagementSystem.allocated;
		data = memoryManagementSystem.data + token;
		(*data).label = label;
		(*data).data = pointer;
		(*data).token = token;
		(*data).line = line;
		(*data).file = file;
		(*data).free = freeFunction;
		inc memoryManagementSystem.allocated;
		jmp emergencyExit;
	}
	emergencyExit:{
		if(memoryManagementSystem.mutexCreated and pthread_mutex_unlock(&memoryManagementSystem.mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock memory system mutex");
		}
		ret token;
	}
}
UPDATEPOINTER(){
	if(!memoryManagementSystem.mutexCreated or !memoryManagementSystem.data or !token or !pointer){
		ret false;
	}
	if(pthread_mutex_lock(&memoryManagementSystem.mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
		printTitledError("pthread error", "could not lock memory system mutex");
	}
	jmp updatePointer;
	updatePointer:{
		(*(memoryManagementSystem.data + token)).data = pointer;
		jmp emergencyExit;
	}
	emergencyExit:{
		if(memoryManagementSystem.mutexCreated and pthread_mutex_unlock(&memoryManagementSystem.mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock memory system mutex");
		}
		ret true;
	}
}
POPPOINTER(){
	if(!memoryManagementSystem.mutexCreated or !memoryManagementSystem.data or !token){
		ret false;
	}
	if(pthread_mutex_lock(&memoryManagementSystem.mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock memory system mutex");
	}
	jmp popPointer;
	popPointer:{
		(*(memoryManagementSystem.data + token)).data = NULL;
		jmp trimSegmentLoop;
	}
	trimSegmentLoop:{
		if(!(*(memoryManagementSystem.data + dec memoryManagementSystem.allocated)).data){
			jmp trimSegmentLoop;
		}
		inc memoryManagementSystem.allocated;
		jmp emergencyExit;
	}
	emergencyExit:{
		if(memoryManagementSystem.mutexCreated and pthread_mutex_unlock(&memoryManagementSystem.mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock memory system mutex");
		}
		ret true;
	}
}
ISHMCTL(){
	const int shmID = (int64)pointer;
	if(shmID != SHMGET_FAILURE){
		shmctl(shmID, IPC_RMID, NULL);
	}
	ret 0;
}
INITPERMISSIONSYSTEM(){
	if(!permissionSystem){
		ret false;
	}
	(*permissionSystem).normalUID = getuid();
	(*permissionSystem).normalGID = getgid();
	ret true;
}
SETPERMISSIONS(){
	const char *dataCurrent;
	const char *dataWall;
	LoadedFile loadedFile;
	char uidStringStart[10];
	char *uidStringCurrent;
	uid_t uid;
	if(!permissionSystem or ((*permissionSystem).normalUID != ROOT_UID and (*permissionSystem).normalGID != ROOT_GID)){
		ret false;
	}
	jmp loadFile;
	loadFile:{
		if(!loadFile("/proc/self/loginuid", &loadedFile)){
			ret false;
		}
		dataCurrent = loadedFile.dataStart;
		dataWall = dataCurrent + loadedFile.dataSize;
		uidStringCurrent = uidStringStart;
		uid = 0;
		jmp calculateUIDLoop;
	}
	calculateUIDLoop:{
		if(dataCurrent < dataWall){
			uid = uid * 10 + *dataCurrent - 48;
			*uidStringCurrent = *dataCurrent;
			inc uidStringCurrent;
			inc dataCurrent;
			jmp calculateUIDLoop;
		}
		free(loadedFile.dataStart);
		popPointer(loadedFile.dataToken);
		jmp getIDs;
	}
	getIDs:{
		struct passwd *passwd = getpwuid(uid);
		if(!passwd){
			ret false;
		}
		(*permissionSystem).normalUID = (*passwd).pw_uid;
		(*permissionSystem).normalGID = (*passwd).pw_gid;
		ret true;
	}
}
LOWERPERMISSIONS(){
	if(!permissionSystem or (geteuid() == (*permissionSystem).normalUID and getegid() == (*permissionSystem).normalGID)){
		ret false;
	}
	setegid((*permissionSystem).normalGID);
	seteuid((*permissionSystem).normalUID);
	ret true;
}
RAISEPERMISSIONS(){
	if(!permissionSystem or (geteuid() == getuid() and getegid() == getgid())){
		ret false;
	}
	setegid(getgid());
	seteuid(getuid());
	ret true;
}
DROPPERMISSIONS(){
	struct passwd *pw;
	char buffer[sizeof("/var/mail/") + 256];
	if(!permissionSystem){
		ret false;
	}
	pw = getpwuid((*permissionSystem).normalUID);
	if(!pw){
		ret false;
	}
	snprintf(buffer, sizeof(buffer), "/var/mail/%s", (*pw).pw_name);
	raisePermissions(permissionSystem);
	initgroups((*pw).pw_name, (*pw).pw_gid);
	setgid((*pw).pw_gid);
	setuid((*pw).pw_uid);
	unsetenv("SUDO_ASKPASS");
	unsetenv("SUDO_COMMAND");
	unsetenv("SUDO_EDITOR");
	unsetenv("SUDO_GID");
	unsetenv("SUDO_HOME");
	unsetenv("SUDO_PROMPT");
	unsetenv("SUDO_PS1");
	unsetenv("SUDO_UID");
	unsetenv("SUDO_USER");
	setenv("MAIL", buffer, true);
	setenv("HOME", (*pw).pw_dir, true);
	setenv("PWD", (*pw).pw_dir, true);
	setenv("USER", (*pw).pw_name, true);
	setenv("LOGNAME", (*pw).pw_name, true);
	setenv("SHELL", (*pw).pw_shell, true);
	setenv("LANG", setlocale(LC_ALL, ""), true);
	ret true;
}
FINIPERMISSIONSYSTEM(){
	if(!permissionSystem){
		ret false;
	}
	(*permissionSystem).normalUID = getuid();
	(*permissionSystem).normalGID = getgid();
	ret true;
}
INSENSITIVESTRINGCOMPARE(){
	jmp compareCharacterLoop;
	compareCharacterLoop:{
		char c1 = *s1;
		c1 |= 32 * (c1 >= 'A' and c1 <= 'Z');
		if(*s0 != c1) /*-*/ ret false;
		if(!c1) /*-------*/ ret true;
		inc s0;
		inc s1;
		jmp compareCharacterLoop;
	}
}
SENSITIVESTRINGCOMPARE(){
	jmp compareCharacterLoop;
	compareCharacterLoop:{
		if(*s0 != *s1) /*-*/ ret false;
		if(!*s0) /*-------*/ ret true;
		inc s0;
		inc s1;
		jmp compareCharacterLoop;
	}
}
INITMONITORSYSTEM(){
	if(!monitorSystem){
		ret false;
	}
	(*monitorSystem).size = 0;
	(*monitorSystem).start = NULL;
	(*monitorSystem).token = 0;
	ret true;
}
CREATEMONITORS(){
	xcb_randr_get_monitors_reply_t *reply;
	uint32 replyToken;
	uint size;
	Monitor *start;
	Monitor *current;
	Monitor *wall;
	uint32 token;
	xcb_randr_monitor_info_iterator_t iterator;
	if(!monitorSystem){
		ret false;
	}
	reply = xcb_wait_for_reply(connection, xcb_randr_get_monitors_unchecked(connection, (*screen).root, true), NULL);
	replyToken = pushPointer(reply, "monitor reply", iFree);
	size = 1;
	if(reply){
		size = (*reply).nMonitors;
	}
	start = malloc(size * sizeof(Monitor));
	token = pushPointer(start, "monitor pointer", iFree);
	if(!start){
		printTitledError("memory allocation error", "could not allocate memory for monitors");
		free(reply);
		popPointer(replyToken);
		ret false;
	}
	current = start;
	wall = current + size;
	if(!reply){
		(*current).name = XCB_NONE;
		(*current).leftX = 0;
		(*current).topY = 0;
		(*current).rightX = screenWidthInPixels;
		(*current).bottomY = screenHeightInPixels;
		(*current).width = screenWidthInPixels;
		(*current).height = screenHeightInPixels;
		(*current).millimeterWidth = screenWidthInMillimeters;
		(*current).millimeterHeight = screenHeightInMillimeters;
		ret true;
	}
	iterator = xcb_randr_get_monitors_monitors_iterator(reply);
	jmp createMonitorLoop;
	createMonitorLoop:{
		if(current < wall){
			const Monitor *monitorCurrent = start;
			const Monitor *const monitorWall = current;
			const xcb_randr_monitor_info_t *const data = iterator.data;
			jmp removeSameMonitorLoop;
			removeSameMonitorLoop:{
				if(monitorCurrent < monitorWall){
					if((*monitorCurrent).leftX == (*data).x and (*monitorCurrent).topY == (*data).y){
						xcb_randr_monitor_info_next(&iterator);
						dec size;
						jmp createMonitorLoop;
					}
					inc monitorCurrent;
					jmp removeSameMonitorLoop;
				}
				(*current).name = (*data).name;
				(*current).leftX = (*data).x;
				(*current).topY = (*data).y;
				(*current).rightX = (*data).x + (*data).width;
				(*current).bottomY = (*data).y + (*data).height;
				(*current).width = (*data).width;
				(*current).height = (*data).height;
				(*current).millimeterWidth = (*data).width_in_millimeters;
				(*current).millimeterHeight = (*data).height_in_millimeters;
				xcb_randr_monitor_info_next(&iterator);
				inc current;
				jmp createMonitorLoop;
			}
		}
		free(reply);
		popPointer(replyToken);
		jmp compareMonitors;
	}
	compareMonitors:{
		if(size == (*monitorSystem).size){
			Monitor *oldCurrent = (*monitorSystem).start;
			current = start;
			wall = current + size;
			jmp compareMonitorLoop;
			compareMonitorLoop:{
				if(current < wall){
					if((*current).name != (*oldCurrent).name or (*current).leftX != (*oldCurrent).leftX or (*current).rightX != (*oldCurrent).rightX or (*current).width != (*oldCurrent).width or (*current).height != (*oldCurrent).height or (*current).millimeterWidth != (*oldCurrent).millimeterWidth or (*current).millimeterHeight != (*oldCurrent).millimeterHeight){
						jmp replaceMonitors;
					}
					inc oldCurrent;
					inc current;
					jmp compareMonitorLoop;
				}
				free(start);
				popPointer(token);
				ret false;
			}
		}
		jmp replaceMonitors;
	}
	replaceMonitors:{
		destroyMonitors(monitorSystem);
		(*monitorSystem).size = size;
		(*monitorSystem).start = start;
		(*monitorSystem).token = token;
		jmp trimMemory;
	}
	trimMemory:{
		if((*monitorSystem).size){
			void *const temp = realloc((*monitorSystem).start, (*monitorSystem).size * sizeof(Monitor));
			updatePointer((*monitorSystem).token, temp);
			if(temp){
				(*monitorSystem).start = temp;
			}
		}
		ret true;
	}
}
GETWHICHMONITOR(){
	switch whichMonitor over
		to NONE_WHICH_MONITOR:{
			ret NULL;
		}
		to POINTER_WHICH_MONITOR:{
			ret findPointerMonitor(monitorSystem);
		}
		to FOCUSED_WINDOW_WHICH_MONITOR:{
			const xcb_window_t window = getFocusedWindow();
			if(window and window != (*screen).root){
				ret findWindowMonitor(monitorSystem, window);
			}
			ret findPointerMonitor(monitorSystem);
		}
		to SELF_WHICH_MONITOR:{
			ret NULL;
		}
		to ALL_WHICH_MONITOR:{
			ret NULL;
		}
		off:{
			ret NULL;
		}
	end
}
DESTROYMONITORS(){
	if(!monitorSystem){
		ret false;
	}
	free((*monitorSystem).start);
	popPointer((*monitorSystem).token);
	(*monitorSystem).size = 0;
	(*monitorSystem).start = NULL;
	(*monitorSystem).token = 0;
	ret true;
}
FINDPOINTERMONITOR(){
	xcb_query_pointer_reply_t *reply;
	uint32 token;
	if(!monitorSystem or !(*monitorSystem).size){
		ret NULL;
	}
	if((*monitorSystem).size == 1){
		ret (*monitorSystem).start;
	}
	reply = xcb_wait_for_reply(connection, xcb_query_pointer_unchecked(connection, (*screen).root), NULL);
	token = pushPointer(reply, "findPoinerMonitors() query pointer reply", iFree);
	if(reply){
		const int x = (*reply).root_x;
		const int y = (*reply).root_y;
		Monitor *current = (*monitorSystem).start;
		Monitor *const wall = current + (*monitorSystem).size;
		free(reply);
		popPointer(token);
		jmp findPointerMonitorLoop;
		findPointerMonitorLoop:{
			if(x >= (*current).leftX and x < (*current).rightX and y >= (*current).topY and y < (*current).bottomY){
				ret current;
			}
			if(inc current < wall){
				jmp findPointerMonitorLoop;
			}
		}
	}
	ret NULL;
}
FINDRECTANGLEMONITOR(){
	Monitor *current;
	Monitor *wall;
	uint mostPixelAmount;
	Monitor *monitor;
	if(!monitorSystem or !(*monitorSystem).size or width < 1 or height < 1){
		ret NULL;
	}
	current = (*monitorSystem).start;
	wall = current + (*monitorSystem).size;
	mostPixelAmount = 0;
	monitor = NULL;
	jmp findRectangleMonitorLoop;
	findRectangleMonitorLoop:{
		if(current < wall){
			int intersectionWidth;
			int intersectionHeight;
			uint pixelAmount;
			getIntersection((*current).leftX, (*current).topY, (*current).width, (*current).height, x, y, width, height, NULL, NULL, &intersectionWidth, &intersectionHeight);
			pixelAmount = intersectionWidth * intersectionHeight;
			if(pixelAmount > mostPixelAmount){
				monitor = current;
				mostPixelAmount = pixelAmount;
			}
			inc current;
			jmp findRectangleMonitorLoop;
		}
		ret monitor;
	}
}
FINDWINDOWMONITOR(){
	xcb_get_geometry_cookie_t geometryCookie;
	xcb_translate_coordinates_cookie_t translateCoordinatesCookie;
	xcb_get_geometry_reply_t *getGeometryReply;
	uint32 getGeometryToken;
	xcb_translate_coordinates_reply_t *translateCoordinatesReply;
	uint32 translateCoordinatesToken;
	Monitor *monitor;
	if(!monitorSystem or !(*monitorSystem).size){
		ret NULL;
	}
	if((*monitorSystem).size == 1){
		ret (*monitorSystem).start;
	}
	geometryCookie = xcb_get_geometry(connection, window);
	translateCoordinatesCookie = xcb_translate_coordinates(connection, window, (*screen).root, 0, 0);
	getGeometryReply = xcb_wait_for_reply(connection, geometryCookie, NULL);
	getGeometryToken = pushPointer(getGeometryReply, "findWindowMonitor() get geometry reply", iFree);
	translateCoordinatesReply = xcb_wait_for_reply(connection, translateCoordinatesCookie, NULL);
	translateCoordinatesToken = pushPointer(translateCoordinatesReply, "findWindowMonitor() translate coordinates reply", iFree);
	monitor = NULL;
	if(getGeometryReply and translateCoordinatesReply){
		const int width = (*getGeometryReply).width + 2 * (*getGeometryReply).border_width;
		const int height = (*getGeometryReply).height + 2 * (*getGeometryReply).border_width;
		const int leftX = (*translateCoordinatesReply).dst_x;
		const int topY = (*translateCoordinatesReply).dst_y;
		const int rightX = leftX + width;
		const int bottomY = topY + height;
		Monitor *current = (*monitorSystem).start;
		Monitor *const wall = current + (*monitorSystem).size;
		int mostPixels = 0;
		jmp findWindowMonitorLoop;
		findWindowMonitorLoop:{
			if((*current).leftX < rightX and (*current).rightX > leftX and (*current).topY < bottomY and (*current).bottomY > topY){
				const int width = ((*current).  rightX <  rightX? (*current). rightX :  rightX) - ((*current).leftX > leftX? (*current).leftX : leftX);
				const int height = ((*current).bottomY < bottomY? (*current).bottomY : bottomY) - ((*current). topY >  topY? (*current). topY :  topY);
				const int pixels = width * height;
				if(pixels > mostPixels){
					mostPixels = pixels;
					monitor = current;
				}
			}
			if(inc current < wall){
				jmp findWindowMonitorLoop;
			}
		}
	}
	free(getGeometryReply);
	popPointer(getGeometryToken);
	free(translateCoordinatesReply);
	popPointer(translateCoordinatesToken);
	ret monitor;
}
FINIMONITORSYSTEM(){
	if(!monitorSystem){
		ret false;
	}
	destroyMonitors(monitorSystem);
	free((*monitorSystem).start);
	popPointer((*monitorSystem).token);
	(*monitorSystem).size = 0;
	(*monitorSystem).start = NULL;
	(*monitorSystem).token = 0;
	ret true;
}



























def struct{
	xcb_window_t /*--------*/ window;
	xcb_pixmap_t /*--------*/ bufferPixmap;
	xcb_pixmap_t /*--------*/ pixmap;
	xcb_gcontext_t /*------*/ gc;
	int32 /*---------------*/ x;
	int32 /*---------------*/ y;
	uint32 /*--------------*/ width;
	uint32 /*--------------*/ height;
	bool /*----------------*/ mapped;
	uint8 /*---------------*/ pad0[3];
} WindowInfo;

def struct{
	xcb_pixmap_t /*--------*/ circlePixmap;
	uint32 /*--------------*/ windowInfoSize;
	WindowInfo * /*--------*/ windowInfoStart;
	uint32 /*--------------*/ windowInfoToken;
	bool /*----------------*/ mapped;
	uint8 /*---------------*/ pad0[3];
} WindowSystem;

INITWINDOWSYSTEM(){
	if(!windowSystem){
		ret false;
	}
	(*windowSystem).circlePixmap = XCB_NONE;
	(*windowSystem).windowInfoSize = 0;
	(*windowSystem).windowInfoStart = NULL;
	(*windowSystem).windowInfoToken = 0;
	(*windowSystem).mapped = false;
	ret true;
}
CREATEWINDOWCIRCLEPIXMAP(){
	Image image;
	xcb_gcontext_t gc;
	struct{
		uint32 /*-*/ generateExpose;
	} valueList;
	if(!windowSystem){
		ret false;
	}
	if(!radius){
		if((*windowSystem).circlePixmap){
			xcb_free_pixmap(connection, (*windowSystem).circlePixmap);
			(*windowSystem).circlePixmap = XCB_NONE;
		}
		ret true;
	}
	if(!createCircle(radius, foreground, background, &image)){
		ret false;
	}
	if((*windowSystem).circlePixmap){
		xcb_free_pixmap(connection, (*windowSystem).circlePixmap);
		(*windowSystem).circlePixmap = XCB_NONE;
	}
	gc = xcb_generate_id(connection);
	valueList.generateExpose = false;
	(*windowSystem).circlePixmap = xcb_generate_id(connection);
	xcb_create_pixmap(connection, depth, (*windowSystem).circlePixmap, (*screen).root, image.width, image.height);
	xcb_create_gc(connection, gc, (*windowSystem).circlePixmap, XCB_GC_GRAPHICS_EXPOSURES, &valueList);
	xcb_put_image(connection, XCB_IMAGE_FORMAT_Z_PIXMAP, (*windowSystem).circlePixmap, gc, image.width, image.height, 0, 0, 0, depth, image.dataSize, image.dataStart);
	xcb_free_gc(connection, gc);
	free(image.dataStart);
	popPointer(image.dataToken);
	ret true;
}
CREATEWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	struct{
		uint32 /*---------*/ backgroundColor;
		uint32 /*---------*/ borderColor;
		uint32 /*---------*/ overrideRedirect;
		uint32 /*---------*/ eventMask;
		xcb_colormap_t /*-*/ colormap;
	} windowValueList;
	struct{
		uint32 /*---------*/ generateExpose;
	} gcValueList;
	if(!windowSystem or !amount){
		ret false;
	}
	destroyWindows(windowSystem);
	free((*windowSystem).windowInfoStart);
	popPointer((*windowSystem).windowInfoToken);
	(*windowSystem).windowInfoSize = amount;
	(*windowSystem).windowInfoStart = malloc((*windowSystem).windowInfoSize * sizeof(WindowInfo));
	(*windowSystem).windowInfoToken = pushPointer((*windowSystem).windowInfoStart, "window info pointer", iFree);
	if(!(*windowSystem).windowInfoStart){
		printTitledError("memory allocation error", "could not allocate memory for windows");
		(*windowSystem).windowInfoSize = 0;
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	windowValueList.backgroundColor = 0x00000000;
	windowValueList.borderColor = 0x00000000;
	windowValueList.overrideRedirect = overrideRedirect;
	windowValueList.eventMask = eventMask;
	windowValueList.colormap = colormap;
	gcValueList.generateExpose = false;
	jmp createWindowLoop;
	createWindowLoop:{
		if(current < wall){
			(*current).window = xcb_generate_id(connection);
			(*current).bufferPixmap = xcb_generate_id(connection);
			(*current).pixmap = xcb_generate_id(connection);
			(*current).gc = xcb_generate_id(connection);
			(*current).x = 0;
			(*current).y = 0;
			(*current).width = 0;
			(*current).height = 0;
			(*current).mapped = false;
			xcb_create_window(connection, depth, (*current).window, (*screen).root, 0, 0, 1, 1, 0, XCB_WINDOW_CLASS_INPUT_OUTPUT, visual, XCB_CW_BACK_PIXEL | XCB_CW_BORDER_PIXEL | XCB_CW_OVERRIDE_REDIRECT | XCB_CW_EVENT_MASK | XCB_CW_COLORMAP, &windowValueList);
			xcb_create_pixmap(connection, depth, (*current).bufferPixmap, (*current).window, screenWidthInPixels, screenHeightInPixels);
			xcb_create_pixmap(connection, depth, (*current).pixmap, (*current).window, screenWidthInPixels, screenHeightInPixels);
			xcb_create_gc(connection, (*current).gc, (*current).pixmap, XCB_GC_GRAPHICS_EXPOSURES, &gcValueList);
			xcb_change_window_attributes(connection, (*current).window, XCB_CW_BACK_PIXMAP, &(*current).pixmap);
			inc current;
			jmp createWindowLoop;
		}
		ret true;
	}
}
MAPWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	Monitor *previousMonitor;
	Monitor *monitorCurrent;
	Monitor *monitorWall;
	xcb_timestamp_t userTime;
	struct{
		int32 /*--*/ x;
		int32 /*--*/ y;
		uint32 /*-*/ width;
		uint32 /*-*/ height;
		uint32 /*-*/ stackMode;
	} valueList;
	if(!windowSystem or !(*windowSystem).windowInfoSize or (*windowSystem).mapped or !monitorSystem or !(*monitorSystem).size or !windowPreferences or !whichMonitor or whichMonitor > ALL_WHICH_MONITOR){
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	previousMonitor = NULL;
	monitorCurrent = (*monitorSystem).start;
	monitorWall = monitorCurrent + (*monitorSystem).size - 1;
	valueList.stackMode = XCB_STACK_MODE_ABOVE;
	userTime = getTimestamp();
	jmp configureWindowLoop;
	configureWindowLoop:{
		if(current < wall){
			Monitor *monitor;
			ElementRectangle rectangle;
			if(!(monitor = getWhichMonitor(monitorSystem, whichMonitor))){
				monitor = monitorCurrent;
			}
			(*current).mapped = false;
			if(monitor != previousMonitor and getRectangle(monitor, NULL, windowPreferences, &rectangle) and rectangle.width and rectangle.height){
				valueList.x = rectangle.x;
				valueList.y = rectangle.y;
				valueList.width = rectangle.width;
				valueList.height = rectangle.height;
				if(rectangle.x != (*current).x or rectangle.y != (*current).y or rectangle.width != (*current).width or rectangle.height != (*current).height){
					(*current).x = rectangle.x;
					(*current).y = rectangle.y;
					(*current).width = rectangle.width;
					(*current).height = rectangle.height;
					xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT | XCB_CONFIG_WINDOW_STACK_MODE, &valueList);
					setWindowProperties(current, windowPreferences, valueList.x, valueList.y, valueList.width, valueList.height);
				}
				drawWindow(windowSystem, current, windowPreferences, NULL, &rectangle);
				xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*current).window, atom._NET_WM_USER_TIME, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &userTime);
				(*current).mapped = true;
			}
			previousMonitor = monitor;
			if(monitorCurrent < monitorWall){
				inc monitorCurrent;
			}
			inc current;
			jmp configureWindowLoop;
		}
		current = (*windowSystem).windowInfoStart;
		jmp mapWindowLoop;
	}
	mapWindowLoop:{
		if(current < wall){
			if((*current).mapped){
				xcb_map_window(connection, (*current).window);
			}
			inc current;
			jmp mapWindowLoop;
		}
		(*windowSystem).mapped = true;
		ret true;
	}
}
CONFIGUREWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	Monitor *previousMonitor;
	Monitor *monitorCurrent;
	Monitor *monitorWall;
	struct{
		int32 /*--*/ x;
		int32 /*--*/ y;
		uint32 /*-*/ width;
		uint32 /*-*/ height;
	} valueList;
	if(!windowSystem or !(*windowSystem).windowInfoSize or !(*windowSystem).mapped or !monitorSystem or !(*monitorSystem).size or !windowPreferences or !whichMonitor or whichMonitor > ALL_WHICH_MONITOR){
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	previousMonitor = NULL;
	monitorCurrent = (*monitorSystem).start;
	monitorWall = monitorCurrent + (*monitorSystem).size - 1;
	jmp configureWindowLoop;
	configureWindowLoop:{
		if(current < wall){
			Monitor *monitor;
			ElementRectangle rectangle;
			if(!(monitor = getWhichMonitor(monitorSystem, whichMonitor))){
				monitor = monitorCurrent;
			}
			if(monitor != previousMonitor and getRectangle(monitor, NULL, windowPreferences, &rectangle) and rectangle.width and rectangle.height){
				valueList.x = rectangle.x;
				valueList.y = rectangle.y;
				valueList.width = rectangle.width;
				valueList.height = rectangle.height;
				if(rectangle.x != (*current).x or rectangle.y != (*current).y or rectangle.width != (*current).width or rectangle.height != (*current).height){
					(*current).x = rectangle.x;
					(*current).y = rectangle.y;
					(*current).width = rectangle.width;
					(*current).height = rectangle.height;
					xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &valueList);
					setWindowProperties(current, windowPreferences, valueList.x, valueList.y, valueList.width, valueList.height);
				}
				drawWindow(windowSystem, current, windowPreferences, NULL, &rectangle);
			}
			previousMonitor = monitor;
			if(monitorCurrent < monitorWall){
				inc monitorCurrent;
			}
			inc current;
			jmp configureWindowLoop;
		}
		current = (*windowSystem).windowInfoStart;
		jmp mapWindowLoop;
	}
	mapWindowLoop:{
		if(current < wall){
			if((*current).mapped){
				xcb_map_window(connection, (*current).window);
			}
			inc current;
			jmp mapWindowLoop;
		}
		(*windowSystem).mapped = true;
		ret true;
	}
}
DRAWWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	if(!windowSystem or !(*windowSystem).windowInfoSize or !monitorSystem or !windowPreferences){
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	jmp drawWindowLoop;
	drawWindowLoop:{
		if(current < wall){
			if((*current).mapped){
				drawWindow(windowSystem, current, windowPreferences, findWindowMonitor(monitorSystem, (*current).window), NULL);
			}
			inc current;
			jmp drawWindowLoop;
		}
		ret true;
	}
}
SETWINDOWPROPERTIES(){
	xcb_window_t window;
	uint32 desktop;
	pid_t pid;
	char hostname[256];
	xcb_atom_t type[1];
	xcb_atom_t state[1];
	struct{
		uint32 /*-*/ flags;
		int32 /*--*/ x;
		int32 /*--*/ y;
		int32 /*--*/ width;
		int32 /*--*/ height;
		int32 /*--*/ minWidth;
		int32 /*--*/ minHeight;
		int32 /*--*/ maxWidth;
		int32 /*--*/ maxHeight;
		int32 /*--*/ widthInc;
		int32 /*--*/ heightInc;
		int32 /*--*/ minAspectNumerator;
		int32 /*--*/ minAspectDenominarator;
		int32 /*--*/ maxAspectNumerator;
		int32 /*--*/ maxAspectDenominarator;
		int32 /*--*/ baseWidth;
		int32 /*--*/ baseHeight;
		int32 /*--*/ winGravity;
	} normalHints;
	struct{
		uint32 /*-*/ flags;
		uint32 /*-*/ input;
		uint32 /*-*/ initialState;
	} hints;
	struct{
		uint32 /*-*/ left;
		uint32 /*-*/ right;
		uint32 /*-*/ top;
		uint32 /*-*/ bottom;
		uint32 /*-*/ leftStartY;
		uint32 /*-*/ leftEndY;
		uint32 /*-*/ rightStartY;
		uint32 /*-*/ rightEndY;
		uint32 /*-*/ topStartX;
		uint32 /*-*/ topEndX;
		uint32 /*-*/ bottomStartX;
		uint32 /*-*/ bottomEndX;
	} strut;
	if(!windowInfo or !(*windowInfo).window){
		ret false;
	}
	window = (*windowInfo).window;
	desktop = 0xFFFFFFFF;
	pid = getpid();
	*hostname = '\0';
	if(gethostname(hostname, countof(hostname)) != GETHOSTNAME_SUCCESS){
		printTitledError("get hostname error", "could not get hostname");
	}
	*(type + 0) = atom._NET_WM_WINDOW_TYPE_NORMAL;
	*(state + 0) = XCB_NONE;
	normalHints.flags = USER_POSITION_NORMAL_HINT | USER_SIZE_NORMAL_HINT | PROGRAM_MINIMUM_SIZE_NORMAL_HINT | PROGRAM_MAXIMUM_SIZE_NORMAL_HINT | PROGRAM_RESIZE_INCREMENT_NORMAL_HINT | PROGRAM_ASPECT_NORMAL_HINT | PROGRAM_BASE_SIZE_NORMAL_HINT | PROGRAM_WINDOW_GRAVITY_NORMAL_HINT;
	normalHints.x = x;
	normalHints.y = y;
	normalHints.width = width;
	normalHints.height = height;
	normalHints.minWidth = width;
	normalHints.minHeight = height;
	normalHints.maxWidth = width;
	normalHints.maxHeight = height;
	normalHints.baseWidth = width;
	normalHints.baseHeight = height;
	normalHints.widthInc = 0;
	normalHints.heightInc = 0;
	normalHints.minAspectNumerator = 1;
	normalHints.minAspectDenominarator = 1;
	normalHints.maxAspectNumerator = 1;
	normalHints.maxAspectDenominarator = 1;
	normalHints.winGravity = XCB_GRAVITY_NORTH_WEST;
	hints.flags = INPUT_HINT | STATE_HINT;
	hints.input = false;
	hints.initialState = NORMAL_STATE;
	if((*windowPreferences).position){
		strut.left = 0;
		strut.right = 0;
		strut.top = 0;
		strut.bottom = 0;
		strut.leftStartY = 0;
		strut.leftEndY = 0;
		strut.rightStartY = 0;
		strut.rightEndY = 0;
		strut.topStartX = 0;
		strut.topEndX = 0;
		strut.bottomStartX = 0;
		strut.bottomEndX = 0;
		switch (*windowPreferences).position over
			to TOP_POSITION:{
				strut.top = height;
				strut.topStartX = x;
				strut.topEndX = x + width;
				brk;
			}
			to BOTTOM_POSITION:{
				strut.bottom = height;
				strut.bottomStartX = x;
				strut.bottomEndX = x + width;
				brk;
			}
			to LEFT_POSITION:{
				strut.left = width;
				strut.leftStartY = y;
				strut.leftEndY = y + height;
				brk;
			}
			to RIGHT_POSITION:{
				strut.right = width;
				strut.rightStartY = y;
				strut.rightEndY = y + height;
				brk;
			}
			off:{
				brk;
			}
		end
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_ICON_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_NORMAL_HINTS, atom.WM_SIZE_HINTS, bitsof(uint32), sizeof(normalHints) / sizeof(uint32), &normalHints);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_HINTS, atom.WM_HINTS, bitsof(uint32), sizeof(hints) / sizeof(uint32), &hints);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_CLASS, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME "\0" PROGRAM_NAME "\0"), PROGRAM_NAME "\0" PROGRAM_NAME "\0");
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_CLIENT_MACHINE, XCB_ATOM_STRING, bitsof(uint8), findStringLength(hostname), hostname);
	if(localeName){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_LOCALE_NAME, XCB_ATOM_STRING, bitsof(uint8), findStringLength(localeName), localeName);
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_ICON_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	if(desktop == 0xFFFFFFFF){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_DESKTOP, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &desktop);
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_WINDOW_TYPE, XCB_ATOM_ATOM, bitsof(uint32), countof(type), type);
	if(*state){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STATE, XCB_ATOM_ATOM, bitsof(uint32), countof(state), state);
	}
	if((*windowPreferences).position){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STRUT, XCB_ATOM_CARDINAL, bitsof(uint32), 4, &strut);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STRUT_PARTIAL, XCB_ATOM_CARDINAL, bitsof(uint32), 12, &strut);
	}
	/*! xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_ICON, , , , ); */
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_PID, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &pid);
	ret true;
}
DRAWWINDOW(){
	ElementRectangle _windowRectangle;
	if(!windowSystem or !windowInfo or !windowPreferences or (!monitor and !windowRectangle)){
		ret false;
	}
	jmp getRectangles;
	getRectangles:{
		if(!windowRectangle){
			windowRectangle = &_windowRectangle;
			if(!getRectangle(monitor, NULL, windowPreferences, windowRectangle) or !(*windowRectangle).width or !(*windowRectangle).height){
				ret false;
			}
		}
		jmp drawWindow;
	}
	drawWindow:{
		const xcb_pixmap_t circlePixmap = (*windowSystem).circlePixmap;
		const xcb_pixmap_t pixmap = (*windowInfo).bufferPixmap;
		const xcb_gcontext_t gc = (*windowInfo).gc;
		const uint width = (*windowRectangle).width;
		const uint height = (*windowRectangle).height;
		fillDrawable(pixmap, gc, 0, 0, width, height, (*windowPreferences).background);
		if(circlePixmap){
			const uint8 cornerUsed = (*windowPreferences).cornerUsed;
			const uint radius = (*windowPreferences).cornerRadius;
			const uint size = radius + 1;
			if(cornerUsed & TOP_LEFT_CORNER) /*-----*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, 0     , 0     , 0           , 0            , size, size);
			if(cornerUsed & TOP_RIGHT_CORNER) /*----*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, radius, 0     , width - size, 0            , size, size);
			if(cornerUsed & BOTTOM_LEFT_CORNER) /*--*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, 0     , radius, 0           , height - size, size, size);
			if(cornerUsed & BOTTOM_RIGHT_CORNER) /*-*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, radius, radius, width - size, height - size, size, size);
		}
		jmp drawWindowElements;
	}
	drawWindowElements:{
		jmp clearArea;
	}
	clearArea:{
		xcb_copy_area(connection, (*windowInfo).bufferPixmap, (*windowInfo).pixmap, (*windowInfo).gc, 0, 0, 0, 0, (*windowInfo).width, (*windowInfo).height);
		if((*windowSystem).mapped){
			xcb_clear_area(connection, false, (*windowInfo).window, 0, 0, 0, 0);
		}
		ret true;
	}
}
UNMAPWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	if(!windowSystem or !(*windowSystem).windowInfoSize or !(*windowSystem).mapped){
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	jmp unmapWindowLoop;
	unmapWindowLoop:{
		if(current < wall){
			if((*current).mapped){
				xcb_unmap_window(connection, (*current).window);
				(*current).mapped = false;
			}
			inc current;
			jmp unmapWindowLoop;
		}
		(*windowSystem).mapped = false;
		ret true;
	}
}
DESTROYWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	if(!windowSystem or !(*windowSystem).windowInfoSize){
		ret false;
	}
	unmapWindows(windowSystem);
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	jmp destroyWindowLoop;
	destroyWindowLoop:{
		if(current < wall){
			xcb_free_gc(connection, (*current).gc);
			xcb_free_pixmap(connection, (*current).pixmap);
			xcb_free_pixmap(connection, (*current).bufferPixmap);
			xcb_destroy_window(connection, (*current).window);
			inc current;
			jmp destroyWindowLoop;
		}
		ret true;
	}
}
GETRECTANGLE(){
	Monitor *monitor;
	int x;
	int y;
	int xOffset;
	int yOffset;
	uint width;
	uint height;
	uint horizontalPadding;
	uint verticalPadding;
	uint horizontalMargin;
	uint verticalMargin;
	int parentX;
	int parentY;
	uint parentWidth;
	uint parentHeight;
	if(_monitor){
		monitor = _monitor;
		parentX = (*monitor).leftX;
		parentY = (*monitor).topY;
		parentWidth = (*monitor).width;
		parentHeight = (*monitor).height;
	}elif(parentRectangle){
		monitor = (*parentRectangle).monitor;
		parentX = 0;
		parentY = 0;
		parentWidth = (*parentRectangle).width;
		parentHeight = (*parentRectangle).height;
		if(!monitor){
			ret false;
		}
	}else{
		ret false;
	}
	x = getTypedNumber((*preferences).x, (*preferences).xType, HORIZONTAL_AXIS, parentWidth, monitor);
	y = getTypedNumber((*preferences).y, (*preferences).yType, VERTICAL_AXIS, parentHeight, monitor);
	xOffset = getTypedNumber((*preferences).xOffset, (*preferences).xOffsetType, HORIZONTAL_AXIS, parentWidth, monitor);
	yOffset = getTypedNumber((*preferences).yOffset, (*preferences).yOffsetType, VERTICAL_AXIS, parentHeight, monitor);
	width = getTypedNumber((*preferences).width, (*preferences).widthType, HORIZONTAL_AXIS, parentWidth, monitor);
	height = getTypedNumber((*preferences).height, (*preferences).heightType, VERTICAL_AXIS, parentHeight, monitor);
	horizontalPadding = getTypedNumber((*preferences).padding, (*preferences).paddingType, HORIZONTAL_AXIS, parentWidth, monitor);
	verticalPadding = getTypedNumber((*preferences).padding, (*preferences).paddingType, VERTICAL_AXIS, parentHeight, monitor);
	horizontalMargin = getTypedNumber((*preferences).margin, (*preferences).marginType, HORIZONTAL_AXIS, parentWidth, monitor);
	verticalMargin = getTypedNumber((*preferences).margin, (*preferences).marginType, VERTICAL_AXIS, parentHeight, monitor);
	if((*preferences).position){
		if((*preferences).position < LEFT_POSITION){
			width = (*monitor).width;
		}
		if((*preferences).position >= LEFT_POSITION){
			height = (*monitor).height;
		}
	}
	if((*preferences).position == LEFT_POSITION){
		x = parentX + 0 * (parentWidth - width) / 2;
	}elif((*preferences).position == RIGHT_POSITION){
		x = parentX + 2 * (parentWidth - width) / 2;
	}elif((*preferences).horizontalAlignment){
		x = parentX + ((*preferences).horizontalAlignment - 1) * (parentWidth - width) / 2;
	}
	if((*preferences).position == TOP_POSITION){
		y = parentY + 0 * (parentHeight - height) / 2;
	}elif((*preferences).position == BOTTOM_POSITION){
		y = parentY + 2 * (parentHeight - height) / 2;
	}elif((*preferences).verticalAlignment){
		y = parentY + ((*preferences).verticalAlignment - 1) * (parentHeight - height) / 2;
	}
	(*rectangle).monitor = monitor;
	(*rectangle).x = x + xOffset;
	(*rectangle).y = y + yOffset;
	(*rectangle).width = width;
	(*rectangle).height = height;
	(*rectangle).horizontalPadding = horizontalPadding;
	(*rectangle).verticalPadding = verticalPadding;
	(*rectangle).horizontalMargin = horizontalMargin;
	(*rectangle).verticalMargin = verticalMargin;
	ret true;
}
GETTYPEDNUMBER(){
	switch type over
		to INTEGER_NUMBER_TYPE: /*----*/ ret number;
		to PERCENTAGE_NUMBER_TYPE: /*-*/ ret size * number / 100;
		to MILLIMETER_NUMBER_TYPE: /*-*/ jmp matchMillimeterType;
		off: /*-----------------------*/ ret 0;
	end
	matchMillimeterType: switch axis over
		to HORIZONTAL_AXIS: /*--------*/ ret (*monitor).width * number / (*monitor).millimeterWidth;
		to VERTICAL_AXIS: /*----------*/ ret (*monitor).height * number / (*monitor).millimeterHeight;
		off: /*-----------------------*/ ret 0;
	end
}
FINDWINDOW(){
	WindowInfo *current;
	WindowInfo *wall;
	if(!windowSystem or !(*windowSystem).windowInfoSize or !window){
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	jmp findWindowLoop;
	findWindowLoop:{
		if(current < wall){
			if((*current).window == window){
				ret true;
			}
			inc current;
			jmp findWindowLoop;
		}
		ret false;
	}
}
FINIWINDOWSYSTEM(){
	if(!windowSystem){
		ret false;
	}
	destroyWindows(windowSystem);
	free((*windowSystem).windowInfoStart);
	popPointer((*windowSystem).windowInfoToken);
	(*windowSystem).windowInfoSize = 0;
	(*windowSystem).windowInfoStart = NULL;
	(*windowSystem).windowInfoToken = 0;
	(*windowSystem).mapped = false;
	if((*windowSystem).circlePixmap){
		xcb_free_pixmap(connection, (*windowSystem).circlePixmap);
		(*windowSystem).circlePixmap = XCB_NONE;
	}
	ret true;
}



























#define INITSLEEPTHREADSYSTEM() /*-----------------------*/ local bool               initSleepThreadSystem(SleepThreadSystem *const sleepThreadSystem)
#define SETSLEEPTHREADOPERATION() /*---------------------*/ local bool               setSleepThreadOperation(SleepThreadSystem *const sleepThreadSystem, bool (*const risingOperation)(void *const arg), void *const risingOperationArgument, bool (*const fallingOperation)(void *const arg), void *const fallingOperationArgument, const bool loopOperation, const bool restartTimer)
#define SETSLEEPTHREADSLEEPTIME() /*---------------------*/ local bool               setSleepThreadSleepTime(SleepThreadSystem *const sleepThreadSystem, const uint milliseconds)
#define BOOTSLEEPTHREAD() /*-----------------------------*/ local bool               bootSleepThread(SleepThreadSystem *const sleepThreadSystem)
#define SIGNALSLEEPTHREAD() /*---------------------------*/ local bool               signalSleepThread(SleepThreadSystem *const sleepThreadSystem)
#define SLEEPTHREADMAIN() /*-----------------------------*/ local void *             sleepThreadMain(void *const arg)
#define QUITSLEEPTHREAD() /*-----------------------------*/ local bool               quitSleepThread(SleepThreadSystem *const sleepThreadSystem)
#define FINISLEEPTHREADSYSTEM() /*-----------------------*/ local bool               finiSleepThreadSystem(SleepThreadSystem *const sleepThreadSystem)

INITSLEEPTHREADSYSTEM(){
	if(!sleepThreadSystem){
		ret false;
	}
	(*sleepThreadSystem).risingOperation = NULL;
	(*sleepThreadSystem).risingOperationArgument = NULL;
	(*sleepThreadSystem).fallingOperation = NULL;
	(*sleepThreadSystem).fallingOperationArgument = NULL;
	(*sleepThreadSystem).seconds = 0;
	(*sleepThreadSystem).nanoseconds = 0;
	(*sleepThreadSystem).loopOperation = false;
	(*sleepThreadSystem).restartTimer = false;
	(*sleepThreadSystem).running = false;
	(*sleepThreadSystem).quittingThread = false;
	(*sleepThreadSystem).mutexCreated = false;
	(*sleepThreadSystem).condCreated = false;
	(*sleepThreadSystem).threadCreated = false;
	ret true;
}
SETSLEEPTHREADOPERATION(){
	if(!sleepThreadSystem){
		ret false;
	}
	(*sleepThreadSystem).risingOperation = risingOperation;
	(*sleepThreadSystem).risingOperationArgument = risingOperationArgument;
	(*sleepThreadSystem).fallingOperation = fallingOperation;
	(*sleepThreadSystem).fallingOperationArgument = fallingOperationArgument;
	(*sleepThreadSystem).loopOperation = loopOperation;
	(*sleepThreadSystem).restartTimer = restartTimer;
	ret true;
}
SETSLEEPTHREADSLEEPTIME(){
	if(!sleepThreadSystem){
		ret false;
	}
	(*sleepThreadSystem).seconds = milliseconds / 1000;
	(*sleepThreadSystem).nanoseconds = (milliseconds - (*sleepThreadSystem).seconds * 1000) * 1000000;
	ret true;
}
BOOTSLEEPTHREAD(){
	if(!sleepThreadSystem or (*sleepThreadSystem).threadCreated or (!(*sleepThreadSystem).risingOperation and !(*sleepThreadSystem).fallingOperation)){
		ret false;
	}
	if(!(*sleepThreadSystem).mutexCreated){
		(*sleepThreadSystem).mutexCreated = pthread_mutex_init(&(*sleepThreadSystem).mutex, NULL) == PTHREAD_MUTEX_INIT_SUCCESS;
		if(!(*sleepThreadSystem).mutexCreated){
			printTitledError("pthread error", "could not init sleep operation mutex");
			ret false;
		}
	}
	if(!(*sleepThreadSystem).condCreated){
		(*sleepThreadSystem).condCreated = pthread_cond_init(&(*sleepThreadSystem).cond, NULL) == PTHREAD_COND_INIT_SUCCESS;
		if(!(*sleepThreadSystem).condCreated){
			printTitledError("pthread error", "could not init sleep operation cond");
			ret false;
		}
	}
	(*sleepThreadSystem).threadCreated = pthread_create(&(*sleepThreadSystem).thread, NULL, &sleepThreadMain, sleepThreadSystem) == PTHREAD_CREATE_SUCCESS;
	if(!(*sleepThreadSystem).threadCreated){
		printTitledError("pthread error", "could not create sleep operation thread");
		ret false;
	}
	ret true;
}
SIGNALSLEEPTHREAD(){
	if(!sleepThreadSystem or !(*sleepThreadSystem).mutexCreated or !(*sleepThreadSystem).condCreated or !(*sleepThreadSystem).threadCreated or !(*sleepThreadSystem).running){
		ret false;
	}
	if(pthread_mutex_lock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock sleep operation mutex");
	}
	if(pthread_cond_signal(&(*sleepThreadSystem).cond) != PTHREAD_COND_SIGNAL_SUCCESS){
		printTitledError("pthread error", "could not signal sleep operation thread");
	}
	if(pthread_mutex_unlock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
		printTitledError("pthread error", "could not unlock sleep operation mutex");
	}
	ret true;
}
SLEEPTHREADMAIN(){
	SleepThreadSystem *const sleepThreadSystem = arg;
	struct timespec ts;
	int waitReturn;
	bool error;
	if(!sleepThreadSystem){
		ret NULL;
	}
	error = false;
	if(pthread_mutex_lock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock sleep operation mutex");
	}
	(*sleepThreadSystem).running = true;
	jmp waitIndefinitely;
	waitIndefinitely:{
		if(pthread_cond_wait(&(*sleepThreadSystem).cond, &(*sleepThreadSystem).mutex) != PTHREAD_COND_WAIT_SUCCESS){
			printTitledError("pthread error", "could not wait sleep operation mutex");
		}
		if((*sleepThreadSystem).quittingThread){
			jmp emergencyExit;
		}
		jmp conductRisingOperation;
	}
	conductRisingOperation:{
		if(globalsLockCreated and pthread_rwlock_rdlock(&globalsLock) != PTHREAD_RWLOCK_RDLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals read lock");
		}
		clock_gettime(CLOCK_REALTIME, &ts);
		ts.tv_sec += (*sleepThreadSystem).seconds;
		ts.tv_nsec += (*sleepThreadSystem).nanoseconds;
		if((*sleepThreadSystem).risingOperation){
			error = !(*(*sleepThreadSystem).risingOperation)((*sleepThreadSystem).risingOperationArgument);
		}
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals read lock");
		}
		if(error){
			error = false;
			jmp waitIndefinitely;
		}
		jmp waitUntilTimedOut;
	}
	waitUntilTimedOut:{
		if((*sleepThreadSystem).quittingThread){
			jmp emergencyExit;
		}
		waitReturn = pthread_cond_timedwait(&(*sleepThreadSystem).cond, &(*sleepThreadSystem).mutex, &ts);
		if((*sleepThreadSystem).quittingThread){
			jmp emergencyExit;
		}
		if(waitReturn != ETIMEDOUT){
			if(waitReturn != PTHREAD_COND_TIMEDWAIT_SUCCESS){
				printTitledError("pthread error", "could not wait sleep operation mutex");
			}
			if((*sleepThreadSystem).restartTimer){
				if(globalsLockCreated and pthread_rwlock_rdlock(&globalsLock) != PTHREAD_RWLOCK_RDLOCK_SUCCESS){
					printTitledError("pthread error", "could not lock globals read lock");
				}
				clock_gettime(CLOCK_REALTIME, &ts);
				ts.tv_sec += (*sleepThreadSystem).seconds;
				ts.tv_nsec += (*sleepThreadSystem).nanoseconds;
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
			}
			jmp waitUntilTimedOut;
		}
		jmp conductFallingOperation;
	}
	conductFallingOperation:{
		if(globalsLockCreated and pthread_rwlock_rdlock(&globalsLock) != PTHREAD_RWLOCK_RDLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals read lock");
		}
		if((*sleepThreadSystem).fallingOperation){
			error = !(*(*sleepThreadSystem).fallingOperation)((*sleepThreadSystem).fallingOperationArgument);
		}
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals read lock");
		}
		if(error){
			error = false;
			jmp waitIndefinitely;
		}
		jmp checkMode;
	}
	checkMode:{
		if((*sleepThreadSystem).loopOperation){
			jmp conductRisingOperation;
		}
		jmp waitIndefinitely;
	}
	emergencyExit:{
		(*sleepThreadSystem).threadCreated = false;
		(*sleepThreadSystem).running = false;
		if(pthread_mutex_unlock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock sleep operation mutex");
		}
		ret NULL;
	}
}
QUITSLEEPTHREAD(){
	if(!sleepThreadSystem or (!(*sleepThreadSystem).threadCreated and !(*sleepThreadSystem).condCreated and !(*sleepThreadSystem).mutexCreated)){
		ret false;
	}
	(*sleepThreadSystem).quittingThread = true;
	if((*sleepThreadSystem).threadCreated){
		if((*sleepThreadSystem).mutexCreated and (*sleepThreadSystem).condCreated){
			if(pthread_mutex_lock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
				printTitledError("pthread error", "could not lock sleep operation mutex");
			}
			if(pthread_cond_signal(&(*sleepThreadSystem).cond) != PTHREAD_COND_SIGNAL_SUCCESS){
				printTitledError("pthread error", "could not signal sleep operation thread");
			}
			if(pthread_mutex_unlock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
				printTitledError("pthread error", "could not unlock sleep operation mutex");
			}
		}
		if(pthread_join((*sleepThreadSystem).thread, NULL) != PTHREAD_JOIN_SUCCESS){
			printTitledError("pthread error", "could not join sleep operation thread");
		}
		(*sleepThreadSystem).threadCreated = false;
	}
	if((*sleepThreadSystem).condCreated){
		if(pthread_cond_destroy(&(*sleepThreadSystem).cond) != PTHREAD_COND_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy sleep operation cond");
		}
		(*sleepThreadSystem).condCreated = false;
	}
	if((*sleepThreadSystem).mutexCreated){
		if(pthread_mutex_destroy(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy sleep operation mutex");
		}
		(*sleepThreadSystem).mutexCreated = false;
	}
	(*sleepThreadSystem).quittingThread = false;
	ret true;
}
FINISLEEPTHREADSYSTEM(){
	if(!sleepThreadSystem){
		ret false;
	}
	quitSleepThread(sleepThreadSystem);
	(*sleepThreadSystem).risingOperation = NULL;
	(*sleepThreadSystem).risingOperationArgument = NULL;
	(*sleepThreadSystem).fallingOperation = NULL;
	(*sleepThreadSystem).fallingOperationArgument = NULL;
	(*sleepThreadSystem).seconds = 0;
	(*sleepThreadSystem).nanoseconds = 0;
	(*sleepThreadSystem).loopOperation = false;
	(*sleepThreadSystem).restartTimer = false;
	(*sleepThreadSystem).running = false;
	(*sleepThreadSystem).quittingThread = false;
	(*sleepThreadSystem).mutexCreated = false;
	(*sleepThreadSystem).condCreated = false;
	(*sleepThreadSystem).threadCreated = false;
	ret true;
}









INITSTRINGTREESYSTEM(){
	#define DATA_BLOCK_SIZE /*-*/ (256)
	if(!stringTreeSystem){
		ret false;
	}
	(*stringTreeSystem).stringArray = NULL;
	(*stringTreeSystem).dataSize = 0;
	(*stringTreeSystem).dataAllocated = 0;
	(*stringTreeSystem).dataStart = NULL;
	(*stringTreeSystem).dataToken = 0;
	(*stringTreeSystem).counter = 1;
	(*stringTreeSystem).returnedCounter = 0;
	ret true;
}
BULKINSERTSTRING(){
	const char *const *stringCurrent;
	if(!stringTreeSystem or !stringArray){
		ret false;
	}
	(*stringTreeSystem).stringArray = stringArray;
	stringCurrent = stringArray;
	jmp insertStringLoop;
	insertStringLoop:{
		insertString(stringTreeSystem, *stringCurrent);
		if(*(inc stringCurrent)){
			jmp insertStringLoop;
		}
		jmp trimMemory;
	}
	trimMemory:{
		if((*stringTreeSystem).dataAllocated){
			void *temp;
			(*stringTreeSystem).dataSize = (*stringTreeSystem).dataAllocated;
			temp = realloc((*stringTreeSystem).dataStart, (*stringTreeSystem).dataSize * sizeof(StringTreeNode));
			updatePointer((*stringTreeSystem).dataToken, temp);
			if(temp){
				(*stringTreeSystem).dataStart = temp;
			}
		}
		ret true;
	}
}
INSERTSTRING(){
	uint size;
	uint allocated;
	StringTreeNode *data;
	StringTreeNode *node;
	bool returnValue;
	if(!stringTreeSystem or !string){
		ret false;
	}
	size = (*stringTreeSystem).dataSize;
	allocated = (*stringTreeSystem).dataAllocated;
	data = (*stringTreeSystem).dataStart;
	jmp findString;
	findString:{
		node = getStringTreeNode(stringTreeSystem, &string);
		if(data and (!node or (*node).letter & b(10000000))){
			ret false;
		}
		jmp addLetterLoop;
	}
	addLetterLoop:{
		if(allocated == size){
			const uint nodeOffset = node - data;
			void *temp;
			size += DATA_BLOCK_SIZE;
			temp = realloc(data, size * sizeof(StringTreeNode));
			if(!(*stringTreeSystem).dataToken){
				(*stringTreeSystem).dataToken = pushPointer(temp, "string tree pointer", iFree);
			}else{
				updatePointer((*stringTreeSystem).dataToken, temp);
			}
			if(!temp){
				printTitledError("memory allocation error", "could not allocate memory for string tree nodes");
				size -= DATA_BLOCK_SIZE;
				returnValue = false;
				jmp completeString;
			}
			data = temp;
			node = data + nodeOffset;
			if(!allocated){
				(*node).letter = '\0';
				(*node).childrenAmount = 0;
				inc allocated;
			}
		}
		if((*node).childrenAmount >= STRING_TREE_NODE_CHILDREN_AMOUNT){
			printTitledError("insert string error", "out of space for new children in string node");
			ret false;
		}
		*((*node).offset + (*node).childrenAmount) = allocated;
		inc (*node).childrenAmount;
		node = data + allocated;
		(*node).childrenAmount = 0;
		inc allocated;
		if(*string){
			(*node).letter = *string;
			inc string;
			jmp addLetterLoop;
		}
		returnValue = true;
		jmp completeString;
	}
	completeString:{
		if(node){
			(*node).letter = b(10000000) | (*stringTreeSystem).counter;
			inc (*stringTreeSystem).counter;
			(*stringTreeSystem).dataSize = size;
			(*stringTreeSystem).dataAllocated = allocated;
			(*stringTreeSystem).dataStart = data;
		}
		ret returnValue;
	}
}
GETSTRINGTREENODE(){
	const uint16 *offsetCurrent;
	const uint16 *offsetWall;
	const char *string;
	StringTreeNode *data;
	StringTreeNode *node;
	char c;
	if(!stringTreeSystem or !(*stringTreeSystem).dataStart or !stringReturn){
		ret NULL;
	}
	data = (*stringTreeSystem).dataStart;
	node = data;
	string = *stringReturn;
	jmp findLetterLoop;
	findLetterLoop:{
		offsetCurrent = (*node).offset;
		offsetWall = offsetCurrent + (*node).childrenAmount;
		c = *string;
		c += (c >= 'A' and c <= 'Z') * 32 - (c == '_') * 50;
		jmp nextLetterLoop;
	}
	nextLetterLoop:{
		if(offsetCurrent < offsetWall){
			StringTreeNode *const child = data + *offsetCurrent;
			if((*child).letter == c and c){
				inc string;
				node = child;
				jmp findLetterLoop;
			}
			if((*child).letter & b(10000000) and !c){
				(*stringTreeSystem).returnedCounter = ((*child).letter & ~b(10000000)) - 1;
				*stringReturn = string;
				ret child;
			}
			inc offsetCurrent;
			jmp nextLetterLoop;
		}
		*stringReturn = string;
		ret node;
	}
}
FINDSTRINGTREESTRING(){
	StringTreeNode *const node = getStringTreeNode(stringTreeSystem, (void *)string);
	if(!node or !((*node).letter & b(10000000))){
		ret false;
	}
	ret true;
}
FINISTRINGTREESYSTEM(){
	if(!stringTreeSystem){
		ret false;
	}
	free((*stringTreeSystem).dataStart);
	popPointer((*stringTreeSystem).dataToken);
	(*stringTreeSystem).stringArray = NULL;
	(*stringTreeSystem).dataSize = 0;
	(*stringTreeSystem).dataAllocated = 0;
	(*stringTreeSystem).dataStart = NULL;
	(*stringTreeSystem).dataToken = 0;
	(*stringTreeSystem).counter = 1;
	(*stringTreeSystem).returnedCounter = 0;
	ret true;
	#undef  DATA_BLOCK_SIZE
}
INITSTDINSYSTEM(){
	#define STDIN_BLOCK_SIZE /*-*/ (1024)
	if(!stdinSystem){
		ret false;
	}
	(*stdinSystem).size = 0;
	(*stdinSystem).allocated = 0;
	(*stdinSystem).start = NULL;
	(*stdinSystem).current = NULL;
	(*stdinSystem).token = 0;
	(*stdinSystem).threadCreated = false;
	(*stdinSystem).operating = false;
	(*stdinSystem).quittingThread = false;
	ret true;
}
CONNECTSTDIN(){
	if(!stdinSystem or (*stdinSystem).threadCreated){
		ret false;
	}
	(*stdinSystem).threadCreated = pthread_create(&(*stdinSystem).thread, NULL, &stdinMain, stdinSystem) == PTHREAD_CREATE_SUCCESS;
	if(!(*stdinSystem).threadCreated){
		printTitledError("pthread error", "could not create stdin thread");
		ret false;
	}
	ret true;
}
STDINMAIN(){
	STDINSystem *const stdinSystem = arg;
	if(!stdinSystem){
		jmp emergencyExit;
	}
	jmp setupThread;
	setupThread:{
		int oldState;
		int oldType;
		if(pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldState) != PTHREAD_SETCANCELSTATE_SUCCESS){
			printTitledError("pthread error", "could not set stdin thread cancel state");
		}
		if(pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldType) != PTHREAD_SETCANCELTYPE_SUCCESS){
			printTitledError("pthread error", "could not set stdin thread cancel type");
		}
		jmp initializeBuffer;
	}
	initializeBuffer:{
		(*stdinSystem).size = STDIN_BLOCK_SIZE;
		(*stdinSystem).allocated = 0;
		(*stdinSystem).start = malloc((*stdinSystem).size * sizeof(char));
		(*stdinSystem).current = (*stdinSystem).start;
		(*stdinSystem).token = pushPointer((*stdinSystem).start, "stdin data pointer", iFree);
		if(!(*stdinSystem).start){
			printTitledError("memory allocation error", "could not allocate memory for stdin data");
			jmp emergencyExit;
		}
		jmp checkSTDIN;
	}
	checkSTDIN:{
		struct pollfd fds;
		fds.fd = STDIN_FILENO;
		fds.events = POLLIN;
		if(poll(&fds, 1, 10) > 0){
			jmp clearSTDINLoop;
		}
		jmp waitIndefinitely;
	}
	clearSTDINLoop:{
		if(fread((*stdinSystem).start, sizeof(char), (*stdinSystem).size, stdin) == (*stdinSystem).size){
			jmp clearSTDINLoop;
		}
		jmp waitIndefinitely;
	}
	waitIndefinitely:{
		char c;
		if((*stdinSystem).quittingThread){
			jmp emergencyExit;
		}
		c = fgetc(stdin);
		if((*stdinSystem).allocated == (*stdinSystem).size){
			const uint offset = (*stdinSystem).current - (*stdinSystem).start;
			void *temp;
			(*stdinSystem).size += STDIN_BLOCK_SIZE;
			temp = realloc((*stdinSystem).start, (*stdinSystem).size * sizeof(char));
			updatePointer((*stdinSystem).token, temp);
			if(!temp){
				printTitledError("memory allocation error", "could not allocate memory for stdin data");
				(*stdinSystem).size -= STDIN_BLOCK_SIZE;
				jmp emergencyExit;
			}
			(*stdinSystem).start = temp;
			(*stdinSystem).current = (*stdinSystem).start + offset;
		}
		*(*stdinSystem).current = c;
		if(c != '\n'){
			inc (*stdinSystem).current;
			inc (*stdinSystem).allocated;
			jmp waitIndefinitely;
		}
		*(*stdinSystem).current = EOF;
		(*stdinSystem).current = (*stdinSystem).start;
		if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals write lock");
		}
		(*stdinSystem).operating = true;
		readConfig(false, "stdin", &getNextSTDINCharacter, &getPreviousSTDINCharacter);
		(*stdinSystem).operating = false;
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals write lock");
		}
		(*stdinSystem).allocated = 0;
		(*stdinSystem).current = (*stdinSystem).start;
		jmp waitIndefinitely;
	}
	emergencyExit:{
		free((*stdinSystem).start);
		popPointer((*stdinSystem).token);
		(*stdinSystem).size = 0;
		(*stdinSystem).allocated = 0;
		(*stdinSystem).start = NULL;
		(*stdinSystem).current = NULL;
		(*stdinSystem).token = 0;
		(*stdinSystem).threadCreated = false;
		(*stdinSystem).quittingThread = false;
		ret NULL;
	}
}
GETNEXTSTDINCHARACTER(){
	STDINSystem *const stdinSystem = arg;
	if(!stdinSystem or !(*stdinSystem).current){
		ret EOF;
	}
	ret *(inc (*stdinSystem).current - 1);
}
GETPREVIOUSSTDINCHARACTER(){
	STDINSystem *const stdinSystem = arg;
	if(!stdinSystem or !(*stdinSystem).current){
		ret EOF;
	}
	ret *(dec (*stdinSystem).current);
}
DISCONNECTSTDIN(){
	if(!stdinSystem or !(*stdinSystem).threadCreated){
		ret false;
	}
	(*stdinSystem).quittingThread = true;
	if((*stdinSystem).threadCreated){
		if((*stdinSystem).operating){
			ret true;
		}
		if(pthread_cancel((*stdinSystem).thread) != PTHREAD_CANCEL_SUCCESS){
			printTitledError("pthread error", "could not cancel stdin thread");
		}
		if(pthread_join((*stdinSystem).thread, NULL) != PTHREAD_JOIN_SUCCESS){
			printTitledError("pthread error", "could not join stdin thread");
		}
		(*stdinSystem).threadCreated = false;
	}
	free((*stdinSystem).start);
	popPointer((*stdinSystem).token);
	(*stdinSystem).size = 0;
	(*stdinSystem).allocated = 0;
	(*stdinSystem).start = NULL;
	(*stdinSystem).current = NULL;
	(*stdinSystem).token = 0;
	(*stdinSystem).quittingThread = false;
	ret true;
}
FINISTDINSYSTEM(){
	if(!stdinSystem){
		ret false;
	}
	disconnectSTDIN(stdinSystem);
	(*stdinSystem).size = 0;
	(*stdinSystem).allocated = 0;
	(*stdinSystem).start = NULL;
	(*stdinSystem).current = NULL;
	(*stdinSystem).token = 0;
	(*stdinSystem).threadCreated = false;
	(*stdinSystem).operating = false;
	(*stdinSystem).quittingThread = false;
	ret true;
	#undef  STDIN_BLOCK_SIZE
}
INITSHAREDMEMORYSYSTEM(){
	#define STAT_FAILURE /*----*/ (-1)
	#define SHMGET_FAILURE /*--*/ (-1)
	#define SHMAT_FAILURE /*---*/ ((void *)-1)
	#define SHMCTL_FAILURE /*--*/ (-1)
	#define SHMDT_FAILURE /*---*/ (-1)
	#define STAT_PATH /*-------*/ ("/dev/shm/" PROGRAM_NAME)
	#define SHM_KEY /*---------*/ (((s.st_dev << 20) & 0xfff00000) | ((s.st_ino << 8) & 0x000fff00) | 0x00000045)
	#define SHARED_SIZE /*-----*/ (65536)
	#define SHM_HEADER_SIZE /*-*/ (sizeof(pthread_mutex_t) + sizeof(pthread_cond_t) + sizeof(uint8))
	#define SHM_FOOTER_SIZE /*-*/ (2)
	#define SHM_BODY_SIZE /*---*/ (SHM_SIZE - SHM_HEADER_SIZE - SHM_FOOTER_SIZE)
	#define SHM_NONE /*--------*/ (0)
	if(!sharedMemorySystem){
		ret false;
	}
	(*sharedMemorySystem).shmID = SHMGET_FAILURE;
	(*sharedMemorySystem).shmToken = 0;
	(*sharedMemorySystem).start = NULL;
	(*sharedMemorySystem).current = NULL;
	(*sharedMemorySystem).token = 0;
	(*sharedMemorySystem).mutexCreated = false;
	(*sharedMemorySystem).condCreated = false;
	(*sharedMemorySystem).threadCreated = false;
	(*sharedMemorySystem).operating = false;
	(*sharedMemorySystem).quittingFromInside = false;
	(*sharedMemorySystem).quittingThread = false;
	ret true;
}
CONNECTSHAREDMEMORY(){
	def struct stat Stat;
	FILE *file;
	Stat s;
	if(!sharedMemorySystem or (*sharedMemorySystem).shmID != SHMGET_FAILURE){
		ret false;
	}
	jmp createKeyFile;
	createKeyFile:{
		uint32 token;
		file = fopen(STAT_PATH, "w");
		token = pushPointer(file, "shm file", fclose);
		if(!file){
			file = fopen(STAT_PATH, "r");
			token = pushPointer(file, "shm file", fclose);
			if(!file){
				printError("%s%s: %s%s:%s %s %s %s\n", colorStart, programName, colorError, "shared memory error", colorEnd, "could neither create nor read", STAT_PATH, "file");
				ret false;
			}
		}
		fclose(file);
		popPointer(token);
		jmp getKeyFileStat;
	}
	getKeyFileStat:{
		if(stat(STAT_PATH, &s) == STAT_FAILURE){
			printTitledError("shared memory error", "could not generate shared memory key");
			ret false;
		}
		jmp createSharedMemory;
	}
	createSharedMemory:{
		(*sharedMemorySystem).shmID = shmget(SHM_KEY, SHARED_SIZE, IPC_CREAT | 0600);
		(*sharedMemorySystem).shmToken = pushPointer((void *)(int64)(*sharedMemorySystem).shmID, "shm id", ishmctl);
		if((*sharedMemorySystem).shmID == SHMGET_FAILURE){
			printTitledError("shared memory error", "could not create shared memory segment");
			ret false;
		}
		jmp attachToSharedMemory;
	}
	attachToSharedMemory:{
		(*sharedMemorySystem).start = shmat((*sharedMemorySystem).shmID, NULL, SHM_NONE);
		if((*sharedMemorySystem).start == SHMAT_FAILURE){
			printTitledError("shared memory error", "could not attach to shared memory");
			(*sharedMemorySystem).start = NULL;
			ret false;
		}
		(*sharedMemorySystem).token = pushPointer((*sharedMemorySystem).start, "shared memory pointer", shmdt);
		(*sharedMemorySystem).mutex = (void *)(*sharedMemorySystem).start;
		(*sharedMemorySystem).cond = (void *)((*sharedMemorySystem).start + sizeof(pthread_mutex_t));
		*((*sharedMemorySystem).start + SHM_HEADER_SIZE - sizeof(uint8)) = EMPTY_SHARED_STATUS;
		jmp createThreadObjects;
	}
	createThreadObjects:{
		pthread_mutexattr_t mutexAttributes;
		pthread_condattr_t condAttributes;
		if(pthread_mutexattr_init(&mutexAttributes) != PTHREAD_MUTEXATTR_INIT_SUCCESS){
			printTitledError("pthread error", "could not init shared mutex attributes");
		}
		if(pthread_mutexattr_setpshared(&mutexAttributes, PTHREAD_PROCESS_SHARED) != PTHREAD_MUTEXATTR_SETPSHARED_SUCCESS){
			printTitledError("pthread error", "could not set shared mutex shared process attribute");
		}
		(*sharedMemorySystem).mutexCreated = pthread_mutex_init((*sharedMemorySystem).mutex, &mutexAttributes) == PTHREAD_MUTEX_INIT_SUCCESS;
		if(!(*sharedMemorySystem).mutexCreated){
			printTitledError("pthread error", "could not init shared mutex");
		}
		if(pthread_mutexattr_destroy(&mutexAttributes) != PTHREAD_MUTEXATTR_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy shared mutex attributes");
		}
		if(pthread_condattr_init(&condAttributes) != PTHREAD_CONDATTR_INIT_SUCCESS){
			printTitledError("pthread error", "could not init shared cond attributes");
		}
		if(pthread_condattr_setpshared(&condAttributes, PTHREAD_PROCESS_SHARED) != PTHREAD_CONDATTR_SETPSHARED_SUCCESS){
			printTitledError("pthread error", "could not set shared cond shared process attribute");
		}
		(*sharedMemorySystem).condCreated = pthread_cond_init((*sharedMemorySystem).cond, &condAttributes) == PTHREAD_COND_INIT_SUCCESS;
		if(!(*sharedMemorySystem).condCreated){
			printTitledError("pthread error", "could not init shared cond");
		}
		if(pthread_condattr_destroy(&condAttributes) != PTHREAD_CONDATTR_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy shared cond attributes");
		}
		(*sharedMemorySystem).threadCreated = pthread_create(&(*sharedMemorySystem).thread, NULL, &sharedMemoryMain, sharedMemorySystem) == PTHREAD_CREATE_SUCCESS;
		if(!(*sharedMemorySystem).threadCreated){
			printTitledError("pthread error", "could not create shared memory thread");
			ret false;
		}
		ret true;
	}
}
SHAREDMEMORYMAIN(){
	SharedMemorySystem *const sharedMemorySystem = arg;
	uint8 *current;
	if(!sharedMemorySystem){
		ret NULL;
	}
	if(pthread_mutex_lock((*sharedMemorySystem).mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock shared mutex");
	}
	current = (*sharedMemorySystem).start + sizeof(pthread_mutex_t) + sizeof(pthread_cond_t);
	jmp waitIndefinitely;
	waitIndefinitely:{
		if(pthread_cond_wait((*sharedMemorySystem).cond, (*sharedMemorySystem).mutex) != PTHREAD_COND_WAIT_SUCCESS){
			printTitledError("pthread error", "could not wait shared mutex");
		}
		if((*sharedMemorySystem).quittingThread){
			*current = FULL_SHARED_STATUS;
			jmp emergencyExit;
		}
		if(*current == FULL_SHARED_STATUS){
			*current = EMPTY_SHARED_STATUS;
			if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
				printTitledError("pthread error", "could not lock globals write lock");
			}
			(*sharedMemorySystem).current = current + 1;
			(*sharedMemorySystem).operating = true;
			readConfig(false, "transmitter", &getNextSharedMemoryCharacter, &getPreviousSharedMemoryCharacter);
			(*sharedMemorySystem).operating = false;
			(*sharedMemorySystem).current = NULL;
			if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
				printTitledError("pthread error", "could not unlock globals write lock");
			}
			if(*current == FULL_SHARED_STATUS){
				(*sharedMemorySystem).quittingFromInside = true;
				jmp emergencyExit;
			}
			*current = EMPTY_SHARED_STATUS;
		}
		jmp waitIndefinitely;
	}
	emergencyExit:{
		if(pthread_mutex_unlock((*sharedMemorySystem).mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock shared mutex");
		}
		(*sharedMemorySystem).threadCreated = false;
		disconnectSharedMemory(sharedMemorySystem);
		ret NULL;
	}
}
GETNEXTSHAREDMEMORYCHARACTER(){
	SharedMemorySystem *const sharedMemorySystem = arg;
	if(!sharedMemorySystem or !(*sharedMemorySystem).current){
		ret EOF;
	}
	ret *(inc (*sharedMemorySystem).current - 1);
}
GETPREVIOUSSHAREDMEMORYCHARACTER(){
	SharedMemorySystem *const sharedMemorySystem = arg;
	if(!sharedMemorySystem or !(*sharedMemorySystem).current){
		ret EOF;
	}
	ret *(dec (*sharedMemorySystem).current);
}
DISCONNECTSHAREDMEMORY(){
	if(!sharedMemorySystem or (!(*sharedMemorySystem).threadCreated and !(*sharedMemorySystem).quittingFromInside)){
		ret false;
	}
	jmp destroyThreadObjects;
	destroyThreadObjects:{
		(*sharedMemorySystem).quittingThread = true;
		if((*sharedMemorySystem).threadCreated){
			if((*sharedMemorySystem).operating){
				*((*sharedMemorySystem).start + sizeof(pthread_mutex_t) + sizeof(pthread_cond_t)) = FULL_SHARED_STATUS;
				(*sharedMemorySystem).quittingThread = false;
				ret true;
			}
			if((*sharedMemorySystem).mutexCreated and (*sharedMemorySystem).condCreated){
				if(pthread_mutex_lock((*sharedMemorySystem).mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
					printTitledError("pthread error", "could not lock shared mutex");
				}
				if(pthread_cond_signal((*sharedMemorySystem).cond) != PTHREAD_COND_SIGNAL_SUCCESS){
					printTitledError("pthread error", "could not signal shared thread");
				}
				if(pthread_mutex_unlock((*sharedMemorySystem).mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock shared mutex");
				}
			}
			if(pthread_join((*sharedMemorySystem).thread, NULL) != PTHREAD_JOIN_SUCCESS){
				printTitledError("pthread error", "could not join shared thread");
			}
			(*sharedMemorySystem).threadCreated = false;
		}
		if((*sharedMemorySystem).cond and (*sharedMemorySystem).condCreated){
			if(pthread_cond_destroy((*sharedMemorySystem).cond) != PTHREAD_COND_DESTROY_SUCCESS){
				printTitledError("pthread error", "could not destroy shared cond");
			}
			(*sharedMemorySystem).condCreated = false;
		}
		if((*sharedMemorySystem).mutex and (*sharedMemorySystem).mutexCreated){
			if(pthread_mutex_destroy((*sharedMemorySystem).mutex) != PTHREAD_MUTEX_DESTROY_SUCCESS){
				printTitledError("pthread error", "could not destroy shared mutex");
			}
			(*sharedMemorySystem).mutexCreated = false;
		}
		jmp markForDeletion;
	}
	markForDeletion:{
		if((*sharedMemorySystem).shmID != SHMGET_FAILURE and shmctl((*sharedMemorySystem).shmID, IPC_RMID, NULL) == SHMCTL_FAILURE){
			printTitledError("shared memory error", "could not mark shared memory for deletion");
		}
		popPointer((*sharedMemorySystem).shmToken);
		(*sharedMemorySystem).shmID = SHMGET_FAILURE;
		(*sharedMemorySystem).shmToken = 0;
		jmp detach;
	}
	detach:{
		if((*sharedMemorySystem).start and shmdt((*sharedMemorySystem).start) == SHMDT_FAILURE){
			printTitledError("shared memory error", "could not detach from shared memory");
		}
		popPointer((*sharedMemorySystem).token);
		(*sharedMemorySystem).start = NULL;
		(*sharedMemorySystem).current = NULL;
		(*sharedMemorySystem).token = 0;
		(*sharedMemorySystem).quittingFromInside = false;
		(*sharedMemorySystem).quittingThread = false;
		ret true;
	}
}
FINISHAREDMEMORYSYSTEM(){
	if(!sharedMemorySystem){
		ret false;
	}
	disconnectSharedMemory(sharedMemorySystem);
	(*sharedMemorySystem).shmID = SHMGET_FAILURE;
	(*sharedMemorySystem).shmToken = 0;
	(*sharedMemorySystem).start = NULL;
	(*sharedMemorySystem).current = NULL;
	(*sharedMemorySystem).token = 0;
	(*sharedMemorySystem).mutexCreated = false;
	(*sharedMemorySystem).condCreated = false;
	(*sharedMemorySystem).threadCreated = false;
	(*sharedMemorySystem).operating = false;
	(*sharedMemorySystem).quittingFromInside = false;
	(*sharedMemorySystem).quittingThread = false;
	ret true;
	#undef  SHM_NONE
	#undef  SHM_BODY_SIZE
	#undef  SHM_FOOTER_SIZE
	#undef  SHM_HEADER_SIZE
	#undef  SHARED_SIZE
	#undef  SHM_KEY
	#undef  STAT_PATH
	#undef  SHMDT_FAILURE
	#undef  SHMCTL_FAILURE
	#undef  SHMAT_FAILURE
	#undef  SHMGET_FAILURE
	#undef  STAT_FAILURE
}
INITSHORTCUTSYSTEM(){
	#define MODIFIER_DATA_BLOCK_SIZE /*-*/ (32)
	if(!shortcutSystem){
		ret false;
	}
	(*shortcutSystem).modifierSize = 0;
	(*shortcutSystem).modifierAllocated = 0;
	(*shortcutSystem).modifierNotInUseOffset = 0;
	(*shortcutSystem).modifierStart = NULL;
	(*shortcutSystem).modifierToken = 0;
	setMemory((*shortcutSystem).codeListStart, 0, SHORTCUT_CODE_AMOUNT, sizeof(uint64));
	ret true;
}
INSERTSHORTCUT(){
	ModifierNode *node;
	if(!shortcutSystem or !onState or onState > RELEASE_SHORTCUT_STATE){
		ret false;
	}
	if((*shortcutSystem).modifierAllocated == (*shortcutSystem).modifierSize){
		void *temp;
		(*shortcutSystem).modifierSize += MODIFIER_DATA_BLOCK_SIZE;
		temp = realloc((*shortcutSystem).modifierStart, (*shortcutSystem).modifierSize * sizeof(ModifierNode));
		if(!(*shortcutSystem).modifierToken){
			(*shortcutSystem).modifierToken = pushPointer((*shortcutSystem).modifierStart, "shortcut modifier list pointer", iFree);
		}else{
			updatePointer((*shortcutSystem).modifierToken, temp);
		}
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for shortcuts");
			(*shortcutSystem).modifierSize -= MODIFIER_DATA_BLOCK_SIZE;
			ret false;
		}
		(*shortcutSystem).modifierStart = temp;
		if(!(*shortcutSystem).modifierAllocated){
			(*shortcutSystem).modifierAllocated = 1;
			(*shortcutSystem).modifierNotInUseOffset = 1;
		}
	}
	node = (*shortcutSystem).modifierStart + (*shortcutSystem).modifierNotInUseOffset;
	(*node).inUse = true;
	(*node).command = command;
	(*node).modifier = modifier;
	(*node).nextOffset = 0;
	(*node).string = string;
	(*node).stringToken = stringToken;
	(*node).field0 = field0;
	(*node).field1 = field1;
	(*node).field2 = field2;
	(*node).field3 = field3;
	(*node).field4 = field4;
	(*node).onState = onState;
	(*node).hasBeenPressed = false;
	if(!*((*shortcutSystem).codeListStart + code)){
		*((*shortcutSystem).codeListStart + code) = (*shortcutSystem).modifierNotInUseOffset;
	}else{
		const uint offset = *((*shortcutSystem).codeListWall + code);
		(*((*shortcutSystem).modifierStart + offset)).nextOffset = (*shortcutSystem).modifierNotInUseOffset - offset;
	}
	*((*shortcutSystem).codeListWall + code) = (*shortcutSystem).modifierNotInUseOffset;
	if((*shortcutSystem).modifierNotInUseOffset == (*shortcutSystem).modifierAllocated){
		inc (*shortcutSystem).modifierAllocated;
		inc (*shortcutSystem).modifierNotInUseOffset;
	}else{
		const ModifierNode *current = node + 1;
		const ModifierNode *const wall = (*shortcutSystem).modifierStart + (*shortcutSystem).modifierAllocated;
		jmp findNextAvailableModifierNodeSlotLoop;
		findNextAvailableModifierNodeSlotLoop:{
			if(current < wall and (*current).inUse){
				inc current;
				jmp findNextAvailableModifierNodeSlotLoop;
			}
			(*shortcutSystem).modifierNotInUseOffset = current - (*shortcutSystem).modifierStart;
		}
	}
	ret true;
}
GETNEXTSHORTCUT(){
	ModifierNode *current;
	int offset;
	if(!shortcutSystem or !nextOffset){
		ret false;
	}
	current = (*shortcutSystem).modifierStart;
	if(!*nextOffset){
		offset = *((*shortcutSystem).codeListStart + code);
		jmp findShortcutModifierLoop;
	}
	code = shortcutCode;
	modifier = shortcutModifier;
	offset = *nextOffset;
	jmp findShortcutModifierLoop;
	findShortcutModifierLoop:{
		if(offset){
			current += offset;
			if((*current).modifier == modifier){
				if(isRelease and !(*current).hasBeenPressed){
					jmp findShortcutModifierLoopControl;
				}
				shortcutCode = code;
				shortcutModifier = modifier;
				eventModifierNode = current;
				(*current).hasBeenPressed = !isRelease;
				if((*current).nextOffset){
					*nextOffset = current - (*shortcutSystem).modifierStart + (*current).nextOffset;
					ret true;
				}
				*nextOffset = 0;
				ret true;
			}
			jmp findShortcutModifierLoopControl;
		}
		*nextOffset = 0;
		ret false;
	}
	findShortcutModifierLoopControl:{
		offset = (*current).nextOffset;
		jmp findShortcutModifierLoop;
	}
}
REMOVESHORTCUT(){
	ModifierNode *modifierStart;
	ModifierNode *node;
	bool hasRemovedShortcut;
	if(!shortcutSystem){
		ret false;
	}
	modifierStart = (*shortcutSystem).modifierStart;
	node = modifierStart + *((*shortcutSystem).codeListStart + code);
	hasRemovedShortcut = false;
	if(node > modifierStart){
		ModifierNode *previousNode = NULL;
		uint modifierAllocated = (*shortcutSystem).modifierAllocated;
		uint modifierNotInUseOffset = (*shortcutSystem).modifierNotInUseOffset;
		jmp removeModifierLoop;
		removeModifierLoop:{
			const int nextOffset = (*node).nextOffset;
			if(modifier == (*node).modifier){
				(*node).inUse = false;
				free((*node).string);
				popPointer((*node).stringToken);
				if(!previousNode){
					*((*shortcutSystem).codeListStart + code) = !!nextOffset * *((*shortcutSystem).codeListStart + code) + nextOffset;
				}else{
					(*previousNode).nextOffset = !!nextOffset * (*previousNode).nextOffset + nextOffset;
				}
				if(node == modifierStart + modifierAllocated - 1){
					if(dec modifierAllocated < modifierNotInUseOffset){
						dec modifierNotInUseOffset;
					}
				}elif(node - modifierStart < modifierNotInUseOffset){
					modifierNotInUseOffset = node - modifierStart;
				}
				hasRemovedShortcut = true;
			}
			if(nextOffset){
				previousNode = node;
				node += nextOffset;
				jmp removeModifierLoop;
			}
			(*shortcutSystem).modifierAllocated = modifierAllocated;
			(*shortcutSystem).modifierNotInUseOffset = modifierNotInUseOffset;
		}
	}
	ret hasRemovedShortcut;
}
FINISHORTCUTSYSTEM(){
	const ModifierNode *current;
	const ModifierNode *wall;
	if(!shortcutSystem){
		ret false;
	}
	current = (*shortcutSystem).modifierStart;
	wall = current + (*shortcutSystem).modifierAllocated;
	jmp freeShortcutStringLoop;
	freeShortcutStringLoop:{
		if(inc current < wall){
			if((*current).inUse){
				free((*current).string);
				popPointer((*current).stringToken);
			}
			jmp freeShortcutStringLoop;
		}
		setMemory((*shortcutSystem).codeListStart, 0, SHORTCUT_CODE_AMOUNT, sizeof(uint64));
		free((*shortcutSystem).modifierStart);
		popPointer((*shortcutSystem).modifierToken);
		(*shortcutSystem).modifierSize = 0;
		(*shortcutSystem).modifierAllocated = 0;
		(*shortcutSystem).modifierNotInUseOffset = 0;
		(*shortcutSystem).modifierStart = NULL;
		(*shortcutSystem).modifierToken = 0;
		ret true;
	}
	#undef  MODIFIER_DATA_BLOCK_SIZE
}
SETCONFIGVARIABLES(){
	ret;
}
READCONFIG(){
	#define STATEMENT_BLOCK_SIZE /*-*/ (256)
	#define DEFAULT_CONFIG_PATH /*--*/ ("/etc/" PROGRAM_NAME "/" PROGRAM_NAME ".conf")
	const Instruction *const *currentScopeInstruction = globalScopeInstruction;
	const char *const *currentScopeInstructionList = globalInstructionList;
	const Instruction *instructionStart;
	const Instruction *instructionStartCopy;
	const Instruction *instructionCurrent;
	const Instruction *name0Instruction;
	const Instruction *name1Instruction;
	const Instruction *name2Instruction;
	const Instruction *name3Instruction;
	const Instruction *name4Instruction;
	const Instruction *nameList0Instruction;
	const Instruction *nameList1Instruction;
	const Instruction *nameList2Instruction;
	const Instruction *nameList3Instruction;
	const Instruction *nameList4Instruction;
	const Instruction *integer0Instruction;
	const Instruction *integer1Instruction;
	const Instruction *integer2Instruction;
	const Instruction *integer3Instruction;
	const Instruction *integer4Instruction;
	const Instruction *string0Instruction;
	const Instruction *string1Instruction;
	const Instruction *string2Instruction;
	const Instruction *string3Instruction;
	const Instruction *string4Instruction;
	const Instruction *image0Instruction;
	const Instruction *image1Instruction;
	const Instruction *image2Instruction;
	const Instruction *image3Instruction;
	const Instruction *image4Instruction;
	const char *imageErrorMessage;
	FILE *configFile = NULL;
	uint32 configFileToken;
	void *system = NULL;
	uint statementSize = STATEMENT_BLOCK_SIZE;
	char *statementStart = NULL;
	uint32 statementToken = 0;
	char *statementCurrent;
	char *statementWall = NULL;
	char *statementConcreteWall;
	uint8 name0Return;
	uint8 name1Return;
	uint8 name2Return;
	uint8 name3Return;
	uint8 name4Return;
	uint8 nameList0Return;
	uint8 nameList1Return;
	uint8 nameList2Return;
	uint8 nameList3Return;
	uint8 nameList4Return;
	int64 integer0Return;
	int64 integer1Return;
	int64 integer2Return;
	int64 integer3Return;
	int64 integer4Return;
	char *string0Return = NULL;
	uint32 string0Token = 0;
	char *string1Return = NULL;
	uint32 string1Token = 0;
	char *string2Return = NULL;
	uint32 string2Token = 0;
	char *string3Return = NULL;
	uint32 string3Token = 0;
	char *string4Return = NULL;
	uint32 string4Token = 0;
	Image image0Return;
	Image image1Return;
	Image image2Return;
	Image image3Return;
	Image image4Return;
	JmpPoint jmpPoint;
	uint fileLine = 1;
	uint statementLine = 0;
	char fileChar;
	uint itemAmount;
	char quote = '\0';
	uint currentScopeInstructionListSize = countof(globalInstructionList) - 1;
	StringTreeSystem *const *const *currentScopeInstructionData = globalScopeInstructionData;
	StringTreeSystem *const *instructionDataStart;
	StringTreeSystem *const *instructionDataStartCopy;
	StringTreeSystem *const *instructionDataCurrent;
	StringTreeSystem *currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
	image0Return.dataStart = NULL;
	image0Return.dataToken = 0;
	image1Return.dataStart = NULL;
	image1Return.dataToken = 0;
	image2Return.dataStart = NULL;
	image2Return.dataToken = 0;
	image3Return.dataStart = NULL;
	image3Return.dataToken = 0;
	image4Return.dataStart = NULL;
	image4Return.dataToken = 0;
	jmp setupPointers;
	setupPointers:{
		if(getNextConfigChar == &ifgetc){
			if(!createConfigFile){
				DIR *const dir = opendir(configPath);
				uint32 token = pushPointer(dir, "config directory argument", closedir);
				if(dir){
					closedir(dir);
					popPointer(token);
					printConfigError("config error", "config file is directory", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
			}
			configFile = fopen(configPath, "r");
			configFileToken = pushPointer(configFile, "config file", fclose);
			if(!configFile){
				#define BUFFER_SIZE /*-*/ (4096)
				FILE *defaultConfigFile;
				uint32 defaultConfigFileToken;
				if(!createConfigFile){
					printConfigError("config error", "could not open config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				configFile = fopen(configPath, "w");
				configFileToken = pushPointer(configFile, "config file", fclose);
				if(!configFile){
					printConfigError("config error", "could not create config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				defaultConfigFile = fopen(DEFAULT_CONFIG_PATH, "r");
				defaultConfigFileToken = pushPointer(defaultConfigFile, "default config file", fclose);
				if(!defaultConfigFile){
					remove(configPath);
					printTitledNamedError("config file error", "could not copy default configuration file from", DEFAULT_CONFIG_PATH);
					jmp configEmergencyExit;
				}
				copyConfigFileLoop:{
					char buffer[BUFFER_SIZE];
					size_t bytesRead;
					if((bytesRead = fread(buffer, sizeof(*buffer), sizeof(buffer), defaultConfigFile))){
						if(fwrite(buffer, sizeof(*buffer), bytesRead, configFile) != bytesRead){
							fclose(defaultConfigFile);
							popPointer(defaultConfigFileToken);
							remove(configPath);
							printTitledError("config copying error", "could not copy default config file correctly");
							jmp configEmergencyExit;
						}
						jmp copyConfigFileLoop;
					}
				}
				fclose(defaultConfigFile);
				popPointer(defaultConfigFileToken);
				fclose(configFile);
				popPointer(configFileToken);
				if(!(configFile = fopen(configPath, "r"))){
					printTitledError("config error", "could not open newly written file");
					jmp configEmergencyExit;
				}
				#undef  BUFFER_SIZE
			}
		}
		statementStart = malloc(statementSize * sizeof(char));
		statementToken = pushPointer(statementStart, "statement pointer", iFree);
		if(!statementStart){
			printTitledError("config error", "could not store user data");
			jmp configEmergencyExit;
		}
		if(getNextConfigChar == &ifgetc){
			system = configFile;
		}elif(getNextConfigChar == &getNextSTDINCharacter){
			system = &stdinSystem;
		}elif(getNextConfigChar == &getNextSharedMemoryCharacter){
			system = &sharedMemorySystem;
		}
		jmp getStatementStart;
	}
	getStatementStart:{
		#define EOF_N1 /*----------------------------*/ (EOF)
		#define ZER_00 /*----------------------------*/ ('\0')
		#define EOT_04 /*----------------------------*/ (0x04)
		#define ALR_07 /*----------------------------*/ ('\a')
		#define BSP_08 /*----------------------------*/ ('\b')
		#define TAB_09 /*----------------------------*/ ('\t')
		#define NLN_10 /*----------------------------*/ ('\n')
		#define VTB_11 /*----------------------------*/ ('\v')
		#define FFD_12 /*----------------------------*/ ('\f')
		#define CRE_13 /*----------------------------*/ ('\r')
		#define ESC_27 /*----------------------------*/ ('\e')
		#define SPC_32 /*----------------------------*/ (' ')
		#define DQT_34 /*----------------------------*/ ('\"')
		#define SQT_39 /*----------------------------*/ ('\'')
		#define AST_42 /*----------------------------*/ ('*')
		#define FSL_47 /*----------------------------*/ ('/')
		#define ZER_48 /*----------------------------*/ ('0')
		#define SCL_59 /*----------------------------*/ (';')
		#define QMK_63 /*----------------------------*/ ('?')
		#define BSL_92 /*----------------------------*/ ('\\')
		#define LOA_97 /*----------------------------*/ ('a')
		#define LOB_98 /*----------------------------*/ ('b')
		#define LOF_102 /*---------------------------*/ ('f')
		#define LON_110 /*---------------------------*/ ('n')
		#define LOR_114 /*---------------------------*/ ('r')
		#define LOT_116 /*---------------------------*/ ('t')
		#define LOV_118 /*---------------------------*/ ('v')
		#define OCB_123 /*---------------------------*/ ('{')
		#define BAR_124 /*---------------------------*/ ('|')
		#define CCB_125 /*---------------------------*/ ('}')
		#define GET_STATEMENT_JMP_POINT /*-----------*/ (0)
		#define STORE_WHITESPACE_JMP_POINT /*--------*/ (1)
		#define CHECK_COMMENT_JMP_POINT /*-----------*/ (2)
		#define STORE_BAR_JMP_POINT /*---------------*/ (3)
		#define GET_DOUBLE_QUOTATION_JMP_POINT /*----*/ (4)
		#define GET_SINGLE_QUOTATION_JMP_POINT /*----*/ (5)
		#define HANDLE_ESCAPE_CHARACTER_JMP_POINT /*-*/ (6)
		#define ENTER_SCOPE_JMP_POINT /*-------------*/ (7)
		#define GET_STATEMENT_END_JMP_POINT /*-------*/ (8)
		statementCurrent = statementStart;
		statementConcreteWall = statementStart + statementSize * sizeof(char);
		statementLine = 0;
		itemAmount = 0;
		free(string0Return);
		popPointer(string0Token);
		free(string1Return);
		popPointer(string1Token);
		free(string2Return);
		popPointer(string2Token);
		free(string3Return);
		popPointer(string3Token);
		free(string4Return);
		popPointer(string4Token);
		free(image0Return.dataStart);
		popPointer(image0Return.dataToken);
		free(image1Return.dataStart);
		popPointer(image1Return.dataToken);
		free(image2Return.dataStart);
		popPointer(image2Return.dataToken);
		free(image3Return.dataStart);
		popPointer(image3Return.dataToken);
		free(image4Return.dataStart);
		popPointer(image4Return.dataToken);
		name0Instruction = NULL;
		name1Instruction = NULL;
		name2Instruction = NULL;
		name3Instruction = NULL;
		name4Instruction = NULL;
		nameList0Instruction = NULL;
		nameList1Instruction = NULL;
		nameList2Instruction = NULL;
		nameList3Instruction = NULL;
		nameList4Instruction = NULL;
		integer0Instruction = NULL;
		integer1Instruction = NULL;
		integer2Instruction = NULL;
		integer3Instruction = NULL;
		integer4Instruction = NULL;
		string0Instruction = NULL;
		string1Instruction = NULL;
		string2Instruction = NULL;
		string3Instruction = NULL;
		string4Instruction = NULL;
		image0Instruction = NULL;
		image1Instruction = NULL;
		image2Instruction = NULL;
		image3Instruction = NULL;
		image4Instruction = NULL;
		string0Return = NULL;
		string0Token = 0;
		string1Return = NULL;
		string1Token = 0;
		string2Return = NULL;
		string2Token = 0;
		string3Return = NULL;
		string3Token = 0;
		string4Return = NULL;
		string4Token = 0;
		image0Return.dataStart = NULL;
		image0Return.dataToken = 0;
		image1Return.dataStart = NULL;
		image1Return.dataToken = 0;
		image2Return.dataStart = NULL;
		image2Return.dataToken = 0;
		image3Return.dataStart = NULL;
		image3Return.dataToken = 0;
		image4Return.dataStart = NULL;
		image4Return.dataToken = 0;
		jmp getStatement;
	}
	getStatement: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp checkCommentStoreCharacter;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	getDoubleQuotation: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getDoubleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getDoubleQuotationStoreCharacter;
		to DQT_34: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getDoubleQuotationStoreCharacter;
	end
	getSingleQuotation: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getSingleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getSingleQuotationStoreCharacter;
		to SQT_39: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getSingleQuotationStoreCharacter;
	end
	handleEscapeCharacter: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to DQT_34: /*--*/ fileChar = '\"'; /*-----------------*/ jmp storeEscapedCharacter;
		to SQT_39: /*--*/ fileChar = '\''; /*-----------------*/ jmp storeEscapedCharacter;
		to ZER_48: /*--*/ fileChar = '\0'; /*-----------------*/ jmp storeEscapedCharacter;
		to QMK_63: /*--*/ fileChar = '\?'; /*-----------------*/ jmp storeEscapedCharacter;
		to BSL_92: /*--*/ fileChar = '\\'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOA_97: /*--*/ fileChar = '\a'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOB_98: /*--*/ fileChar = '\b'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOF_102: /*-*/ fileChar = '\f'; /*-----------------*/ jmp storeEscapedCharacter;
		to LON_110: /*-*/ fileChar = '\n'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOR_114: /*-*/ fileChar = '\r'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOT_116: /*-*/ fileChar = '\t'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOV_118: /*-*/ fileChar = '\v'; /*-----------------*/ jmp storeEscapedCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	checkComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to AST_42: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreSingleLineComment;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	ignoreMultipleLineComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to AST_42: /*--*/ /*----------------------------------*/ jmp checkMultipleLineCommentEnd;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	end
	checkMultipleLineCommentEnd: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	end
	ignoreSingleLineComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreSingleLineComment;
	end
	endOfFile:{
		if(statementCurrent == statementStart){
			jmp successfulConfig;
		}
		if(getPreviousConfigChar){
			getPreviousConfigChar(system);
		}
		jmp completeStatement;
	}
	storeWhitespace:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp getStatement;
		}
		inc itemAmount;
		fileChar = '\0';
		jmp getStatementStoreCharacter;
	}
	completeStatement:{
		if(statementCurrent <= statementStart){
			jmp getStatement;
		}
		if(!*(statementCurrent - 1)){
			jmp getStatementEnd;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = GET_STATEMENT_END_JMP_POINT;
		jmp storeCharacter;
	}
	handleOpeningBracket:{
		if(statementCurrent <= statementStart){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray opening bracket error", "could not enter nameless scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(*(statementCurrent - 1)){
			inc itemAmount;
			fileChar = '\0';
			jmpPoint = ENTER_SCOPE_JMP_POINT;
			jmp storeCharacter;
		}
		jmp enterScope;
	}
	enterScope:{
		StringTreeSystem *stringTreeSystem;
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(currentScopeInstruction == globalScopeInstruction){
			stringTreeSystem = &globalScopesInstructionStringTreeSystem;
		}else{
			printConfigError("invalid scope error", "no scopes inside current scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(!findStringTreeString(stringTreeSystem, &statementCurrent)){
			printConfigError("invalid scope error", "invalid scope name", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(itemAmount > 1){
			/*! missing space between final argument and scope imminent */
			printConfigError("scope argument error", "too many arguments", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, (void *)1, (void *)1, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		currentScopeInstruction = scope1ScopeInstruction;
		currentScopeInstructionData = scope1ScopeInstructionData;
		currentScopeInstructionList = scope1ScopeInstructionList;
		currentScopeInstructionStringTreeSystem = &scope1ScopeInstructionStringTreeSystem;
		currentScopeInstructionListSize = countof(scope1ScopeInstructionList) - 1;
		jmp getStatementStart;
	}
	attemptStoreBar:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp storeBar;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = STORE_BAR_JMP_POINT;
		jmp storeCharacter;
	}
	storeBar:{
		fileChar = '|';
		jmpPoint = STORE_WHITESPACE_JMP_POINT;
		jmp storeCharacter;
	}
	handleClosingBracket:{
		if(statementCurrent > statementStart){
			if(getNextConfigChar != &ifgetc){
				getPreviousConfigChar(system);
				jmp completeStatement;
			}
			fseek(configFile, -1, SEEK_CUR);
			jmp completeStatement;
		}
		if(currentScopeInstruction == globalScopeInstruction){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray closing bracket error", "could not drop to previous config scope", '}', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(currentScopeInstruction == scope1ScopeInstruction){
			currentScopeInstruction = globalScopeInstruction;
			currentScopeInstructionData = globalScopeInstructionData;
			currentScopeInstructionList = globalInstructionList;
			currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
			currentScopeInstructionListSize = countof(globalInstructionList) - 1;
		}
		jmp getStatementStart;
	}
	storeEscapedCharacter:{
		*(statementCurrent - 1) = fileChar;
		if(quote == '\"'){
			jmp getDoubleQuotation;
		}
		jmp getSingleQuotation;
	}
	getStatementStoreCharacter:{
		jmpPoint = GET_STATEMENT_JMP_POINT;
		jmp storeCharacter;
	}
	getDoubleQuotationStoreCharacter:{
		jmpPoint = GET_DOUBLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	getSingleQuotationStoreCharacter:{
		jmpPoint = GET_SINGLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	handleEscapeCharacterStoreCharacter:{
		jmpPoint = HANDLE_ESCAPE_CHARACTER_JMP_POINT;
		jmp storeCharacter;
	}
	checkCommentStoreCharacter:{
		jmpPoint = CHECK_COMMENT_JMP_POINT;
		jmp storeCharacter;
	}
	storeCharacter:{
		if(statementCurrent >= statementConcreteWall){
			const uint offset = statementCurrent - statementStart;
			void *temp;
			statementSize += STATEMENT_BLOCK_SIZE;
			temp = realloc(statementStart, statementSize * sizeof(char));
			updatePointer(statementToken, temp);
			if(!temp){
				printConfigError("memory allocation error", "could not allocate memory for config statement", ';', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				statementSize -= STATEMENT_BLOCK_SIZE;
				jmp getStatementStart;
			}
			statementStart = temp;
			statementCurrent = statementStart + offset;
			statementConcreteWall = statementStart + statementSize * sizeof(char);
		}
		if(jmpPoint != CHECK_COMMENT_JMP_POINT and !statementLine){
			statementLine = fileLine;
		}
		*statementCurrent = fileChar;
		inc statementCurrent;
		switch jmpPoint over
			to GET_STATEMENT_JMP_POINT: /*-----------*/ jmp getStatement;
			to STORE_WHITESPACE_JMP_POINT: /*--------*/ jmp storeWhitespace;
			to CHECK_COMMENT_JMP_POINT: /*-----------*/ jmp checkComment;
			to STORE_BAR_JMP_POINT: /*---------------*/ jmp storeBar;
			to GET_DOUBLE_QUOTATION_JMP_POINT: /*----*/ jmp getDoubleQuotation;
			to GET_SINGLE_QUOTATION_JMP_POINT: /*----*/ jmp getSingleQuotation;
			to HANDLE_ESCAPE_CHARACTER_JMP_POINT: /*-*/ jmp handleEscapeCharacter;
			to ENTER_SCOPE_JMP_POINT: /*-------------*/ jmp enterScope;
			off: /*----------------------------------*/ jmp getStatementEnd;
		end
	}
	getStatementEnd:{
		if(statementCurrent > statementStart) /*-*/ jmp findStatement;
		if(!feof(configFile)) /*-----------------*/ jmp getStatementStart;
		/*---------------------------------------*/ jmp successfulConfig;
		#undef  GET_STATEMENT_END_JMP_POINT
		#undef  ENTER_SCOPE_JMP_POINT
		#undef  HANDLE_ESCAPE_CHARACTER_JMP_POINT
		#undef  GET_SINGLE_QUOTATION_JMP_POINT
		#undef  GET_DOUBLE_QUOTATION_JMPPOINT
		#undef  STORE_BAR_JMP_POINT
		#undef  CHECK_COMMENT_JMP_POINT
		#undef  STORE_WHITESPACE_JMP_POINT
		#undef  GET_STATEMENT_JMP_POINT
		#undef  CCB_125
		#undef  BAR_124
		#undef  OCB_123
		#undef  LOV_118
		#undef  LOT_116
		#undef  LOR_114
		#undef  LON_110
		#undef  LOF_102
		#undef  LOB_98
		#undef  LOA_97
		#undef  BSL_92
		#undef  QMK_63
		#undef  SCL_59
		#undef  ZER_48
		#undef  FSL_47
		#undef  AST_42
		#undef  SQT_39
		#undef  DQT_34
		#undef  SPC_32
		#undef  ESC_27
		#undef  CRE_13
		#undef  FFD_12
		#undef  VTB_11
		#undef  NLN_10
		#undef  TAB_09
		#undef  BSP_08
		#undef  ALR_07
		#undef  EOT_04
		#undef  ZER_00
		#undef  EOF_N1
	}
	findStatement:{
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(!findStringTreeString(currentScopeInstructionStringTreeSystem, &statementCurrent)){
			printConfigError("config error", "unrecognized instruction", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp printAllInstructionPatterns;
		}
		instructionStart = *(currentScopeInstruction + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionStartCopy = instructionStart;
		instructionCurrent = instructionStart;
		instructionDataStart = *(currentScopeInstructionData + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionDataStartCopy = instructionDataStart;
		instructionDataCurrent = instructionDataStart;
		if(*instructionCurrent == NONE_INSTRUCTION_TYPE){
			jmp unimplementedInstruction;
		}
		if(statementCurrent >= statementWall and *instructionCurrent != END_INSTRUCTION_TYPE){
			printConfigError("config error", "missing instruction body", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		inc statementCurrent;
		jmp switchInstructionLoop;
	}
	switchInstructionLoop: switch *instructionCurrent over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp unimplementedInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp matchName;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp matchNameList;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp matchInteger;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp matchString;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp matchImageString;
		off: /*---------------------------*/ jmp endOfInstruction;
	end
	unimplementedInstruction:{
		printConfigError("implementation error", "using unimplemented instruction", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchName:{
		char *s;
		uint8 *namePointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!name0Instruction){
			namePointer = &name0Return;
			name0Instruction = instructionCurrent;
		}elif(!name1Instruction){
			namePointer = &name1Return;
			name1Instruction = instructionCurrent;
		}elif(!name2Instruction){
			namePointer = &name2Return;
			name2Instruction = instructionCurrent;
		}elif(!name3Instruction){
			namePointer = &name3Return;
			name3Instruction = instructionCurrent;
		}else{
			namePointer = &name4Return;
			name4Instruction = instructionCurrent;
		}
		s = statementCurrent;
		if(!findStringTreeString(*instructionDataCurrent, &s)){
			printConfigError("match string error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		statementCurrent = s;
		inc statementCurrent;
		*namePointer = (**instructionDataCurrent).returnedCounter;
		jmp advanceDataInstruction;
	}
	matchNameList:{
		uint8 *nameListPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!nameList0Instruction){
			nameListPointer = &nameList0Return;
			nameList0Instruction = instructionCurrent;
		}elif(!nameList1Instruction){
			nameListPointer = &nameList1Return;
			nameList1Instruction = instructionCurrent;
		}elif(!nameList2Instruction){
			nameListPointer = &nameList2Return;
			nameList2Instruction = instructionCurrent;
		}elif(!nameList3Instruction){
			nameListPointer = &nameList3Return;
			nameList3Instruction = instructionCurrent;
		}else{
			nameListPointer = &nameList4Return;
			nameList4Instruction = instructionCurrent;
		}
		switch matchNameList(*instructionDataCurrent, statementWall, &statementCurrent, nameListPointer) over
			to INVALID_NAME_NAME_LIST: /*--*/ jmp invalidNameNameList;
			to PREMATURE_END_NAME_LIST: /*-*/ jmp prematureEndNameList;
			off: /*------------------------*/ jmp advanceDataInstruction;
		end
	}
	invalidNameNameList:{
		printConfigError("bar list error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	prematureEndNameList:{
		printConfigError("bar list error", "missing final name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchInteger:{
		int64 *integerPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!integer0Instruction){
			integerPointer = &integer0Return;
			integer0Instruction = instructionCurrent;
		}elif(!integer1Instruction){
			integerPointer = &integer1Return;
			integer1Instruction = instructionCurrent;
		}elif(!integer2Instruction){
			integerPointer = &integer2Return;
			integer2Instruction = instructionCurrent;
		}elif(!integer3Instruction){
			integerPointer = &integer3Return;
			integer3Instruction = instructionCurrent;
		}else{
			integerPointer = &integer4Return;
			integer4Instruction = instructionCurrent;
		}
		switch matchInteger(&statementCurrent, statementWall, integerPointer) over
			to NON_NUMBER_NUMBER: /*-------*/ jmp printNonNumberError;
			to OVERFLOWN_NUMBER_NUMBER: /*-*/ jmp printOverflownNumberError;
			to DIVIDED_BY_ZERO_NUMBER: /*--*/ jmp printDividedByZeroNumberError;
			off: /*------------------------*/ jmp advanceInstruction;
		end
	}
	printNonNumberError:{
		printConfigError("match integer error", "not a number", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printOverflownNumberError:{
		printConfigError("match integer error", "integer overflow", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printDividedByZeroNumberError:{
		printConfigError("match integer error", "integer divided by zero", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchString:{
		char **stringPointer;
		uint32 *stringTokenPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!string0Instruction){
			stringPointer = &string0Return;
			stringTokenPointer = &string0Token;
			string0Instruction = instructionCurrent;
		}elif(!string1Instruction){
			stringPointer = &string1Return;
			stringTokenPointer = &string1Token;
			string1Instruction = instructionCurrent;
		}elif(!string2Instruction){
			stringPointer = &string2Return;
			stringTokenPointer = &string2Token;
			string2Instruction = instructionCurrent;
		}elif(!string3Instruction){
			stringPointer = &string3Return;
			stringTokenPointer = &string3Token;
			string3Instruction = instructionCurrent;
		}else{
			stringPointer = &string4Return;
			stringTokenPointer = &string4Token;
			string4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, stringPointer, stringTokenPointer)){
			printConfigError("match string error", "could not allocate string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		jmp advanceInstruction;
	}
	matchImageString:{
		char *string = NULL;
		uint32 token = 0;
		Image *imagePointer;
		uint8 matchImageReturn;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!image0Instruction){
			imagePointer = &image0Return;
			image0Instruction = instructionCurrent;
		}elif(!image1Instruction){
			imagePointer = &image1Return;
			image1Instruction = instructionCurrent;
		}elif(!image2Instruction){
			imagePointer = &image2Return;
			image2Instruction = instructionCurrent;
		}elif(!image3Instruction){
			imagePointer = &image3Return;
			image3Instruction = instructionCurrent;
		}else{
			imagePointer = &image4Return;
			image4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, &string, &token)){
			printConfigError("match image error", "could not allocate image string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		matchImageReturn = matchImage(string, &imageErrorMessage, &image0Return);
		free(string);
		popPointer(token);
		switch matchImageReturn over
			to CANNOT_OPEN_MATCH_IMAGE: /*--------*/ jmp printCannotOpenReadConfig;
			to CANNOT_READ_MATCH_IMAGE: /*--------*/ jmp printCannotReadReadConfig;
			to UNSUPPORTED_FORMAT_MATCH_IMAGE: /*-*/ jmp printUnsupportedFormatReadConfig;
			to BAD_HEADER_MATCH_IMAGE: /*---------*/ jmp printBadHeaderReadConfig;
			to BAD_DEPTH_MATCH_IMAGE: /*----------*/ jmp printBadDepthReadConfig;
			to BAD_COMPRESSION_MATCH_IMAGE: /*----*/ jmp printBadCompressionReadConfig;
			to UNSUPPORTED_HEIGHT_MATCH_IMAGE: /*-*/ jmp printUnsupportedHeightReadConfig;
			to BAD_SIZE_MATCH_IMAGE: /*-----------*/ jmp printBadSizeReadConfig;
			to FAILED_MATCH_IMAGE: /*-------------*/ jmp printFailedReadConfig;
			to BAD_PIXELS_MATCH_IMAGE: /*---------*/ jmp printBadPixelsReadConfig;
			to BAD_IMAGE_MATCH_IMAGE: /*----------*/ jmp printBadImageReadConfig;
			off: /*-------------------------------*/ jmp advanceInstruction;
		end
	}
	printCannotOpenReadConfig:{
		printConfigError("match image error", "could not open image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printCannotReadReadConfig:{
		printConfigError("match image error", "could not read image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedFormatReadConfig:{
		printConfigError("match image error", "image file not bmp", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadHeaderReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadDepthReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadCompressionReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedHeightReadConfig:{
		printConfigError("match image error", "negative height is not supported", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadSizeReadConfig:{
		printConfigError("match image error", "could not traverse image past the header", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printFailedReadConfig:{
		printConfigError("match image error", "could not allocate pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadPixelsReadConfig:{
		printConfigError("match image error", "could not read pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadImageReadConfig:{
		printConfigError("match image error", "image is broken", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	endOfInstruction:{
		if(instructionStart == setInstruction){
			#define applySubinstruction(s, i) /*-*/ instructionStart = s##i##Subinstruction; instructionDataStart = s##i##SubinstructionData
			switch name0Return over
				/*!*/
				off: /*-*/ brk;
			end
		}
		if(instructionStart == doInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, Do); jmp assessSubinstruction;
				off: /*----------------*/ /*-----------------------------*/ brk;
			end
		}
		if(instructionStart == grabKeycodeInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabKeycode); jmp assessSubinstruction;
				off: /*----------------*/ /*--------------------------------------*/ brk;
			end
		}
		if(instructionStart == grabButtonInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabButton); jmp assessSubinstruction;
				off: /*----------------*/ /*-------------------------------------*/ brk;
			end
			#undef  applySubinstruction
		}
		if(statementCurrent < statementWall){
			printConfigError("config error", "extra parameters error", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(instructionStartCopy == helpInstruction){
			printError("%s%s: %s: line %u: %s%s:%s %s:\n", colorStart, programName, configPath, statementLine, colorError, "config help menu", colorEnd, displaySimpleConfigErrors? "contracted" : "expanded");
			jmp printAllInstructionPatterns;
		}
		if(instructionStartCopy == expandInstruction){
			displaySimpleConfigErrors = false;
			jmp getStatementStart;
		}
		if(instructionStartCopy == contractInstruction){
			displaySimpleConfigErrors = true;
			jmp getStatementStart;
		}
		if(instructionStartCopy == readConfigInstruction){
			readConfig(false, string0Return, &ifgetc, NULL);
			jmp getStatementStart;
		}
		if(instructionStartCopy == useTerminalInstruction){
			switch name0Return over
				to TRUE_BOOLEAN:{
					if(!connectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == useMessengerInstruction){
			switch name0Return over
				to TRUE_BOOLEAN:{
					if(!connectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == setInstruction){
			switch name0Return over
				/*!*/
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == doInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			end
			switch matchCommand(name0Return, string0Return, getNextConfigChar == &ifgetc? CONFIG_MATCH_COMMAND_ORIGIN : getNextConfigChar == &getNextSTDINCharacter? STDIN_MATCH_COMMAND_ORIGIN : TRANSMITTER_MATCH_COMMAND_ORIGIN, field0, field1, field2, field3, field4) over
				to TYPICAL_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to RESTART_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to EXIT_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				off:{
					printConfigError("config error", "do subinstruction not implemented yet", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionStart, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == grabKeycodeInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			end
			if(!insertShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_key_checked(connection, true, (*screen).root, nameList0Return, integer0Return, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab key on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == grabButtonInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			end
			if(!insertShortcut(&buttonShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_button_checked(connection, true, (*screen).root, XCB_EVENT_MASK_NO_EVENT, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, integer0Return, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab button on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabKeycodeInstruction){
			if(!removeShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find key to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_key_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab key from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabButtonInstruction){
			if(!removeShortcut(&buttonShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find button to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_button_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab button from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == stopInstruction){
			jmp successfulConfig;
		}
		jmp getStatementStart;
	}
	advanceInstruction:{
		inc instructionCurrent;
		jmp switchInstructionLoop;
	}
	advanceDataInstruction:{
		inc instructionCurrent;
		inc instructionDataCurrent;
		jmp switchInstructionLoop;
	}
	assessSubinstruction:{
		instructionCurrent = instructionStart + (instructionCurrent - instructionStartCopy);
		instructionDataCurrent = instructionDataStart + (instructionDataCurrent - instructionDataStartCopy);
		if(statementCurrent < statementWall){
			jmp switchInstructionLoop;
		}
		jmp printMissingArgumentError;
	}
	printMissingArgumentError:{
		printConfigError("config error", "missing argument error", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printAllInstructionPatterns:{
		const char *const *const wall = currentScopeInstructionList + currentScopeInstructionListSize;
		const char *const *current = currentScopeInstructionList;
		const Instruction *const *in = currentScopeInstruction;
		StringTreeSystem *const *const *da = currentScopeInstructionData;
		jmp printExpandedHelpInstructions;
		printExpandedHelpInstructions:{
			const Instruction *n = *in - 1;
			StringTreeSystem *const *d = *da;
			printError("\tpattern | %s", *current);
			jmp printHelpInstructionParametersLoop;
			printHelpInstructionParametersLoop: switch *(inc n) over
				to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
				to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
				to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
				to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
				to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
				to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
				off: /*---------------------------*/ jmp printHelpInstructionParametersLoopExit;
			end
			noneInstruction:{
				printError(" <unimplemented>");
				jmp printHelpInstructionParametersLoopExit;
			}
			nameInstruction:{
				if(displaySimpleConfigErrors){
					printError(" name");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" (%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
					printNameLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameLoop;
						}
						printError(")");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			nameListInstruction:{
				if(displaySimpleConfigErrors){
					printError(" list");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" ((%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
					printNameListOnceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListOnceLoop;
						}
						stringArray = (**d).stringArray;
						printError(")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
						inc stringArray;
						jmp printNameListTwiceLoop;
					}
					printNameListTwiceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListTwiceLoop;
						}
						printError("))*(?![\\s]*[|]))");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			numberInstruction:{
				if(displaySimpleConfigErrors){
					printError(" number");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
				jmp printHelpInstructionParametersLoop;
			}
			stringInstruction:{
				if(displaySimpleConfigErrors){
					printError(" string");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
			imageInstruction:{
				if(displaySimpleConfigErrors){
					printError(" image");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
		}
		printHelpInstructionParametersLoopExit:{
			inc in;
			inc da;
			if(displaySimpleConfigErrors){
				printError("\n");
			}else{
				printError(" $\n");
			}
			if(inc current < wall){
				jmp printExpandedHelpInstructions;
			}
			printError("\n");
			jmp getStatementStart;
		}
	}
	successfulConfig:{
		if(currentScopeInstruction != globalScopeInstruction){
			*statementCurrent = '\0';
			statementWall = statementCurrent;
			statementLine = fileLine;
			if(fileLine != 1){
				dec statementLine;
			}
			printConfigError("config error", "missing closing scope bracket", '\0', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		jmp configEmergencyExit;
	}
	configEmergencyExit:{
		if(configFile and fileLine == 1 and !statementLine){
			printConfigError("config warning", "empty config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		free(statementStart);
		popPointer(statementToken);
		if(configFile){
			fclose(configFile);
			popPointer(configFileToken);
		}
		jmp postReadConfig;
	}
	postReadConfig:{
		xcb_flush(connection);
		ret;
	}
	#undef  DEFAULT_CONFIG_PATH
	#undef  STATEMENT_BLOCK_SIZE
}
IFGETC(){
	if(!system){
		ret EOF;
	}
	ret fgetc(system);
}
MATCHNAMELIST(){
	char *current = *statementCurrentReturn;
	uint value = 0;
	jmp matchNameLoop;
	matchNameLoop:{
		if(!findStringTreeString(stringTreeSystem, &current)){
			ret INVALID_NAME_NAME_LIST;
		}
		value |= !!(*stringTreeSystem).returnedCounter * (1 << ((*stringTreeSystem).returnedCounter - 1));
		jmp matchBar;
	}
	matchBar: switch *(inc current) over
		to '\0': /*-*/ jmp endCheck;
		to '|': /*--*/ jmp advance;
		off: /*-----*/ jmp successful;
	end
	endCheck:{
		if(current >= statementWall){
			jmp successful;
		}
		jmp matchBar;
	}
	advance:{
		if(inc current >= statementWall){
			ret PREMATURE_END_NAME_LIST;
		}
		inc current;
		jmp matchNameLoop;
	}
	successful:{
		*valueReturn = value;
		*statementCurrentReturn = current;
		ret SUCCESS_NAME_LIST;
	}
}
MATCHINTEGER(){
	#define LEVEL0_JMP_POINT /*-*/ (0)
	#define LEVEL1_JMP_POINT /*-*/ (1)
	#define LEVEL2_JMP_POINT /*-*/ (2)
	char *current = *statementCurrent - 1;
	int64 number = 0;
	char op = '\0';
	JmpPoint jmpPoint;
	int64 i0 = 0;
	int64 i1 = 0;
	char o0 = '\0';
	char o1 = '\0';
	jmpPoint = LEVEL0_JMP_POINT;
	jmp matchWhitespace0Loop;
	matchWhitespace0Loop:{
		if(inc current >= statementWall){
			number = 0;
			op = '\0';
			jmp matchOperationReturnPoint;
		}
		switch *current over
			to '\0': /*-*/ jmp matchOperation;
			to '\t': /*-*/ jmp matchWhitespace0Loop;
			to '\n': /*-*/ jmp matchWhitespace0Loop;
			to '\v': /*-*/ jmp matchWhitespace0Loop;
			to '\f': /*-*/ jmp matchWhitespace0Loop;
			to '\r': /*-*/ jmp matchWhitespace0Loop;
			to ' ': /*--*/ jmp matchWhitespace0Loop;
			off: /*-----*/ jmp matchInteger;
		end
	}
	matchInteger:{
		number = 0;
		dec current;
		jmp initialCheck;
	}
	initialCheck: switch *(inc current) over
		to '0': /*-*/ /*--------*/ jmp formatCheck;
		to '1': /*-*/ dec current; jmp matchDecimalLoop;
		to '2': /*-*/ dec current; jmp matchDecimalLoop;
		to '3': /*-*/ dec current; jmp matchDecimalLoop;
		to '4': /*-*/ dec current; jmp matchDecimalLoop;
		to '5': /*-*/ dec current; jmp matchDecimalLoop;
		to '6': /*-*/ dec current; jmp matchDecimalLoop;
		to '7': /*-*/ dec current; jmp matchDecimalLoop;
		to '8': /*-*/ dec current; jmp matchDecimalLoop;
		to '9': /*-*/ dec current; jmp matchDecimalLoop;
		to '+': /*-*/ /*--------*/ jmp matchOperation;
		to '-': /*-*/ /*--------*/ jmp matchOperation;
		to '*': /*-*/ /*--------*/ jmp matchOperation;
		to '/': /*-*/ /*--------*/ jmp matchOperation;
		off: /*----*/ /*--------*/ jmp matchMacro;
	end
	formatCheck: switch *(inc current) over
		to '\0': /*-*/ /*--------*/ jmp matchOperation;
		to '\t': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ /*--------*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ dec current; jmp matchOctalLoop;
		to '1': /*--*/ dec current; jmp matchOctalLoop;
		to '2': /*--*/ dec current; jmp matchOctalLoop;
		to '3': /*--*/ dec current; jmp matchOctalLoop;
		to '4': /*--*/ dec current; jmp matchOctalLoop;
		to '5': /*--*/ dec current; jmp matchOctalLoop;
		to '6': /*--*/ dec current; jmp matchOctalLoop;
		to '7': /*--*/ dec current; jmp matchOctalLoop;
		to 'B': /*--*/ /*--------*/ jmp matchBinaryLoop;
		to 'b': /*--*/ /*--------*/ jmp matchBinaryLoop;
		to 'X': /*--*/ /*--------*/ jmp matchHexadecimalLoop;
		to 'x': /*--*/ /*--------*/ jmp matchHexadecimalLoop;
		to '+': /*--*/ /*--------*/ jmp matchOperation;
		to '-': /*--*/ /*--------*/ jmp matchOperation;
		to '*': /*--*/ /*--------*/ jmp matchOperation;
		to '/': /*--*/ /*--------*/ jmp matchOperation;
		off: /*-----*/ /*--------*/ jmp nonNumber;
	end
	matchBinaryLoop: switch *(inc current) over
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateBinary;
		to '1': /*--*/ jmp calculateBinary;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	end
	matchOctalLoop: switch *(inc current) over
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateOctal;
		to '1': /*--*/ jmp calculateOctal;
		to '2': /*--*/ jmp calculateOctal;
		to '3': /*--*/ jmp calculateOctal;
		to '4': /*--*/ jmp calculateOctal;
		to '5': /*--*/ jmp calculateOctal;
		to '6': /*--*/ jmp calculateOctal;
		to '7': /*--*/ jmp calculateOctal;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	end
	matchDecimalLoop: switch *(inc current) over
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateDecimal;
		to '1': /*--*/ jmp calculateDecimal;
		to '2': /*--*/ jmp calculateDecimal;
		to '3': /*--*/ jmp calculateDecimal;
		to '4': /*--*/ jmp calculateDecimal;
		to '5': /*--*/ jmp calculateDecimal;
		to '6': /*--*/ jmp calculateDecimal;
		to '7': /*--*/ jmp calculateDecimal;
		to '8': /*--*/ jmp calculateDecimal;
		to '9': /*--*/ jmp calculateDecimal;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	end
	matchHexadecimalLoop: switch *(inc current) over
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateHexadecimal;
		to '1': /*--*/ jmp calculateHexadecimal;
		to '2': /*--*/ jmp calculateHexadecimal;
		to '3': /*--*/ jmp calculateHexadecimal;
		to '4': /*--*/ jmp calculateHexadecimal;
		to '5': /*--*/ jmp calculateHexadecimal;
		to '6': /*--*/ jmp calculateHexadecimal;
		to '7': /*--*/ jmp calculateHexadecimal;
		to '8': /*--*/ jmp calculateHexadecimal;
		to '9': /*--*/ jmp calculateHexadecimal;
		to 'A': /*--*/ jmp calculateHexadecimal;
		to 'B': /*--*/ jmp calculateHexadecimal;
		to 'C': /*--*/ jmp calculateHexadecimal;
		to 'D': /*--*/ jmp calculateHexadecimal;
		to 'E': /*--*/ jmp calculateHexadecimal;
		to 'F': /*--*/ jmp calculateHexadecimal;
		to 'a': /*--*/ jmp calculateHexadecimal;
		to 'b': /*--*/ jmp calculateHexadecimal;
		to 'c': /*--*/ jmp calculateHexadecimal;
		to 'd': /*--*/ jmp calculateHexadecimal;
		to 'e': /*--*/ jmp calculateHexadecimal;
		to 'f': /*--*/ jmp calculateHexadecimal;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	end
	matchMacro:{
		if(!findStringTreeString(&macroStringTreeSystem, &current)){
			jmp nonNumber;
		}
		if(macroStringTreeSystem.returnedCounter < 5){
			number = macroStringTreeSystem.returnedCounter;
			inc number;
		}elif(macroStringTreeSystem.returnedCounter < 9){
			number = macroStringTreeSystem.returnedCounter - 5;
		}elif(macroStringTreeSystem.returnedCounter < 11){
			number = macroStringTreeSystem.returnedCounter - 9;
		}elif(macroStringTreeSystem.returnedCounter < 15){
			number = macroStringTreeSystem.returnedCounter - 11;
		}elif(macroStringTreeSystem.returnedCounter < 17){
			number = macroStringTreeSystem.returnedCounter - 15;
		}else{
			number = 0;
		}
		switch *current over
			to '\0': /*-*/ jmp matchOperation;
			to '\t': /*-*/ jmp matchWhitespace1Loop;
			to '\n': /*-*/ jmp matchWhitespace1Loop;
			to '\v': /*-*/ jmp matchWhitespace1Loop;
			to '\f': /*-*/ jmp matchWhitespace1Loop;
			to '\r': /*-*/ jmp matchWhitespace1Loop;
			to ' ': /*--*/ jmp matchWhitespace1Loop;
			to '+': /*--*/ jmp matchOperation;
			to '-': /*--*/ jmp matchOperation;
			to '*': /*--*/ jmp matchOperation;
			to '/': /*--*/ jmp matchOperation;
			off: /*-----*/ jmp nonNumber;
		end
	}
	calculateBinary:{
		const int copy = number;
		number = number * 2 + *current - 48;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchBinaryLoop;
	}
	calculateOctal:{
		const int copy = number;
		number = number * 8 + *current - 48;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchOctalLoop;
	}
	calculateDecimal:{
		const int copy = number;
		number = number * 10 + *current - 48;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchDecimalLoop;
	}
	calculateHexadecimal:{
		const int copy = number;
		number = number * 16 + *current - (*current >= '0') * 48 - (*current >= 'A') * 7 - (*current >= 'a') * 32;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchHexadecimalLoop;
	}
	matchWhitespace1Loop:{
		if(inc current >= statementWall){
			op = '\0';
			jmp matchOperationReturnPoint;
		}
		switch *current over
			to '\0': /*-*/ jmp matchOperation;
			to '\t': /*-*/ jmp matchWhitespace1Loop;
			to '\n': /*-*/ jmp matchWhitespace1Loop;
			to '\v': /*-*/ jmp matchWhitespace1Loop;
			to '\f': /*-*/ jmp matchWhitespace1Loop;
			to '\r': /*-*/ jmp matchWhitespace1Loop;
			to ' ': /*--*/ jmp matchWhitespace1Loop;
			off: /*-----*/ jmp matchOperation;
		end
	}
	matchOperation: switch *current over
		to '+': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		to '-': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		to '*': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		to '/': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		off: /*----*/ op = '\0'; /*-----*/ jmp matchOperationReturnPoint;
	end
	matchOperationReturnPoint: switch jmpPoint over
		to LEVEL0_JMP_POINT: /*-*/ jmp switchOperation0;
		to LEVEL1_JMP_POINT: /*-*/ jmp switchOperation1;
		off: /*-----------------*/ jmp switchOperation2;
	end
	switchOperation0: switch op over
		to '\0': /*-*/ jmp level0;
		to '+': /*--*/ jmp level1;
		to '-': /*--*/ jmp level1;
		to '*': /*--*/ jmp level2;
		to '/': /*--*/ jmp level2;
	end
	switchOperation1: switch op over
		to '\0': /*-*/ jmp level1End;
		to '+': /*--*/ jmp level1FoundLevel1;
		to '-': /*--*/ jmp level1FoundLevel1;
		to '*': /*--*/ jmp level2;
		to '/': /*--*/ jmp level2;
	end
	switchOperation2: switch op over
		to '\0': /*-*/ jmp level2End;
		to '+': /*--*/ jmp level2FoundLevel1;
		to '-': /*--*/ jmp level2FoundLevel1;
		to '*': /*--*/ jmp level2FoundLevel2;
		to '/': /*--*/ jmp level2FoundLevel2;
	end
	level0:{
		i0 = number;
		jmp validNumber;
	}
	level1:{
		i0 = number;
		o0 = op;
		jmpPoint = LEVEL1_JMP_POINT;
		jmp matchWhitespace0Loop;
	}
	level2:{
		i1 = number;
		o1 = op;
		jmpPoint = LEVEL2_JMP_POINT;
		jmp matchWhitespace0Loop;
	}
	level1End:{
		if(o0 == '+'){
			i0 += number;
		}else{
			i0 -= number;
		}
		o0 = op;
		jmp validNumber;
	}
	level1FoundLevel1:{
		if(o0 == '+'){
			i0 += number;
		}else{
			i0 -= number;
		}
		o0 = op;
		jmp matchWhitespace0Loop;
	}
	level2End:{
		if(o1 == '*'){
			i1 *= number;
		}else{
			if(!number){
				jmp dividedByZeroNumber;
			}
			i1 /= number;
		}
		switch o0 over
			to '\0': /*-*/ i0  = i1; jmp validNumber;
			to '+': /*--*/ i0 += i1; jmp validNumber;
			to '-': /*--*/ i0 -= i1; jmp validNumber;
		end
	}
	level2FoundLevel1:{
		if(o1 == '*'){
			i1 *= number;
		}else{
			if(!number){
				jmp dividedByZeroNumber;
			}
			i1 /= number;
		}
		switch o0 over
			to '\0': /*-*/ o1 = '\0'; /*-*/ number = i1; jmp level1;
			to '+': /*--*/ i0 += i1; /*--*/ number = i0; jmp level1;
			to '-': /*--*/ i0 -= i1; /*--*/ number = i0; jmp level1;
		end
	}
	level2FoundLevel2:{
		if(o1 == '*'){
			i1 *= number;
		}else{
			if(!number){
				jmp dividedByZeroNumber;
			}
			i1 /= number;
		}
		o1 = op;
		jmp matchWhitespace0Loop;
	}
	validNumber:{
		*statementCurrent = current + 1;
		*returnValue = i0;
		ret VALID_NUMBER_NUMBER;
	}
	nonNumber:{
		*statementCurrent = current + 1;
		ret NON_NUMBER_NUMBER;
	}
	overflownNumber:{
		*statementCurrent = current + 1;
		ret OVERFLOWN_NUMBER_NUMBER;
	}
	dividedByZeroNumber:{
		*statementCurrent = current + 1;
		ret DIVIDED_BY_ZERO_NUMBER;
	}
	#undef  LEVEL2_JMP_POINT
	#undef  LEVEL1_JMP_POINT
	#undef  LEVEL0_JMP_POINT
}
MATCHSTRING(){
	#define STRING_BLOCK_SIZE /*-*/ (1024)
	uint size = STRING_BLOCK_SIZE;
	char *dataStart = malloc(size * sizeof(char));
	uint32 dataToken = pushPointer(dataStart, "matched string pointer", iFree);
	uint allocated = 0;
	char *dataCurrent = dataStart;
	char *current = *statementCurrent;
	jmp validateMalloc;
	validateMalloc:{
		if(!dataStart){
			ret false;
		}
		jmp copyStringLoop;
	}
	copyStringLoop:{
		if(allocated == size){
			const uint offset = dataCurrent - dataStart;
			void *temp;
			size += STRING_BLOCK_SIZE;
			temp = realloc(dataStart, size * sizeof(char));
			updatePointer(dataToken, temp);
			if(!temp){
				free(dataStart);
				popPointer(dataToken);
				ret false;
			}
			dataStart = temp;
			dataCurrent = dataStart + offset;
		}
		*dataCurrent = *current;
		inc allocated;
		if(*current){
			inc current;
			inc dataCurrent;
			jmp copyStringLoop;
		}
		inc current;
		jmp trimMemory;
	}
	trimMemory:{
		void *const temp = realloc(dataStart, allocated * sizeof(char));
		updatePointer(dataToken, temp);
		if(temp){
			dataStart = temp;
		}
		jmp returnValidString;
	}
	returnValidString:{
		*statementCurrent = current;
		*stringReturn = dataStart;
		*stringToken = dataToken;
		ret true;
	}
	#undef  STRING_BLOCK_SIZE
}
MATCHIMAGE(){
	#define FILE_HEADER_SIZE /*---*/ (14)
	#define BITMAPCOREHEADER /*---*/ (12)
	#define OS22XBITMAPHEADER /*--*/ (64)
	#define BITMAPINFOHEADER /*---*/ (40)
	#define BITMAPV2INFOHEADER /*-*/ (52)
	#define BITMAPV3INFOHEADER /*-*/ (56)
	#define BITMAPV4HEADER /*-----*/ (108)
	#define BITMAPV5HEADER /*-----*/ (124)
	#define BI_RGB /*-------------*/ (0)
	#define BI_RLE8 /*------------*/ (1)
	#define BI_RLE4 /*------------*/ (2)
	#define BI_BITFIELDS /*-------*/ (3)
	#define BI_JPEG /*------------*/ (4)
	#define BI_PNG /*-------------*/ (5)
	#define BI_ALPHABITFIELDS /*--*/ (6)
	#define BI_CMYK /*------------*/ (11)
	#define BI_CMYKRLE8 /*--------*/ (12)
	#define BI_CMYKRLE4 /*--------*/ (13)
	FILE *file = NULL;
	uint32 fileToken = 0;
	uint8 b;
	uint8 m;
	uint32 headerSize;
	int32 width;
	int32 height;
	uint16 depth;
	uint32 compression;
	uint32 *data = NULL;
	uint32 dataToken = 0;
	uint8 returnValue;
	*errorMessage = NULL;
	jmp openFile;
	openFile:{
		file = fopen(path, "rb");
		fileToken = pushPointer(file, "image file", fclose);
		if(!file){
			returnValue = CANNOT_OPEN_MATCH_IMAGE;
			jmp failedImage;
		}
		jmp readHeaders;
	}
	readHeaders:{
		uint8 header[FILE_HEADER_SIZE + BITMAPINFOHEADER];
		if(fread(header, sizeof(uint8), FILE_HEADER_SIZE + 34, file) != FILE_HEADER_SIZE + 34){
			returnValue = CANNOT_READ_MATCH_IMAGE;
			jmp failedImage;
		}
		b /*-----------*/ = *(uint8  *)(header + 0);
		m /*-----------*/ = *(uint8  *)(header + 1);
		headerSize /*--*/ = *(uint32 *)(header + 14);
		width /*-------*/ = *( int32 *)(header + 18);
		height /*------*/ = *( int32 *)(header + 22);
		depth /*-------*/ = *(uint16 *)(header + 28);
		compression /*-*/ = *(uint32 *)(header + 30);
		jmp queryFileFormat;
	}
	queryFileFormat:{
		if(b != 'B' or m != 'M'){
			returnValue = UNSUPPORTED_FORMAT_MATCH_IMAGE;
			jmp failedImage;
		}
		jmp queryHeaderSupport;
	}
	queryHeaderSupport: switch headerSize over
		to BITMAPCOREHEADER: /*---*/ *errorMessage = "BITMAPCOREHEADER header not supported"; /*--*/ jmp printHeaderError;
		to OS22XBITMAPHEADER: /*--*/ *errorMessage = "OS22XBITMAPHEADER header not supported"; /*-*/ jmp printHeaderError;
		to BITMAPINFOHEADER: /*---*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV2INFOHEADER: /*-*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV3INFOHEADER: /*-*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV4HEADER: /*-----*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV5HEADER: /*-----*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		off: /*-------------------*/ *errorMessage = "unrecognized header"; /*--------------------*/ jmp printHeaderError;
	end
	printHeaderError:{
		returnValue = BAD_HEADER_MATCH_IMAGE;
		jmp failedImage;
	}
	queryDepth: switch depth over
		to 1: /*--*/ *errorMessage = "1 bit depth not supported"; /*---*/ jmp printDepthError;
		to 4: /*--*/ *errorMessage = "4 bit depth not supported"; /*---*/ jmp printDepthError;
		to 8: /*--*/ *errorMessage = "8 bit depth not supported"; /*---*/ jmp printDepthError;
		to 16: /*-*/ *errorMessage = "16 bit depth not supported"; /*--*/ jmp printDepthError;
		to 24: /*-*/ /*------------------------------------------------*/ jmp queryCompression;
		to 32: /*-*/ /*------------------------------------------------*/ jmp queryCompression;
		off: /*---*/ *errorMessage = "unknown depth not supported"; /*-*/ jmp printDepthError;
	end
	printDepthError:{
		returnValue = BAD_DEPTH_MATCH_IMAGE;
		jmp failedImage;
	}
	queryCompression: switch compression over
		to BI_RGB: /*------------*/ /*----------------------------------------------------------------*/ jmp queryHeight;
		to BI_RLE8: /*-----------*/ *errorMessage = "BI_RLE8 compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_RLE4: /*-----------*/ *errorMessage = "BI_RLE4 compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_BITFIELDS: /*------*/ /*----------------------------------------------------------------*/ jmp queryHeight;
		to BI_JPEG: /*-----------*/ *errorMessage = "BI_JPEG compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_PNG: /*------------*/ *errorMessage = "BI_PNG compression not supported"; /*------------*/ jmp printCompressionError;
		to BI_ALPHABITFIELDS: /*-*/ *errorMessage = "BI_ALPHABITFIELDS compression not supported"; /*-*/ jmp printCompressionError;
		to BI_CMYK: /*-----------*/ *errorMessage = "BI_CMYK compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_CMYKRLE8: /*-------*/ *errorMessage = "BI_CMYKRLE8 compression not supported"; /*-------*/ jmp printCompressionError;
		to BI_CMYKRLE4: /*-------*/ *errorMessage = "BI_CMYKRLE4 compression not supported"; /*-------*/ jmp printCompressionError;
		off: /*------------------*/ *errorMessage = "unrecognized compression used"; /*---------------*/ jmp printCompressionError;
	end
	printCompressionError:{
		returnValue = BAD_COMPRESSION_MATCH_IMAGE;
		jmp failedImage;
	}
	queryHeight:{
		if(height < 0){
			returnValue = UNSUPPORTED_HEIGHT_MATCH_IMAGE;
			jmp failedImage;
		}
		jmp setupImage;
	}
	setupImage:{
		if(fseek(file, FILE_HEADER_SIZE + headerSize, SEEK_SET)){
			returnValue = BAD_SIZE_MATCH_IMAGE;
			jmp failedImage;
		}
		(*image).width = width;
		(*image).height = height;
		(*image).dataSize = width * height * sizeof(uint32);
		data = malloc((*image).dataSize * sizeof(uint8));
		dataToken = pushPointer(data, "image data pointer", iFree);
		if(!data){
			returnValue = FAILED_MATCH_IMAGE;
			jmp failedImage;
		}
		jmp readPixels;
	}
	readPixels:{
		const uint32 amount = (depth * width + 31) / 8 / width;
		const uint widthTwice = 2 * width;
		uint32 *const start = data + (height - 1) * width;
		uint32 *current = start;
		uint multipleCounter = 0;
		uint32 *currentWall = current + width;
		jmp readRowLoop;
		readRowLoop:{
			if(fread(current, sizeof(uint8), amount, file) != amount){
				if(current == start){
					returnValue = BAD_PIXELS_MATCH_IMAGE;
					jmp failedImage;
				}
				returnValue = BAD_IMAGE_MATCH_IMAGE;
				jmp failedImage;
			}
			if(depth == 24){
				*current |= 0xFF000000;
			}
			multipleCounter += amount;
			multipleCounter -= (multipleCounter > 4) * 4;
			if(inc current < currentWall){
				jmp readRowLoop;
			}
			if((current -= widthTwice) >= data){
				fseek(file, 4 - multipleCounter, SEEK_CUR);
				multipleCounter = 0;
				currentWall -= width;
				jmp readRowLoop;
			}
			jmp successfulImage;
		}
	}
	successfulImage:{
		fclose(file);
		popPointer(fileToken);
		(*image).dataStart = data;
		(*image).dataToken = dataToken;
		ret SUCCESS_MATCH_IMAGE;
	}
	failedImage:{
		free(data);
		popPointer(dataToken);
		if(file){
			fclose(file);
			popPointer(fileToken);
		}
		ret returnValue;
	}
	#undef  BI_CMYKRLE4
	#undef  BI_CMYKRLE8
	#undef  BI_CMYK
	#undef  BI_ALPHABITFIELDS
	#undef  BI_PNG
	#undef  BI_JPEG
	#undef  BI_BITFIELDS
	#undef  BI_RLE4
	#undef  BI_RLE8
	#undef  BI_RGB
	#undef  BITMAPV5HEADER
	#undef  BITMAPV4HEADER
	#undef  BITMAPV3INFOHEADER
	#undef  BITMAPV2INFOHEADER
	#undef  BITMAPINFOHEADER
	#undef  OS22XBITMAPHEADER
	#undef  BITMAPCOREHEADER
	#undef  FILE_HEADER_SIZE
}
MATCHCOMMAND(){
	uint8 commandReturned = TYPICAL_MATCH_COMMAND_TYPE;
	(void)field0;
	(void)field1;
	(void)field2;
	(void)field3;
	(void)field4;
	switch origin over
		to PRESS_MATCH_COMMAND_ORIGIN:{
			printCommand("press", command);
			if(!((*eventModifierNode).onState & PRESS_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to RELEASE_MATCH_COMMAND_ORIGIN:{
			printCommand("release", command);
			if(!((*eventModifierNode).onState & RELEASE_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to CONFIG_MATCH_COMMAND_ORIGIN:{
			printCommand("config", command);
			jmp matchCommand;
		}
		to STDIN_MATCH_COMMAND_ORIGIN:{
			printCommand("stdin", command);
			jmp matchCommand;
		}
		to TRANSMITTER_MATCH_COMMAND_ORIGIN:{
			printCommand("transmitter", command);
			jmp matchCommand;
		}
		off:{
			jmp emergencyExit;
		}
	end
	matchCommand: switch command over
		to NONE_COMMAND: /*----*/ jmp noneCommand;
		to EXECUTE_COMMAND: /*-*/ jmp executeCommand;
		to RESTART_COMMAND: /*-*/ jmp restartCommand;
		to EXIT_COMMAND: /*----*/ jmp exitCommand;
		off: /*----------------*/ jmp unrecognizedCommand;
	end
	noneCommand:{
		jmp emergencyExit;
	}
	executeCommand:{
		spawnProcess(execute);
		jmp emergencyExit;
	}
	restartCommand:{
		commandReturned = RESTART_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	exitCommand:{
		commandReturned = EXIT_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	unrecognizedCommand:{
		printTitledValuedError("command error", "executed unrecognized command with type", command);
		jmp emergencyExit;
	}
	emergencyExit:{
		ret commandReturned;
	}
}
UNGRABSHORTCUTS(){
	if(!connection){
		ret false;
	}
	if(keycodeShortcutSystem.modifierAllocated > 1){
		xcb_ungrab_key(connection, XCB_GRAB_ANY, (*screen).root, XCB_MOD_MASK_ANY);
	}
	if(buttonShortcutSystem.modifierAllocated > 1){
		xcb_ungrab_button(connection, XCB_BUTTON_INDEX_ANY, (*screen).root, XCB_MOD_MASK_ANY);
	}
	ret true;
}
FREECONFIGVARIABLES(){
	ret;
}
FINDSTRINGLENGTH(){
	const uint8 *current = string;
	jmp advanceStringPointerLoop;
	advanceStringPointerLoop:{
		if(*current){
			inc current;
			jmp advanceStringPointerLoop;
		}
		ret current - (uint8 *)string;
	}
}
FINDSUBSTRING(){
	const char *stringCurrent;
	const char *stringWall;
	char substringStartingCharacter;
	if(!string or !stringLength or !substring or !substringLength){
		ret NULL;
	}
	stringCurrent = string;
	stringWall = stringCurrent + stringLength;
	substringStartingCharacter = *substring;
	jmp findSubstringLoop;
	findSubstringLoop:{
		if(stringCurrent < stringWall){
			if(*stringCurrent == substringStartingCharacter){
				if(stringWall - stringCurrent < substringLength){
					ret NULL;
				}
				if(compareMemory(stringCurrent, substring, substringLength)){
					ret (void *)stringCurrent;
				}
			}
			inc stringCurrent;
			jmp findSubstringLoop;
		}
		ret NULL;
	}
}
GETINTERSECTION(){
	const int leftX = x0 > x1? x0 : x1;
	const int topY = y0 > y1? y0 : y1;
	const int rightX = x0 + width0 < x1 + width1? x0 + width0 : x1 + width1;
	const int bottomY = y0 + height0 < y1 + height1? y0 + height0 : y1 + height1;
	const int intersectionWidth = rightX > leftX? rightX - leftX : 0;
	const int intersectionHeight = bottomY > topY? bottomY - topY : 0;
	if(xReturn) /*------*/ *xReturn = leftX;
	if(yReturn) /*------*/ *yReturn = topY;
	if(widthReturn) /*--*/ *widthReturn = intersectionWidth;
	if(heightReturn) /*-*/ *heightReturn = intersectionHeight;
	ret;
}
LOADFILE(){
	#define DATA_BLOCK_SIZE /*-*/ (1024)
	FILE *file;
	uint32 token;
	uint dataAllocated;
	uint dataSize;
	char *dataStart;
	char *dataCurrent;
	uint32 dataToken;
	if(!path or !loadedFileReturn){
		ret false;
	}
	file = fopen(path, "r");
	token = pushPointer(file, "loadFile() file", fclose);
	if(!file){
		ret false;
	}
	dataAllocated = 0;
	dataSize = 0;
	dataStart = NULL;
	dataCurrent = dataStart;
	dataToken = 0;
	jmp allocateMemory;
	allocateMemory:{
		uint offset = 0;
		void *temp;
		if(dataCurrent){
			offset = dataCurrent - dataStart;
		}
		dataSize += DATA_BLOCK_SIZE;
		temp = realloc(dataStart, dataSize * sizeof(char));
		if(!dataToken){
			dataToken = pushPointer(temp, "loaded system file data", iFree);
		}else{
			updatePointer(dataToken, temp);
		}
		if(!temp){
			free(dataStart);
			popPointer(dataToken);
			fclose(file);
			popPointer(token);
			ret false;
		}
		dataStart = temp;
		dataCurrent = dataStart + offset;
		jmp loadFileSegmentLoop;
	}
	loadFileSegmentLoop:{
		const uint amountRead = fread(dataCurrent, sizeof(char), DATA_BLOCK_SIZE, file);
		dataAllocated += amountRead;
		if(amountRead == DATA_BLOCK_SIZE){
			jmp allocateMemory;
		}
		dataSize = dataAllocated;
		jmp trimMemory;
	}
	trimMemory:{
		if(dataSize){
			void *const temp = realloc(dataStart, dataSize * sizeof(char));
			updatePointer(dataToken, temp);
			if(temp){
				dataStart = temp;
			}
		}
		fclose(file);
		popPointer(token);
		(*loadedFileReturn).dataSize = dataSize;
		(*loadedFileReturn).dataStart = dataStart;
		(*loadedFileReturn).dataToken = dataToken;
		ret true;
	}
	#undef  DATA_BLOCK_SIZE
}
SPAWNPROCESS(){
	#define FORK_FAILURE /*-------*/ (-1)
	#define CHILD_FORK_PROCESS /*-*/ (0)
	#define SETSID_FAILURE /*-----*/ (-1)
	#define SETGID_FAILURE /*-----*/ (-1)
	#define SETUID_FAILURE /*-----*/ (-1)
	#define CHDIR_FAILURE /*------*/ (-1)
	if(!string){
		ret;
	}
	switch fork() over
		to FORK_FAILURE:{
			printTitledError("fork error", "could not execute shell command");
			ret;
		}
		to CHILD_FORK_PROCESS:{
			char *env;
			if(setsid() == SETSID_FAILURE){
				printTitledError("fork error", "could not set group leader");
				exit(EXIT_SUCCESS);
			}
			if(!dropPermissions(&permissionSystem)){
				printTitledError("fork error", "could not drop superuser privileges");
				exit(EXIT_SUCCESS);
			}
			env = getenv("HOME");
			if(env and chdir(env) == CHDIR_FAILURE){
				printTitledError("fork error", "could not change directory to home");
			}
			execl("/bin/sh", "sh", "-c", string, NULL);
			exit(EXIT_SUCCESS);
		}
		off:{
			ret;
		}
	end
	#undef  CHDIR_FAILURE
	#undef  SETUID_FAILURE
	#undef  SETGID_FAILURE
	#undef  SETSID_FAILURE
	#undef  CHILD_FORK_PROCESS
	#undef  FORK_FAILURE
}
CREATECIRCLE(){
	const uint width = radius * 2 + 1;
	const uint height = width;
	const int r2 = radius * radius;
	uint32 *data = malloc(width * height * sizeof(uint32));
	uint32 token = pushPointer(data, "createCorner() data pointer", iFree);
	int y = -radius;
	uint32 *currentData = data;
	if(!data){
		ret false;
	}
	jmp yLoop;
	yLoop:{
		if(y <= radius){
			const int y2 = y * y;
			int x = -radius;
			jmp xLoop;
			xLoop:{
				if(x <= radius){
					const int x2y2 = x * x + y2;
					if(x2y2 <= r2){
						*currentData = foreground;
					}else{
						*currentData = background;
					}
					inc currentData;
					inc x;
					jmp xLoop;
				}
				inc y;
				jmp yLoop;
			}
		}
		(*image).x = 0;
		(*image).y = 0;
		(*image).width = width;
		(*image).height = height;
		(*image).dataStart = data;
		(*image).dataToken = token;
		(*image).dataSize = width * height * sizeof(uint32);
		ret true;
	}
}
COMPOSITEIMAGES(){
	int intersectionWidth;
	int intersectionHeight;
	uint32 *sourceCurrent;
	uint32 *sourceWidthWall;
	uint32 *sourceWall;
	uint32 *destinationCurrent;
	if(sourceX < 0 or sourceY < 0 or sourceX >= (*source).width or sourceY >= (*source).height){
		ret false;
	}
	{
		const int b1lx = 0;
		const int b1ty = 0;
		const int b1rx = (*destination).width;
		const int b1by = (*destination).height;
		const int b2lx = destinationX;
		const int b2ty = destinationY;
		const int b2rx = b2lx + (*source).width - sourceX;
		const int b2by = b2ty + (*source).height - sourceY;
		intersectionWidth = (b1rx < b2rx? b1rx : b2rx) - (b1lx > b2lx? b1lx : b2lx);
		intersectionHeight = (b1by < b2by? b1by : b2by) - (b1ty > b2ty? b1ty : b2ty);
		if(intersectionWidth < 1 or intersectionWidth < 1){
			ret false;
		}
	}
	sourceCurrent = (uint32 *)(*source).dataStart + sourceY * (*source).width + sourceX;
	if(destinationX < 0){
		sourceCurrent -= destinationX;
		destinationX = 0;
	}
	if(destinationY < 0){
		sourceCurrent -= destinationY * (*source).width;
		destinationY = 0;
	}
	sourceWidthWall = sourceCurrent + intersectionWidth;
	sourceWall = sourceCurrent + intersectionHeight * (*source).width;
	destinationCurrent = (uint32 *)(*destination).dataStart + destinationY * (*destination).width + destinationX;
	jmp yLoop;
	yLoop:{
		if(sourceCurrent < sourceWall){
			jmp xLoop;
			xLoop:{
				if(sourceCurrent < sourceWidthWall){
					operation(sourceCurrent, destinationCurrent);
					inc sourceCurrent;
					inc destinationCurrent;
					jmp xLoop;
				}
				sourceCurrent += (*source).width - intersectionWidth;
				sourceWidthWall += (*source).width;
				destinationCurrent += (*destination).width - intersectionWidth;
				jmp yLoop;
			}
		}
		ret true;
	}
}
COMPOSITEIMAGESOVER(){
	const uint32 s = *source;
	const uint32 d = *destination;
	const uint64 a_a = s >> 24;
	if(a_a == 0xFF){
		*destination = s;
		ret;
	}
	if(a_a){
		const uint32 r_a = (s & 0x00FF0000) >> 16;
		const uint32 g_a = (s & 0x0000FF00) >> 8;
		const uint32 b_a = (s & 0x000000FF) >> 0;
		const uint32 a_b = d >> 24;
		const uint32 r_b = (d & 0x00FF0000) >> 16;
		const uint32 g_b = (d & 0x0000FF00) >> 8;
		const uint32 b_b = (d & 0x000000FF) >> 0;
		const uint32 a_0 = a_a + a_b * (0xFF - a_a) / 0xFF;
		const uint32 r = (r_a * a_a + r_b * a_b * (0xFF - a_a) / 0xFF) / a_0;
		const uint32 g = (g_a * a_a + g_b * a_b * (0xFF - a_a) / 0xFF) / a_0;
		const uint32 b = (b_a * a_a + b_b * a_b * (0xFF - a_a) / 0xFF) / a_0;
		*destination = (a_0 << 24) + ((r & 0x000000FF) << 16) + ((g & 0x000000FF) << 8) + ((b & 0x000000FF) << 0);
		ret;
	}
	ret;
}
COMPOSITEIMAGESAND(){
	if(!(*source >> 24)){
		*destination = 0x00000000;
		ret;
	}
	ret;
}
TWOPASSBOXBLUR(){
	uint32 *intermediateData;
	uint32 *kernelColumnRStart;
	uint32 *kernelColumnGStart;
	uint32 *kernelColumnBStart;
	uint32 *pixelRStart;
	uint32 *pixelGStart;
	uint32 *pixelBStart;
	if(boxSize == 1){
		ret;
	}
	intermediateData = malloc(width * height * sizeof(uint32));
	kernelColumnRStart = malloc(boxSize + 2 * width * sizeof(uint32));
	kernelColumnGStart = malloc(boxSize + 2 * width * sizeof(uint32));
	kernelColumnBStart = malloc(boxSize + 2 * width * sizeof(uint32));
	pixelRStart = malloc(boxSize + 2 * width * height * sizeof(uint32));
	pixelGStart = malloc(boxSize + 2 * width * height * sizeof(uint32));
	pixelBStart = malloc(boxSize + 2 * width * height * sizeof(uint32));
	{
		const int divisor = boxSize * boxSize;
		const int boxDistanceFromZero = boxSize >> 1;
		const int nBoxDistanceFromZero = -boxDistanceFromZero;
		const int widthMinusOne = width - 1;
		const int heightMinusOne = height - 1;
		const int heightMinusBoxSize = height - boxSize;
		uint32 *tx = destinationData;
		uint32 *txCopy = tx;
		uint32 *rx = intermediateData;
		uint32 r;
		uint32 g;
		uint32 b;
		jmp loop;
		loop:{
			uint32 *kernelColumnRCurrent = kernelColumnRStart;
			uint32 *kernelColumnGCurrent = kernelColumnGStart;
			uint32 *kernelColumnBCurrent = kernelColumnBStart;
			uint32 *kernelColumnRCurrentCopy = kernelColumnRStart;
			uint32 *kernelColumnGCurrentCopy = kernelColumnGStart;
			uint32 *kernelColumnBCurrentCopy = kernelColumnBStart;
			uint32 *pixelRCurrent = pixelRStart;
			uint32 *pixelGCurrent = pixelGStart;
			uint32 *pixelBCurrent = pixelBStart;
			uint32 *pixelRCurrentCopy = pixelRStart;
			uint32 *pixelGCurrentCopy = pixelGStart;
			uint32 *pixelBCurrentCopy = pixelBStart;
			int x = 0;
			int y = 0;
			{
				int kx = nBoxDistanceFromZero;
				r = 0;
				g = 0;
				b = 0;
				while(kx <= boxDistanceFromZero){
					int ky = nBoxDistanceFromZero;
					int usedX = x + kx;
					if(usedX < 0){
						usedX = 0;
					}
					*kernelColumnRCurrent = 0;
					*kernelColumnGCurrent = 0;
					*kernelColumnBCurrent = 0;
					tx += usedX;
					while(ky <= boxDistanceFromZero){
						int usedY = y + ky;
						uint32 color;
						if(usedY < 0){
							usedY = 0;
						}
						color = *(tx + usedY * width);
						*pixelRCurrent = (color & 0xFF0000) >> 16;
						*pixelGCurrent = (color & 0x00FF00) >>  8;
						*pixelBCurrent =  color & 0x0000FF;
						*kernelColumnRCurrent += *pixelRCurrent;
						*kernelColumnGCurrent += *pixelGCurrent;
						*kernelColumnBCurrent += *pixelBCurrent;
						inc pixelRCurrent;
						inc pixelGCurrent;
						inc pixelBCurrent;
						inc ky;
					}
					tx -= usedX;
					r += *kernelColumnRCurrent;
					g += *kernelColumnGCurrent;
					b += *kernelColumnBCurrent;
					pixelRCurrent += heightMinusBoxSize;
					pixelGCurrent += heightMinusBoxSize;
					pixelBCurrent += heightMinusBoxSize;
					inc kernelColumnRCurrent;
					inc kernelColumnGCurrent;
					inc kernelColumnBCurrent;
					inc kx;
				}
				*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
				inc rx;
			}
			inc x;
			xFirstLoop:{
				int kx = boxDistanceFromZero;
				int ky = nBoxDistanceFromZero;
				int usedX = x + kx;
				if(usedX < 0){
					usedX = 0;
				}elif(usedX >= width){
					usedX = widthMinusOne;
				}
				r -= *kernelColumnRCurrentCopy;
				g -= *kernelColumnGCurrentCopy;
				b -= *kernelColumnBCurrentCopy;
				kernelColumnRCurrent = kernelColumnRCurrentCopy + boxSize;
				kernelColumnGCurrent = kernelColumnGCurrentCopy + boxSize;
				kernelColumnBCurrent = kernelColumnBCurrentCopy + boxSize;
				inc kernelColumnRCurrentCopy;
				inc kernelColumnGCurrentCopy;
				inc kernelColumnBCurrentCopy;
				{
					uint32 lr = 0;
					uint32 lg = 0;
					uint32 lb = 0;
					tx += usedX;
					while(ky <= boxDistanceFromZero){
						int usedY = y + ky;
						uint32 color;
						if(usedY < 0){
							usedY = 0;
						}elif(usedY >= height){
							usedY = heightMinusOne;
						}
						color = *(tx + usedY * width);
						*pixelRCurrent = (color & 0xFF0000) >> 16;
						*pixelGCurrent = (color & 0x00FF00) >>  8;
						*pixelBCurrent =  color & 0x0000FF;
						lr += *pixelRCurrent;
						lg += *pixelGCurrent;
						lb += *pixelBCurrent;
						inc pixelRCurrent;
						inc pixelGCurrent;
						inc pixelBCurrent;
						inc ky;
					}
					tx -= usedX;
					r += lr;
					g += lg;
					b += lb;
					*kernelColumnRCurrent = lr;
					*kernelColumnGCurrent = lg;
					*kernelColumnBCurrent = lb;
					pixelRCurrent += heightMinusBoxSize;
					pixelGCurrent += heightMinusBoxSize;
					pixelBCurrent += heightMinusBoxSize;
				}
				*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
				inc rx;
				if(inc x < width){
					jmp xFirstLoop;
				}
			}
			inc y;
			yLoop:{
				uint32 *pr;
				uint32 *pg;
				uint32 *pb;
				int ky = boxDistanceFromZero;
				int usedY = y + ky;
				if(usedY < 0){
					usedY = 0;
				}elif(usedY >= height){
					usedY = heightMinusOne;
				}
				x = 0;
				{
					int kx = nBoxDistanceFromZero;
					kernelColumnRCurrent = kernelColumnRStart;
					kernelColumnGCurrent = kernelColumnGStart;
					kernelColumnBCurrent = kernelColumnBStart;
					kernelColumnRCurrentCopy = kernelColumnRStart;
					kernelColumnGCurrentCopy = kernelColumnGStart;
					kernelColumnBCurrentCopy = kernelColumnBStart;
					pixelRCurrent = pixelRCurrentCopy;
					pixelGCurrent = pixelGCurrentCopy;
					pixelBCurrent = pixelBCurrentCopy;
					pr = pixelRCurrent + boxSize;
					pg = pixelGCurrent + boxSize;
					pb = pixelBCurrent + boxSize;
					r = 0;
					g = 0;
					b = 0;
					tx += usedY * width;
					while(kx <= boxDistanceFromZero){
						int usedX = x + kx;
						uint32 color;
						if(usedX < 0){
							usedX = 0;
						}elif(usedX >= width){
							usedX = widthMinusOne;
						}
						color = *(tx + usedX);
						*pr = (color & 0xFF0000) >> 16;
						*pg = (color & 0x00FF00) >>  8;
						*pb =  color & 0x0000FF;
						*kernelColumnRCurrent += *pr - *pixelRCurrent;
						*kernelColumnGCurrent += *pg - *pixelGCurrent;
						*kernelColumnBCurrent += *pb - *pixelBCurrent;
						r += *kernelColumnRCurrent;
						g += *kernelColumnGCurrent;
						b += *kernelColumnBCurrent;
						pixelRCurrent += height;
						pixelGCurrent += height;
						pixelBCurrent += height;
						pr += height;
						pg += height;
						pb += height;
						inc kernelColumnRCurrent;
						inc kernelColumnGCurrent;
						inc kernelColumnBCurrent;
						inc kx;
					}
					tx -= usedY * width;
					*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
					inc rx;
					inc x;
				}
				{
					int usedX = x + boxDistanceFromZero;
					usedY *= width;
					tx += usedY;
					xLoop:{
						uint32 color;
						if(usedX >= width){
							usedX = widthMinusOne;
						}
						kernelColumnRCurrent = kernelColumnRCurrentCopy + boxSize;
						kernelColumnGCurrent = kernelColumnGCurrentCopy + boxSize;
						kernelColumnBCurrent = kernelColumnBCurrentCopy + boxSize;
						r -= *kernelColumnRCurrentCopy;
						g -= *kernelColumnGCurrentCopy;
						b -= *kernelColumnBCurrentCopy;
						color = *(tx + usedX);
						*pr = (color & 0xFF0000) >> 16;
						*pg = (color & 0x00FF00) >>  8;
						*pb =  color & 0x0000FF;
						*kernelColumnRCurrent += *pr - *pixelRCurrent;
						*kernelColumnGCurrent += *pg - *pixelGCurrent;
						*kernelColumnBCurrent += *pb - *pixelBCurrent;
						r += *kernelColumnRCurrent;
						g += *kernelColumnGCurrent;
						b += *kernelColumnBCurrent;
						inc kernelColumnRCurrentCopy;
						inc kernelColumnGCurrentCopy;
						inc kernelColumnBCurrentCopy;
						pixelRCurrent += height;
						pixelGCurrent += height;
						pixelBCurrent += height;
						pr += height;
						pg += height;
						pb += height;
						*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
						inc rx;
						if(inc x < width){
							inc usedX;
							jmp xLoop;
						}
					}
					tx -= usedY;
				}
				if(inc y < height){
					inc pixelRCurrentCopy;
					inc pixelGCurrentCopy;
					inc pixelBCurrentCopy;
					jmp yLoop;
				}
			}
			if(txCopy == destinationData){
				tx = intermediateData;
				txCopy = tx;
				rx = destinationData;
				jmp loop;
			}
		}
	}
	free(intermediateData);
	free(kernelColumnRStart);
	free(kernelColumnGStart);
	free(kernelColumnBStart);
	free(pixelRStart);
	free(pixelGStart);
	free(pixelBStart);
	ret;
}
ROTATEIMAGE(){
	const int oldWidth = (*image).width;
	const int oldHeight = (*image).height;
	const int oldSize = (*image).dataSize;
	uint32 *newData;
	uint32 newDataToken;
	uint32 *current = (*image).dataStart;
	uint32 *const yWall = (void *)((uint8 *)current + oldSize);
	uint32 *xWall = current + oldWidth;
	int newWidth;
	int newHeight;
	uint32 *newDataCurrent;
	int newDataNextX;
	int newDataNextY;
	if(!rotation){
		ret true;
	}
	newData = malloc(oldSize * sizeof(uint8));
	newDataToken = pushPointer(newData, "rotateImage() new data pointer", iFree);
	if(!newData){
		printTitledError("memory allocation error", "could not allocate rotated image color data");
		ret false;
	}
	switch rotation over
		to DEGREES_90_ROTATION: /*--*/ jmp rotate90Degrees;
		to DEGREES_180_ROTATION: /*-*/ jmp rotate180Degrees;
		to DEGREES_270_ROTATION: /*-*/ jmp rotate270Degrees;
		off: /*---------------------*/ ret false;
	end
	rotate90Degrees:{
		newWidth = oldHeight;
		newHeight = oldWidth;
		newDataCurrent = newData + newWidth - 1;
		newDataNextX = newWidth;
		newDataNextY = -newHeight * newWidth - 1;
		jmp copyYAxisLoop;
	}
	rotate180Degrees:{
		newWidth = oldWidth;
		newHeight = oldHeight;
		newDataCurrent = newData + newHeight * newWidth - 1;
		newDataNextX = -1;
		newDataNextY = 0;
		jmp copyYAxisLoop;
	}
	rotate270Degrees:{
		newWidth = oldHeight;
		newHeight = oldWidth;
		newDataCurrent = newData + newHeight * newWidth - newWidth;
		newDataNextX = -newWidth;
		newDataNextY = newHeight * newWidth + 1;
		jmp copyYAxisLoop;
	}
	copyYAxisLoop:{
		if(current < yWall){
			jmp copyXAxisLoop;
			copyXAxisLoop:{
				if(current < xWall){
					*newDataCurrent = *current;
					newDataCurrent += newDataNextX;
					inc current;
					jmp copyXAxisLoop;
				}
				newDataCurrent += newDataNextY;
				xWall += oldWidth;
				jmp copyYAxisLoop;
			}
		}
		jmp success;
	}
	success:{
		if(deletePreviousData){
			free((*image).dataStart);
			popPointer((*image).dataToken);
		}
		(*image).width = newWidth;
		(*image).height = newHeight;
		(*image).dataStart = newData;
		(*image).dataToken = newDataToken;
		ret true;
	}
}









#define XCB_SYNC() /*-*/ bool  xcb_sync(ConnectionSystem *const connectionSystem)

XCB_SYNC(){
	xcb_connection_t *connection;
	xcb_get_input_focus_reply_t *reply;
	uint32 token;
	if(!connectionIsOpen(connectionSystem)){
		ret false;
	}
	connection = (*connectionSystem).connection;
	reply = xcb_wait_for_reply(connection, xcb_get_input_focus(connection), NULL);
	token = insertMemoryManagementPointer((*connectionSystem).memoryManagementSystem, reply, "xcb_sync() xcb_get_input_focus() reply", &memoryManagementFree);
	free(reply);
	removeMemoryManagementPointer((*connectionSystem).memoryManagementSystem, token);
	if(!reply){
		ret false;
	}
	ret true;
}









GETFOCUSEDWINDOW(){
	xcb_get_property_cookie_t propertyCookie;
	xcb_get_input_focus_cookie_t inputFocusCookie;
	xcb_window_t window = XCB_NONE;
	jmp getCookies;
	getCookies:{
		propertyCookie = xcb_get_property_unchecked(connection, false, (*screen).root, atom._NET_ACTIVE_WINDOW, XCB_ATOM_WINDOW, 0, 1);
		inputFocusCookie = xcb_get_input_focus_unchecked(connection);
		jmp getActiveWindow;
	}
	getActiveWindow:{
		xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, propertyCookie, NULL);
		uint32 token = pushPointer(reply, "getFocusedWindow() get property reply", iFree);
		bool found = false;
		if(reply){
			if(xcb_get_property_value_length(reply) == sizeof(xcb_window_t)){
				window = *(xcb_window_t *)xcb_get_property_value(reply);
				found = true;
			}
			free(reply);
			popPointer(token);
			if(found){
				xcb_discard_reply(connection, inputFocusCookie);
				ret window;
			}
		}
		jmp getFocusedWindow;
	}
	getFocusedWindow:{
		xcb_get_input_focus_reply_t *const reply = xcb_wait_for_reply(connection, inputFocusCookie, NULL);
		uint32 token = pushPointer(reply, "getFocusedWindow() get input focus reply", iFree);
		if(reply){
			window = (*reply).focus;
			free(reply);
			popPointer(token);
		}
		ret window;
	}
}
GRABDEVICE(){
	uint currentAttempt = 0;
	struct timespec ts;
	ts.tv_sec = 0;
	ts.tv_nsec = 10 * 1000000;
	if(!attemptAmount){
		ret false;
	}
	jmp grabDeviceLoop;
	grabDeviceLoop:{
		void *reply;
		uint32 token;
		switch device over
			to KEYBOARD_GRAB_DEVICE:{
				reply = xcb_wait_for_reply(connection, xcb_grab_keyboard_unchecked(connection, true, (*screen).root, getTimestamp(), XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC), NULL);
				token = pushPointer(reply, "grab keyboard reply", iFree);
				brk;
			}
			to POINTER_GRAB_DEVICE:{
				reply = xcb_wait_for_reply(connection, xcb_grab_pointer_unchecked(connection, true, (*screen).root, XCB_EVENT_MASK_BUTTON_PRESS, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, getTimestamp()), NULL);
				token = pushPointer(reply, "grab pointer reply", iFree);
				brk;
			}
			off:{
				ret true;
			}
		end
		if(reply){
			const bool flag = (*(xcb_grab_keyboard_reply_t *)reply).status == XCB_GRAB_STATUS_SUCCESS;
			free(reply);
			popPointer(token);
			if(flag){
				ret true;
			}
		}
		if(inc currentAttempt < attemptAmount){
			nanosleep(&ts, NULL);
			jmp grabDeviceLoop;
		}
		ret false;
	}
}
TIGHTENCLIPPINGRECTANGLE(){
	int intersectionX;
	int intersectionY;
	int intersectionWidth;
	int intersectionHeight;
	if(!gc or !clipXReturn or !clipYReturn or !clipWidthReturn or !clipHeightReturn){
		ret false;
	}
	getIntersection(x, y, width, height, *clipXReturn, *clipYReturn, *clipWidthReturn, *clipHeightReturn, &intersectionX, &intersectionY, &intersectionWidth, &intersectionHeight);
	setClippingRectangle(gc, intersectionX, intersectionY, intersectionWidth, intersectionHeight);
	*clipXReturn = intersectionX;
	*clipYReturn = intersectionY;
	*clipWidthReturn = intersectionWidth;
	*clipHeightReturn = intersectionHeight;
	ret true;
}
RESTART(){
	if(!isInsideConfig){
		disconnectSharedMemory(&sharedMemorySystem);
		disconnectSTDIN(&stdinSystem);
	}
	freeConfigVariables();
	ungrabShortcuts();
	finiShortcutSystem(&buttonShortcutSystem);
	finiShortcutSystem(&keycodeShortcutSystem);
	setConfigVariables();
	ret;
}
CLEANUP(){
	free(event);
	popPointer(eventToken);
	event = NULL;
	eventToken = 0;
	finiSharedMemorySystem(&sharedMemorySystem);
	finiSTDINSystem(&stdinSystem);
	finiSleepThreadSystem(&sleepThreadSystem);
	cancelThreads();
	ungrabShortcuts();
	freeConfigVariables();
	finiWindowSystem(&windowSystem);
	finiMonitorSystem(&monitorSystem);
	if(connection){
		xcb_flush(connection);
		xcb_disconnect(connection);
		popPointer(connectionToken);
		connection = NULL;
		connectionToken = 0;
	}
	finiShortcutSystem(&buttonShortcutSystem);
	finiShortcutSystem(&keycodeShortcutSystem);
	finiStringTreeSystem(&macroStringTreeSystem);
	finiStringTreeSystem(&whichMonitorStringTreeSystem);
	finiStringTreeSystem(&cornerStringTreeSystem);
	finiStringTreeSystem(&verticalAlignmentStringTreeSystem);
	finiStringTreeSystem(&horizontalAlignmentStringTreeSystem);
	finiStringTreeSystem(&numberTypeStringTreeSystem);
	finiStringTreeSystem(&shortcutStateStringTreeSystem);
	finiStringTreeSystem(&modifierStringTreeSystem);
	finiStringTreeSystem(&commandStringTreeSystem);
	finiStringTreeSystem(&variableStringTreeSystem);
	finiStringTreeSystem(&booleanStringTreeSystem);
	finiStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
	finiStringTreeSystem(&globalInstructionStringTreeSystem);
	finiStringTreeSystem(&globalScopesInstructionStringTreeSystem);
	finiPermissionSystem(&permissionSystem);
	if(memoryManagementSystem.allocated > 1){
		printError("%s%s: %s%s:%s %s", colorStart, programName, colorError, "warning", colorEnd, "program exited with unaccounted for data pointers, namely:\n");
		printUnaccountedForPointers(memoryManagementSystem.data + 1, memoryManagementSystem.data + memoryManagementSystem.allocated);
	}
	finiMemorySystem();
	closeErrorStream();
	exit(EXIT_SUCCESS);
}
CANCELTHREADS(){
	if(globalsLockCreated){
		if(pthread_rwlock_destroy(&globalsLock) != PTHREAD_RWLOCK_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy globals lock");
		}
		globalsLockCreated = false;
	}
	ret;
}
PRINTUNACCOUNTEDFORPOINTERS(){
	if(current < wall){
		jmp printPointedVariablesLoop;
		printPointedVariablesLoop:{
			if((*current).data){
				labelExamined = (*current).label;
				printError("\t%s: line %u: %s\n", (*current).file, (*current).line, labelExamined);
			}
			if(inc current < wall){
				jmp printPointedVariablesLoop;
			}
		}
	}
	ret;
}
PRINTERROR(){
	if(openErrorStream()){
		va_list arguments;
		va_start(arguments, message);
		flockfile(errorStream);
		vfprintf(errorStream, message, arguments);
		funlockfile(errorStream);
		va_end(arguments);
		closeErrorStream();
	}
	ret;
}
PRINTTITLEDERROR(){
	printError("%s%s: %s%s:%s %s\n", colorStart, programName, colorError, title, colorEnd, message);
	ret;
}
PRINTTITLEDQUOTEDERROR(){
	printError("%s%s: %s%s:%s \"%s\" %s\n", colorStart, programName, colorError, title, colorEnd, argument, message);
	ret;
}
PRINTCONNECTIONERROR(){
	const char *string;
	jmp findConnectionError;
	findConnectionError: switch xcb_connection_has_error(connection) over
		to XCB_CONN_ERROR: /*-------------------*/ string = "socket/pipe/stream error"; /*------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_EXT_NOTSUPPORTED: /*-*/ string = "extension not supported"; /*-------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_MEM_INSUFFICIENT: /*-*/ string = "insufficient memory"; /*-----------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_REQ_LEN_EXCEED: /*---*/ string = "exceeded request length"; /*-------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_PARSE_ERR: /*--------*/ string = "error parsing display string"; /*--*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_INVALID_SCREEN: /*---*/ string = "screen-display mismatch"; /*-------*/ jmp printConnectionError;
		off: /*---------------------------------*/ string = "unrecognized connection error"; /*-*/ jmp printConnectionError;
	end
	printConnectionError:{
		printTitledError("fatal X server error", string);
		ret;
	}
}
PRINTTITLEDNAMEDERROR(){
	printError("%s%s: %s%s:%s %s %s\n", colorStart, programName, colorError, title, colorEnd, message, name);
	ret;
}
PRINTXERROR(){
	#define useExtensionName(n0, n1) /*------*/ n0 == n1##ErrorName? "X " #n1 " error"
	#define useErrorName(n0, n1) /*----------*/ n0 == n1##ErrorName and (*error).error_code >= n1##BaseError? *(n1##ErrorName + ((*error).error_code - n1##BaseError))
	#define useErrorOperationName(n0, n1) /*-*/ n0 == n1##ErrorName? *(n1##OperationName + ((*error).minor_code >= countof(n1##OperationName)? countof(n1##OperationName) - 1 : (*error).minor_code))
	#define baseBaseError (0)
	const xcb_generic_error_t *const error = (void *)event;
	printError("%s%s: %s%s:%s %s error in %s operation using the 0x%x resource\n", colorStart, programName, colorError
		, name == baseErrorName? "X error"
		: useExtensionName(name, randr)
		: useExtensionName(name, xfixes)
		: useExtensionName(name, xinput)
		: "X unrecognized extension event"
		, colorEnd
		, useErrorName(name, base)
		: useErrorName(name, randr)
		: useErrorName(name, xfixes)
		: useErrorName(name, xinput)
		: "unrecognized"
		, useErrorOperationName(name, base)
		: useErrorOperationName(name, randr)
		: useErrorOperationName(name, xfixes)
		: useErrorOperationName(name, xinput)
		: "unrecognized"
	, (*error).resource_id);
	ret;
	#undef  useErrorOperationName
	#undef  useErrorName
}
PRINTTITLEDVALUEDERROR(){
	printError("%s%s: %s%s:%s %s %u\n", colorStart, programName, colorError, title, colorEnd, message, value);
	ret;
}
PRINTCONFIGERROR(){
	const char *statementCurrent = statementStart;
	const uint itemAmountWall = instructionCurrent - instructionStart;
	uint itemAmount = 0;
	uint spaceAmount = 0;
	StringTreeSystem *const *data;
	if(!openErrorStream()){
		ret;
	}
	flockfile(errorStream);
	fprintf(errorStream, "%s%s: %s: ", colorStart, programName, configPath);
	if(printLine){
		fprintf(errorStream, "line %u: ", statementLine);
	}
	fprintf(errorStream, "%s%s:%s %s", colorError, type, colorEnd, message);
	if(printConfig){
		fprintf(errorStream, ":\n\t config |");
	}else{
		fprintf(errorStream, "\n");
		jmp emergencyExit;
	}
	jmp printStatementItemLoop;
	printStatementItemLoop:{
		if(statementCurrent < statementWall){
			fprintf(errorStream, " %s", statementCurrent);
			jmp pushOutTermLoop;
			pushOutTermLoop:{
				if(*(inc statementCurrent)){
					jmp pushOutTermLoop;
				}
				inc statementCurrent;
			}
			if(itemAmount == itemAmountWall and instructionStart){
				spaceAmount = statementCurrent - statementStart;
			}
			inc itemAmount;
			jmp printStatementItemLoop;
		}
		if(spaceAmount == 0 and finalStatementCharacter != ';'){
			fprintf(errorStream, " ");
		}
		fprintf(errorStream, "%c\n", finalStatementCharacter);
		jmp printPattern;
	}
	printPattern:{
		if(printPointer){
			if(spaceAmount == statementCurrent - statementStart){
				dec spaceAmount;
			}
			fprintf(errorStream, "\t        |%*c^\n", inc spaceAmount, ' ');
		}
		if(!printPattern or !instructionStart){
			fprintf(errorStream, "\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, "\n\tpattern | %s", *(currentScopeInstructionList + (*currentScopeInstructionStringTreeSystem).returnedCounter));
		dec instructionStart;
		data = instructionDataStart;
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoop: switch *(inc instructionStart) over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
		off: /*---------------------------*/ jmp printInstructionParameterLoopExit;
	end
	noneInstruction:{
		fprintf(errorStream, " <unimplemented>");
		jmp printInstructionParameterLoopExit;
	}
	nameInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " name");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " (%s", *stringArray);
			inc stringArray;
			jmp printNameLoop;
			printNameLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
				}
				fprintf(errorStream, ")");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	nameListInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " list");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " ((%s", *stringArray);
			inc stringArray;
			jmp printNameListOnceLoop;
			printNameListOnceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
				}
				stringArray = (**data).stringArray;
				fprintf(errorStream, ")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
				inc stringArray;
				jmp printNameListTwiceLoop;
			}
			printNameListTwiceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListTwiceLoop;
				}
				fprintf(errorStream, "))*(?![\\s]*[|]))");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	numberInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " number");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
		jmp printInstructionParameterLoop;
	}
	stringInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " string");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	imageInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " image");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	printTilde:{
		fprintf(errorStream, " ~");
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoopExit:{
		if(displaySimpleConfigErrors){
			fprintf(errorStream, "\n\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, " $\n\n");
		jmp emergencyExit;
	}
	emergencyExit:{
		funlockfile(errorStream);
		closeErrorStream();
		ret;
	}
}

