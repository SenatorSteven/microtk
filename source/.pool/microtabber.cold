
/*!
	future features:
		implement a way of storing element data. through that, when something changes just update that data. once that happens draw the elements from memory. that way we can easily check clicking on the elements afterwards.
		add pointer support.
		add the client pictures.
		support differently colored selections using _NET_WM_STATE's _NET_WM_STATE_DEMANDS_ATTENTION.
		order windows based on an x, y, or (x, y) order.
		check validity of window unmap event.
		check validity of window map event.
		check validity of window configure attributes should they change.
		check validity of window properties should they change.
		optimize properties further. for example, we shouldn't be keeping both _NET_CLIENT_LIST and _NET_CLIENT_LIST_STACKING updated since the user is using either or neither.
		use scopes for each element in config.
		implement a shown clients setting with possible settings none, monitor, workspace, all.
		optimize query text extent calls when drawing the window.
		implement selection horizontal order and selection vertical order such that we can also place selections right to left and bottom to top.
		implement closing button on every selection.
		implement rotated text.
		implement resizable window.
*/

/*!
	if the window is already shown the window we try to take the pixels from might return... not its own pixels. but rather what is shown below?
*/



























/*!includes:{*/
	#include <errno.h>
	#include <grp.h>
	#include <limits.h>
	#include <locale.h>
	#include <poll.h>
	#include <pthread.h>
	#include <pwd.h>
	#include <signal.h>
	#include <stdarg.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <sys/shm.h>
	#include <sys/stat.h>
	#include <sys/wait.h>
	#include <xcb/randr.h>
/*!}*/

/*!defines:{*/
	#define DEBUG /*-----------------------------------------*/ (false)

	#define PROGRAM_NAME /*----------------------------------*/ "microtabber"

	#define WHICH_MONITOR_CONTENT(k, v, n, p) /*-------------*/ { \
		  v(none)           k(NONE##p) \
		, v(pointer)        k(POINTER##p) \
		, v(focused-window) k(FOCUSED_WINDOW##p) \
		, v(all)            k(ALL##p) \
		, n(NULL)           k(NULL##p) \
	}

	#define NUMBER_TYPE_CONTENT(k, v, n, p) /*---------------*/ { \
		  v(none)       k(NONE##p) \
		, v(integer)    k(INTEGER##p) \
		, v(percentage) k(PERCENTAGE##p) \
		, v(millimeter) k(MILLIMETER##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define POSITION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(bottom) k(BOTTOM##p) \
		, v(left)   k(LEFT##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define HORIZONTAL_ALIGNMENT_CONTENT(k, v, n, p) /*------*/ { \
		  v(none)   k(NONE##p) \
		, v(left)   k(LEFT##p) \
		, v(center) k(CENTER##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define VERTICAL_ALIGNMENT_CONTENT(k, v, n, p) /*--------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(center) k(CENTER##p) \
		, v(bottom) k(BOTTOM##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define CORNER_CONTENT(k, v, n, p) /*--------------------*/ { \
		  v(none)         k(NONE##p         = (b(0000))) \
		, v(top-left)     k(TOP_LEFT##p     = (b(0001))) \
		, v(top-right)    k(TOP_RIGHT##p    = (b(0010))) \
		, v(bottom-left)  k(BOTTOM_LEFT##p  = (b(0100))) \
		, v(bottom-right) k(BOTTOM_RIGHT##p = (b(1000))) \
		, n(NULL)         k(NULL##p) \
	}

	#define AXIS_CONTENT(k, v, n, p) /*----------------------*/ { \
		  v(none)       k(NONE##p) \
		, v(horizontal) k(HORIZONTAL##p) \
		, v(vertical)   k(VERTICAL##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define STARTING_SELECTION_CONTENT(k, v, n, p) /*--------*/ { \
		  v(none)    k(NONE##p) \
		, v(first)   k(FIRST##p) \
		, v(last)    k(LAST##p) \
		, v(focused) k(FOCUSED##p) \
		, n(NULL)    k(NULL##p) \
	}

	#define SELECTION_ACTION_CONTENT(k, v, n, p) /*----------*/ { \
		  v(none)            k(NONE##p) \
		, v(focus-window)    k(FOCUS_WINDOW##p) \
		, v(move-to-desktop) k(MOVE_TO_DESKTOP##p) \
		, n(NULL)            k(NULL##p) \
	}

	#define NONE_WHICH_SELECTION /*--------------------------*/ (0)
	#define PREVIOUS_WHICH_SELECTION /*----------------------*/ (1)
	#define NEXT_WHICH_SELECTION /*--------------------------*/ (2)
	#define LEFT_WHICH_SELECTION /*--------------------------*/ (3)
	#define RIGHT_WHICH_SELECTION /*-------------------------*/ (4)
	#define ABOVE_WHICH_SELECTION /*-------------------------*/ (5)
	#define BELOW_WHICH_SELECTION /*-------------------------*/ (6)

	#define _STRING_TREE_NODE_CHILDREN_AMOUNT /*-------------*/ (14)
	#define STRING_TREE_NODE_CHILDREN_AMOUNT /*--------------*/ (_STRING_TREE_NODE_CHILDREN_AMOUNT > 28? 28 : _STRING_TREE_NODE_CHILDREN_AMOUNT)

	#define EMPTY_SHARED_STATUS /*---------------------------*/ (0)
	#define FULL_SHARED_STATUS /*----------------------------*/ (1)

	#define SHORTCUT_CODE_AMOUNT /*--------------------------*/ (256)

	#define SHORTCUT_STATE_CONTENT(k, v, n, p) /*------------*/ { \
		  v(none)    k(NONE##p    = (b(000))) \
		, v(press)   k(PRESS##p   = (b(001))) \
		, v(repeat)  k(REPEAT##p  = (b(010))) \
		, v(release) k(RELEASE##p = (b(100))) \
		, n(NULL)    k(NULL##p) \
	}

	#define NONE_INSTRUCTION_TYPE /*-------------------------*/ (b(000000))
	#define NAME_INSTRUCTION_TYPE /*-------------------------*/ (b(000001))
	#define NAME_LIST_INSTRUCTION_TYPE /*--------------------*/ (b(000010))
	#define NUMBER_INSTRUCTION_TYPE /*-----------------------*/ (b(000100))
	#define STRING_INSTRUCTION_TYPE /*-----------------------*/ (b(001000))
	#define IMAGE_INSTRUCTION_TYPE /*------------------------*/ (b(010000))
	#define END_INSTRUCTION_TYPE /*--------------------------*/ (b(100000))

	#define GLOBAL_SCOPES_INSTRUCTION_CONTENT(k, v, n, p) /*-*/ { \
		  v(scope1) k(SCOPE1##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define GLOBAL_INSTRUCTION_CONTENT(k, v, n, p) /*--------*/ { \
		  v(help)           k(HELP##p) \
		, v(expand)         k(EXPAND##p) \
		, v(contract)       k(CONTRACT##p) \
		, v(read-config)    k(READ_CONFIG##p) \
		, v(use-terminal)   k(USE_TERMINAL##p) \
		, v(use-messenger)  k(USE_MESSENGER##p) \
		, v(set)            k(SET##p) \
		, v(do)             k(DO##p) \
		, v(grab-keycode)   k(GRAB_KEYCODE##p) \
		, v(grab-button)    k(GRAB_BUTTON##p) \
		, v(ungrab-keycode) k(UNGRAB_KEYCODE##p) \
		, v(ungrab-button)  k(UNGRAB_BUTTON##p) \
		, v(stop)           k(STOP##p) \
		, n(NULL)           k(NULL##p) \
	}

	#define SCOPE1_SCOPE_INSTRUCTION_CONTENT(k, v, n, p) /*--*/ { \
		  v(help)     k(HELP##p) \
		, v(expand)   k(EXPAND##p) \
		, v(contract) k(CONTRACT##p) \
		, v(stop)     k(STOP##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define BOOLEAN_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)  k(NONE##p) \
		, v(true)  k(TRUE##p) \
		, v(false) k(FALSE##p) \
		, n(NULL)  k(NULL##p) \
	}

	#define VARIABLE_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)                            k(NONE##p) \
		, v(window-x)                        k(WINDOW_X##p) \
		, v(window-y)                        k(WINDOW_Y##p) \
		, v(window-x-offset)                 k(WINDOW_X_OFFSET##p) \
		, v(window-y-offset)                 k(WINDOW_Y_OFFSET##p) \
		, v(window-width)                    k(WINDOW_WIDTH##p) \
		, v(window-height)                   k(WINDOW_HEIGHT##p) \
		, v(window-horizontal-alignment)     k(WINDOW_HORIZONTAL_ALIGNMENT##p) \
		, v(window-vertical-alignment)       k(WINDOW_VERTICAL_ALIGNMENT##p) \
		, v(window-corner-radius)            k(WINDOW_CORNER_RADIUS##p) \
		, v(window-background)               k(WINDOW_BACKGROUND##p) \
		, v(selection-x)                     k(SELECTION_X##p) \
		, v(selection-y)                     k(SELECTION_Y##p) \
		, v(selection-x-offset)              k(SELECTION_X_OFFSET##p) \
		, v(selection-y-offset)              k(SELECTION_Y_OFFSET##p) \
		, v(selection-width)                 k(SELECTION_WIDTH##p) \
		, v(selection-height)                k(SELECTION_HEIGHT##p) \
		, v(selection-margin)                k(SELECTION_MARGIN##p) \
		, v(selection-horizontal-alignment)  k(SELECTION_HORIZONTAL_ALIGNMENT##p) \
		, v(selection-vertical-alignment)    k(SELECTION_VERTICAL_ALIGNMENT##p) \
		, v(selection-clip-children)         k(SELECTION_CLIP_CHILDREN##p) \
		, v(selection-background)            k(SELECTION_BACKGROUND##p) \
		, v(selection-selected-background)   k(SELECTION_SELECTED_BACKGROUND##p) \
		, v(client-x)                        k(CLIENT_X##p) \
		, v(client-y)                        k(CLIENT_Y##p) \
		, v(client-x-offset)                 k(CLIENT_X_OFFSET##p) \
		, v(client-y-offset)                 k(CLIENT_Y_OFFSET##p) \
		, v(client-width)                    k(CLIENT_WIDTH##p) \
		, v(client-height)                   k(CLIENT_HEIGHT##p) \
		, v(client-horizontal-alignment)     k(CLIENT_HORIZONTAL_ALIGNMENT##p) \
		, v(client-vertical-alignment)       k(CLIENT_VERTICAL_ALIGNMENT##p) \
		, v(client-background)               k(CLIENT_BACKGROUND##p) \
		, v(client-selected-background)      k(CLIENT_SELECTED_BACKGROUND##p) \
		, v(title-x)                         k(TITLE_X##p) \
		, v(title-y)                         k(TITLE_Y##p) \
		, v(title-x-offset)                  k(TITLE_X_OFFSET##p) \
		, v(title-y-offset)                  k(TITLE_Y_OFFSET##p) \
		, v(title-width)                     k(TITLE_WIDTH##p) \
		, v(title-height)                    k(TITLE_HEIGHT##p) \
		, v(title-horizontal-alignment)      k(TITLE_HORIZONTAL_ALIGNMENT##p) \
		, v(title-vertical-alignment)        k(TITLE_VERTICAL_ALIGNMENT##p) \
		, v(title-clip-children)             k(TITLE_CLIP_CHILDREN##p) \
		, v(title-background)                k(TITLE_BACKGROUND##p) \
		, v(title-selected-background)       k(TITLE_SELECTED_BACKGROUND##p) \
		, v(title-text-x)                    k(TITLE_TEXT_X##p) \
		, v(title-text-y)                    k(TITLE_TEXT_Y##p) \
		, v(title-text-x-offset)             k(TITLE_TEXT_X_OFFSET##p) \
		, v(title-text-y-offset)             k(TITLE_TEXT_Y_OFFSET##p) \
		, v(title-text-horizontal-alignment) k(TITLE_TEXT_HORIZONTAL_ALIGNMENT##p) \
		, v(title-text-vertical-alignment)   k(TITLE_TEXT_VERTICAL_ALIGNMENT##p) \
		, v(title-text-foreground)           k(TITLE_TEXT_FOREGROUND##p) \
		, v(title-text-background)           k(TITLE_TEXT_BACKGROUND##p) \
		, v(title-text-selected-foreground)  k(TITLE_TEXT_SELECTED_FOREGROUND##p) \
		, v(title-text-selected-background)  k(TITLE_TEXT_SELECTED_BACKGROUND##p) \
		, v(title-text-cutoff)               k(TITLE_TEXT_CUTOFF##p) \
		, v(client-order)                    k(CLIENT_ORDER##p) \
		, v(selection-axis)                  k(SELECTION_AXIS##p) \
		, v(selection-axis-amount)           k(SELECTION_AXIS_AMOUNT##p) \
		, v(starting-selection)              k(STARTING_SELECTION##p) \
		, v(allow-circular-navigation)       k(ALLOW_CIRCULAR_NAVIGATION##p) \
		, v(selection-action)                k(SELECTION_ACTION##p) \
		, v(which-monitor)                   k(WHICH_MONITOR##p) \
		, v(font)                            k(FONT##p) \
		, n(NULL)                            k(NULL##p) \
	}

	#define COMMAND_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)                  k(NONE##p) \
		, v(execute)               k(EXECUTE##p) \
		, v(set-current-selection) k(SET_CURRENT_SELECTION##p) \
		, v(show)                  k(SHOW##p) \
		, v(hide)                  k(HIDE##p) \
		, v(toggle-visibility)     k(TOGGLE_VISIBILITY##p) \
		, v(draw)                  k(DRAW##p) \
		, v(select-previous)       k(SELECT_PREVIOUS##p) \
		, v(select-next)           k(SELECT_NEXT##p) \
		, v(select-left)           k(SELECT_LEFT##p) \
		, v(select-right)          k(SELECT_RIGHT##p) \
		, v(select-above)          k(SELECT_ABOVE##p) \
		, v(select-below)          k(SELECT_BELOW##p) \
		, v(pick-selection)        k(PICK_SELECTION##p) \
		, v(restart)               k(RESTART##p) \
		, v(exit)                  k(EXIT##p) \
		, n(NULL)                  k(NULL##p) \
	}

	#define MODIFIER_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)     k(NONE##p) \
		, v(shift)    k(SHIFT##p) \
		, v(caps)     k(CAPS##p) \
		, v(control)  k(CONTROL##p) \
		, v(mod-1)    k(MOD_1##p) \
		, v(mod-2)    k(MOD_2##p) \
		, v(mod-3)    k(MOD_3##p) \
		, v(mod-4)    k(MOD_4##p) \
		, v(mod-5)    k(MOD_5##p) \
		, v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define CLIENT_ORDER_CONTENT(k, v, n, p) /*--------------*/ { \
		  v(none)     k(NONE##p) \
		, v(creation) k(CREATION##p) \
		, v(stacking) k(STACKING##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NAME_LIST /*--------------------------------*/ (0)
	#define SUCCESS_NAME_LIST /*-----------------------------*/ (1)
	#define INVALID_NAME_NAME_LIST /*------------------------*/ (2)
	#define PREMATURE_END_NAME_LIST /*-----------------------*/ (3)

	#define MACRO_CONTENT(k, v, n, p) /*---------------------*/ { \
		  v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NUMBER /*-----------------------------------*/ (0)
	#define VALID_NUMBER_NUMBER /*---------------------------*/ (1)
	#define NON_NUMBER_NUMBER /*-----------------------------*/ (2)
	#define OVERFLOWN_NUMBER_NUMBER /*-----------------------*/ (3)
	#define DIVIDED_BY_ZERO_NUMBER /*------------------------*/ (4)

	#define NONE_MATCH_IMAGE /*------------------------------*/ (0)
	#define CANNOT_OPEN_MATCH_IMAGE /*-----------------------*/ (1)
	#define CANNOT_READ_MATCH_IMAGE /*-----------------------*/ (2)
	#define UNSUPPORTED_FORMAT_MATCH_IMAGE /*----------------*/ (3)
	#define BAD_HEADER_MATCH_IMAGE /*------------------------*/ (4)
	#define BAD_DEPTH_MATCH_IMAGE /*-------------------------*/ (5)
	#define BAD_COMPRESSION_MATCH_IMAGE /*-------------------*/ (6)
	#define UNSUPPORTED_HEIGHT_MATCH_IMAGE /*----------------*/ (7)
	#define BAD_SIZE_MATCH_IMAGE /*--------------------------*/ (8)
	#define FAILED_MATCH_IMAGE /*----------------------------*/ (9)
	#define BAD_PIXELS_MATCH_IMAGE /*------------------------*/ (10)
	#define BAD_IMAGE_MATCH_IMAGE /*-------------------------*/ (11)
	#define SUCCESS_MATCH_IMAGE /*---------------------------*/ (12)

	#define NONE_MATCH_COMMAND_ORIGIN /*---------------------*/ (0)
	#define PRESS_MATCH_COMMAND_ORIGIN /*--------------------*/ (1)
	#define RELEASE_MATCH_COMMAND_ORIGIN /*------------------*/ (2)
	#define CONFIG_MATCH_COMMAND_ORIGIN /*-------------------*/ (3)
	#define STDIN_MATCH_COMMAND_ORIGIN /*--------------------*/ (4)
	#define TRANSMITTER_MATCH_COMMAND_ORIGIN /*--------------*/ (5)

	#define NONE_MATCH_COMMAND_TYPE /*-----------------------*/ (0)
	#define TYPICAL_MATCH_COMMAND_TYPE /*--------------------*/ (1)
	#define RESTART_MATCH_COMMAND_TYPE /*--------------------*/ (2)
	#define EXIT_MATCH_COMMAND_TYPE /*-----------------------*/ (3)

	#define ROTATION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)        k(NONE##p) \
		, v(degrees-90)  k(DEGREES_90##p)  \
		, v(degrees-180) k(DEGREES_180##p) \
		, v(degrees-270) k(DEGREES_270##p) \
		, n(NULL)        k(NULL##p) \
	}

	#define INITCLIENTLISTSYSTEM() /*------------------------*/ local bool               initClientListSystem(ClientListSystem *const clientListSystem)
	#define SETCLIENTLISTTEXTCUTOFF() /*---------------------*/ local bool               setClientListTextCutoff(ClientListSystem *const clientListSystem, const uint titleTextCutoff, const xcb_font_t font)
	#define CREATECLIENTLIST() /*----------------------------*/ local bool               createClientList(ClientListSystem *const clientListSystem, const xcb_atom_t property, const xcb_font_t font)
	#define UPDATECLIENTSTITLE() /*--------------------------*/ local bool               updateClientsTitle(ClientListSystem *const clientListSystem, const xcb_font_t font)
	#define SETCLIENTLISTCLIENTTITLE() /*--------------------*/ local bool               setClientListClientTitle(ClientListSystem *const clientListSystem, Client *const client, const xcb_font_t font)
	#define DESTROYCLIENTLIST() /*---------------------------*/ local bool               destroyClientList(ClientListSystem *const clientListSystem)
	#define FINDCLIENTLISTWINDOW() /*------------------------*/ local Client *           findClientListWindow(ClientListSystem *const clientListSystem, const xcb_window_t window)
	#define FINICLIENTLISTSYSTEM() /*------------------------*/ local bool               finiClientListSystem(ClientListSystem *const clientListSystem)

	#define INITSELECTIONSYSTEM() /*-------------------------*/ local bool               initSelectionSystem(SelectionSystem *const selectionSystem)
	#define SETSELECTIONAXIS() /*----------------------------*/ local bool               setSelectionAxis(SelectionSystem *const selectionSystem, const uint8 selectionAxis)
	#define SETSELECTIONAXISAMOUNT() /*----------------------*/ local bool               setSelectionAxisAmount(SelectionSystem *const selectionSystem, const uint selectionAxisAmount)
	#define SETSELECTIONAMOUNT() /*--------------------------*/ local bool               setSelectionAmount(SelectionSystem *const selectionSystem, const uint selectionAmount)
	#define SETSTARTINGSELECTION() /*------------------------*/ local bool               setStartingSelection(SelectionSystem *const selectionSystem, const uint8 startingSelection)
	#define SETCURRENTSELECTION() /*-------------------------*/ local bool               setCurrentSelection(SelectionSystem *const selectionSystem, ClientListSystem *const clientListSystem)
	#define SETSELECTIONNAVIGATION() /*----------------------*/ local bool               setSelectionNavigation(SelectionSystem *const selectionSystem, const bool allowCircularNavigation)
	#define SETSELECTIONACTION() /*--------------------------*/ local bool               setSelectionAction(SelectionSystem *const selectionSystem, const uint8 selectionAction)
	#define MOVECURRENTSELECTION() /*------------------------*/ local bool               moveCurrentSelection(SelectionSystem *const selectionSystem, const uint8 whichSelection)
	#define PICKSELECTION() /*-------------------------------*/ local bool               pickSelection(SelectionSystem *const selectionSystem, ClientListSystem *const clientListSystem)
	#define FINISELECTIONSYSTEM() /*-------------------------*/ local bool               finiSelectionSystem(SelectionSystem *const selectionSystem)

	#define SETCONFIGVARIABLES() /*--------------------------*/ local void               setConfigVariables(void)
	#define READCONFIG() /*----------------------------------*/ local void               readConfig(const bool createConfigFile, const char *const configPath, int (*getNextConfigChar)(void *const arg), int (*getPreviousConfigChar)(void *const arg))
	#define IFGETC() /*--------------------------------------*/ local int                ifgetc(void *const system)
	#define MATCHNAMELIST() /*-------------------------------*/ local uint8              matchNameList(StringTreeSystem *const stringTreeSystem, const char *const statementWall, char **statementCurrentReturn, uint8 *const valueReturn)
	#define MATCHINTEGER() /*--------------------------------*/ local uint8              matchInteger(char **statementCurrent, const char *const statementWall, int64 *const returnValue)
	#define MATCHSTRING() /*---------------------------------*/ local bool               matchString(char **statementCurrent, char **stringReturn, uint32 *stringToken)
	#define MATCHIMAGE() /*----------------------------------*/ local uint8              matchImage(const char *const path, const char **errorMessage, Image *const image)
	#define MATCHCOMMAND() /*--------------------------------*/ local uint8              matchCommand(const Command command, const char *const execute, const uint8 origin, const int32 field0, const int32 field1, const int32 field2, const int32 field3, const int32 field4)
	#define FREECONFIGVARIABLES() /*-------------------------*/ local void               freeConfigVariables(void)

	#define CREATECIRCLE() /*--------------------------------*/ local bool               createCircle(const int radius, const uint32 foreground, const uint32 background, Image *image)
	#define COMPOSITEIMAGES() /*-----------------------------*/ local void               compositeImages(void (*operation)(const uint32 *const, uint32 *const), const int sourceX, const int sourceY, Image *const source, int destinationX, int destinationY, Image *const destination)
	#define COMPOSITEIMAGESOVER() /*-------------------------*/ local void               compositeImagesOver(const uint32 *const source, uint32 *const destination)
	#define COMPOSITEIMAGESAND() /*--------------------------*/ local void               compositeImagesAnd(const uint32 *const source, uint32 *const destination)
	#define TWOPASSBOXBLUR() /*------------------------------*/ local void               twoPassBoxBlur(const int width, const int height, const int boxSize, uint32 *destinationData)
	#define SCALEIMAGE() /*----------------------------------*/ local bool               scaleImage(void *const source, const uint sourceWidth, const uint sourceHeight, void *const destination, const uint destinationWidth, const uint destinationHeight)
	#define ROTATEIMAGE() /*---------------------------------*/ local bool               rotateImage(const uint8 rotation, Image *const image, const bool deletePreviousData)

	#define XCB_SYNC() /*------------------------------------*/ local bool               xcb_sync(void)
	#define GETWINDOWCLASS() /*------------------------------*/ local uint8              getWindowClass(xcb_window_t window)
	#define GETFOCUSEDWINDOW() /*----------------------------*/ local xcb_window_t       getFocusedWindow(void)

	#define RESTART() /*-------------------------------------*/ local void               restart(const bool isInsideConfig)
	#define CLEANUP() /*-------------------------------------*/ local void               cleanup(void)
	#define CANCELTHREADS() /*-------------------------------*/ local void               cancelThreads(void)

	#define PRINTUNACCOUNTEDFORPOINTERS() /*-----------------*/ local void               printUnaccountedForPointers(const Pointer *current, const Pointer *wall)
	#define PRINTERROR() /*----------------------------------*/ local void               printError(const char *const message, ...)
	#define PRINTTITLEDERROR() /*----------------------------*/ local void               printTitledError(const char *const title, const char *const message)
	#define PRINTTITLEDQUOTEDERROR() /*----------------------*/ local void               printTitledQuotedError(const char *const title, const char *const argument, const char *const message)
	#define PRINTCONNECTIONERROR() /*------------------------*/ local void               printConnectionError(void)
	#define PRINTTITLEDNAMEDERROR() /*-----------------------*/ local void               printTitledNamedError(const char *const title, const char *const message, const char *const name)
	#define PRINTXERROR() /*---------------------------------*/ local void               printXError(const char *const *const name)
	#define PRINTTITLEDVALUEDERROR() /*----------------------*/ local void               printTitledValuedError(const char *const title, const char *const message, const uint value)
	#define PRINTCONFIGERROR() /*----------------------------*/ local void               printConfigError(const char *const type, const char *const message, const char finalStatementCharacter, const bool printLine, const bool printConfig, const bool printPointer, const bool printPattern, const char *const configPath, const uint statementLine, const char *const statementStart, const char *const statementWall, const Instruction *instructionStart, const Instruction *instructionCurrent, StringTreeSystem *const *const instructionDataStart, const char *const *currentScopeInstructionList, const StringTreeSystem *const currentScopeInstructionStringTreeSystem)

	#if DEBUG
		#define printCommand(s, c) /*---*/ (fprintf(DEFAULT_OUTPUT_STREAM, "%s%s: %s" s " command:%s %s\n", colorStart, programName, colorEvent, colorEnd, *(commandList + (c >= countof(commandList)? countof(commandList) - 1 : c))))
	#else
		#define printCommand(s, c) /*---*/ EMPTY_MACRO
	#endif
/*!}*/

/*!defs:{*/
	def enum ENUM_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	def enum ENUM_CONTENT(GLOBAL_INSTRUCTION);
	def enum ENUM_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	def enum ENUM_CONTENT(BOOLEAN);
	def enum ENUM_CONTENT(VARIABLE);
	def enum ENUM_CONTENT(COMMAND);
	def enum ENUM_CONTENT(MODIFIER);
	def enum ENUM_CONTENT(SHORTCUT_STATE);
	def enum ENUM_CONTENT(NUMBER_TYPE);
	def enum ENUM_CONTENT(POSITION);
	def enum ENUM_CONTENT(HORIZONTAL_ALIGNMENT);
	def enum ENUM_CONTENT(VERTICAL_ALIGNMENT);
	def enum ENUM_CONTENT(CORNER);
	def enum ENUM_CONTENT(CLIENT_ORDER);
	def enum ENUM_CONTENT(AXIS);
	def enum ENUM_CONTENT(STARTING_SELECTION);
	def enum ENUM_CONTENT(SELECTION_ACTION);
	def enum ENUM_CONTENT(WHICH_MONITOR);
	def enum ENUM_CONTENT(ROTATION);
	def enum ENUM_CONTENT(MACRO);

	def struct{
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		int32 /*---------------*/ xOffset;
		int32 /*---------------*/ yOffset;
		int32 /*---------------*/ width;
		int32 /*---------------*/ height;
		int32 /*---------------*/ padding;
		int32 /*---------------*/ margin;
		uint8 /*---------------*/ xType;
		uint8 /*---------------*/ yType;
		uint8 /*---------------*/ xOffsetType;
		uint8 /*---------------*/ yOffsetType;
		uint8 /*---------------*/ widthType;
		uint8 /*---------------*/ heightType;
		uint8 /*---------------*/ paddingType;
		uint8 /*---------------*/ marginType;
		uint8 /*---------------*/ position;
		uint8 /*---------------*/ horizontalAlignment;
		uint8 /*---------------*/ verticalAlignment;
		uint8 /*---------------*/ pad0[3];
		bool /*----------------*/ clipChildren;
		uint8 /*---------------*/ cornerUsed;
		uint32 /*--------------*/ cornerRadius;
		uint32 /*--------------*/ foreground;
		uint32 /*--------------*/ background;
		uint32 /*--------------*/ selectedForeground;
		uint32 /*--------------*/ selectedBackground;
	} ElementPreferences;

	def struct{
		xcb_window_t /*--------*/ window;
		xcb_pixmap_t /*--------*/ bufferPixmap;
		xcb_pixmap_t /*--------*/ pixmap;
		xcb_gcontext_t /*------*/ gc;
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
		bool /*----------------*/ mapped;
		uint8 /*---------------*/ pad0[3];
	} WindowInfo;

	def struct{
		xcb_pixmap_t /*--------*/ circlePixmap;
		uint32 /*--------------*/ windowInfoSize;
		WindowInfo * /*--------*/ windowInfoStart;
		uint32 /*--------------*/ windowInfoToken;
		bool /*----------------*/ mapped;
		uint8 /*---------------*/ pad0[3];
	} WindowSystem;

	def struct{
		Monitor * /*-----------*/ monitor;
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
		uint32 /*--------------*/ horizontalPadding;
		uint32 /*--------------*/ verticalPadding;
		uint32 /*--------------*/ horizontalMargin;
		uint32 /*--------------*/ verticalMargin;
	} ElementRectangle;

	def struct{
		xcb_window_t /*--------*/ window;
		uint32 /*--------------*/ titleSize;
		uint16 * /*------------*/ titleStart;
		uint32 /*--------------*/ titleToken;
		int32 /*---------------*/ fontX;
		int32 /*---------------*/ fontY;
		uint32 /*--------------*/ fontWidth;
		uint32 /*--------------*/ fontHeight;
		uint8 /*---------------*/ pad0[4];
	} Client;

	def struct{
		Client * /*------------*/ clientStart;
		uint32 /*--------------*/ clientToken;
		uint32 /*--------------*/ clientSize;
		uint32 /*--------------*/ titleTextCutoff;
		uint8 /*---------------*/ pad0[4];
	} ClientListSystem;

	def struct{
		uint32 /*--------------*/ selectionAmount;
		uint32 /*--------------*/ selectionAxisAmount;
		int32 /*---------------*/ currentSelection;
		uint8 /*---------------*/ startingSelection;
		uint8 /*---------------*/ selectionAxis;
		bool /*----------------*/ allowCircularNavigation;
		uint8 /*---------------*/ selectionAction;
	} SelectionSystem;

	def struct{
		bool /*----------------*/ (*risingOperation)(void *const arg);
		void * /*--------------*/ risingOperationArgument;
		bool /*----------------*/ (*fallingOperation)(void *const arg);
		void * /*--------------*/ fallingOperationArgument;
		uint32 /*--------------*/ seconds;
		uint32 /*--------------*/ nanoseconds;
		bool /*----------------*/ loopOperation;
		bool /*----------------*/ restartTimer;
		uint8 /*---------------*/ pad0[1];
		bool /*----------------*/ running;
		bool /*----------------*/ quittingThread;
		bool /*----------------*/ mutexCreated;
		bool /*----------------*/ condCreated;
		bool /*----------------*/ threadCreated;
		pthread_mutex_t /*-----*/ mutex;
		pthread_cond_t /*------*/ cond;
		pthread_t /*-----------*/ thread;
	} SleepThreadSystem;

	def struct{
		uint8 /*---------------*/ letter;
		uint8 /*---------------*/ childrenAmount;
		uint16 /*--------------*/ offset[STRING_TREE_NODE_CHILDREN_AMOUNT];
	} StringTreeNode;

	def struct{
		const char *const * /*-*/ stringArray;
		uint32 /*--------------*/ dataSize;
		uint32 /*--------------*/ dataAllocated;
		StringTreeNode * /*----*/ dataStart;
		uint32 /*--------------*/ dataToken;
		uint8 /*---------------*/ counter;
		uint8 /*---------------*/ returnedCounter;
		uint8 /*---------------*/ pad0[2];
	} StringTreeSystem;

	def struct{
		uint32 /*--------------*/ size;
		uint32 /*--------------*/ allocated;
		char * /*--------------*/ start;
		char * /*--------------*/ current;
		uint32 /*--------------*/ token;
		uint8 /*---------------*/ pad0[1];
		bool /*----------------*/ threadCreated;
		bool /*----------------*/ operating;
		bool /*----------------*/ quittingThread;
		pthread_t /*-----------*/ thread;
	} STDINSystem;

	def struct{
		int32 /*---------------*/ shmID;
		uint32 /*--------------*/ shmToken;
		uint8 * /*-------------*/ start;
		uint8 * /*-------------*/ current;
		uint32 /*--------------*/ token;
		uint8 /*---------------*/ pad0[6];
		bool /*----------------*/ mutexCreated;
		bool /*----------------*/ condCreated;
		bool /*----------------*/ threadCreated;
		bool /*----------------*/ operating;
		bool /*----------------*/ quittingFromInside;
		bool /*----------------*/ quittingThread;
		pthread_mutex_t * /*---*/ mutex;
		pthread_cond_t * /*----*/ cond;
		pthread_t /*-----------*/ thread;
	} SharedMemorySystem;
/*!}*/

/*!globals:{*/
	local const char * /*-------------------*/ programName;
	local const char * /*-------------------*/ errorPath;
	local const char * /*-------------------*/ colorStart;
	local const char * /*-------------------*/ colorFatal;
	local const char * /*-------------------*/ colorError;
	local const char * /*-------------------*/ colorEvent;
	local const char * /*-------------------*/ colorEnd;
	local const char * /*-------------------*/ labelExamined;
	local const char * /*-------------------*/ connectionName;
	local const char * /*-------------------*/ configPath;
	local const char * /*-------------------*/ localeName;
	local const ModifierNode * /*-----------*/ eventModifierNode;
	local bool /*---------------------------*/ mustOpenErrorStream;
	local FILE * /*-------------------------*/ errorStream;
	local uint32 /*-------------------------*/ errorStreamToken;
	local volatile bool /*------------------*/ processingSignal;
	local bool /*---------------------------*/ quitting;
	local MemoryManagementSystem /*------------*/ memoryManagementSystem;
	local PermissionSystem /*---------------*/ permissionSystem;
	local bool /*---------------------------*/ globalsLockCreated;
	local pthread_rwlock_t /*---------------*/ globalsLock;
	local int /*----------------------------*/ screenNumber;
	local xcb_connection_t * /*-------------*/ connection;
	local uint32 /*-------------------------*/ connectionToken;
	local xcb_screen_t * /*-----------------*/ screen;
	local uint /*---------------------------*/ screenWidthInPixels;
	local uint /*---------------------------*/ screenHeightInPixels;
	local uint /*---------------------------*/ screenWidthInMillimeters;
	local uint /*---------------------------*/ screenHeightInMillimeters;
	local uint8 /*--------------------------*/ randrMajorOpcode;
	local uint8 /*--------------------------*/ randrBaseEvent;
	local uint8 /*--------------------------*/ randrBaseError;
	local CommonAtoms /*--------------------*/ atom;
	local xcb_visualid_t /*-----------------*/ visual;
	local uint8 /*--------------------------*/ depth;
	local xcb_colormap_t /*-----------------*/ colormap;
	local MonitorSystem /*------------------*/ monitorSystem;
	local ElementPreferences /*-------------*/ windowPreferences;
	local ElementPreferences /*-------------*/ selectionPreferences;
	local ElementPreferences /*-------------*/ clientPreferences;
	local ElementPreferences /*-------------*/ titlePreferences;
	local ElementPreferences /*-------------*/ titleTextPreferences;
	local uint8 /*--------------------------*/ clientOrder;
	local uint8 /*--------------------------*/ whichMonitor;
	local xcb_font_t /*---------------------*/ font;
	local WindowSystem /*-------------------*/ windowSystem;
	local ClientListSystem /*---------------*/ clientListSystem;
	local ClientListSystem /*---------------*/ clientListStackingSystem;
	local SelectionSystem /*----------------*/ selectionSystem;
	local SleepThreadSystem /*--------------*/ sleepThreadSystem;
	local StringTreeSystem /*---------------*/ globalScopesInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ globalInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ scope1ScopeInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ booleanStringTreeSystem;
	local StringTreeSystem /*---------------*/ variableStringTreeSystem;
	local StringTreeSystem /*---------------*/ commandStringTreeSystem;
	local StringTreeSystem /*---------------*/ modifierStringTreeSystem;
	local StringTreeSystem /*---------------*/ shortcutStateStringTreeSystem;
	local StringTreeSystem /*---------------*/ numberTypeStringTreeSystem;
	local StringTreeSystem /*---------------*/ horizontalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ verticalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ cornerStringTreeSystem;
	local StringTreeSystem /*---------------*/ clientOrderStringTreeSystem;
	local StringTreeSystem /*---------------*/ axisStringTreeSystem;
	local StringTreeSystem /*---------------*/ startingSelectionStringTreeSystem;
	local StringTreeSystem /*---------------*/ selectionActionStringTreeSystem;
	local StringTreeSystem /*---------------*/ whichMonitorStringTreeSystem;
	local StringTreeSystem /*---------------*/ macroStringTreeSystem;
	local bool /*---------------------------*/ displaySimpleConfigErrors;
	local STDINSystem /*--------------------*/ stdinSystem;
	local SharedMemorySystem /*-------------*/ sharedMemorySystem;
	local ShortcutSystem /*-----------------*/ keycodeShortcutSystem;
	local ShortcutSystem /*-----------------*/ buttonShortcutSystem;
	local xcb_generic_event_t * /*----------*/ event;
	local uint32 /*-------------------------*/ eventToken;
	local int /*----------------------------*/ keyPressNextOffset;
	local int /*----------------------------*/ keyReleaseNextOffset;
	local int /*----------------------------*/ buttonPressNextOffset;
	local int /*----------------------------*/ buttonReleaseNextOffset;
	local uint8 /*--------------------------*/ shortcutCode;
	local uint16 /*-------------------------*/ shortcutModifier;
	local bool /*---------------------------*/ expectingSecondKeyRelease;
	local uint8 /*--------------------------*/ realKeyReleaseModifier;

	local const char *const /*--------------*/ globalScopesInstructionList[] = STRING_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	local const char *const /*--------------*/ globalInstructionList[] = STRING_CONTENT(GLOBAL_INSTRUCTION);
	local const char *const /*--------------*/ scope1ScopeInstructionList[] = STRING_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	local const char *const /*--------------*/ booleanList[] = STRING_CONTENT(BOOLEAN);
	local const char *const /*--------------*/ variableList[] = STRING_CONTENT(VARIABLE);
	local const char *const /*--------------*/ commandList[] = STRING_CONTENT(COMMAND);
	local const char *const /*--------------*/ modifierList[] = STRING_CONTENT(MODIFIER);
	local const char *const /*--------------*/ shortcutStateList[] = STRING_CONTENT(SHORTCUT_STATE);
	local const char *const /*--------------*/ numberTypeList[] = STRING_CONTENT(NUMBER_TYPE);
	local const char *const /*--------------*/ horizontalAlignmentList[] = STRING_CONTENT(HORIZONTAL_ALIGNMENT);
	local const char *const /*--------------*/ verticalAlignmentList[] = STRING_CONTENT(VERTICAL_ALIGNMENT);
	local const char *const /*--------------*/ cornerList[] = STRING_CONTENT(CORNER);
	local const char *const /*--------------*/ clientOrderList[] = STRING_CONTENT(CLIENT_ORDER);
	local const char *const /*--------------*/ axisList[] = STRING_CONTENT(AXIS);
	local const char *const /*--------------*/ startingSelectionList[] = STRING_CONTENT(STARTING_SELECTION);
	local const char *const /*--------------*/ selectionActionList[] = STRING_CONTENT(SELECTION_ACTION);
	local const char *const /*--------------*/ whichMonitorList[] = STRING_CONTENT(WHICH_MONITOR);
	local const char *const /*--------------*/ macroList[] = STRING_CONTENT(MACRO);

	local const Instruction /*--------------*/ helpInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ expandInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ contractInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ readConfigInstruction[] = {STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useTerminalInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useMessengerInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ setInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ doInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ stopInstruction[] = {END_INSTRUCTION_TYPE};

	local const Instruction /*--------------*/ windowXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowWidthSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowHeightSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowCornerRadiusSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ windowBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionWidthSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionHeightSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionMarginSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionClipChildrenSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionSelectedBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ clientXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ clientYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ clientXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ clientYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ clientWidthSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ clientHeightSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ clientHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ clientVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ clientBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ clientSelectedBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleWidthSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleHeightSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleSelectedBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleTextXSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleTextYSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleTextXOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleTextYOffsetSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleTextHorizontalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleTextVerticalAlignmentSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleClipChildrenSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleTextForegroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleTextBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleTextSelectedForegroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleTextSelectedBackgroundSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ titleTextCutoffSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ clientOrderSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionAxisSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionAxisAmountSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ startingSelectionSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ allowCircularNavigationSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ selectionActionSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ whichMonitorSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ fontSetSubinstruction[] = {NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};

	local StringTreeSystem *const *const /*-*/ helpInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ expandInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ contractInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ readConfigInstructionData = NULL;
	local StringTreeSystem *const /*--------*/ useTerminalInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ useMessengerInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ setInstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ doInstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabKeycodeInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabButtonInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabKeycodeInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabButtonInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const *const /*-*/ stopInstructionData = NULL;

	local StringTreeSystem *const /*--------*/ windowXSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowYSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowXOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowYOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowWidthSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowHeightSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowHorizontalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &horizontalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowVerticalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &verticalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowCornerRadiusSetSubinstructionData[] = {&variableStringTreeSystem, &cornerStringTreeSystem};
	local StringTreeSystem *const /*--------*/ windowBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionXSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionYSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionXOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionYOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionWidthSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionHeightSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionMarginSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionHorizontalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &horizontalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionVerticalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &verticalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionClipChildrenSetSubinstructionData[] = {&variableStringTreeSystem, &booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionSelectedBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ clientXSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ clientYSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ clientXOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ clientYOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ clientWidthSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ clientHeightSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ clientHorizontalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &horizontalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ clientVerticalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &verticalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ clientBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ clientSelectedBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleXSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleYSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleXOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleYOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleWidthSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleHeightSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleHorizontalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &horizontalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleVerticalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &verticalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleClipChildrenSetSubinstructionData[] = {&variableStringTreeSystem, &booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleSelectedBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleTextXSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleTextYSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleTextXOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleTextYOffsetSetSubinstructionData[] = {&variableStringTreeSystem, &numberTypeStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleTextHorizontalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &horizontalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleTextVerticalAlignmentSetSubinstructionData[] = {&variableStringTreeSystem, &verticalAlignmentStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleTextForegroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleTextBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleTextSelectedForegroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleTextSelectedBackgroundSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ titleTextCutoffSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ clientOrderSetSubinstructionData[] = {&variableStringTreeSystem, &clientOrderStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionAxisSetSubinstructionData[] = {&variableStringTreeSystem, &axisStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionAxisAmountSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ startingSelectionSetSubinstructionData[] = {&variableStringTreeSystem, &startingSelectionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ allowCircularNavigationSetSubinstructionData[] = {&variableStringTreeSystem, &booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ selectionActionSetSubinstructionData[] = {&variableStringTreeSystem, &selectionActionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ whichMonitorSetSubinstructionData[] = {&variableStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ fontSetSubinstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeDoSubinstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};

	#define getInstruction(i) /*-----*/ (i##Instruction)
	#define getInstructionData(i) /*-*/ (i##InstructionData)
	#define getGlobalScope(i) /*-----*/ { \
		  get##i(help) \
		, get##i(expand) \
		, get##i(contract) \
		, get##i(readConfig) \
		, get##i(useTerminal) \
		, get##i(useMessenger) \
		, get##i(set) \
		, get##i(do) \
		, get##i(grabKeycode) \
		, get##i(grabButton) \
		, get##i(ungrabKeycode) \
		, get##i(ungrabButton) \
		, get##i(stop) \
	}
/*!}*/

int main(int argumentAmount, const char *const *argument){
	setGlobals:{
		programName /*---------------*/ = *argument;
		errorPath /*-----------------*/ = NULL;
		colorStart /*----------------*/ = MESSAGE_START;
		colorFatal /*----------------*/ = MESSAGE_FATAL;
		colorError /*----------------*/ = MESSAGE_ERROR;
		colorEvent /*----------------*/ = MESSAGE_EVENT;
		colorEnd /*------------------*/ = MESSAGE_END;
		connectionName /*------------*/ = NULL;
		configPath /*----------------*/ = NULL;
		localeName /*----------------*/ = setlocale(LC_ALL, "");
		mustOpenErrorStream /*-------*/ = false;
		errorStream /*---------------*/ = DEFAULT_ERROR_STREAM;
		errorStreamToken /*----------*/ = 0;
		quitting /*------------------*/ = false;
		connection /*----------------*/ = NULL;
		connectionToken /*-----------*/ = 0;
		event /*---------------------*/ = NULL;
		eventToken /*----------------*/ = 0;
		keyPressNextOffset /*--------*/ = 0;
		keyReleaseNextOffset /*------*/ = 0;
		buttonPressNextOffset /*-----*/ = 0;
		buttonReleaseNextOffset /*---*/ = 0;
		shortcutCode /*--------------*/ = 0;
		shortcutModifier /*----------*/ = XCB_NONE;
		expectingSecondKeyRelease /*-*/ = false;
		initMemorySystem();
		initPermissionSystem(&permissionSystem);
		initMonitorSystem(&monitorSystem);
		initClientListSystem(&clientListSystem);
		initClientListSystem(&clientListStackingSystem);
		initSelectionSystem(&selectionSystem);
		initWindowSystem(&windowSystem);
		initSleepThreadSystem(&sleepThreadSystem);
		initStringTreeSystem(&globalScopesInstructionStringTreeSystem);
		initStringTreeSystem(&globalInstructionStringTreeSystem);
		initStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
		initStringTreeSystem(&booleanStringTreeSystem);
		initStringTreeSystem(&variableStringTreeSystem);
		initStringTreeSystem(&commandStringTreeSystem);
		initStringTreeSystem(&modifierStringTreeSystem);
		initStringTreeSystem(&shortcutStateStringTreeSystem);
		initStringTreeSystem(&numberTypeStringTreeSystem);
		initStringTreeSystem(&horizontalAlignmentStringTreeSystem);
		initStringTreeSystem(&verticalAlignmentStringTreeSystem);
		initStringTreeSystem(&cornerStringTreeSystem);
		initStringTreeSystem(&clientOrderStringTreeSystem);
		initStringTreeSystem(&axisStringTreeSystem);
		initStringTreeSystem(&startingSelectionStringTreeSystem);
		initStringTreeSystem(&selectionActionStringTreeSystem);
		initStringTreeSystem(&whichMonitorStringTreeSystem);
		initStringTreeSystem(&macroStringTreeSystem);
		initSTDINSystem(&stdinSystem);
		initSharedMemorySystem(&sharedMemorySystem);
		initShortcutSystem(&keycodeShortcutSystem);
		initShortcutSystem(&buttonShortcutSystem);
		setConfigVariables();
		setPermissions(&permissionSystem);
		lowerPermissions(&permissionSystem);
		processingSignal = false;
		jmp getProgramArguments;
	}
	initSystems:{
		if(createMonitors(&monitorSystem)){
			createWindows(&windowSystem, monitorSystem.size, true, XCB_EVENT_MASK_PROPERTY_CHANGE);
		}
		createClientList(&clientListSystem, atom._NET_CLIENT_LIST, font);
		createClientList(&clientListStackingSystem, atom._NET_CLIENT_LIST_STACKING, font);
		bulkInsertString(&globalScopesInstructionStringTreeSystem, globalScopesInstructionList);
		bulkInsertString(&globalInstructionStringTreeSystem, globalInstructionList);
		bulkInsertString(&scope1ScopeInstructionStringTreeSystem, scope1ScopeInstructionList);
		bulkInsertString(&booleanStringTreeSystem, booleanList);
		bulkInsertString(&variableStringTreeSystem, variableList);
		bulkInsertString(&commandStringTreeSystem, commandList);
		bulkInsertString(&modifierStringTreeSystem, modifierList);
		bulkInsertString(&shortcutStateStringTreeSystem, shortcutStateList);
		bulkInsertString(&numberTypeStringTreeSystem, numberTypeList);
		bulkInsertString(&horizontalAlignmentStringTreeSystem, horizontalAlignmentList);
		bulkInsertString(&verticalAlignmentStringTreeSystem, verticalAlignmentList);
		bulkInsertString(&cornerStringTreeSystem, cornerList);
		bulkInsertString(&clientOrderStringTreeSystem, clientOrderList);
		bulkInsertString(&axisStringTreeSystem, axisList);
		bulkInsertString(&startingSelectionStringTreeSystem, startingSelectionList);
		bulkInsertString(&selectionActionStringTreeSystem, selectionActionList);
		bulkInsertString(&whichMonitorStringTreeSystem, whichMonitorList);
		bulkInsertString(&macroStringTreeSystem, macroList);
		jmp readConfig;
	}
	switchEvent:{
		#define XCB_ONE /*-*/ (1)
		if(((*event).response_type & ~b(10000000)) > XCB_NONE and ((*event).response_type & ~b(10000000)) < XCB_GE_GENERIC){
			printXEvent(baseEventName);
		}
		switch (*event).response_type & ~b(10000000) over
			to XCB_NONE: /*--------------*/ jmp errorEvent;
			to XCB_ONE: /*---------------*/ jmp unrecognizedEvent;
			to XCB_KEY_PRESS: /*---------*/ jmp keyPressEvent;
			to XCB_KEY_RELEASE: /*-------*/ jmp keyReleaseEvent;
			to XCB_BUTTON_PRESS: /*------*/ jmp buttonPressEvent;
			to XCB_BUTTON_RELEASE: /*----*/ jmp buttonReleaseEvent;
			to XCB_MOTION_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_ENTER_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_LEAVE_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*----------*/ jmp unexpectedEvent;
			to XCB_FOCUS_OUT: /*---------*/ jmp unexpectedEvent;
			to XCB_KEYMAP_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*-*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*-------*/ jmp unexpectedEvent;
			to XCB_VISIBILITY_NOTIFY: /*-*/ jmp unexpectedEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_MAP_NOTIFY: /*--------*/ jmp unexpectedEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ jmp propertyNotifyEvent;
			to XCB_SELECTION_CLEAR: /*---*/ jmp unexpectedEvent;
			to XCB_SELECTION_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_SELECTION_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_COLORMAP_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CLIENT_MESSAGE: /*----*/ jmp eventLoop;
			to XCB_MAPPING_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*--------*/ jmp genericEvent;
			off: /*----------------------*/ jmp extensionEvent;
		end
		#undef  XCB_ONE
	}
	keyReleaseEvent:{
		#define e /*-*/ ((xcb_key_release_event_t *)event)
		uint8 keycode = (*e).detail;
		uint16 modifier = (*e).state & b(11111111);
		if(getNextShortcut(&keycodeShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &keyReleaseNextOffset)){
			xcb_query_keymap_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_keymap_unchecked(connection), NULL);
			uint32 token = pushPointer(reply, "query keymap reply", iFree);
			if(reply){
				const bool keyIsPressed = !!(*((*reply).keys + (*e).detail / 8) & (1 << (*e).detail % 8));
				free(reply);
				popPointer(token);
				if(keyIsPressed){
					keyReleaseNextOffset = 0;
					jmp eventLoop;
				}
			}
			jmp matchCommandRelease;
		}
		if(keycode != shortcutCode and modifier == shortcutModifier){
			expectingSecondKeyRelease = true;
			realKeyReleaseModifier = shortcutModifier;
			jmp eventLoop;
		}
		if(keycode == shortcutCode and modifier != shortcutModifier){
			if(!expectingSecondKeyRelease){
				jmp eventLoop;
			}
			keycode = shortcutCode;
			modifier = realKeyReleaseModifier;
			expectingSecondKeyRelease = false;
			keyReleaseNextOffset = 0;
			if(getNextShortcut(&keycodeShortcutSystem, true, keycode, modifier, &keyReleaseNextOffset)){
				jmp matchCommandRelease;
			}
		}
		jmp eventLoop;
		#undef  e
	}
	buttonPressEvent:{
		#define e /*-*/ ((xcb_button_press_event_t *)event)
		if(getNextShortcut(&buttonShortcutSystem, false, (*e).detail, (*e).state & b(11111111), &buttonPressNextOffset)){
			jmp matchCommandPress;
		}
		jmp eventLoop;
		#undef  e
	}
	buttonReleaseEvent:{
		#define e /*-*/ ((xcb_button_release_event_t *)event)
		if(getNextShortcut(&buttonShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &buttonReleaseNextOffset)){
			jmp matchCommandRelease;
		}
		jmp eventLoop;
		#undef  e
	}
	{
		uint8 commandOrigin;
		matchCommandPress:{
			commandOrigin = PRESS_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommandRelease:{
			commandOrigin = RELEASE_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommand: switch matchCommand((*eventModifierNode).command, (*eventModifierNode).string, commandOrigin, (*eventModifierNode).field0, (*eventModifierNode).field1, (*eventModifierNode).field2, (*eventModifierNode).field3, (*eventModifierNode).field4) over
			to TYPICAL_MATCH_COMMAND_TYPE:{
				jmp eventLoopCheckShortcuts;
			}
			to RESTART_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp readConfig;
			}
			to EXIT_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp mainEmergencyExit;
			}
			off:{
				jmp eventLoopCheckShortcuts;
			}
		end
	}
	propertyNotifyEvent:{
		#define e /*-*/ ((xcb_property_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		const xcb_atom_t property = (*e).atom;
		Client *client;
		bool update = false;
		if(eventWindow == (*screen).root){
			if(property == atom._NET_CLIENT_LIST){
				if(createClientList(&clientListSystem, atom._NET_CLIENT_LIST, font)){
					setSelectionAmount(&selectionSystem, clientListSystem.clientSize);
					if(clientOrder == CREATION_CLIENT_ORDER and windowSystem.mapped){
						drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
					}
				}
				jmp eventLoop;
			}
			if(property == atom._NET_CLIENT_LIST_STACKING){
				if(createClientList(&clientListStackingSystem, atom._NET_CLIENT_LIST_STACKING, font)){
					setSelectionAmount(&selectionSystem, clientListStackingSystem.clientSize);
					if(clientOrder == STACKING_CLIENT_ORDER and windowSystem.mapped){
						drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
					}
				}
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		if((client = findClientListWindow(&clientListSystem, eventWindow))){
			if(setClientListClientTitle(&clientListSystem, client, font)){
				update = true;
			}
		}
		if((client = findClientListWindow(&clientListStackingSystem, eventWindow))){
			if(setClientListClientTitle(&clientListStackingSystem, client, font)){
				update = true;
			}
		}
		if(update and windowSystem.mapped){
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp eventLoop;
		#undef  e
	}
	genericEvent:{
		#define e /*-*/ ((xcb_ge_generic_event_t *)event)
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  e
	}
	extensionEvent:{
		#define isExtensionEvent(e) /*-*/ (eventType >= e##BaseEvent and eventType < e##BaseEvent + countof(e##EventName) - 1)
		const uint8 eventType = (*event).response_type & ~b(10000000);
		if(isExtensionEvent(randr)) /*-*/ jmp switchRandrEvent;
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  isExtensionEvent
	}
	switchRandrEvent:{
		printXEvent(randrEventName);
		switch ((*event).response_type & ~b(10000000)) - randrBaseEvent over
			to XCB_RANDR_SCREEN_CHANGE_NOTIFY:
			to XCB_RANDR_NOTIFY:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
					printTitledError("pthread error", "could not lock globals write lock");
				}
				{
					int screenNumber;
					xcb_connection_t *const connection = xcb_connect_to_display_with_auth_info(connectionName, NULL, &screenNumber);
					uint32 token = pushPointer(connection, "X connection", iXCBDisconnect);
					if(connection){
						xcb_screen_t *const screen = xcb_setup_roots_iterator(xcb_get_setup(connection)).data + screenNumber;
						if(screen){
							screenWidthInPixels = (*screen).width_in_pixels;
							screenHeightInPixels = (*screen).height_in_pixels;
							screenWidthInMillimeters = (*screen).width_in_millimeters;
							screenHeightInMillimeters = (*screen).height_in_millimeters;
						}else{
							screenWidthInPixels = 0;
							screenHeightInPixels = 0;
							screenWidthInMillimeters = 0;
							screenHeightInMillimeters = 0;
						}
						xcb_disconnect(connection);
						popPointer(token);
					}
				}
				if(createMonitors(&monitorSystem)){
					const bool mapped = windowSystem.mapped;
					if(createWindows(&windowSystem, monitorSystem.size, true, XCB_EVENT_MASK_PROPERTY_CHANGE)){
						if(mapped){
							mapWindows(&windowSystem, &monitorSystem, &windowPreferences, whichMonitor);
						}
					}
				}
				jmp eventLoop;
			}
			off:{
				jmp unrecognizedEvent;
			}
		end
	}
	unrecognizedEvent:{
		printTitledValuedError("X event error", "unrecognized event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unexpectedEvent:{
		printTitledValuedError("unexpected X event", "unexpected event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unhandledEvent:{
		printTitledValuedError("X event error", "unhandled event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	mainEmergencyExit:{
		cleanup();
		ret 0;
	}
}
SETWINDOWPROPERTIES(){
	xcb_window_t window;
	uint32 desktop;
	pid_t pid;
	char hostname[256];
	xcb_atom_t type[1];
	xcb_atom_t state[2];
	struct{
		uint32 /*-*/ flags;
		int32 /*--*/ x;
		int32 /*--*/ y;
		int32 /*--*/ width;
		int32 /*--*/ height;
		int32 /*--*/ minWidth;
		int32 /*--*/ minHeight;
		int32 /*--*/ maxWidth;
		int32 /*--*/ maxHeight;
		int32 /*--*/ widthInc;
		int32 /*--*/ heightInc;
		int32 /*--*/ minAspectNumerator;
		int32 /*--*/ minAspectDenominarator;
		int32 /*--*/ maxAspectNumerator;
		int32 /*--*/ maxAspectDenominarator;
		int32 /*--*/ baseWidth;
		int32 /*--*/ baseHeight;
		int32 /*--*/ winGravity;
	} normalHints;
	struct{
		uint32 /*-*/ flags;
		uint32 /*-*/ input;
		uint32 /*-*/ initialState;
	} hints;
	struct{
		uint32 /*-*/ left;
		uint32 /*-*/ right;
		uint32 /*-*/ top;
		uint32 /*-*/ bottom;
		uint32 /*-*/ leftStartY;
		uint32 /*-*/ leftEndY;
		uint32 /*-*/ rightStartY;
		uint32 /*-*/ rightEndY;
		uint32 /*-*/ topStartX;
		uint32 /*-*/ topEndX;
		uint32 /*-*/ bottomStartX;
		uint32 /*-*/ bottomEndX;
	} strut;
	if(!windowInfo or !(*windowInfo).window){
		ret false;
	}
	window = (*windowInfo).window;
	desktop = 0xFFFFFFFF;
	pid = getpid();
	*hostname = '\0';
	if(gethostname(hostname, countof(hostname)) != GETHOSTNAME_SUCCESS){
		printTitledError("get hostname error", "could not get hostname");
	}
	*(type + 0) = atom._NET_WM_WINDOW_TYPE_UTILITY;
	*(state + 0) = atom._NET_WM_STATE_STICKY;
	*(state + 1) = atom._NET_WM_STATE_ABOVE;
	normalHints.flags = USER_POSITION_NORMAL_HINT | USER_SIZE_NORMAL_HINT | PROGRAM_MINIMUM_SIZE_NORMAL_HINT | PROGRAM_MAXIMUM_SIZE_NORMAL_HINT | PROGRAM_RESIZE_INCREMENT_NORMAL_HINT | PROGRAM_ASPECT_NORMAL_HINT | PROGRAM_BASE_SIZE_NORMAL_HINT | PROGRAM_WINDOW_GRAVITY_NORMAL_HINT;
	normalHints.x = x;
	normalHints.y = y;
	normalHints.width = width;
	normalHints.height = height;
	normalHints.minWidth = width;
	normalHints.minHeight = height;
	normalHints.maxWidth = width;
	normalHints.maxHeight = height;
	normalHints.baseWidth = width;
	normalHints.baseHeight = height;
	normalHints.widthInc = 0;
	normalHints.heightInc = 0;
	normalHints.minAspectNumerator = 1;
	normalHints.minAspectDenominarator = 1;
	normalHints.maxAspectNumerator = 1;
	normalHints.maxAspectDenominarator = 1;
	normalHints.winGravity = XCB_GRAVITY_NORTH_WEST;
	hints.flags = INPUT_HINT | STATE_HINT;
	hints.input = false;
	hints.initialState = NORMAL_STATE;
	if((*windowPreferences).position){
		strut.left = 0;
		strut.right = 0;
		strut.top = 0;
		strut.bottom = 0;
		strut.leftStartY = 0;
		strut.leftEndY = 0;
		strut.rightStartY = 0;
		strut.rightEndY = 0;
		strut.topStartX = 0;
		strut.topEndX = 0;
		strut.bottomStartX = 0;
		strut.bottomEndX = 0;
		switch (*windowPreferences).position over
			to TOP_POSITION:{
				strut.top = height;
				strut.topStartX = x;
				strut.topEndX = x + width;
				brk;
			}
			to BOTTOM_POSITION:{
				strut.bottom = height;
				strut.bottomStartX = x;
				strut.bottomEndX = x + width;
				brk;
			}
			to LEFT_POSITION:{
				strut.left = width;
				strut.leftStartY = y;
				strut.leftEndY = y + height;
				brk;
			}
			to RIGHT_POSITION:{
				strut.right = width;
				strut.rightStartY = y;
				strut.rightEndY = y + height;
				brk;
			}
			off:{
				brk;
			}
		end
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_ICON_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_NORMAL_HINTS, atom.WM_SIZE_HINTS, bitsof(uint32), sizeof(normalHints) / sizeof(uint32), &normalHints);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_HINTS, atom.WM_HINTS, bitsof(uint32), sizeof(hints) / sizeof(uint32), &hints);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_CLASS, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME "\0" PROGRAM_NAME "\0"), PROGRAM_NAME "\0" PROGRAM_NAME "\0");
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_CLIENT_MACHINE, XCB_ATOM_STRING, bitsof(uint8), findStringLength(hostname), hostname);
	if(localeName){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_LOCALE_NAME, XCB_ATOM_STRING, bitsof(uint8), findStringLength(localeName), localeName);
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_ICON_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	if(desktop == 0xFFFFFFFF){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_DESKTOP, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &desktop);
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_WINDOW_TYPE, XCB_ATOM_ATOM, bitsof(uint32), countof(type), type);
	if(*state){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STATE, XCB_ATOM_ATOM, bitsof(uint32), countof(state), state);
	}
	if((*windowPreferences).position){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STRUT, XCB_ATOM_CARDINAL, bitsof(uint32), 4, &strut);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STRUT_PARTIAL, XCB_ATOM_CARDINAL, bitsof(uint32), 12, &strut);
	}
	/*! xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_ICON, , , , ); */
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_PID, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &pid);
	ret true;
}
DRAWWINDOW(){
	ElementRectangle _windowRectangle;
	ElementRectangle selectionRectangle;
	ElementRectangle clientRectangle;
	ElementRectangle titleRectangle;
	bool hasSelectionRectangle;
	bool hasClientRectangle;
	bool hasTitleRectangle;
	if(!windowSystem or !windowInfo or !windowPreferences or (!monitor and !windowRectangle)){
		ret false;
	}
	jmp getRectangles;
	getRectangles:{
		if(!windowRectangle){
			windowRectangle = &_windowRectangle;
			if(!getRectangle(monitor, NULL, windowPreferences, windowRectangle) or !(*windowRectangle).width or !(*windowRectangle).height){
				ret false;
			}
		}
		hasSelectionRectangle = getRectangle(NULL, windowRectangle, &selectionPreferences, &selectionRectangle) and selectionRectangle.width and selectionRectangle.height;
		hasClientRectangle = getRectangle(NULL, &selectionRectangle, &clientPreferences, &clientRectangle) and clientRectangle.width and clientRectangle.height;
		hasTitleRectangle = getRectangle(NULL, &selectionRectangle, &titlePreferences, &titleRectangle) and titleRectangle.width and titleRectangle.height;
		titleTextPreferences.widthType = INTEGER_NUMBER_TYPE;
		titleTextPreferences.heightType = INTEGER_NUMBER_TYPE;
		jmp drawWindow;
	}
	drawWindow:{
		const xcb_pixmap_t circlePixmap = (*windowSystem).circlePixmap;
		const xcb_pixmap_t pixmap = (*windowInfo).bufferPixmap;
		const xcb_gcontext_t gc = (*windowInfo).gc;
		const uint width = (*windowRectangle).width;
		const uint height = (*windowRectangle).height;
		fillDrawable(pixmap, gc, 0, 0, width, height, (*windowPreferences).background);
		if(circlePixmap){
			const uint8 cornerUsed = (*windowPreferences).cornerUsed;
			const uint radius = (*windowPreferences).cornerRadius;
			const uint size = radius + 1;
			if(cornerUsed & TOP_LEFT_CORNER) /*-----*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, 0     , 0     , 0           , 0            , size, size);
			if(cornerUsed & TOP_RIGHT_CORNER) /*----*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, radius, 0     , width - size, 0            , size, size);
			if(cornerUsed & BOTTOM_LEFT_CORNER) /*--*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, 0     , radius, 0           , height - size, size, size);
			if(cornerUsed & BOTTOM_RIGHT_CORNER) /*-*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, radius, radius, width - size, height - size, size, size);
		}
		jmp drawWindowElements;
	}
	drawWindowElements:{
		def struct{
			xcb_void_cookie_t /*-*/ cookie;
			uint32 /*------------*/ windowWidth;
			uint32 /*------------*/ windowHeight;
		} Structure;
		Client *start;
		Client *current;
		Client *wall;
		Client *selected;
		int x = selectionRectangle.x;
		int y = selectionRectangle.y;
		int clipX = 0;
		int clipY = 0;
		int clipWidth = (*windowInfo).width;
		int clipHeight = (*windowInfo).height;
		bool clippedChildren = false;
		uint currentSelectionAxisAmount = 0;
		Structure *structureStart;
		Structure *structureCurrent;
		Structure *structureWall;
		uint32 structureToken;
		uint maximumImageSize = 0;
		void *imageBufferStart = NULL;
		uint32 imageBufferToken = 0;
		switch clientOrder over
			to CREATION_CLIENT_ORDER:{
				start = clientListSystem.clientStart;
				current = start;
				wall = current + clientListSystem.clientSize;
				brk;
			}
			to STACKING_CLIENT_ORDER:{
				start = clientListStackingSystem.clientStart;
				current = start;
				wall = current + clientListStackingSystem.clientSize;
				brk;
			}
			off:{
				start = (void *)1;
				current = start;
				wall = current;
				brk;
			}
		end
		selected = current + selectionSystem.currentSelection;
		{
			struct{
				xcb_font_t /*-*/ font;
			} valueList;
			valueList.font = font;
			xcb_change_gc(connection, (*windowInfo).gc, XCB_GC_FONT, &valueList);
		}
		structureStart = malloc((wall - start) * sizeof(Structure));
		structureToken = pushPointer(structureStart, "structure pointer", iFree);
		structureCurrent = structureStart;
		structureWall = structureCurrent + (wall - start);
		jmp getImageCookieLoop;
		getImageCookieLoop:{
			if(structureCurrent < structureWall){
				if(hasSelectionRectangle and hasClientRectangle){
					(*structureCurrent).cookie.sequence = xcb_get_geometry(connection, (*current).window).sequence;
				}
				inc current;
				inc structureCurrent;
				jmp getImageCookieLoop;
			}
			current = start;
			structureCurrent = structureStart;
			jmp getImageReplyLoop;
		}
		getImageReplyLoop:{
			if(structureCurrent < structureWall){
				if(hasSelectionRectangle and hasClientRectangle){
					xcb_get_geometry_reply_t *const reply = xcb_wait_for_reply(connection, (*structureCurrent).cookie, NULL);
					uint32 token = pushPointer(reply, "drawWindow() get geometry reply", iFree);
					(*structureCurrent).cookie.sequence = XCB_NONE;
					(*structureCurrent).windowWidth = 0;
					(*structureCurrent).windowHeight = 0;
					if(reply){
						const uint windowWidth = (*reply).width;
						const uint windowHeight = (*reply).height;
						uint size = windowWidth * windowHeight;
						if(size > maximumImageSize){
							maximumImageSize = size;
						}
						if(windowWidth and windowHeight){
							(*structureCurrent).cookie.sequence = xcb_get_image(connection, XCB_IMAGE_FORMAT_Z_PIXMAP, (*current).window, 0, 0, windowWidth, windowHeight, 0xFFFFFFFF).sequence;
						}
						(*structureCurrent).windowWidth = windowWidth;
						(*structureCurrent).windowHeight = windowHeight;
						free(reply);
						popPointer(token);
					}
				}
				inc current;
				inc structureCurrent;
				jmp getImageReplyLoop;
			}
			current = start;
			structureCurrent = structureStart;
			if(maximumImageSize){
				imageBufferStart = malloc(maximumImageSize * sizeof(uint32));
				imageBufferToken = pushPointer(imageBufferStart, "drawWindow() image data pointer", iFree);
			}
			jmp drawSelectionLoop;
		}
		drawSelectionLoop:{
			if(current < wall){
				if(hasSelectionRectangle){
					uint32 color;
					if(current == selected){
						color = selectionPreferences.selectedBackground;
					}else{
						color = selectionPreferences.background;
					}
					fillDrawable((*windowInfo).bufferPixmap, (*windowInfo).gc, x, y, selectionRectangle.width, selectionRectangle.height, color);
					if(selectionPreferences.clipChildren){
						if(tightenClippingRectangle((*windowInfo).gc, x, y, selectionRectangle.width, selectionRectangle.height, &clipX, &clipY, &clipWidth, &clipHeight)){
							clippedChildren = true;
						}
					}
					if(hasClientRectangle){
						uint width = (*structureCurrent).windowWidth;
						uint height = (*structureCurrent).windowHeight;
						if(current == selected){
							color = clientPreferences.selectedBackground;
						}else{
							color = clientPreferences.background;
						}
						fillDrawable((*windowInfo).bufferPixmap, (*windowInfo).gc, x + clientRectangle.x, y + clientRectangle.y, clientRectangle.width, clientRectangle.height, color);
						if(width and height){
							xcb_get_image_reply_t *const reply = xcb_wait_for_reply(connection, (*structureCurrent).cookie, NULL);
							uint32 token = pushPointer(reply, "drawWindow() get image reply", iFree);
							if(reply){
								if(width > clientRectangle.width){
									width = clientRectangle.width;
								}
								if(height > clientRectangle.height){
									height = clientRectangle.height;
								}
								scaleImage(xcb_get_image_data(reply), (*structureCurrent).windowWidth, (*structureCurrent).windowHeight, imageBufferStart, width, height);
								xcb_put_image(connection, XCB_IMAGE_FORMAT_Z_PIXMAP, (*windowInfo).bufferPixmap, (*windowInfo).gc, width, height, x + clientRectangle.x + (clientRectangle.width - width) / 2, y + clientRectangle.y + (clientRectangle.height - height) / 2, 0, depth, width * height * sizeof(uint32), imageBufferStart);
								free(reply);
								popPointer(token);
							}
						}
					}
					if(hasTitleRectangle){
						if(current == selected){
							color = titlePreferences.selectedBackground;
						}else{
							color = titlePreferences.background;
						}
						fillDrawable((*windowInfo).bufferPixmap, (*windowInfo).gc, x + titleRectangle.x, y + titleRectangle.y, titleRectangle.width, titleRectangle.height, color);
						if(titlePreferences.clipChildren){
							if(tightenClippingRectangle((*windowInfo).gc, x + titleRectangle.x, y + titleRectangle.y, titleRectangle.width, titleRectangle.height, &clipX, &clipY, &clipWidth, &clipHeight)){
								clippedChildren = true;
							}
						}
						if((*current).titleSize){
							ElementRectangle titleTextRectangle;
							titleTextPreferences.width = (*current).fontWidth;
							titleTextPreferences.height = (*current).fontHeight;
							if(getRectangle(NULL, &titleRectangle, &titleTextPreferences, &titleTextRectangle) and titleTextRectangle.width and titleTextRectangle.height){
								struct{
									uint32 /*-*/ foreground;
									uint32 /*-*/ background;
								} valueList;
								if(current == selected){
									valueList.foreground = titleTextPreferences.selectedForeground;
									valueList.background = titleTextPreferences.selectedBackground;
								}else{
									valueList.foreground = titleTextPreferences.foreground;
									valueList.background = titleTextPreferences.background;
								}
								xcb_change_gc(connection, (*windowInfo).gc, XCB_GC_FOREGROUND | XCB_GC_BACKGROUND, &valueList);
								xcb_image_text_16(connection, (*current).titleSize, (*windowInfo).bufferPixmap, (*windowInfo).gc, x + titleRectangle.x + titleTextRectangle.x + (*current).fontX, y + titleRectangle.y + titleTextRectangle.y + (*current).fontY, (void *)(*current).titleStart);
							}
						}
					}
					inc structureCurrent;
				}
				if(clippedChildren){
					unsetClippingRectangle((*windowInfo).gc);
					clipX = 0;
					clipY = 0;
					clipWidth = (*windowInfo).width;
					clipHeight = (*windowInfo).height;
					clippedChildren = false;
				}
				if(selectionSystem.selectionAxisAmount and inc currentSelectionAxisAmount == selectionSystem.selectionAxisAmount){
					switch selectionSystem.selectionAxis over
						to NONE_AXIS: /*-------*/ /*---------------------*/ /*----------------------------------------------------------------------*/ brk;
						to HORIZONTAL_AXIS: /*-*/ x = selectionRectangle.x; y += selectionRectangle.height + selectionRectangle.verticalMargin; /*--*/ brk;
						to VERTICAL_AXIS: /*---*/ y = selectionRectangle.y; x += selectionRectangle.width + selectionRectangle.horizontalMargin; /*-*/ brk;
						off: /*----------------*/ /*---------------------*/ /*----------------------------------------------------------------------*/ brk;
					end
					currentSelectionAxisAmount = 0;
				}else{
					switch selectionSystem.selectionAxis over
						to NONE_AXIS: /*-------*/ /*----------------------------------------------------------------------*/ brk;
						to HORIZONTAL_AXIS: /*-*/ x += selectionRectangle.width + selectionRectangle.horizontalMargin; /*-*/ brk;
						to VERTICAL_AXIS: /*---*/ y += selectionRectangle.height + selectionRectangle.verticalMargin; /*--*/ brk;
						off: /*----------------*/ /*----------------------------------------------------------------------*/ brk;
					end
				}
				inc current;
				jmp drawSelectionLoop;
			}
			free(imageBufferStart);
			popPointer(imageBufferToken);
			free(structureStart);
			popPointer(structureToken);
			jmp clearArea;
		}
	}
	clearArea:{
		xcb_copy_area(connection, (*windowInfo).bufferPixmap, (*windowInfo).pixmap, (*windowInfo).gc, 0, 0, 0, 0, (*windowInfo).width, (*windowInfo).height);
		if((*windowSystem).mapped){
			xcb_clear_area(connection, false, (*windowInfo).window, 0, 0, 0, 0);
		}
		ret true;
	}
}
INITCLIENTLISTSYSTEM(){
	if(!clientListSystem){
		ret false;
	}
	(*clientListSystem).clientSize = 0;
	(*clientListSystem).clientStart = NULL;
	(*clientListSystem).clientToken = 0;
	(*clientListSystem).titleTextCutoff = 0;
	ret true;
}
SETCLIENTLISTTEXTCUTOFF(){
	if(!clientListSystem or titleTextCutoff == (*clientListSystem).titleTextCutoff){
		ret false;
	}
	(*clientListSystem).titleTextCutoff = titleTextCutoff;
	updateClientsTitle(clientListSystem, font);
	ret true;
}
CREATECLIENTLIST(){
	xcb_get_property_reply_t *reply;
	uint32 token;
	uint length;
	Client *current;
	Client *wall;
	xcb_window_t *windowCurrent;
	struct{
		uint32 /*-*/ eventMask;
	} valueList;
	if(!clientListSystem or !property){
		ret false;
	}
	reply = xcb_wait_for_reply(connection, xcb_get_property_unchecked(connection, false, (*screen).root, property, XCB_ATOM_WINDOW, 0, 0xFFFFFFFF), NULL);
	token = pushPointer(reply, "createClientList() get property reply", iFree);
	if(!reply){
		ret false;
	}
	length = xcb_get_property_value_length(reply) / sizeof(xcb_window_t);
	destroyClientList(clientListSystem);
	if(!length){
		free(reply);
		popPointer(token);
		ret false;
	}
	(*clientListSystem).clientSize = length;
	(*clientListSystem).clientStart = malloc((*clientListSystem).clientSize * sizeof(Client));
	(*clientListSystem).clientToken = pushPointer((*clientListSystem).clientStart, "client list pointer", iFree);
	if(!(*clientListSystem).clientStart){
		free(reply);
		popPointer(token);
		ret false;
	}
	current = (*clientListSystem).clientStart;
	wall = current + (*clientListSystem).clientSize;
	windowCurrent = xcb_get_property_value(reply);
	valueList.eventMask = XCB_EVENT_MASK_PROPERTY_CHANGE;
	jmp addClientLoop;
	addClientLoop:{
		if(current < wall){
			(*current).window = *windowCurrent;
			(*current).titleSize = 0;
			(*current).titleStart = NULL;
			(*current).titleToken = 0;
			(*current).fontX = 0;
			(*current).fontY = 0;
			(*current).fontWidth = 0;
			(*current).fontHeight = 0;
			xcb_discard_reply(connection, xcb_change_window_attributes_checked(connection, (*current).window, XCB_CW_EVENT_MASK, &valueList));
			setClientListClientTitle(clientListSystem, current, font);
			inc windowCurrent;
			inc current;
			jmp addClientLoop;
		}
		free(reply);
		popPointer(token);
		ret true;
	}
}
UPDATECLIENTSTITLE(){
	Client *current;
	Client *wall;
	if(!clientListSystem or !(*clientListSystem).clientSize){
		ret false;
	}
	current = (*clientListSystem).clientStart;
	wall = current + (*clientListSystem).clientSize;
	jmp updateClientTitle;
	updateClientTitle:{
		if(current < wall){
			(*current).fontX = 0;
			(*current).fontY = 0;
			(*current).fontWidth = 0;
			(*current).fontHeight = 0;
			setClientListClientTitle(clientListSystem, current, font);
			inc current;
			jmp updateClientTitle;
		}
		ret true;
	}
}
SETCLIENTLISTCLIENTTITLE(){
	xcb_get_property_cookie_t visibleNameCookie;
	xcb_get_property_cookie_t name0Cookie;
	xcb_get_property_cookie_t name1Cookie;
	xcb_get_property_reply_t *visibleNameReply;
	xcb_get_property_reply_t *name0Reply;
	xcb_get_property_reply_t *name1Reply;
	uint32 visibleNameToken;
	uint32 name0Token;
	uint32 name1Token;
	uint length;
	uint8 *start;
	if(!clientListSystem or !client){
		ret false;
	}
	visibleNameCookie = xcb_get_property(connection, false, (*client).window, atom._NET_WM_VISIBLE_NAME, atom.UTF8_STRING, 0, 0xFFFFFFFF);
	name0Cookie = xcb_get_property(connection, false, (*client).window, atom._NET_WM_NAME, atom.UTF8_STRING, 0, 0xFFFFFFFF);
	name1Cookie = xcb_get_property(connection, false, (*client).window, atom.WM_NAME, XCB_ATOM_STRING, 0, 0xFFFFFFFF);
	visibleNameReply = xcb_wait_for_reply(connection, visibleNameCookie, NULL);
	name0Reply = xcb_wait_for_reply(connection, name0Cookie, NULL);
	name1Reply = xcb_wait_for_reply(connection, name1Cookie, NULL);
	visibleNameToken = pushPointer(visibleNameReply, "setClientListClientTitle() get property reply", iFree);
	name0Token = pushPointer(name0Reply, "setClientListClientTitle() get property reply", iFree);
	name1Token = pushPointer(name1Reply, "setClientListClientTitle() get property reply", iFree);
	if(visibleNameReply and xcb_get_property_value_length(visibleNameReply)){
		start = xcb_get_property_value(visibleNameReply);
		length = xcb_get_property_value_length(visibleNameReply);
		jmp setTitle;
	}
	if(name0Reply and xcb_get_property_value_length(name0Reply)){
		start = xcb_get_property_value(name0Reply);
		length = xcb_get_property_value_length(name0Reply);
		jmp setTitle;
	}
	if(name1Reply and xcb_get_property_value_length(name1Reply)){
		start = xcb_get_property_value(name1Reply);
		length = xcb_get_property_value_length(name1Reply);
		jmp setTitle;
	}
	start = (void *)"untitled";
	length = lengthof("untitled");
	jmp setTitle;
	setTitle:{
		if(!*(start + length - 1)){
			dec length;
		}
		free((*client).titleStart);
		popPointer((*client).titleToken);
		(*client).titleSize = length + 1;
		(*client).titleStart = malloc((*client).titleSize * sizeof(uint16));
		(*client).titleToken = pushPointer((*client).titleStart, "client title pointer", iFree);
		(*client).titleSize = UTF8ToUCS2(start, length, (*client).titleStart, (*client).titleSize);
		if((*clientListSystem).titleTextCutoff and (*client).titleSize > (*clientListSystem).titleTextCutoff){
			uint16 *const current = (*client).titleStart + (*clientListSystem).titleTextCutoff;
			(*client).titleSize = (*clientListSystem).titleTextCutoff;
			if((*clientListSystem).titleTextCutoff > 3){
				*(current - 3) = ASCII_TO_UCS2('.');
				*(current - 2) = ASCII_TO_UCS2('.');
				*(current - 1) = ASCII_TO_UCS2('.');
			}
		}
		if(font){
			xcb_query_text_extents_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_text_extents_unchecked(connection, font, (*client).titleSize, (void *)(*client).titleStart), NULL);
			uint32 token = pushPointer(reply, "setClientListClientTitle() query text extents reply", iFree);
			if(reply){
				(*client).fontX = (*reply).overall_left;
				(*client).fontY = (*reply).font_ascent;
				(*client).fontWidth = (*reply).overall_width;
				(*client).fontHeight = (*reply).font_ascent + (*reply).font_descent;
				free(reply);
				popPointer(token);
			}
		}
		jmp trimMemory;
	}
	trimMemory:{
		void *const temp = realloc((*client).titleStart, (*client).titleSize * sizeof(uint16));
		updatePointer((*client).titleToken, temp);
		if(temp){
			(*client).titleStart = temp;
		}
		jmp emergencyExit;
	}
	emergencyExit:{
		free(visibleNameReply);
		popPointer(visibleNameToken);
		free(name0Reply);
		popPointer(name0Token);
		free(name1Reply);
		popPointer(name1Token);
		ret true;
	}
}
DESTROYCLIENTLIST(){
	Client *current;
	Client *wall;
	struct{
		uint32 /*-*/ eventMask;
	} valueList;
	if(!clientListSystem){
		ret false;
	}
	current = (*clientListSystem).clientStart;
	wall = current + (*clientListSystem).clientSize;
	valueList.eventMask = XCB_EVENT_MASK_NO_EVENT;
	jmp detroyClientLoop;
	detroyClientLoop:{
		if(current < wall){
			xcb_discard_reply(connection, xcb_change_window_attributes_checked(connection, (*current).window, XCB_CW_EVENT_MASK, &valueList));
			free((*current).titleStart);
			popPointer((*current).titleToken);
			inc current;
			jmp detroyClientLoop;
		}
		free((*clientListSystem).clientStart);
		popPointer((*clientListSystem).clientToken);
		(*clientListSystem).clientSize = 0;
		(*clientListSystem).clientStart = NULL;
		(*clientListSystem).clientToken = 0;
		ret true;
	}
}
FINDCLIENTLISTWINDOW(){
	Client *current;
	Client *wall;
	if(!clientListSystem or !(*clientListSystem).clientSize){
		ret NULL;
	}
	current = (*clientListSystem).clientStart;
	wall = current + (*clientListSystem).clientSize;
	jmp findClientListWindowLoop;
	findClientListWindowLoop:{
		if((*current).window == window){
			ret current;
		}
		if(inc current < wall){
			jmp findClientListWindowLoop;
		}
		ret NULL;
	}
}
FINICLIENTLISTSYSTEM(){
	if(!clientListSystem){
		ret false;
	}
	destroyClientList(clientListSystem);
	(*clientListSystem).clientSize = 0;
	(*clientListSystem).clientStart = NULL;
	(*clientListSystem).clientToken = 0;
	(*clientListSystem).titleTextCutoff = 0;
	ret true;
}
INITSELECTIONSYSTEM(){
	if(!selectionSystem){
		ret false;
	}
	(*selectionSystem).selectionAxis = NONE_AXIS;
	(*selectionSystem).selectionAxisAmount = 0;
	(*selectionSystem).selectionAmount = 0;
	(*selectionSystem).startingSelection = NONE_STARTING_SELECTION;
	(*selectionSystem).currentSelection = -1;
	(*selectionSystem).allowCircularNavigation = false;
	(*selectionSystem).selectionAction = NONE_SELECTION_ACTION;
	ret true;
}
SETSELECTIONAXIS(){
	if(!selectionSystem or selectionAxis > VERTICAL_AXIS){
		ret false;
	}
	(*selectionSystem).selectionAxis = selectionAxis;
	ret true;
}
SETSELECTIONAXISAMOUNT(){
	if(!selectionSystem){
		ret false;
	}
	(*selectionSystem).selectionAxisAmount = selectionAxisAmount;
	ret true;
}
SETSELECTIONAMOUNT(){
	if(!selectionSystem){
		ret false;
	}
	(*selectionSystem).selectionAmount = selectionAmount;
	if((*selectionSystem).currentSelection > (int)(*selectionSystem).selectionAmount - 1){
		(*selectionSystem).currentSelection = (*selectionSystem).selectionAmount - 1;
	}
	if(!(*selectionSystem).selectionAxisAmount){
		(*selectionSystem).selectionAxisAmount = (*selectionSystem).selectionAmount;
	}
	ret true;
}
SETSTARTINGSELECTION(){
	if(!selectionSystem or startingSelection > FOCUSED_STARTING_SELECTION){
		ret false;
	}
	(*selectionSystem).startingSelection = startingSelection;
	ret true;
}
SETCURRENTSELECTION(){
	if(!selectionSystem){
		ret false;
	}
	switch (*selectionSystem).startingSelection over
		to NONE_STARTING_SELECTION:{
			(*selectionSystem).currentSelection = -1;
			ret true;
		}
		to FIRST_STARTING_SELECTION:{
			(*selectionSystem).currentSelection = -1;
			if((*selectionSystem).selectionAmount){
				(*selectionSystem).currentSelection = 0;
			}
			ret true;
		}
		to LAST_STARTING_SELECTION:{
			(*selectionSystem).currentSelection = -1;
			if((*selectionSystem).selectionAmount){
				(*selectionSystem).currentSelection = (*selectionSystem).selectionAmount - 1;
			}
			ret true;
		}
		to FOCUSED_STARTING_SELECTION:{
			Client *client;
			(*selectionSystem).currentSelection = -1;
			if((client = findClientListWindow(clientListSystem, getFocusedWindow()))){
				(*selectionSystem).currentSelection = client - (*clientListSystem).clientStart;
			}
			ret true;
		}
		off:{
			ret false;
		}
	end
}
SETSELECTIONNAVIGATION(){
	if(!selectionSystem){
		ret false;
	}
	(*selectionSystem).allowCircularNavigation = allowCircularNavigation;
	ret true;
}
SETSELECTIONACTION(){
	if(!selectionSystem or selectionAction > MOVE_TO_DESKTOP_SELECTION_ACTION){
		ret false;
	}
	(*selectionSystem).selectionAction = selectionAction;
	ret true;
}
MOVECURRENTSELECTION(){
	if(!selectionSystem or !(*selectionSystem).selectionAxisAmount or !(*selectionSystem).selectionAmount){
		ret false;
	}
	switch whichSelection over
		to NONE_WHICH_SELECTION:{
			ret false;
		}
		to PREVIOUS_WHICH_SELECTION:{
			jmp selectPrevious;
		}
		to NEXT_WHICH_SELECTION:{
			jmp selectNext;
		}
		to LEFT_WHICH_SELECTION:{
			switch (*selectionSystem).selectionAxis over
				to NONE_AXIS: /*-------*/ ret false;
				to HORIZONTAL_AXIS: /*-*/ jmp selectLeft;
				to VERTICAL_AXIS: /*---*/ jmp selectAbove;
				off: /*----------------*/ ret false;
			end
		}
		to RIGHT_WHICH_SELECTION:{
			switch (*selectionSystem).selectionAxis over
				to NONE_AXIS: /*-------*/ ret false;
				to HORIZONTAL_AXIS: /*-*/ jmp selectRight;
				to VERTICAL_AXIS: /*---*/ jmp selectBelow;
				off: /*----------------*/ ret false;
			end
		}
		to ABOVE_WHICH_SELECTION:{
			switch (*selectionSystem).selectionAxis over
				to NONE_AXIS: /*-------*/ ret false;
				to HORIZONTAL_AXIS: /*-*/ jmp selectAbove;
				to VERTICAL_AXIS: /*---*/ jmp selectLeft;
				off: /*----------------*/ ret false;
			end
		}
		to BELOW_WHICH_SELECTION:{
			switch (*selectionSystem).selectionAxis over
				to NONE_AXIS: /*-------*/ ret false;
				to HORIZONTAL_AXIS: /*-*/ jmp selectBelow;
				to VERTICAL_AXIS: /*---*/ jmp selectRight;
				off: /*----------------*/ ret false;
			end
		}
		off:{
			ret false;
		}
	end
	selectPrevious:{
		if((*selectionSystem).currentSelection > 0){
			dec (*selectionSystem).currentSelection;
			ret true;
		}
		if((*selectionSystem).currentSelection == -1 or (*selectionSystem).allowCircularNavigation){
			(*selectionSystem).currentSelection = (*selectionSystem).selectionAmount - 1;
			ret true;
		}
		ret false;
	}
	selectNext:{
		if((*selectionSystem).currentSelection < (int)(*selectionSystem).selectionAmount - 1){
			inc (*selectionSystem).currentSelection;
			ret true;
		}
		if((*selectionSystem).currentSelection == -1 or (*selectionSystem).allowCircularNavigation){
			(*selectionSystem).currentSelection = 0;
			ret true;
		}
		ret false;
	}
	selectLeft:{
		if((*selectionSystem).currentSelection == -1){
			const uint height = (*selectionSystem).selectionAmount / (*selectionSystem).selectionAxisAmount + !!((*selectionSystem).selectionAmount % (*selectionSystem).selectionAxisAmount);
			(*selectionSystem).currentSelection = height / 2 * (*selectionSystem).selectionAxisAmount + (*selectionSystem).selectionAxisAmount - 1;
			if((*selectionSystem).currentSelection > (int)(*selectionSystem).selectionAmount - 1){
				(*selectionSystem).currentSelection = (*selectionSystem).selectionAmount - 1;
			}
			ret true;
		}
		if(!((*selectionSystem).currentSelection % (*selectionSystem).selectionAxisAmount)){
			if(!(*selectionSystem).allowCircularNavigation){
				ret false;
			}
			(*selectionSystem).currentSelection += (*selectionSystem).selectionAxisAmount - 1;
			if((*selectionSystem).currentSelection > (int)(*selectionSystem).selectionAmount - 1){
				(*selectionSystem).currentSelection = (*selectionSystem).selectionAmount - 1;
			}
			ret true;
		}
		dec (*selectionSystem).currentSelection;
		ret true;
	}
	selectRight:{
		if((*selectionSystem).currentSelection == -1){
			const uint height = (*selectionSystem).selectionAmount / (*selectionSystem).selectionAxisAmount + !!((*selectionSystem).selectionAmount % (*selectionSystem).selectionAxisAmount);
			(*selectionSystem).currentSelection = height / 2 * (*selectionSystem).selectionAxisAmount;
			ret true;
		}
		if((*selectionSystem).currentSelection == (int)(*selectionSystem).selectionAmount - 1 or !(((*selectionSystem).currentSelection + 1) % (*selectionSystem).selectionAxisAmount)){
			if(!(*selectionSystem).allowCircularNavigation){
				ret false;
			}
			(*selectionSystem).currentSelection -= (*selectionSystem).currentSelection % (*selectionSystem).selectionAxisAmount;
			ret true;
		}
		inc (*selectionSystem).currentSelection;
		ret true;
	}
	selectAbove:{
		if((*selectionSystem).currentSelection == -1){
			const uint height = (*selectionSystem).selectionAmount / (*selectionSystem).selectionAxisAmount + !!((*selectionSystem).selectionAmount % (*selectionSystem).selectionAxisAmount);
			(*selectionSystem).currentSelection = (height - 1) * (*selectionSystem).selectionAxisAmount + (*selectionSystem).selectionAxisAmount / 2;
			if((*selectionSystem).currentSelection > (int)(*selectionSystem).selectionAmount - 1){
				(*selectionSystem).currentSelection = (*selectionSystem).selectionAmount - 1;
			}
			ret true;
		}
		if((*selectionSystem).currentSelection < (int)(*selectionSystem).selectionAxisAmount){
			uint height;
			if(!(*selectionSystem).allowCircularNavigation){
				ret false;
			}
			height = (*selectionSystem).selectionAmount / (*selectionSystem).selectionAxisAmount + !!((*selectionSystem).selectionAmount % (*selectionSystem).selectionAxisAmount);
			(*selectionSystem).currentSelection += (height - 1) * (*selectionSystem).selectionAxisAmount;
			if((*selectionSystem).currentSelection > (int)(*selectionSystem).selectionAmount - 1){
				(*selectionSystem).currentSelection -= (*selectionSystem).selectionAxisAmount;
			}
			ret true;
		}
		(*selectionSystem).currentSelection -= (*selectionSystem).selectionAxisAmount;
		ret true;
	}
	selectBelow:{
		if((*selectionSystem).currentSelection == -1){
			(*selectionSystem).currentSelection = (*selectionSystem).selectionAxisAmount / 2;
			if((*selectionSystem).currentSelection > (int)(*selectionSystem).selectionAmount - 1){
				(*selectionSystem).currentSelection = (*selectionSystem).selectionAmount - 1;
			}
			ret true;
		}
		if((*selectionSystem).currentSelection > (int)((*selectionSystem).selectionAmount - (*selectionSystem).selectionAxisAmount - 1)){
			uint height;
			if(!(*selectionSystem).allowCircularNavigation){
				ret false;
			}
			height = (*selectionSystem).selectionAmount / (*selectionSystem).selectionAxisAmount + !!((*selectionSystem).selectionAmount % (*selectionSystem).selectionAxisAmount);
			(*selectionSystem).currentSelection -= (height - 1) * (*selectionSystem).selectionAxisAmount;
			if((*selectionSystem).currentSelection < 0){
				(*selectionSystem).currentSelection += (*selectionSystem).selectionAxisAmount;
			}
			ret true;
		}
		(*selectionSystem).currentSelection += (*selectionSystem).selectionAxisAmount;
		ret true;
	}
}
PICKSELECTION(){
	xcb_window_t window;
	if(!selectionSystem or (*selectionSystem).currentSelection == -1 or !clientListSystem or !(*clientListSystem).clientSize or (*selectionSystem).currentSelection >= (int)(*clientListSystem).clientSize){
		ret false;
	}
	window = (*((*clientListSystem).clientStart + (*selectionSystem).currentSelection)).window;
	switch (*selectionSystem).selectionAction over
		to NONE_SELECTION_ACTION:{
			ret false;
		}
		to FOCUS_WINDOW_SELECTION_ACTION:{
			xcb_discard_reply(connection, xcb_set_input_focus_checked(connection, XCB_INPUT_FOCUS_POINTER_ROOT, window, getTimestamp()));
			ret true;
		}
		to MOVE_TO_DESKTOP_SELECTION_ACTION:{
			xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property(connection, false, window, atom._NET_WM_DESKTOP, XCB_ATOM_CARDINAL, 0, 1), NULL);
			uint32 token = pushPointer(reply, "pickSelection() get property reply", iFree);
			xcb_client_message_event_t message;
			if(!reply or xcb_get_property_value_length(reply) != sizeof(uint32)){
				free(reply);
				popPointer(token);
				ret false;
			}
			message.response_type = XCB_CLIENT_MESSAGE;
			message.format = 32;
			message.window = (*screen).root;
			message.type = atom._NET_CURRENT_DESKTOP;
			*(message.data.data32 + 0) = *(uint32 *)xcb_get_property_value(reply);
			*(message.data.data32 + 1) = getTimestamp();
			*(message.data.data32 + 2) = 0;
			*(message.data.data32 + 3) = 0;
			*(message.data.data32 + 4) = 0;
			xcb_send_event(connection, false, (*screen).root, XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY | XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT, &message);
			free(reply);
			popPointer(token);
			ret true;
		}
		off:{
			ret false;
		}
	end
}
FINISELECTIONSYSTEM(){
	if(!selectionSystem){
		ret false;
	}
	(*selectionSystem).selectionAxis = NONE_AXIS;
	(*selectionSystem).selectionAxisAmount = 0;
	(*selectionSystem).selectionAmount = 0;
	(*selectionSystem).startingSelection = NONE_STARTING_SELECTION;
	(*selectionSystem).currentSelection = -1;
	(*selectionSystem).allowCircularNavigation = false;
	(*selectionSystem).selectionAction = NONE_SELECTION_ACTION;
	ret true;
}
SETCONFIGVARIABLES(){
	setElementPreferences(&windowPreferences);
	setElementPreferences(&selectionPreferences);
	setElementPreferences(&clientPreferences);
	setElementPreferences(&titlePreferences);
	setElementPreferences(&titleTextPreferences);
	setClientListTextCutoff(&clientListSystem, 0, font);
	setClientListTextCutoff(&clientListStackingSystem, 0, font);
	clientOrder = NONE_CLIENT_ORDER;
	setSelectionAxis(&selectionSystem, NONE_AXIS);
	setSelectionAxisAmount(&selectionSystem, 0);
	setSelectionAmount(&selectionSystem, 0);
	setStartingSelection(&selectionSystem, NONE_STARTING_SELECTION);
	setCurrentSelection(&selectionSystem, NULL);
	setSelectionNavigation(&selectionSystem, false);
	setSelectionAction(&selectionSystem, NONE_SELECTION_ACTION);
	whichMonitor = NONE_WHICH_MONITOR;
	font = XCB_NONE;
	createWindowCirclePixmap(&windowSystem, 0, 0x00000000, 0x00000000);
	ret;
}
READCONFIG(){
	#define STATEMENT_BLOCK_SIZE /*-*/ (256)
	#define DEFAULT_CONFIG_PATH /*--*/ ("/etc/" PROGRAM_NAME "/" PROGRAM_NAME ".conf")
	const Instruction *const *currentScopeInstruction = globalScopeInstruction;
	const char *const *currentScopeInstructionList = globalInstructionList;
	const Instruction *instructionStart;
	const Instruction *instructionStartCopy;
	const Instruction *instructionCurrent;
	const Instruction *name0Instruction;
	const Instruction *name1Instruction;
	const Instruction *name2Instruction;
	const Instruction *name3Instruction;
	const Instruction *name4Instruction;
	const Instruction *nameList0Instruction;
	const Instruction *nameList1Instruction;
	const Instruction *nameList2Instruction;
	const Instruction *nameList3Instruction;
	const Instruction *nameList4Instruction;
	const Instruction *integer0Instruction;
	const Instruction *integer1Instruction;
	const Instruction *integer2Instruction;
	const Instruction *integer3Instruction;
	const Instruction *integer4Instruction;
	const Instruction *string0Instruction;
	const Instruction *string1Instruction;
	const Instruction *string2Instruction;
	const Instruction *string3Instruction;
	const Instruction *string4Instruction;
	const Instruction *image0Instruction;
	const Instruction *image1Instruction;
	const Instruction *image2Instruction;
	const Instruction *image3Instruction;
	const Instruction *image4Instruction;
	const char *imageErrorMessage;
	FILE *configFile = NULL;
	uint32 configFileToken;
	void *system = NULL;
	uint statementSize = STATEMENT_BLOCK_SIZE;
	char *statementStart = NULL;
	uint32 statementToken = 0;
	char *statementCurrent;
	char *statementWall = NULL;
	char *statementConcreteWall;
	uint8 name0Return;
	uint8 name1Return;
	uint8 name2Return;
	uint8 name3Return;
	uint8 name4Return;
	uint8 nameList0Return;
	uint8 nameList1Return;
	uint8 nameList2Return;
	uint8 nameList3Return;
	uint8 nameList4Return;
	int64 integer0Return;
	int64 integer1Return;
	int64 integer2Return;
	int64 integer3Return;
	int64 integer4Return;
	char *string0Return = NULL;
	uint32 string0Token = 0;
	char *string1Return = NULL;
	uint32 string1Token = 0;
	char *string2Return = NULL;
	uint32 string2Token = 0;
	char *string3Return = NULL;
	uint32 string3Token = 0;
	char *string4Return = NULL;
	uint32 string4Token = 0;
	Image image0Return;
	Image image1Return;
	Image image2Return;
	Image image3Return;
	Image image4Return;
	JmpPoint jmpPoint;
	uint fileLine = 1;
	uint statementLine = 0;
	char fileChar;
	uint itemAmount;
	char quote = '\0';
	uint currentScopeInstructionListSize = countof(globalInstructionList) - 1;
	StringTreeSystem *const *const *currentScopeInstructionData = globalScopeInstructionData;
	StringTreeSystem *const *instructionDataStart;
	StringTreeSystem *const *instructionDataStartCopy;
	StringTreeSystem *const *instructionDataCurrent;
	StringTreeSystem *currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
	image0Return.dataStart = NULL;
	image0Return.dataToken = 0;
	image1Return.dataStart = NULL;
	image1Return.dataToken = 0;
	image2Return.dataStart = NULL;
	image2Return.dataToken = 0;
	image3Return.dataStart = NULL;
	image3Return.dataToken = 0;
	image4Return.dataStart = NULL;
	image4Return.dataToken = 0;
	jmp setupPointers;
	setupPointers:{
		if(getNextConfigChar == &ifgetc){
			if(!createConfigFile){
				DIR *const dir = opendir(configPath);
				uint32 token = pushPointer(dir, "config directory argument", closedir);
				if(dir){
					closedir(dir);
					popPointer(token);
					printConfigError("config error", "config file is directory", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
			}
			configFile = fopen(configPath, "r");
			configFileToken = pushPointer(configFile, "config file", fclose);
			if(!configFile){
				#define BUFFER_SIZE /*-*/ (4096)
				FILE *defaultConfigFile;
				uint32 defaultConfigFileToken;
				if(!createConfigFile){
					printConfigError("config error", "could not open config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				configFile = fopen(configPath, "w");
				configFileToken = pushPointer(configFile, "config file", fclose);
				if(!configFile){
					printConfigError("config error", "could not create config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				defaultConfigFile = fopen(DEFAULT_CONFIG_PATH, "r");
				defaultConfigFileToken = pushPointer(defaultConfigFile, "default config file", fclose);
				if(!defaultConfigFile){
					remove(configPath);
					printTitledNamedError("config file error", "could not copy default configuration file from", DEFAULT_CONFIG_PATH);
					jmp configEmergencyExit;
				}
				copyConfigFileLoop:{
					char buffer[BUFFER_SIZE];
					size_t bytesRead;
					if((bytesRead = fread(buffer, sizeof(*buffer), sizeof(buffer), defaultConfigFile))){
						if(fwrite(buffer, sizeof(*buffer), bytesRead, configFile) != bytesRead){
							fclose(defaultConfigFile);
							popPointer(defaultConfigFileToken);
							remove(configPath);
							printTitledError("config copying error", "could not copy default config file correctly");
							jmp configEmergencyExit;
						}
						jmp copyConfigFileLoop;
					}
				}
				fclose(defaultConfigFile);
				popPointer(defaultConfigFileToken);
				fclose(configFile);
				popPointer(configFileToken);
				if(!(configFile = fopen(configPath, "r"))){
					printTitledError("config error", "could not open newly written file");
					jmp configEmergencyExit;
				}
				#undef  BUFFER_SIZE
			}
		}
		statementStart = malloc(statementSize * sizeof(char));
		statementToken = pushPointer(statementStart, "statement pointer", iFree);
		if(!statementStart){
			printTitledError("config error", "could not store user data");
			jmp configEmergencyExit;
		}
		if(getNextConfigChar == &ifgetc){
			system = configFile;
		}elif(getNextConfigChar == &getNextSTDINCharacter){
			system = &stdinSystem;
		}elif(getNextConfigChar == &getNextSharedMemoryCharacter){
			system = &sharedMemorySystem;
		}
		jmp getStatementStart;
	}
	getStatementStart:{
		#define EOF_N1 /*----------------------------*/ (EOF)
		#define ZER_00 /*----------------------------*/ ('\0')
		#define EOT_04 /*----------------------------*/ (0x04)
		#define ALR_07 /*----------------------------*/ ('\a')
		#define BSP_08 /*----------------------------*/ ('\b')
		#define TAB_09 /*----------------------------*/ ('\t')
		#define NLN_10 /*----------------------------*/ ('\n')
		#define VTB_11 /*----------------------------*/ ('\v')
		#define FFD_12 /*----------------------------*/ ('\f')
		#define CRE_13 /*----------------------------*/ ('\r')
		#define ESC_27 /*----------------------------*/ ('\e')
		#define SPC_32 /*----------------------------*/ (' ')
		#define DQT_34 /*----------------------------*/ ('\"')
		#define SQT_39 /*----------------------------*/ ('\'')
		#define AST_42 /*----------------------------*/ ('*')
		#define FSL_47 /*----------------------------*/ ('/')
		#define ZER_48 /*----------------------------*/ ('0')
		#define SCL_59 /*----------------------------*/ (';')
		#define QMK_63 /*----------------------------*/ ('?')
		#define BSL_92 /*----------------------------*/ ('\\')
		#define LOA_97 /*----------------------------*/ ('a')
		#define LOB_98 /*----------------------------*/ ('b')
		#define LOF_102 /*---------------------------*/ ('f')
		#define LON_110 /*---------------------------*/ ('n')
		#define LOR_114 /*---------------------------*/ ('r')
		#define LOT_116 /*---------------------------*/ ('t')
		#define LOV_118 /*---------------------------*/ ('v')
		#define OCB_123 /*---------------------------*/ ('{')
		#define BAR_124 /*---------------------------*/ ('|')
		#define CCB_125 /*---------------------------*/ ('}')
		#define GET_STATEMENT_JMP_POINT /*-----------*/ (0)
		#define STORE_WHITESPACE_JMP_POINT /*--------*/ (1)
		#define CHECK_COMMENT_JMP_POINT /*-----------*/ (2)
		#define STORE_BAR_JMP_POINT /*---------------*/ (3)
		#define GET_DOUBLE_QUOTATION_JMP_POINT /*----*/ (4)
		#define GET_SINGLE_QUOTATION_JMP_POINT /*----*/ (5)
		#define HANDLE_ESCAPE_CHARACTER_JMP_POINT /*-*/ (6)
		#define ENTER_SCOPE_JMP_POINT /*-------------*/ (7)
		#define GET_STATEMENT_END_JMP_POINT /*-------*/ (8)
		statementCurrent = statementStart;
		statementConcreteWall = statementStart + statementSize * sizeof(char);
		statementLine = 0;
		itemAmount = 0;
		free(string0Return);
		popPointer(string0Token);
		free(string1Return);
		popPointer(string1Token);
		free(string2Return);
		popPointer(string2Token);
		free(string3Return);
		popPointer(string3Token);
		free(string4Return);
		popPointer(string4Token);
		free(image0Return.dataStart);
		popPointer(image0Return.dataToken);
		free(image1Return.dataStart);
		popPointer(image1Return.dataToken);
		free(image2Return.dataStart);
		popPointer(image2Return.dataToken);
		free(image3Return.dataStart);
		popPointer(image3Return.dataToken);
		free(image4Return.dataStart);
		popPointer(image4Return.dataToken);
		name0Instruction = NULL;
		name1Instruction = NULL;
		name2Instruction = NULL;
		name3Instruction = NULL;
		name4Instruction = NULL;
		nameList0Instruction = NULL;
		nameList1Instruction = NULL;
		nameList2Instruction = NULL;
		nameList3Instruction = NULL;
		nameList4Instruction = NULL;
		integer0Instruction = NULL;
		integer1Instruction = NULL;
		integer2Instruction = NULL;
		integer3Instruction = NULL;
		integer4Instruction = NULL;
		string0Instruction = NULL;
		string1Instruction = NULL;
		string2Instruction = NULL;
		string3Instruction = NULL;
		string4Instruction = NULL;
		image0Instruction = NULL;
		image1Instruction = NULL;
		image2Instruction = NULL;
		image3Instruction = NULL;
		image4Instruction = NULL;
		string0Return = NULL;
		string0Token = 0;
		string1Return = NULL;
		string1Token = 0;
		string2Return = NULL;
		string2Token = 0;
		string3Return = NULL;
		string3Token = 0;
		string4Return = NULL;
		string4Token = 0;
		image0Return.dataStart = NULL;
		image0Return.dataToken = 0;
		image1Return.dataStart = NULL;
		image1Return.dataToken = 0;
		image2Return.dataStart = NULL;
		image2Return.dataToken = 0;
		image3Return.dataStart = NULL;
		image3Return.dataToken = 0;
		image4Return.dataStart = NULL;
		image4Return.dataToken = 0;
		jmp getStatement;
	}
	getStatement: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp checkCommentStoreCharacter;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	getDoubleQuotation: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getDoubleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getDoubleQuotationStoreCharacter;
		to DQT_34: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getDoubleQuotationStoreCharacter;
	end
	getSingleQuotation: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getSingleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getSingleQuotationStoreCharacter;
		to SQT_39: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getSingleQuotationStoreCharacter;
	end
	handleEscapeCharacter: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to DQT_34: /*--*/ fileChar = '\"'; /*-----------------*/ jmp storeEscapedCharacter;
		to SQT_39: /*--*/ fileChar = '\''; /*-----------------*/ jmp storeEscapedCharacter;
		to ZER_48: /*--*/ fileChar = '\0'; /*-----------------*/ jmp storeEscapedCharacter;
		to QMK_63: /*--*/ fileChar = '\?'; /*-----------------*/ jmp storeEscapedCharacter;
		to BSL_92: /*--*/ fileChar = '\\'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOA_97: /*--*/ fileChar = '\a'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOB_98: /*--*/ fileChar = '\b'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOF_102: /*-*/ fileChar = '\f'; /*-----------------*/ jmp storeEscapedCharacter;
		to LON_110: /*-*/ fileChar = '\n'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOR_114: /*-*/ fileChar = '\r'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOT_116: /*-*/ fileChar = '\t'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOV_118: /*-*/ fileChar = '\v'; /*-----------------*/ jmp storeEscapedCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	checkComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to AST_42: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreSingleLineComment;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	end
	ignoreMultipleLineComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to AST_42: /*--*/ /*----------------------------------*/ jmp checkMultipleLineCommentEnd;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	end
	checkMultipleLineCommentEnd: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	end
	ignoreSingleLineComment: switch fileChar = getNextConfigChar(system) over
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreSingleLineComment;
	end
	endOfFile:{
		if(statementCurrent == statementStart){
			jmp successfulConfig;
		}
		if(getPreviousConfigChar){
			getPreviousConfigChar(system);
		}
		jmp completeStatement;
	}
	storeWhitespace:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp getStatement;
		}
		inc itemAmount;
		fileChar = '\0';
		jmp getStatementStoreCharacter;
	}
	completeStatement:{
		if(statementCurrent <= statementStart){
			jmp getStatement;
		}
		if(!*(statementCurrent - 1)){
			jmp getStatementEnd;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = GET_STATEMENT_END_JMP_POINT;
		jmp storeCharacter;
	}
	handleOpeningBracket:{
		if(statementCurrent <= statementStart){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray opening bracket error", "could not enter nameless scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(*(statementCurrent - 1)){
			inc itemAmount;
			fileChar = '\0';
			jmpPoint = ENTER_SCOPE_JMP_POINT;
			jmp storeCharacter;
		}
		jmp enterScope;
	}
	enterScope:{
		StringTreeSystem *stringTreeSystem;
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(currentScopeInstruction == globalScopeInstruction){
			stringTreeSystem = &globalScopesInstructionStringTreeSystem;
		}else{
			printConfigError("invalid scope error", "no scopes inside current scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(!findStringTreeString(stringTreeSystem, &statementCurrent)){
			printConfigError("invalid scope error", "invalid scope name", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(itemAmount > 1){
			/*! missing space between final argument and scope imminent */
			printConfigError("scope argument error", "too many arguments", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, (void *)1, (void *)1, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		currentScopeInstruction = scope1ScopeInstruction;
		currentScopeInstructionData = scope1ScopeInstructionData;
		currentScopeInstructionList = scope1ScopeInstructionList;
		currentScopeInstructionStringTreeSystem = &scope1ScopeInstructionStringTreeSystem;
		currentScopeInstructionListSize = countof(scope1ScopeInstructionList) - 1;
		jmp getStatementStart;
	}
	attemptStoreBar:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp storeBar;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = STORE_BAR_JMP_POINT;
		jmp storeCharacter;
	}
	storeBar:{
		fileChar = '|';
		jmpPoint = STORE_WHITESPACE_JMP_POINT;
		jmp storeCharacter;
	}
	handleClosingBracket:{
		if(statementCurrent > statementStart){
			if(getNextConfigChar != &ifgetc){
				getPreviousConfigChar(system);
				jmp completeStatement;
			}
			fseek(configFile, -1, SEEK_CUR);
			jmp completeStatement;
		}
		if(currentScopeInstruction == globalScopeInstruction){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray closing bracket error", "could not drop to previous config scope", '}', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(currentScopeInstruction == scope1ScopeInstruction){
			currentScopeInstruction = globalScopeInstruction;
			currentScopeInstructionData = globalScopeInstructionData;
			currentScopeInstructionList = globalInstructionList;
			currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
			currentScopeInstructionListSize = countof(globalInstructionList) - 1;
		}
		jmp getStatementStart;
	}
	storeEscapedCharacter:{
		*(statementCurrent - 1) = fileChar;
		if(quote == '\"'){
			jmp getDoubleQuotation;
		}
		jmp getSingleQuotation;
	}
	getStatementStoreCharacter:{
		jmpPoint = GET_STATEMENT_JMP_POINT;
		jmp storeCharacter;
	}
	getDoubleQuotationStoreCharacter:{
		jmpPoint = GET_DOUBLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	getSingleQuotationStoreCharacter:{
		jmpPoint = GET_SINGLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	handleEscapeCharacterStoreCharacter:{
		jmpPoint = HANDLE_ESCAPE_CHARACTER_JMP_POINT;
		jmp storeCharacter;
	}
	checkCommentStoreCharacter:{
		jmpPoint = CHECK_COMMENT_JMP_POINT;
		jmp storeCharacter;
	}
	storeCharacter:{
		if(statementCurrent >= statementConcreteWall){
			const uint offset = statementCurrent - statementStart;
			void *temp;
			statementSize += STATEMENT_BLOCK_SIZE;
			temp = realloc(statementStart, statementSize * sizeof(char));
			updatePointer(statementToken, temp);
			if(!temp){
				printConfigError("memory allocation error", "could not allocate memory for config statement", ';', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				statementSize -= STATEMENT_BLOCK_SIZE;
				jmp getStatementStart;
			}
			statementStart = temp;
			statementCurrent = statementStart + offset;
			statementConcreteWall = statementStart + statementSize * sizeof(char);
		}
		if(jmpPoint != CHECK_COMMENT_JMP_POINT and !statementLine){
			statementLine = fileLine;
		}
		*statementCurrent = fileChar;
		inc statementCurrent;
		switch jmpPoint over
			to GET_STATEMENT_JMP_POINT: /*-----------*/ jmp getStatement;
			to STORE_WHITESPACE_JMP_POINT: /*--------*/ jmp storeWhitespace;
			to CHECK_COMMENT_JMP_POINT: /*-----------*/ jmp checkComment;
			to STORE_BAR_JMP_POINT: /*---------------*/ jmp storeBar;
			to GET_DOUBLE_QUOTATION_JMP_POINT: /*----*/ jmp getDoubleQuotation;
			to GET_SINGLE_QUOTATION_JMP_POINT: /*----*/ jmp getSingleQuotation;
			to HANDLE_ESCAPE_CHARACTER_JMP_POINT: /*-*/ jmp handleEscapeCharacter;
			to ENTER_SCOPE_JMP_POINT: /*-------------*/ jmp enterScope;
			off: /*----------------------------------*/ jmp getStatementEnd;
		end
	}
	getStatementEnd:{
		if(statementCurrent > statementStart) /*-*/ jmp findStatement;
		if(!feof(configFile)) /*-----------------*/ jmp getStatementStart;
		/*---------------------------------------*/ jmp successfulConfig;
		#undef  GET_STATEMENT_END_JMP_POINT
		#undef  ENTER_SCOPE_JMP_POINT
		#undef  HANDLE_ESCAPE_CHARACTER_JMP_POINT
		#undef  GET_SINGLE_QUOTATION_JMP_POINT
		#undef  GET_DOUBLE_QUOTATION_JMPPOINT
		#undef  STORE_BAR_JMP_POINT
		#undef  CHECK_COMMENT_JMP_POINT
		#undef  STORE_WHITESPACE_JMP_POINT
		#undef  GET_STATEMENT_JMP_POINT
		#undef  CCB_125
		#undef  BAR_124
		#undef  OCB_123
		#undef  LOV_118
		#undef  LOT_116
		#undef  LOR_114
		#undef  LON_110
		#undef  LOF_102
		#undef  LOB_98
		#undef  LOA_97
		#undef  BSL_92
		#undef  QMK_63
		#undef  SCL_59
		#undef  ZER_48
		#undef  FSL_47
		#undef  AST_42
		#undef  SQT_39
		#undef  DQT_34
		#undef  SPC_32
		#undef  ESC_27
		#undef  CRE_13
		#undef  FFD_12
		#undef  VTB_11
		#undef  NLN_10
		#undef  TAB_09
		#undef  BSP_08
		#undef  ALR_07
		#undef  EOT_04
		#undef  ZER_00
		#undef  EOF_N1
	}
	findStatement:{
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(!findStringTreeString(currentScopeInstructionStringTreeSystem, &statementCurrent)){
			printConfigError("config error", "unrecognized instruction", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp printAllInstructionPatterns;
		}
		instructionStart = *(currentScopeInstruction + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionStartCopy = instructionStart;
		instructionCurrent = instructionStart;
		instructionDataStart = *(currentScopeInstructionData + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionDataStartCopy = instructionDataStart;
		instructionDataCurrent = instructionDataStart;
		if(*instructionCurrent == NONE_INSTRUCTION_TYPE){
			jmp unimplementedInstruction;
		}
		if(statementCurrent >= statementWall and *instructionCurrent != END_INSTRUCTION_TYPE){
			printConfigError("config error", "missing instruction body", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		inc statementCurrent;
		jmp switchInstructionLoop;
	}
	switchInstructionLoop: switch *instructionCurrent over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp unimplementedInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp matchName;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp matchNameList;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp matchInteger;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp matchString;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp matchImageString;
		off: /*---------------------------*/ jmp endOfInstruction;
	end
	unimplementedInstruction:{
		printConfigError("implementation error", "using unimplemented instruction", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchName:{
		char *s;
		uint8 *namePointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!name0Instruction){
			namePointer = &name0Return;
			name0Instruction = instructionCurrent;
		}elif(!name1Instruction){
			namePointer = &name1Return;
			name1Instruction = instructionCurrent;
		}elif(!name2Instruction){
			namePointer = &name2Return;
			name2Instruction = instructionCurrent;
		}elif(!name3Instruction){
			namePointer = &name3Return;
			name3Instruction = instructionCurrent;
		}else{
			namePointer = &name4Return;
			name4Instruction = instructionCurrent;
		}
		s = statementCurrent;
		if(!findStringTreeString(*instructionDataCurrent, &s)){
			printConfigError("match string error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		statementCurrent = s;
		inc statementCurrent;
		*namePointer = (**instructionDataCurrent).returnedCounter;
		jmp advanceDataInstruction;
	}
	matchNameList:{
		uint8 *nameListPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!nameList0Instruction){
			nameListPointer = &nameList0Return;
			nameList0Instruction = instructionCurrent;
		}elif(!nameList1Instruction){
			nameListPointer = &nameList1Return;
			nameList1Instruction = instructionCurrent;
		}elif(!nameList2Instruction){
			nameListPointer = &nameList2Return;
			nameList2Instruction = instructionCurrent;
		}elif(!nameList3Instruction){
			nameListPointer = &nameList3Return;
			nameList3Instruction = instructionCurrent;
		}else{
			nameListPointer = &nameList4Return;
			nameList4Instruction = instructionCurrent;
		}
		switch matchNameList(*instructionDataCurrent, statementWall, &statementCurrent, nameListPointer) over
			to INVALID_NAME_NAME_LIST: /*--*/ jmp invalidNameNameList;
			to PREMATURE_END_NAME_LIST: /*-*/ jmp prematureEndNameList;
			off: /*------------------------*/ jmp advanceDataInstruction;
		end
	}
	invalidNameNameList:{
		printConfigError("bar list error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	prematureEndNameList:{
		printConfigError("bar list error", "missing final name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchInteger:{
		int64 *integerPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!integer0Instruction){
			integerPointer = &integer0Return;
			integer0Instruction = instructionCurrent;
		}elif(!integer1Instruction){
			integerPointer = &integer1Return;
			integer1Instruction = instructionCurrent;
		}elif(!integer2Instruction){
			integerPointer = &integer2Return;
			integer2Instruction = instructionCurrent;
		}elif(!integer3Instruction){
			integerPointer = &integer3Return;
			integer3Instruction = instructionCurrent;
		}else{
			integerPointer = &integer4Return;
			integer4Instruction = instructionCurrent;
		}
		switch matchInteger(&statementCurrent, statementWall, integerPointer) over
			to NON_NUMBER_NUMBER: /*-------*/ jmp printNonNumberError;
			to OVERFLOWN_NUMBER_NUMBER: /*-*/ jmp printOverflownNumberError;
			to DIVIDED_BY_ZERO_NUMBER: /*--*/ jmp printDividedByZeroNumberError;
			off: /*------------------------*/ jmp advanceInstruction;
		end
	}
	printNonNumberError:{
		printConfigError("match integer error", "not a number", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printOverflownNumberError:{
		printConfigError("match integer error", "integer overflow", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printDividedByZeroNumberError:{
		printConfigError("match integer error", "integer divided by zero", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchString:{
		char **stringPointer;
		uint32 *stringTokenPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!string0Instruction){
			stringPointer = &string0Return;
			stringTokenPointer = &string0Token;
			string0Instruction = instructionCurrent;
		}elif(!string1Instruction){
			stringPointer = &string1Return;
			stringTokenPointer = &string1Token;
			string1Instruction = instructionCurrent;
		}elif(!string2Instruction){
			stringPointer = &string2Return;
			stringTokenPointer = &string2Token;
			string2Instruction = instructionCurrent;
		}elif(!string3Instruction){
			stringPointer = &string3Return;
			stringTokenPointer = &string3Token;
			string3Instruction = instructionCurrent;
		}else{
			stringPointer = &string4Return;
			stringTokenPointer = &string4Token;
			string4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, stringPointer, stringTokenPointer)){
			printConfigError("match string error", "could not allocate string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		jmp advanceInstruction;
	}
	matchImageString:{
		char *string = NULL;
		uint32 token = 0;
		Image *imagePointer;
		uint8 matchImageReturn;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!image0Instruction){
			imagePointer = &image0Return;
			image0Instruction = instructionCurrent;
		}elif(!image1Instruction){
			imagePointer = &image1Return;
			image1Instruction = instructionCurrent;
		}elif(!image2Instruction){
			imagePointer = &image2Return;
			image2Instruction = instructionCurrent;
		}elif(!image3Instruction){
			imagePointer = &image3Return;
			image3Instruction = instructionCurrent;
		}else{
			imagePointer = &image4Return;
			image4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, &string, &token)){
			printConfigError("match image error", "could not allocate image string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		matchImageReturn = matchImage(string, &imageErrorMessage, &image0Return);
		free(string);
		popPointer(token);
		switch matchImageReturn over
			to CANNOT_OPEN_MATCH_IMAGE: /*--------*/ jmp printCannotOpenReadConfig;
			to CANNOT_READ_MATCH_IMAGE: /*--------*/ jmp printCannotReadReadConfig;
			to UNSUPPORTED_FORMAT_MATCH_IMAGE: /*-*/ jmp printUnsupportedFormatReadConfig;
			to BAD_HEADER_MATCH_IMAGE: /*---------*/ jmp printBadHeaderReadConfig;
			to BAD_DEPTH_MATCH_IMAGE: /*----------*/ jmp printBadDepthReadConfig;
			to BAD_COMPRESSION_MATCH_IMAGE: /*----*/ jmp printBadCompressionReadConfig;
			to UNSUPPORTED_HEIGHT_MATCH_IMAGE: /*-*/ jmp printUnsupportedHeightReadConfig;
			to BAD_SIZE_MATCH_IMAGE: /*-----------*/ jmp printBadSizeReadConfig;
			to FAILED_MATCH_IMAGE: /*-------------*/ jmp printFailedReadConfig;
			to BAD_PIXELS_MATCH_IMAGE: /*---------*/ jmp printBadPixelsReadConfig;
			to BAD_IMAGE_MATCH_IMAGE: /*----------*/ jmp printBadImageReadConfig;
			off: /*-------------------------------*/ jmp advanceInstruction;
		end
	}
	printCannotOpenReadConfig:{
		printConfigError("match image error", "could not open image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printCannotReadReadConfig:{
		printConfigError("match image error", "could not read image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedFormatReadConfig:{
		printConfigError("match image error", "image file not bmp", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadHeaderReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadDepthReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadCompressionReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedHeightReadConfig:{
		printConfigError("match image error", "negative height is not supported", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadSizeReadConfig:{
		printConfigError("match image error", "could not traverse image past the header", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printFailedReadConfig:{
		printConfigError("match image error", "could not allocate pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadPixelsReadConfig:{
		printConfigError("match image error", "could not read pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadImageReadConfig:{
		printConfigError("match image error", "image is broken", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	endOfInstruction:{
		if(instructionStart == setInstruction){
			#define applySubinstruction(s, i) /*-*/ instructionStart = s##i##Subinstruction; instructionDataStart = s##i##SubinstructionData
			switch name0Return over
				to WINDOW_X_VARIABLE: /*------------------------*/ applySubinstruction(windowX, Set); /*----------------------*/ jmp assessSubinstruction;
				to WINDOW_Y_VARIABLE: /*------------------------*/ applySubinstruction(windowY, Set); /*----------------------*/ jmp assessSubinstruction;
				to WINDOW_X_OFFSET_VARIABLE: /*-----------------*/ applySubinstruction(windowXOffset, Set); /*----------------*/ jmp assessSubinstruction;
				to WINDOW_Y_OFFSET_VARIABLE: /*-----------------*/ applySubinstruction(windowYOffset, Set); /*----------------*/ jmp assessSubinstruction;
				to WINDOW_WIDTH_VARIABLE: /*--------------------*/ applySubinstruction(windowWidth, Set); /*------------------*/ jmp assessSubinstruction;
				to WINDOW_HEIGHT_VARIABLE: /*-------------------*/ applySubinstruction(windowHeight, Set); /*-----------------*/ jmp assessSubinstruction;
				to WINDOW_HORIZONTAL_ALIGNMENT_VARIABLE: /*-----*/ applySubinstruction(windowHorizontalAlignment, Set); /*----*/ jmp assessSubinstruction;
				to WINDOW_VERTICAL_ALIGNMENT_VARIABLE: /*-------*/ applySubinstruction(windowVerticalAlignment, Set); /*------*/ jmp assessSubinstruction;
				to WINDOW_CORNER_RADIUS_VARIABLE: /*------------*/ applySubinstruction(windowCornerRadius, Set); /*-----------*/ jmp assessSubinstruction;
				to WINDOW_BACKGROUND_VARIABLE: /*---------------*/ applySubinstruction(windowBackground, Set); /*-------------*/ jmp assessSubinstruction;
				to SELECTION_X_VARIABLE: /*---------------------*/ applySubinstruction(selectionX, Set); /*-------------------*/ jmp assessSubinstruction;
				to SELECTION_Y_VARIABLE: /*---------------------*/ applySubinstruction(selectionY, Set); /*-------------------*/ jmp assessSubinstruction;
				to SELECTION_X_OFFSET_VARIABLE: /*--------------*/ applySubinstruction(selectionXOffset, Set); /*-------------*/ jmp assessSubinstruction;
				to SELECTION_Y_OFFSET_VARIABLE: /*--------------*/ applySubinstruction(selectionYOffset, Set); /*-------------*/ jmp assessSubinstruction;
				to SELECTION_WIDTH_VARIABLE: /*-----------------*/ applySubinstruction(selectionWidth, Set); /*---------------*/ jmp assessSubinstruction;
				to SELECTION_HEIGHT_VARIABLE: /*----------------*/ applySubinstruction(selectionHeight, Set); /*--------------*/ jmp assessSubinstruction;
				to SELECTION_MARGIN_VARIABLE: /*----------------*/ applySubinstruction(selectionMargin, Set); /*--------------*/ jmp assessSubinstruction;
				to SELECTION_HORIZONTAL_ALIGNMENT_VARIABLE: /*--*/ applySubinstruction(selectionHorizontalAlignment, Set); /*-*/ jmp assessSubinstruction;
				to SELECTION_VERTICAL_ALIGNMENT_VARIABLE: /*----*/ applySubinstruction(selectionVerticalAlignment, Set); /*---*/ jmp assessSubinstruction;
				to SELECTION_CLIP_CHILDREN_VARIABLE: /*---------*/ applySubinstruction(selectionClipChildren, Set); /*--------*/ jmp assessSubinstruction;
				to SELECTION_BACKGROUND_VARIABLE: /*------------*/ applySubinstruction(selectionBackground, Set); /*----------*/ jmp assessSubinstruction;
				to SELECTION_SELECTED_BACKGROUND_VARIABLE: /*---*/ applySubinstruction(selectionSelectedBackground, Set); /*--*/ jmp assessSubinstruction;
				to CLIENT_X_VARIABLE: /*------------------------*/ applySubinstruction(clientX, Set); /*----------------------*/ jmp assessSubinstruction;
				to CLIENT_Y_VARIABLE: /*------------------------*/ applySubinstruction(clientY, Set); /*----------------------*/ jmp assessSubinstruction;
				to CLIENT_X_OFFSET_VARIABLE: /*-----------------*/ applySubinstruction(clientXOffset, Set); /*----------------*/ jmp assessSubinstruction;
				to CLIENT_Y_OFFSET_VARIABLE: /*-----------------*/ applySubinstruction(clientYOffset, Set); /*----------------*/ jmp assessSubinstruction;
				to CLIENT_WIDTH_VARIABLE: /*--------------------*/ applySubinstruction(clientWidth, Set); /*------------------*/ jmp assessSubinstruction;
				to CLIENT_HEIGHT_VARIABLE: /*-------------------*/ applySubinstruction(clientHeight, Set); /*-----------------*/ jmp assessSubinstruction;
				to CLIENT_HORIZONTAL_ALIGNMENT_VARIABLE: /*-----*/ applySubinstruction(clientHorizontalAlignment, Set); /*----*/ jmp assessSubinstruction;
				to CLIENT_VERTICAL_ALIGNMENT_VARIABLE: /*-------*/ applySubinstruction(clientVerticalAlignment, Set); /*------*/ jmp assessSubinstruction;
				to CLIENT_BACKGROUND_VARIABLE: /*---------------*/ applySubinstruction(clientBackground, Set); /*-------------*/ jmp assessSubinstruction;
				to CLIENT_SELECTED_BACKGROUND_VARIABLE: /*------*/ applySubinstruction(clientSelectedBackground, Set); /*-----*/ jmp assessSubinstruction;
				to TITLE_X_VARIABLE: /*-------------------------*/ applySubinstruction(titleX, Set); /*-----------------------*/ jmp assessSubinstruction;
				to TITLE_Y_VARIABLE: /*-------------------------*/ applySubinstruction(titleY, Set); /*-----------------------*/ jmp assessSubinstruction;
				to TITLE_X_OFFSET_VARIABLE: /*------------------*/ applySubinstruction(titleXOffset, Set); /*-----------------*/ jmp assessSubinstruction;
				to TITLE_Y_OFFSET_VARIABLE: /*------------------*/ applySubinstruction(titleYOffset, Set); /*-----------------*/ jmp assessSubinstruction;
				to TITLE_WIDTH_VARIABLE: /*---------------------*/ applySubinstruction(titleWidth, Set); /*-------------------*/ jmp assessSubinstruction;
				to TITLE_HEIGHT_VARIABLE: /*--------------------*/ applySubinstruction(titleHeight, Set); /*------------------*/ jmp assessSubinstruction;
				to TITLE_HORIZONTAL_ALIGNMENT_VARIABLE: /*------*/ applySubinstruction(titleHorizontalAlignment, Set); /*-----*/ jmp assessSubinstruction;
				to TITLE_VERTICAL_ALIGNMENT_VARIABLE: /*--------*/ applySubinstruction(titleVerticalAlignment, Set); /*-------*/ jmp assessSubinstruction;
				to TITLE_CLIP_CHILDREN_VARIABLE: /*-------------*/ applySubinstruction(titleClipChildren, Set); /*------------*/ jmp assessSubinstruction;
				to TITLE_BACKGROUND_VARIABLE: /*----------------*/ applySubinstruction(titleBackground, Set); /*--------------*/ jmp assessSubinstruction;
				to TITLE_SELECTED_BACKGROUND_VARIABLE: /*-------*/ applySubinstruction(titleSelectedBackground, Set); /*------*/ jmp assessSubinstruction;
				to TITLE_TEXT_X_VARIABLE: /*--------------------*/ applySubinstruction(titleTextX, Set); /*-------------------*/ jmp assessSubinstruction;
				to TITLE_TEXT_Y_VARIABLE: /*--------------------*/ applySubinstruction(titleTextY, Set); /*-------------------*/ jmp assessSubinstruction;
				to TITLE_TEXT_X_OFFSET_VARIABLE: /*-------------*/ applySubinstruction(titleTextXOffset, Set); /*-------------*/ jmp assessSubinstruction;
				to TITLE_TEXT_Y_OFFSET_VARIABLE: /*-------------*/ applySubinstruction(titleTextYOffset, Set); /*-------------*/ jmp assessSubinstruction;
				to TITLE_TEXT_HORIZONTAL_ALIGNMENT_VARIABLE: /*-*/ applySubinstruction(titleTextHorizontalAlignment, Set); /*-*/ jmp assessSubinstruction;
				to TITLE_TEXT_VERTICAL_ALIGNMENT_VARIABLE: /*---*/ applySubinstruction(titleTextVerticalAlignment, Set); /*---*/ jmp assessSubinstruction;
				to TITLE_TEXT_FOREGROUND_VARIABLE: /*-----------*/ applySubinstruction(titleTextForeground, Set); /*----------*/ jmp assessSubinstruction;
				to TITLE_TEXT_BACKGROUND_VARIABLE: /*-----------*/ applySubinstruction(titleTextBackground, Set); /*----------*/ jmp assessSubinstruction;
				to TITLE_TEXT_SELECTED_FOREGROUND_VARIABLE: /*--*/ applySubinstruction(titleTextSelectedForeground, Set); /*--*/ jmp assessSubinstruction;
				to TITLE_TEXT_SELECTED_BACKGROUND_VARIABLE: /*--*/ applySubinstruction(titleTextSelectedBackground, Set); /*--*/ jmp assessSubinstruction;
				to TITLE_TEXT_CUTOFF_VARIABLE: /*---------------*/ applySubinstruction(titleTextCutoff, Set); /*--------------*/ jmp assessSubinstruction;
				to CLIENT_ORDER_VARIABLE: /*--------------------*/ applySubinstruction(clientOrder, Set); /*------------------*/ jmp assessSubinstruction;
				to SELECTION_AXIS_VARIABLE: /*------------------*/ applySubinstruction(selectionAxis, Set); /*----------------*/ jmp assessSubinstruction;
				to SELECTION_AXIS_AMOUNT_VARIABLE: /*-----------*/ applySubinstruction(selectionAxisAmount, Set); /*----------*/ jmp assessSubinstruction;
				to STARTING_SELECTION_VARIABLE: /*--------------*/ applySubinstruction(startingSelection, Set); /*------------*/ jmp assessSubinstruction;
				to ALLOW_CIRCULAR_NAVIGATION_VARIABLE: /*-------*/ applySubinstruction(allowCircularNavigation, Set); /*------*/ jmp assessSubinstruction;
				to SELECTION_ACTION_VARIABLE: /*----------------*/ applySubinstruction(selectionAction, Set); /*--------------*/ jmp assessSubinstruction;
				to WHICH_MONITOR_VARIABLE: /*-------------------*/ applySubinstruction(whichMonitor, Set); /*-----------------*/ jmp assessSubinstruction;
				to FONT_VARIABLE: /*----------------------------*/ applySubinstruction(font, Set); /*-------------------------*/ jmp assessSubinstruction;
				off: /*-----------------------------------------*/ /*---------------------------------------------------------*/ brk;
			end
		}
		if(instructionStart == doInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, Do); jmp assessSubinstruction;
				off: /*----------------*/ /*-----------------------------*/ brk;
			end
		}
		if(instructionStart == grabKeycodeInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabKeycode); jmp assessSubinstruction;
				off: /*----------------*/ /*--------------------------------------*/ brk;
			end
		}
		if(instructionStart == grabButtonInstruction){
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabButton); jmp assessSubinstruction;
				off: /*----------------*/ /*-------------------------------------*/ brk;
			end
			#undef  applySubinstruction
		}
		if(statementCurrent < statementWall){
			printConfigError("config error", "extra parameters error", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(instructionStartCopy == helpInstruction){
			printError("%s%s: %s: line %u: %s%s:%s %s:\n", colorStart, programName, configPath, statementLine, colorError, "config help menu", colorEnd, displaySimpleConfigErrors? "contracted" : "expanded");
			jmp printAllInstructionPatterns;
		}
		if(instructionStartCopy == expandInstruction){
			displaySimpleConfigErrors = false;
			jmp getStatementStart;
		}
		if(instructionStartCopy == contractInstruction){
			displaySimpleConfigErrors = true;
			jmp getStatementStart;
		}
		if(instructionStartCopy == readConfigInstruction){
			readConfig(false, string0Return, &ifgetc, NULL);
			jmp getStatementStart;
		}
		if(instructionStartCopy == useTerminalInstruction){
			switch name0Return over
				to TRUE_BOOLEAN:{
					if(!connectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == useMessengerInstruction){
			switch name0Return over
				to TRUE_BOOLEAN:{
					if(!connectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == setInstruction){
			switch name0Return over
				to WINDOW_X_VARIABLE:{
					windowPreferences.x = integer0Return;
					windowPreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_Y_VARIABLE:{
					windowPreferences.y = integer0Return;
					windowPreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_X_OFFSET_VARIABLE:{
					windowPreferences.xOffset = integer0Return;
					windowPreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_Y_OFFSET_VARIABLE:{
					windowPreferences.yOffset = integer0Return;
					windowPreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_WIDTH_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					windowPreferences.width = integer0Return;
					windowPreferences.widthType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_HEIGHT_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					windowPreferences.height = integer0Return;
					windowPreferences.heightType = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_HORIZONTAL_ALIGNMENT_VARIABLE:{
					windowPreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_VERTICAL_ALIGNMENT_VARIABLE:{
					windowPreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to WINDOW_CORNER_RADIUS_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					if(integer0Return != windowPreferences.cornerRadius){
						if(createWindowCirclePixmap(&windowSystem, integer0Return, windowPreferences.background, 0x00000000)){
							windowPreferences.cornerRadius = integer0Return;
							windowPreferences.cornerUsed = nameList0Return;
						}
					}
					jmp getStatementStart;
				}
				to WINDOW_BACKGROUND_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					windowPreferences.background = integer0Return;
					createWindowCirclePixmap(&windowSystem, windowPreferences.cornerRadius, integer0Return, 0x00000000);
					jmp getStatementStart;
				}
				to SELECTION_X_VARIABLE:{
					selectionPreferences.x = integer0Return;
					selectionPreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_Y_VARIABLE:{
					selectionPreferences.y = integer0Return;
					selectionPreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_X_OFFSET_VARIABLE:{
					selectionPreferences.xOffset = integer0Return;
					selectionPreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_Y_OFFSET_VARIABLE:{
					selectionPreferences.yOffset = integer0Return;
					selectionPreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_WIDTH_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					selectionPreferences.width = integer0Return;
					selectionPreferences.widthType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_HEIGHT_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					selectionPreferences.height = integer0Return;
					selectionPreferences.heightType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_MARGIN_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					selectionPreferences.margin = integer0Return;
					selectionPreferences.marginType = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_HORIZONTAL_ALIGNMENT_VARIABLE:{
					selectionPreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_VERTICAL_ALIGNMENT_VARIABLE:{
					selectionPreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_CLIP_CHILDREN_VARIABLE:{
					switch name1Return over
						to TRUE_BOOLEAN: /*--*/ selectionPreferences.clipChildren = true; /*--*/ jmp getStatementStart;
						to FALSE_BOOLEAN: /*-*/ selectionPreferences.clipChildren = false; /*-*/ jmp getStatementStart;
						off: /*--------------*/ /*--------------------------------------------*/ jmp getStatementStart;
					end
				}
				to SELECTION_BACKGROUND_VARIABLE:{
					selectionPreferences.background = integer0Return;
					jmp getStatementStart;
				}
				to SELECTION_SELECTED_BACKGROUND_VARIABLE:{
					selectionPreferences.selectedBackground = integer0Return;
					jmp getStatementStart;
				}
				to CLIENT_X_VARIABLE:{
					clientPreferences.x = integer0Return;
					clientPreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to CLIENT_Y_VARIABLE:{
					clientPreferences.y = integer0Return;
					clientPreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to CLIENT_X_OFFSET_VARIABLE:{
					clientPreferences.xOffset = integer0Return;
					clientPreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to CLIENT_Y_OFFSET_VARIABLE:{
					clientPreferences.yOffset = integer0Return;
					clientPreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to CLIENT_WIDTH_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					clientPreferences.width = integer0Return;
					clientPreferences.widthType = name1Return;
					jmp getStatementStart;
				}
				to CLIENT_HEIGHT_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					clientPreferences.height = integer0Return;
					clientPreferences.heightType = name1Return;
					jmp getStatementStart;
				}
				to CLIENT_HORIZONTAL_ALIGNMENT_VARIABLE:{
					clientPreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to CLIENT_VERTICAL_ALIGNMENT_VARIABLE:{
					clientPreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to CLIENT_BACKGROUND_VARIABLE:{
					clientPreferences.background = integer0Return;
					jmp getStatementStart;
				}
				to CLIENT_SELECTED_BACKGROUND_VARIABLE:{
					clientPreferences.selectedBackground = integer0Return;
					jmp getStatementStart;
				}
				to TITLE_X_VARIABLE:{
					titlePreferences.x = integer0Return;
					titlePreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to TITLE_Y_VARIABLE:{
					titlePreferences.y = integer0Return;
					titlePreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to TITLE_X_OFFSET_VARIABLE:{
					titlePreferences.xOffset = integer0Return;
					titlePreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to TITLE_Y_OFFSET_VARIABLE:{
					titlePreferences.yOffset = integer0Return;
					titlePreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to TITLE_WIDTH_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					titlePreferences.width = integer0Return;
					titlePreferences.widthType = name1Return;
					jmp getStatementStart;
				}
				to TITLE_HEIGHT_VARIABLE:{
					if(integer0Return < 1){
						printConfigError("integer domain error", "integer is not in [1, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					titlePreferences.height = integer0Return;
					titlePreferences.heightType = name1Return;
					jmp getStatementStart;
				}
				to TITLE_HORIZONTAL_ALIGNMENT_VARIABLE:{
					titlePreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to TITLE_VERTICAL_ALIGNMENT_VARIABLE:{
					titlePreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to TITLE_CLIP_CHILDREN_VARIABLE:{
					switch name1Return over
						to TRUE_BOOLEAN: /*--*/ titlePreferences.clipChildren = true; /*--*/ jmp getStatementStart;
						to FALSE_BOOLEAN: /*-*/ titlePreferences.clipChildren = false; /*-*/ jmp getStatementStart;
						off: /*--------------*/ /*----------------------------------------*/ jmp getStatementStart;
					end
				}
				to TITLE_BACKGROUND_VARIABLE:{
					titlePreferences.background = integer0Return;
					jmp getStatementStart;
				}
				to TITLE_SELECTED_BACKGROUND_VARIABLE:{
					titlePreferences.selectedBackground = integer0Return;
					jmp getStatementStart;
				}
				to TITLE_TEXT_X_VARIABLE:{
					titleTextPreferences.x = integer0Return;
					titleTextPreferences.xType = name1Return;
					jmp getStatementStart;
				}
				to TITLE_TEXT_Y_VARIABLE:{
					titleTextPreferences.y = integer0Return;
					titleTextPreferences.yType = name1Return;
					jmp getStatementStart;
				}
				to TITLE_TEXT_X_OFFSET_VARIABLE:{
					titleTextPreferences.xOffset = integer0Return;
					titleTextPreferences.xOffsetType = name1Return;
					jmp getStatementStart;
				}
				to TITLE_TEXT_Y_OFFSET_VARIABLE:{
					titleTextPreferences.yOffset = integer0Return;
					titleTextPreferences.yOffsetType = name1Return;
					jmp getStatementStart;
				}
				to TITLE_TEXT_HORIZONTAL_ALIGNMENT_VARIABLE:{
					titleTextPreferences.horizontalAlignment = name1Return;
					jmp getStatementStart;
				}
				to TITLE_TEXT_VERTICAL_ALIGNMENT_VARIABLE:{
					titleTextPreferences.verticalAlignment = name1Return;
					jmp getStatementStart;
				}
				to TITLE_TEXT_FOREGROUND_VARIABLE:{
					titleTextPreferences.foreground = integer0Return;
					jmp getStatementStart;
				}
				to TITLE_TEXT_BACKGROUND_VARIABLE:{
					titleTextPreferences.background = integer0Return;
					jmp getStatementStart;
				}
				to TITLE_TEXT_SELECTED_FOREGROUND_VARIABLE:{
					titleTextPreferences.selectedForeground = integer0Return;
					jmp getStatementStart;
				}
				to TITLE_TEXT_SELECTED_BACKGROUND_VARIABLE:{
					titleTextPreferences.selectedBackground = integer0Return;
					jmp getStatementStart;
				}
				to TITLE_TEXT_CUTOFF_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					setClientListTextCutoff(&clientListSystem, integer0Return, font);
					setClientListTextCutoff(&clientListStackingSystem, integer0Return, font);
					jmp getStatementStart;
				}
				to CLIENT_ORDER_VARIABLE:{
					clientOrder = name1Return;
					jmp getStatementStart;
				}
				to SELECTION_AXIS_VARIABLE:{
					setSelectionAxis(&selectionSystem, name1Return);
					jmp getStatementStart;
				}
				to SELECTION_AXIS_AMOUNT_VARIABLE:{
					if(integer0Return < 0){
						printConfigError("integer domain error", "integer is not in [0, +infinity)", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, integer0Instruction, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					setSelectionAxisAmount(&selectionSystem, integer0Return);
					jmp getStatementStart;
				}
				to STARTING_SELECTION_VARIABLE:{
					setStartingSelection(&selectionSystem, name1Return);
					jmp getStatementStart;
				}
				to ALLOW_CIRCULAR_NAVIGATION_VARIABLE:{
					switch name1Return over
						to TRUE_BOOLEAN: /*--*/ setSelectionNavigation(&selectionSystem, true); /*--*/ jmp getStatementStart;
						to FALSE_BOOLEAN: /*-*/ setSelectionNavigation(&selectionSystem, false); /*-*/ jmp getStatementStart;
						off: /*--------------*/ /*--------------------------------------------------*/ jmp getStatementStart;
					end
				}
				to SELECTION_ACTION_VARIABLE:{
					setSelectionAction(&selectionSystem, name1Return);
					jmp getStatementStart;
				}
				to WHICH_MONITOR_VARIABLE:{
					whichMonitor = name1Return;
					jmp getStatementStart;
				}
				to FONT_VARIABLE:{
					if(font){
						xcb_close_font(connection, font);
					}
					font = xcb_generate_id(connection);
					{
						const xcb_void_cookie_t cookie = xcb_open_font_checked(connection, font, findStringLength(string0Return), string0Return);
						xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
						uint32 token = pushPointer(error, "open font error", iFree);
						if(error){
							xcb_open_font(connection, font, lengthof("fixed"), "fixed");
							printError("%s%s: %s%s:%s %s \"%s\"\n", colorStart, programName, colorError, "open font error", colorEnd, "could not open font", string0Return);
							free(error);
							popPointer(token);
						}
					}
					updateClientsTitle(&clientListSystem, font);
					updateClientsTitle(&clientListStackingSystem, font);
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == doInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			end
			switch matchCommand(name0Return, string0Return, getNextConfigChar == &ifgetc? CONFIG_MATCH_COMMAND_ORIGIN : getNextConfigChar == &getNextSTDINCharacter? STDIN_MATCH_COMMAND_ORIGIN : TRANSMITTER_MATCH_COMMAND_ORIGIN, field0, field1, field2, field3, field4) over
				to TYPICAL_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to RESTART_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to EXIT_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				off:{
					printConfigError("config error", "do subinstruction not implemented yet", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionStart, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp getStatementStart;
				}
			end
		}
		if(instructionStartCopy == grabKeycodeInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			end
			if(!insertShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_key_checked(connection, true, (*screen).root, nameList0Return, integer0Return, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab key on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == grabButtonInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch name0Return over
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			end
			if(!insertShortcut(&buttonShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_button_checked(connection, true, (*screen).root, XCB_EVENT_MASK_NO_EVENT, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, integer0Return, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab button on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabKeycodeInstruction){
			if(!removeShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find key to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_key_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab key from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabButtonInstruction){
			if(!removeShortcut(&buttonShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find button to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_button_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab button from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == stopInstruction){
			jmp successfulConfig;
		}
		jmp getStatementStart;
	}
	advanceInstruction:{
		inc instructionCurrent;
		jmp switchInstructionLoop;
	}
	advanceDataInstruction:{
		inc instructionCurrent;
		inc instructionDataCurrent;
		jmp switchInstructionLoop;
	}
	assessSubinstruction:{
		instructionCurrent = instructionStart + (instructionCurrent - instructionStartCopy);
		instructionDataCurrent = instructionDataStart + (instructionDataCurrent - instructionDataStartCopy);
		if(statementCurrent < statementWall){
			jmp switchInstructionLoop;
		}
		jmp printMissingArgumentError;
	}
	printMissingArgumentError:{
		printConfigError("config error", "missing argument error", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printAllInstructionPatterns:{
		const char *const *const wall = currentScopeInstructionList + currentScopeInstructionListSize;
		const char *const *current = currentScopeInstructionList;
		const Instruction *const *in = currentScopeInstruction;
		StringTreeSystem *const *const *da = currentScopeInstructionData;
		jmp printExpandedHelpInstructions;
		printExpandedHelpInstructions:{
			const Instruction *n = *in - 1;
			StringTreeSystem *const *d = *da;
			printError("\tpattern | %s", *current);
			jmp printHelpInstructionParametersLoop;
			printHelpInstructionParametersLoop: switch *(inc n) over
				to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
				to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
				to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
				to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
				to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
				to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
				off: /*---------------------------*/ jmp printHelpInstructionParametersLoopExit;
			end
			noneInstruction:{
				printError(" <unimplemented>");
				jmp printHelpInstructionParametersLoopExit;
			}
			nameInstruction:{
				if(displaySimpleConfigErrors){
					printError(" name");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" (%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
					printNameLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameLoop;
						}
						printError(")");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			nameListInstruction:{
				if(displaySimpleConfigErrors){
					printError(" list");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" ((%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
					printNameListOnceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListOnceLoop;
						}
						stringArray = (**d).stringArray;
						printError(")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
						inc stringArray;
						jmp printNameListTwiceLoop;
					}
					printNameListTwiceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListTwiceLoop;
						}
						printError("))*(?![\\s]*[|]))");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			numberInstruction:{
				if(displaySimpleConfigErrors){
					printError(" number");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
				jmp printHelpInstructionParametersLoop;
			}
			stringInstruction:{
				if(displaySimpleConfigErrors){
					printError(" string");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
			imageInstruction:{
				if(displaySimpleConfigErrors){
					printError(" image");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
		}
		printHelpInstructionParametersLoopExit:{
			inc in;
			inc da;
			if(displaySimpleConfigErrors){
				printError("\n");
			}else{
				printError(" $\n");
			}
			if(inc current < wall){
				jmp printExpandedHelpInstructions;
			}
			printError("\n");
			jmp getStatementStart;
		}
	}
	successfulConfig:{
		if(currentScopeInstruction != globalScopeInstruction){
			*statementCurrent = '\0';
			statementWall = statementCurrent;
			statementLine = fileLine;
			if(fileLine != 1){
				dec statementLine;
			}
			printConfigError("config error", "missing closing scope bracket", '\0', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		jmp configEmergencyExit;
	}
	configEmergencyExit:{
		if(configFile and fileLine == 1 and !statementLine){
			printConfigError("config warning", "empty config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		free(statementStart);
		popPointer(statementToken);
		if(configFile){
			fclose(configFile);
			popPointer(configFileToken);
		}
		jmp postReadConfig;
	}
	postReadConfig:{
		switch clientOrder over
			to NONE_CLIENT_ORDER: /*-----*/ setSelectionAmount(&selectionSystem, 0); /*-----------------------------------*/ brk;
			to CREATION_CLIENT_ORDER: /*-*/ setSelectionAmount(&selectionSystem, clientListSystem.clientSize); /*---------*/ brk;
			to STACKING_CLIENT_ORDER: /*-*/ setSelectionAmount(&selectionSystem, clientListStackingSystem.clientSize); /*-*/ brk;
			off: /*----------------------*/ setSelectionAmount(&selectionSystem, 0); /*-----------------------------------*/ brk;
		end
		if(!configureWindows(&windowSystem, &monitorSystem, &windowPreferences, whichMonitor)){
			if(windowSystem.mapped){
				drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
			}
		}
		xcb_flush(connection);
		ret;
	}
	#undef  DEFAULT_CONFIG_PATH
	#undef  STATEMENT_BLOCK_SIZE
}
MATCHCOMMAND(){
	uint8 commandReturned = TYPICAL_MATCH_COMMAND_TYPE;
	(void)field0;
	(void)field1;
	(void)field2;
	(void)field3;
	(void)field4;
	switch origin over
		to PRESS_MATCH_COMMAND_ORIGIN:{
			printCommand("press", command);
			if(!((*eventModifierNode).onState & PRESS_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to RELEASE_MATCH_COMMAND_ORIGIN:{
			printCommand("release", command);
			if(!((*eventModifierNode).onState & RELEASE_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to CONFIG_MATCH_COMMAND_ORIGIN:{
			printCommand("config", command);
			jmp matchCommand;
		}
		to STDIN_MATCH_COMMAND_ORIGIN:{
			printCommand("stdin", command);
			jmp matchCommand;
		}
		to TRANSMITTER_MATCH_COMMAND_ORIGIN:{
			printCommand("transmitter", command);
			jmp matchCommand;
		}
		off:{
			jmp emergencyExit;
		}
	end
	matchCommand: switch command over
		to NONE_COMMAND: /*------------------*/ jmp noneCommand;
		to EXECUTE_COMMAND: /*---------------*/ jmp executeCommand;
		to SET_CURRENT_SELECTION_COMMAND: /*-*/ jmp setCurrentSelectionCommand;
		to SHOW_COMMAND: /*------------------*/ jmp showCommand;
		to HIDE_COMMAND: /*------------------*/ jmp hideCommand;
		to TOGGLE_VISIBILITY_COMMAND: /*-----*/ jmp toggleVisibilityCommand;
		to DRAW_COMMAND: /*------------------*/ jmp drawCommand;
		to SELECT_PREVIOUS_COMMAND: /*-------*/ jmp selectPreviousCommand;
		to SELECT_NEXT_COMMAND: /*-----------*/ jmp selectNextCommand;
		to SELECT_LEFT_COMMAND: /*-----------*/ jmp selectLeftCommand;
		to SELECT_RIGHT_COMMAND: /*----------*/ jmp selectRightCommand;
		to SELECT_ABOVE_COMMAND: /*----------*/ jmp selectAboveCommand;
		to SELECT_BELOW_COMMAND: /*----------*/ jmp selectBelowCommand;
		to PICK_SELECTION_COMMAND: /*--------*/ jmp pickSelectionCommand;
		to RESTART_COMMAND: /*---------------*/ jmp restartCommand;
		to EXIT_COMMAND: /*------------------*/ jmp exitCommand;
		off: /*------------------------------*/ jmp unrecognizedCommand;
	end
	noneCommand:{
		jmp emergencyExit;
	}
	executeCommand:{
		spawnProcess(execute);
		jmp emergencyExit;
	}
	setCurrentSelectionCommand:{
		switch clientOrder over
			to NONE_CLIENT_ORDER: /*-----*/ /*-------------------------------------------------------------------*/ jmp emergencyExit;
			to CREATION_CLIENT_ORDER: /*-*/ setCurrentSelection(&selectionSystem, &clientListSystem); /*---------*/ jmp emergencyExit;
			to STACKING_CLIENT_ORDER: /*-*/ setCurrentSelection(&selectionSystem, &clientListStackingSystem); /*-*/ jmp emergencyExit;
			off: /*----------------------*/ /*-------------------------------------------------------------------*/ jmp emergencyExit;
		end
	}
	showCommand:{
		mapWindows(&windowSystem, &monitorSystem, &windowPreferences, whichMonitor);
		jmp emergencyExit;
	}
	hideCommand:{
		unmapWindows(&windowSystem);
		jmp emergencyExit;
	}
	toggleVisibilityCommand:{
		if(!windowSystem.mapped){
			jmp showCommand;
		}
		jmp hideCommand;
	}
	drawCommand:{
		drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		jmp emergencyExit;
	}
	selectPreviousCommand:{
		if(windowSystem.mapped){
			moveCurrentSelection(&selectionSystem, PREVIOUS_WHICH_SELECTION);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	selectNextCommand:{
		if(windowSystem.mapped){
			moveCurrentSelection(&selectionSystem, NEXT_WHICH_SELECTION);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	selectLeftCommand:{
		if(windowSystem.mapped){
			moveCurrentSelection(&selectionSystem, LEFT_WHICH_SELECTION);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	selectRightCommand:{
		if(windowSystem.mapped){
			moveCurrentSelection(&selectionSystem, RIGHT_WHICH_SELECTION);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	selectAboveCommand:{
		if(windowSystem.mapped){
			moveCurrentSelection(&selectionSystem, ABOVE_WHICH_SELECTION);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	selectBelowCommand:{
		if(windowSystem.mapped){
			moveCurrentSelection(&selectionSystem, BELOW_WHICH_SELECTION);
			drawWindows(&windowSystem, &monitorSystem, &windowPreferences);
		}
		jmp emergencyExit;
	}
	pickSelectionCommand:{
		switch clientOrder over
			to NONE_CLIENT_ORDER: /*-----*/ /*-------------------------------------------------------------*/ jmp emergencyExit;
			to CREATION_CLIENT_ORDER: /*-*/ pickSelection(&selectionSystem, &clientListSystem); /*---------*/ jmp emergencyExit;
			to STACKING_CLIENT_ORDER: /*-*/ pickSelection(&selectionSystem, &clientListStackingSystem); /*-*/ jmp emergencyExit;
			off: /*----------------------*/ /*-------------------------------------------------------------*/ jmp emergencyExit;
		end
	}
	restartCommand:{
		commandReturned = RESTART_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	exitCommand:{
		commandReturned = EXIT_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	unrecognizedCommand:{
		printTitledValuedError("command error", "executed unrecognized command with type", command);
		jmp emergencyExit;
	}
	emergencyExit:{
		ret commandReturned;
	}
}
FREECONFIGVARIABLES(){
	if(font){
		xcb_close_font(connection, font);
		font = XCB_NONE;
	}
	ret;
}
SCALEIMAGE(){
	uint y;
	uint xWall;
	uint yWall;
	uint32 *destinationCurrent;
	if(!source or !destination or !sourceWidth or !sourceHeight or !destinationWidth or !destinationHeight){
		ret false;
	}
	y = 0;
	destinationCurrent = destination;
	xWall = destinationWidth * sourceWidth;
	yWall = destinationHeight * sourceHeight;
	jmp yLoop;
	yLoop:{
		if(y < yWall){
			uint x = 0;
			jmp xLoop;
			xLoop:{
				if(x < destinationWidth * sourceWidth){
					*destinationCurrent = 0xFF000000 | *((uint32 *)source + y / destinationHeight * sourceWidth + x / destinationWidth);
					inc destinationCurrent;
					x += sourceWidth;
					jmp xLoop;
				}
				y += sourceHeight;
				jmp yLoop;
			}
		}
		ret true;
	}
}
CLEANUP(){
	free(event);
	popPointer(eventToken);
	event = NULL;
	eventToken = 0;
	finiSharedMemorySystem(&sharedMemorySystem);
	finiSTDINSystem(&stdinSystem);
	finiSleepThreadSystem(&sleepThreadSystem);
	cancelThreads();
	ungrabShortcuts();
	freeConfigVariables();
	finiSelectionSystem(&selectionSystem);
	finiClientListSystem(&clientListStackingSystem);
	finiClientListSystem(&clientListSystem);
	finiWindowSystem(&windowSystem);
	finiMonitorSystem(&monitorSystem);
	if(connection){
		xcb_flush(connection);
		xcb_disconnect(connection);
		popPointer(connectionToken);
		connection = NULL;
		connectionToken = 0;
	}
	finiShortcutSystem(&buttonShortcutSystem);
	finiShortcutSystem(&keycodeShortcutSystem);
	finiStringTreeSystem(&macroStringTreeSystem);
	finiStringTreeSystem(&whichMonitorStringTreeSystem);
	finiStringTreeSystem(&selectionActionStringTreeSystem);
	finiStringTreeSystem(&startingSelectionStringTreeSystem);
	finiStringTreeSystem(&axisStringTreeSystem);
	finiStringTreeSystem(&clientOrderStringTreeSystem);
	finiStringTreeSystem(&cornerStringTreeSystem);
	finiStringTreeSystem(&verticalAlignmentStringTreeSystem);
	finiStringTreeSystem(&horizontalAlignmentStringTreeSystem);
	finiStringTreeSystem(&numberTypeStringTreeSystem);
	finiStringTreeSystem(&shortcutStateStringTreeSystem);
	finiStringTreeSystem(&modifierStringTreeSystem);
	finiStringTreeSystem(&commandStringTreeSystem);
	finiStringTreeSystem(&variableStringTreeSystem);
	finiStringTreeSystem(&booleanStringTreeSystem);
	finiStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
	finiStringTreeSystem(&globalInstructionStringTreeSystem);
	finiStringTreeSystem(&globalScopesInstructionStringTreeSystem);
	finiPermissionSystem(&permissionSystem);
	if(memoryManagementSystem.allocated > 1){
		printError("%s%s: %s%s:%s %s", colorStart, programName, colorError, "warning", colorEnd, "program exited with unaccounted for data pointers, namely:\n");
		printUnaccountedForPointers(memoryManagementSystem.data + 1, memoryManagementSystem.data + memoryManagementSystem.allocated);
	}
	finiMemorySystem();
	closeErrorStream();
	exit(EXIT_SUCCESS);
}
PRINTCONFIGERROR(){
	const char *statementCurrent = statementStart;
	const uint itemAmountWall = instructionCurrent - instructionStart;
	uint itemAmount = 0;
	uint spaceAmount = 0;
	StringTreeSystem *const *data;
	if(!openErrorStream()){
		ret;
	}
	flockfile(errorStream);
	fprintf(errorStream, "%s%s: %s: ", colorStart, programName, configPath);
	if(printLine){
		fprintf(errorStream, "line %u: ", statementLine);
	}
	fprintf(errorStream, "%s%s:%s %s", colorError, type, colorEnd, message);
	if(printConfig){
		fprintf(errorStream, ":\n\t config |");
	}else{
		fprintf(errorStream, "\n");
		jmp emergencyExit;
	}
	jmp printStatementItemLoop;
	printStatementItemLoop:{
		if(statementCurrent < statementWall){
			fprintf(errorStream, " %s", statementCurrent);
			jmp pushOutTermLoop;
			pushOutTermLoop:{
				if(*(inc statementCurrent)){
					jmp pushOutTermLoop;
				}
				inc statementCurrent;
			}
			if(itemAmount == itemAmountWall and instructionStart){
				spaceAmount = statementCurrent - statementStart;
			}
			inc itemAmount;
			jmp printStatementItemLoop;
		}
		if(spaceAmount == 0 and finalStatementCharacter != ';'){
			fprintf(errorStream, " ");
		}
		fprintf(errorStream, "%c\n", finalStatementCharacter);
		jmp printPattern;
	}
	printPattern:{
		if(printPointer){
			if(spaceAmount == statementCurrent - statementStart){
				dec spaceAmount;
			}
			fprintf(errorStream, "\t        |%*c^\n", inc spaceAmount, ' ');
		}
		if(!printPattern or !instructionStart){
			fprintf(errorStream, "\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, "\n\tpattern | %s", *(currentScopeInstructionList + (*currentScopeInstructionStringTreeSystem).returnedCounter));
		dec instructionStart;
		data = instructionDataStart;
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoop: switch *(inc instructionStart) over
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
		off: /*---------------------------*/ jmp printInstructionParameterLoopExit;
	end
	noneInstruction:{
		fprintf(errorStream, " <unimplemented>");
		jmp printInstructionParameterLoopExit;
	}
	nameInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " name");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " (%s", *stringArray);
			inc stringArray;
			jmp printNameLoop;
			printNameLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
				}
				fprintf(errorStream, ")");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	nameListInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " list");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " ((%s", *stringArray);
			inc stringArray;
			jmp printNameListOnceLoop;
			printNameListOnceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
				}
				stringArray = (**data).stringArray;
				fprintf(errorStream, ")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
				inc stringArray;
				jmp printNameListTwiceLoop;
			}
			printNameListTwiceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListTwiceLoop;
				}
				fprintf(errorStream, "))*(?![\\s]*[|]))");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	numberInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " number");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
		jmp printInstructionParameterLoop;
	}
	stringInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " string");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	imageInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " image");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	printTilde:{
		fprintf(errorStream, " ~");
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoopExit:{
		if(displaySimpleConfigErrors){
			fprintf(errorStream, "\n\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, " $\n\n");
		jmp emergencyExit;
	}
	emergencyExit:{
		funlockfile(errorStream);
		closeErrorStream();
		ret;
	}
}

